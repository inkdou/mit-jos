cscope 15 $HOME/Robux/tags -c               0001555359
	@/root/Robux/boot/main.c

1 #include 
	~<inc/x86.h
>

2 #include 
	~<inc/elf.h
>

32 #define 
	#SECTSIZE
 512

	)

33 #define 
	#ELFHDR
 ((struct 
Elf
 *) 0x10000)

34 

	)

35 void 
readsect
(void*, 
uint32_t
);

36 void 
readseg
(
uint32_t
, uint32_t, uint32_t);

39 
	$bootmain
(void)

41 struct 
Proghdr
 *
ph
, *
eph
;

44 
	`readseg
((
uint32_t
) 
ELFHDR
, 
SECTSIZE
*8, 0);

47 if (
ELFHDR
->
e_magic
 != 
ELF_MAGIC
)

48 goto 
bad
;

51 
ph
 = (struct 
Proghdr
 *) ((
uint8_t
 *) 
ELFHDR
 + ELFHDR->
e_phoff
);

52 
eph
 = 
ph
 + 
ELFHDR
->
e_phnum
;

53 for (; 
ph
 < 
eph
; ph++)

56 
	`readseg
(
ph
->
p_pa
, ph->
p_memsz
, ph->
p_offset
);

60 ((void (*)(void)) (
ELFHDR
->
e_entry
))();

62 
bad
:

63 
	`outw
(0x8A00, 0x8A00);

64 
	`outw
(0x8A00, 0x8E00);

67 
	}
}

72 
	$readseg
(
uint32_t
 
pa
, uint32_t 
count
, uint32_t 
offset
)

74 
uint32_t
 
end_pa
;

76 
end_pa
 = 
pa
 + 
count
;

79 
pa
 &= ~(
SECTSIZE
 - 1);

82 
offset
 = (offset / 
SECTSIZE
) + 1;

87 while (
pa
 < 
end_pa
) {

92 
	`readsect
((
uint8_t
*) 
pa
, 
offset
);

93 
pa
 += 
SECTSIZE
;

94 
offset
++;

96 
	}
}

99 
	$waitdisk
(void)

102 while ((
	`inb
(0x1F7) & 0xC0) != 0x40)

104 
	}
}

107 
	$readsect
(void *
dst
, 
uint32_t
 
offset
)

110 
	`waitdisk
();

112 
	`outb
(0x1F2, 1);

113 
	`outb
(0x1F3, 
offset
);

114 
	`outb
(0x1F4, 
offset
 >> 8);

115 
	`outb
(0x1F5, 
offset
 >> 16);

116 
	`outb
(0x1F6, (
offset
 >> 24) | 0xE0);

117 
	`outb
(0x1F7, 0x20);

120 
	`waitdisk
();

123 
	`insl
(0x1F0, 
dst
, 
SECTSIZE
/4);

124 
	}
}

	@/root/Robux/contrib/sha2/sha2.c

34 #include 
	~<inc/string.h
>

35 #include 
	~<inc/assert.h
>

36 #include 
	~<contrib/sha2/sha2.h
>

87 #if !
defined
(
BYTE_ORDER
) || (BYTE_ORDER != 
LITTLE_ENDIAN
 && BYTE_ORDER != 
BIG_ENDIAN
)

88 #error 
Define
 
BYTE_ORDER
 
to
 
be
 
equal
 to 
either
 
LITTLE_ENDIAN
 
or
 
BIG_ENDIAN


105 #ifdef 
SHA2_USE_INTTYPES_H


107 typedef 
uint8_t
 
	tsha2_byte
;

108 typedef 
uint32_t
 
	tsha2_word32
;

109 typedef 
uint64_t
 
	tsha2_word64
;

113 typedef 
u_int8_t
 
	tsha2_byte
;

114 typedef 
u_int32_t
 
	tsha2_word32
;

115 typedef 
u_int64_t
 
	tsha2_word64
;

122 #define 
	#SHA256_SHORT_BLOCK_LENGTH
 (
SHA256_BLOCK_LENGTH
 - 8)

	)

123 #define 
	#SHA384_SHORT_BLOCK_LENGTH
 (
SHA384_BLOCK_LENGTH
 - 16)

	)

124 #define 
	#SHA512_SHORT_BLOCK_LENGTH
 (
SHA512_BLOCK_LENGTH
 - 16)

	)

128 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


129 #define 
	#REVERSE32
(
w
,
x
) { \

130 
sha2_word32
 
tmp
 = (
w
); \

131 
tmp
 = (tmp >> 16) | (tmp << 16); \

132 (
x
) = ((
tmp
 & 0xff00ff00UL) >> 8) | ((tmp & 0x00ff00ffUL) << 8); \

133 }

	)

134 #define 
	#REVERSE64
(
w
,
x
) { \

135 
sha2_word64
 
tmp
 = (
w
); \

136 
tmp
 = (tmp >> 32) | (tmp << 32); \

137 
tmp
 = ((tmp & 0xff00ff00ff00ff00ULL) >> 8) | \

138 ((
tmp
 & 0x00ff00ff00ff00ffULL) << 8); \

139 (
x
) = ((
tmp
 & 0xffff0000ffff0000ULL) >> 16) | \

140 ((
tmp
 & 0x0000ffff0000ffffULL) << 16); \

141 }

	)

149 #define 
	#ADDINC128
(
w
,
n
) { \

150 (
w
)[0] += (
sha2_word64
)(
n
); \

151 if ((
w
)[0] < (
n
)) { \

152 (
w
)[1]++; \

154 }

	)

165 #if !
defined
(
SHA2_USE_MEMSET_MEMCPY
) && !defined(
SHA2_USE_BZERO_BCOPY
)

167 #define 
	#SHA2_USE_MEMSET_MEMCPY
 1

	)

169 #if 
defined
(
SHA2_USE_MEMSET_MEMCPY
) && defined(
SHA2_USE_BZERO_BCOPY
)

171 #error 
Define
 
either
 
SHA2_USE_MEMSET_MEMCPY
 
or
 
SHA2_USE_BZERO_BCOPY
, 
not
 
both
!

174 #ifdef 
SHA2_USE_MEMSET_MEMCPY


175 #define 
	#MEMSET_BZERO
(
p
,
l
) 
	`memset
((p), 0, (l))

	)

176 #define 
	#MEMCPY_BCOPY
(
d
,
s
,
l
) 
	`memcpy
((d), (s), (l))

	)

178 #ifdef 
SHA2_USE_BZERO_BCOPY


179 #define 
	#MEMSET_BZERO
(
p
,
l
) 
	`bzero
((p), (l))

	)

180 #define 
	#MEMCPY_BCOPY
(
d
,
s
,
l
) 
	`bcopy
((s), (d), (l))

	)

194 #define 
	#R
(
b
,
x
) ((x) >> (b))

	)

196 #define 
	#S32
(
b
,
x
) (((x) >> (b)) | ((x) << (32 - (b))))

	)

198 #define 
	#S64
(
b
,
x
) (((x) >> (b)) | ((x) << (64 - (b))))

	)

201 #define 
	#Ch
(
x
,
y
,
z
) (((x) & (y)) ^ ((~(x)) & (z)))

	)

202 #define 
	#Maj
(
x
,
y
,
z
) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

	)

205 #define 
	#Sigma0_256
(
x
) (
	`S32
(2, (x)) ^ S32(13, (x)) ^ S32(22, (x)))

	)

206 #define 
	#Sigma1_256
(
x
) (
	`S32
(6, (x)) ^ S32(11, (x)) ^ S32(25, (x)))

	)

207 #define 
	#sigma0_256
(
x
) (
	`S32
(7, (x)) ^ S32(18, (x)) ^ 
	`R
(3 , (x)))

	)

208 #define 
	#sigma1_256
(
x
) (
	`S32
(17, (x)) ^ S32(19, (x)) ^ 
	`R
(10, (x)))

	)

211 #define 
	#Sigma0_512
(
x
) (
	`S64
(28, (x)) ^ S64(34, (x)) ^ S64(39, (x)))

	)

212 #define 
	#Sigma1_512
(
x
) (
	`S64
(14, (x)) ^ S64(18, (x)) ^ S64(41, (x)))

	)

213 #define 
	#sigma0_512
(
x
) (
	`S64
( 1, (x)) ^ S64( 8, (x)) ^ 
	`R
( 7, (x)))

	)

214 #define 
	#sigma1_512
(
x
) (
	`S64
(19, (x)) ^ S64(61, (x)) ^ 
	`R
( 6, (x)))

	)

221 void 
SHA512_Last
(
SHA512_CTX
*);

222 void 
SHA256_Transform
(
SHA256_CTX
*, const 
sha2_word32
*);

223 void 
SHA512_Transform
(
SHA512_CTX
*, const 
sha2_word64
*);

228 const static 
sha2_word32
 
	gK256
[64] = {

248 const static 
sha2_word32
 
	gsha256_initial_hash_value
[8] = {

260 const static 
sha2_word64
 
	gK512
[80] = {

304 const static 
sha2_word64
 
	gsha384_initial_hash_value
[8] = {

316 const static 
sha2_word64
 
	gsha512_initial_hash_value
[8] = {

331 static const char *
	gsha2_hex_digits
 = "0123456789abcdef";

335 void 
	$SHA256_Init
(
SHA256_CTX
* 
context
) {

336 if (
context
 == (
SHA256_CTX
*)0) {

339 
	`MEMCPY_BCOPY
(
context
->
state
, 
sha256_initial_hash_value
, 
SHA256_DIGEST_LENGTH
);

340 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA256_BLOCK_LENGTH
);

341 
context
->
bitcount
 = 0;

342 
	}
}

344 #ifdef 
SHA2_UNROLL_TRANSFORM


348 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


350 #define 
	#ROUND256_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

351 
	`REVERSE32
(*
data
++, 
W256
[
j
]); \

352 
T1
 = (
h
) + 
	`Sigma1_256
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

353 
K256
[
j
] + 
W256
[j]; \

354 (
d
) += 
T1
; \

355 (
h
) = 
T1
 + 
	`Sigma0_256
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

356 
j
++

	)

361 #define 
	#ROUND256_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

362 
T1
 = (
h
) + 
	`Sigma1_256
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

363 
K256
[
j
] + (
W256
[j] = *
data
++); \

364 (
d
) += 
T1
; \

365 (
h
) = 
T1
 + 
	`Sigma0_256
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

366 
j
++

	)

370 #define 
	#ROUND256
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

371 
s0
 = 
W256
[(
j
+1)&0x0f]; \

372 
s0
 = 
	`sigma0_256
(s0); \

373 
s1
 = 
W256
[(
j
+14)&0x0f]; \

374 
s1
 = 
	`sigma1_256
(s1); \

375 
T1
 = (
h
) + 
	`Sigma1_256
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + 
K256
[
j
] + \

376 (
W256
[
j
&0x0f] += 
s1
 + W256[(j+9)&0x0f] + 
s0
); \

377 (
d
) += 
T1
; \

378 (
h
) = 
T1
 + 
	`Sigma0_256
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

379 
j
++

	)

381 void 
	$SHA256_Transform
(
SHA256_CTX
* 
context
, const 
sha2_word32
* 
data
) {

382 
sha2_word32
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

383 
sha2_word32
 
T1
, *
W256
;

384 int 
j
;

386 
W256
 = (
sha2_word32
*)
context
->
buffer
;

389 
a
 = 
context
->
state
[0];

390 
b
 = 
context
->
state
[1];

391 
c
 = 
context
->
state
[2];

392 
d
 = 
context
->
state
[3];

393 
e
 = 
context
->
state
[4];

394 
f
 = 
context
->
state
[5];

395 
g
 = 
context
->
state
[6];

396 
h
 = 
context
->
state
[7];

398 
j
 = 0;

401 
	`ROUND256_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

402 
	`ROUND256_0_TO_15
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

403 
	`ROUND256_0_TO_15
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

404 
	`ROUND256_0_TO_15
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

405 
	`ROUND256_0_TO_15
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

406 
	`ROUND256_0_TO_15
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

407 
	`ROUND256_0_TO_15
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

408 
	`ROUND256_0_TO_15
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

409 } while (
j
 < 16);

413 
	`ROUND256
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

414 
	`ROUND256
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

415 
	`ROUND256
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

416 
	`ROUND256
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

417 
	`ROUND256
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

418 
	`ROUND256
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

419 
	`ROUND256
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

420 
	`ROUND256
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

421 } while (
j
 < 64);

424 
context
->
state
[0] += 
a
;

425 
context
->
state
[1] += 
b
;

426 
context
->
state
[2] += 
c
;

427 
context
->
state
[3] += 
d
;

428 
context
->
state
[4] += 
e
;

429 
context
->
state
[5] += 
f
;

430 
context
->
state
[6] += 
g
;

431 
context
->
state
[7] += 
h
;

434 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 0;

435 
	}
}

439 void 
	$SHA256_Transform
(
SHA256_CTX
* 
context
, const 
sha2_word32
* 
data
) {

440 
sha2_word32
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

441 
sha2_word32
 
T1
, 
T2
, *
W256
;

442 int 
j
;

444 
W256
 = (
sha2_word32
*)
context
->
buffer
;

447 
a
 = 
context
->
state
[0];

448 
b
 = 
context
->
state
[1];

449 
c
 = 
context
->
state
[2];

450 
d
 = 
context
->
state
[3];

451 
e
 = 
context
->
state
[4];

452 
f
 = 
context
->
state
[5];

453 
g
 = 
context
->
state
[6];

454 
h
 = 
context
->
state
[7];

456 
j
 = 0;

458 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


460 
	`REVERSE32
(*
data
++,
W256
[
j
]);

462 
T1
 = 
h
 + 
	`Sigma1_256
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K256
[
j
] + 
W256
[j];

465 
T1
 = 
h
 + 
	`Sigma1_256
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K256
[
j
] + (
W256
[j] = *
data
++);

467 
T2
 = 
	`Sigma0_256
(
a
) + 
	`Maj
(a, 
b
, 
c
);

468 
h
 = 
g
;

469 
g
 = 
f
;

470 
f
 = 
e
;

471 
e
 = 
d
 + 
T1
;

472 
d
 = 
c
;

473 
c
 = 
b
;

474 
b
 = 
a
;

475 
a
 = 
T1
 + 
T2
;

477 
j
++;

478 } while (
j
 < 16);

482 
s0
 = 
W256
[(
j
+1)&0x0f];

483 
s0
 = 
	`sigma0_256
(s0);

484 
s1
 = 
W256
[(
j
+14)&0x0f];

485 
s1
 = 
	`sigma1_256
(s1);

488 
T1
 = 
h
 + 
	`Sigma1_256
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K256
[
j
] +

489 (
W256
[
j
&0x0f] += 
s1
 + W256[(j+9)&0x0f] + 
s0
);

490 
T2
 = 
	`Sigma0_256
(
a
) + 
	`Maj
(a, 
b
, 
c
);

491 
h
 = 
g
;

492 
g
 = 
f
;

493 
f
 = 
e
;

494 
e
 = 
d
 + 
T1
;

495 
d
 = 
c
;

496 
c
 = 
b
;

497 
b
 = 
a
;

498 
a
 = 
T1
 + 
T2
;

500 
j
++;

501 } while (
j
 < 64);

504 
context
->
state
[0] += 
a
;

505 
context
->
state
[1] += 
b
;

506 
context
->
state
[2] += 
c
;

507 
context
->
state
[3] += 
d
;

508 
context
->
state
[4] += 
e
;

509 
context
->
state
[5] += 
f
;

510 
context
->
state
[6] += 
g
;

511 
context
->
state
[7] += 
h
;

514 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 
T2
 = 0;

515 
	}
}

519 void 
	$SHA256_Update
(
SHA256_CTX
* 
context
, const 
sha2_byte
 *
data
, 
size_t
 
len
) {

520 unsigned int 
freespace
, 
usedspace
;

522 if (
len
 == 0) {

528 
	`assert
(
context
 != (
SHA256_CTX
*)0 && 
data
 != (
sha2_byte
*)0);

530 
usedspace
 = (
context
->
bitcount
 >> 3) % 
SHA256_BLOCK_LENGTH
;

531 if (
usedspace
 > 0) {

533 
freespace
 = 
SHA256_BLOCK_LENGTH
 - 
usedspace
;

535 if (
len
 >= 
freespace
) {

537 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
freespace
);

538 
context
->
bitcount
 += 
freespace
 << 3;

539 
len
 -= 
freespace
;

540 
data
 += 
freespace
;

541 
	`SHA256_Transform
(
context
, (
sha2_word32
*)context->
buffer
);

544 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
len
);

545 
context
->
bitcount
 += 
len
 << 3;

547 
usedspace
 = 
freespace
 = 0;

551 while (
len
 >= 
SHA256_BLOCK_LENGTH
) {

553 
	`SHA256_Transform
(
context
, (
sha2_word32
*)
data
);

554 
context
->
bitcount
 += 
SHA256_BLOCK_LENGTH
 << 3;

555 
len
 -= 
SHA256_BLOCK_LENGTH
;

556 
data
 += 
SHA256_BLOCK_LENGTH
;

558 if (
len
 > 0) {

560 
	`MEMCPY_BCOPY
(
context
->
buffer
, 
data
, 
len
);

561 
context
->
bitcount
 += 
len
 << 3;

564 
usedspace
 = 
freespace
 = 0;

565 
	}
}

567 void 
	$SHA256_Final
(
sha2_byte
 
digest
[], 
SHA256_CTX
* 
context
) {

568 
sha2_word32
 *
d
 = (sha2_word32*)
digest
;

569 unsigned int 
usedspace
;

572 
	`assert
(
context
 != (
SHA256_CTX
*)0);

575 if (
digest
 != (
sha2_byte
*)0) {

576 
usedspace
 = (
context
->
bitcount
 >> 3) % 
SHA256_BLOCK_LENGTH
;

577 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


579 
	`REVERSE64
(
context
->
bitcount
,context->bitcount);

581 if (
usedspace
 > 0) {

583 
context
->
buffer
[
usedspace
++] = 0x80;

585 if (
usedspace
 <= 
SHA256_SHORT_BLOCK_LENGTH
) {

587 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA256_SHORT_BLOCK_LENGTH
 - usedspace);

589 if (
usedspace
 < 
SHA256_BLOCK_LENGTH
) {

590 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA256_BLOCK_LENGTH
 - usedspace);

593 
	`SHA256_Transform
(
context
, (
sha2_word32
*)context->
buffer
);

596 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA256_SHORT_BLOCK_LENGTH
);

600 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA256_SHORT_BLOCK_LENGTH
);

603 *
context
->
buffer
 = 0x80;

606 *(
sha2_word64
*)&
context
->
buffer
[
SHA256_SHORT_BLOCK_LENGTH
] = context->
bitcount
;

609 
	`SHA256_Transform
(
context
, (
sha2_word32
*)context->
buffer
);

611 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


614 int 
j
;

615 for (
j
 = 0; j < 8; j++) {

616 
	`REVERSE32
(
context
->
state
[
j
],context->state[j]);

617 *
d
++ = 
context
->
state
[
j
];

621 
	`MEMCPY_BCOPY
(
d
, 
context
->
state
, 
SHA256_DIGEST_LENGTH
);

626 
	`MEMSET_BZERO
(
context
, sizeof(
SHA256_CTX
));

627 
usedspace
 = 0;

628 
	}
}

630 char *
	$SHA256_End
(
SHA256_CTX
* 
context
, char 
buffer
[]) {

631 
sha2_byte
 
digest
[
SHA256_DIGEST_LENGTH
], *
d
 = digest;

632 int 
i
;

635 
	`assert
(
context
 != (
SHA256_CTX
*)0);

637 if (
buffer
 != (char*)0) {

638 
	`SHA256_Final
(
digest
, 
context
);

640 for (
i
 = 0; i < 
SHA256_DIGEST_LENGTH
; i++) {

641 *
buffer
++ = 
sha2_hex_digits
[(*
d
 & 0xf0) >> 4];

642 *
buffer
++ = 
sha2_hex_digits
[*
d
 & 0x0f];

643 
d
++;

645 *
buffer
 = (char)0;

647 
	`MEMSET_BZERO
(
context
, sizeof(
SHA256_CTX
));

649 
	`MEMSET_BZERO
(
digest
, 
SHA256_DIGEST_LENGTH
);

650 return 
buffer
;

651 
	}
}

653 char* 
	$SHA256_Data
(const 
sha2_byte
* 
data
, 
size_t
 
len
, char 
digest
[
SHA256_DIGEST_STRING_LENGTH
]) {

654 
SHA256_CTX
 
context
;

656 
	`SHA256_Init
(&
context
);

657 
	`SHA256_Update
(&
context
, 
data
, 
len
);

658 return 
	`SHA256_End
(&
context
, 
digest
);

659 
	}
}

663 void 
	$SHA512_Init
(
SHA512_CTX
* 
context
) {

664 if (
context
 == (
SHA512_CTX
*)0) {

667 
	`MEMCPY_BCOPY
(
context
->
state
, 
sha512_initial_hash_value
, 
SHA512_DIGEST_LENGTH
);

668 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA512_BLOCK_LENGTH
);

669 
context
->
bitcount
[0] = context->bitcount[1] = 0;

670 
	}
}

672 #ifdef 
SHA2_UNROLL_TRANSFORM


675 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


677 #define 
	#ROUND512_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

678 
	`REVERSE64
(*
data
++, 
W512
[
j
]); \

679 
T1
 = (
h
) + 
	`Sigma1_512
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

680 
K512
[
j
] + 
W512
[j]; \

681 (
d
) += 
T1
, \

682 (
h
) = 
T1
 + 
	`Sigma0_512
(
a
) + 
	`Maj
((a), (
b
), (
c
)), \

683 
j
++

	)

688 #define 
	#ROUND512_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

689 
T1
 = (
h
) + 
	`Sigma1_512
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

690 
K512
[
j
] + (
W512
[j] = *
data
++); \

691 (
d
) += 
T1
; \

692 (
h
) = 
T1
 + 
	`Sigma0_512
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

693 
j
++

	)

697 #define 
	#ROUND512
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

698 
s0
 = 
W512
[(
j
+1)&0x0f]; \

699 
s0
 = 
	`sigma0_512
(s0); \

700 
s1
 = 
W512
[(
j
+14)&0x0f]; \

701 
s1
 = 
	`sigma1_512
(s1); \

702 
T1
 = (
h
) + 
	`Sigma1_512
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + 
K512
[
j
] + \

703 (
W512
[
j
&0x0f] += 
s1
 + W512[(j+9)&0x0f] + 
s0
); \

704 (
d
) += 
T1
; \

705 (
h
) = 
T1
 + 
	`Sigma0_512
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

706 
j
++

	)

708 void 
	$SHA512_Transform
(
SHA512_CTX
* 
context
, const 
sha2_word64
* 
data
) {

709 
sha2_word64
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

710 
sha2_word64
 
T1
, *
W512
 = (sha2_word64*)
context
->
buffer
;

711 int 
j
;

714 
a
 = 
context
->
state
[0];

715 
b
 = 
context
->
state
[1];

716 
c
 = 
context
->
state
[2];

717 
d
 = 
context
->
state
[3];

718 
e
 = 
context
->
state
[4];

719 
f
 = 
context
->
state
[5];

720 
g
 = 
context
->
state
[6];

721 
h
 = 
context
->
state
[7];

723 
j
 = 0;

725 
	`ROUND512_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

726 
	`ROUND512_0_TO_15
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

727 
	`ROUND512_0_TO_15
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

728 
	`ROUND512_0_TO_15
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

729 
	`ROUND512_0_TO_15
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

730 
	`ROUND512_0_TO_15
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

731 
	`ROUND512_0_TO_15
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

732 
	`ROUND512_0_TO_15
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

733 } while (
j
 < 16);

737 
	`ROUND512
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

738 
	`ROUND512
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

739 
	`ROUND512
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

740 
	`ROUND512
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

741 
	`ROUND512
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

742 
	`ROUND512
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

743 
	`ROUND512
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

744 
	`ROUND512
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

745 } while (
j
 < 80);

748 
context
->
state
[0] += 
a
;

749 
context
->
state
[1] += 
b
;

750 
context
->
state
[2] += 
c
;

751 
context
->
state
[3] += 
d
;

752 
context
->
state
[4] += 
e
;

753 
context
->
state
[5] += 
f
;

754 
context
->
state
[6] += 
g
;

755 
context
->
state
[7] += 
h
;

758 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 0;

759 
	}
}

763 void 
	$SHA512_Transform
(
SHA512_CTX
* 
context
, const 
sha2_word64
* 
data
) {

764 
sha2_word64
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

765 
sha2_word64
 
T1
, 
T2
, *
W512
 = (sha2_word64*)
context
->
buffer
;

766 int 
j
;

769 
a
 = 
context
->
state
[0];

770 
b
 = 
context
->
state
[1];

771 
c
 = 
context
->
state
[2];

772 
d
 = 
context
->
state
[3];

773 
e
 = 
context
->
state
[4];

774 
f
 = 
context
->
state
[5];

775 
g
 = 
context
->
state
[6];

776 
h
 = 
context
->
state
[7];

778 
j
 = 0;

780 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


782 
	`REVERSE64
(*
data
++, 
W512
[
j
]);

784 
T1
 = 
h
 + 
	`Sigma1_512
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K512
[
j
] + 
W512
[j];

787 
T1
 = 
h
 + 
	`Sigma1_512
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K512
[
j
] + (
W512
[j] = *
data
++);

789 
T2
 = 
	`Sigma0_512
(
a
) + 
	`Maj
(a, 
b
, 
c
);

790 
h
 = 
g
;

791 
g
 = 
f
;

792 
f
 = 
e
;

793 
e
 = 
d
 + 
T1
;

794 
d
 = 
c
;

795 
c
 = 
b
;

796 
b
 = 
a
;

797 
a
 = 
T1
 + 
T2
;

799 
j
++;

800 } while (
j
 < 16);

804 
s0
 = 
W512
[(
j
+1)&0x0f];

805 
s0
 = 
	`sigma0_512
(s0);

806 
s1
 = 
W512
[(
j
+14)&0x0f];

807 
s1
 = 
	`sigma1_512
(s1);

810 
T1
 = 
h
 + 
	`Sigma1_512
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K512
[
j
] +

811 (
W512
[
j
&0x0f] += 
s1
 + W512[(j+9)&0x0f] + 
s0
);

812 
T2
 = 
	`Sigma0_512
(
a
) + 
	`Maj
(a, 
b
, 
c
);

813 
h
 = 
g
;

814 
g
 = 
f
;

815 
f
 = 
e
;

816 
e
 = 
d
 + 
T1
;

817 
d
 = 
c
;

818 
c
 = 
b
;

819 
b
 = 
a
;

820 
a
 = 
T1
 + 
T2
;

822 
j
++;

823 } while (
j
 < 80);

826 
context
->
state
[0] += 
a
;

827 
context
->
state
[1] += 
b
;

828 
context
->
state
[2] += 
c
;

829 
context
->
state
[3] += 
d
;

830 
context
->
state
[4] += 
e
;

831 
context
->
state
[5] += 
f
;

832 
context
->
state
[6] += 
g
;

833 
context
->
state
[7] += 
h
;

836 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 
T2
 = 0;

837 
	}
}

841 void 
	$SHA512_Update
(
SHA512_CTX
* 
context
, const 
sha2_byte
 *
data
, 
size_t
 
len
) {

842 unsigned int 
freespace
, 
usedspace
;

844 if (
len
 == 0) {

850 
	`assert
(
context
 != (
SHA512_CTX
*)0 && 
data
 != (
sha2_byte
*)0);

852 
usedspace
 = (
context
->
bitcount
[0] >> 3) % 
SHA512_BLOCK_LENGTH
;

853 if (
usedspace
 > 0) {

855 
freespace
 = 
SHA512_BLOCK_LENGTH
 - 
usedspace
;

857 if (
len
 >= 
freespace
) {

859 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
freespace
);

860 
	`ADDINC128
(
context
->
bitcount
, 
freespace
 << 3);

861 
len
 -= 
freespace
;

862 
data
 += 
freespace
;

863 
	`SHA512_Transform
(
context
, (
sha2_word64
*)context->
buffer
);

866 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
len
);

867 
	`ADDINC128
(
context
->
bitcount
, 
len
 << 3);

869 
usedspace
 = 
freespace
 = 0;

873 while (
len
 >= 
SHA512_BLOCK_LENGTH
) {

875 
	`SHA512_Transform
(
context
, (
sha2_word64
*)
data
);

876 
	`ADDINC128
(
context
->
bitcount
, 
SHA512_BLOCK_LENGTH
 << 3);

877 
len
 -= 
SHA512_BLOCK_LENGTH
;

878 
data
 += 
SHA512_BLOCK_LENGTH
;

880 if (
len
 > 0) {

882 
	`MEMCPY_BCOPY
(
context
->
buffer
, 
data
, 
len
);

883 
	`ADDINC128
(
context
->
bitcount
, 
len
 << 3);

886 
usedspace
 = 
freespace
 = 0;

887 
	}
}

889 void 
	$SHA512_Last
(
SHA512_CTX
* 
context
) {

890 unsigned int 
usedspace
;

892 
usedspace
 = (
context
->
bitcount
[0] >> 3) % 
SHA512_BLOCK_LENGTH
;

893 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


895 
	`REVERSE64
(
context
->
bitcount
[0],context->bitcount[0]);

896 
	`REVERSE64
(
context
->
bitcount
[1],context->bitcount[1]);

898 if (
usedspace
 > 0) {

900 
context
->
buffer
[
usedspace
++] = 0x80;

902 if (
usedspace
 <= 
SHA512_SHORT_BLOCK_LENGTH
) {

904 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA512_SHORT_BLOCK_LENGTH
 - usedspace);

906 if (
usedspace
 < 
SHA512_BLOCK_LENGTH
) {

907 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA512_BLOCK_LENGTH
 - usedspace);

910 
	`SHA512_Transform
(
context
, (
sha2_word64
*)context->
buffer
);

913 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA512_BLOCK_LENGTH
 - 2);

917 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA512_SHORT_BLOCK_LENGTH
);

920 *
context
->
buffer
 = 0x80;

923 *(
sha2_word64
*)&
context
->
buffer
[
SHA512_SHORT_BLOCK_LENGTH
] = context->
bitcount
[1];

924 *(
sha2_word64
*)&
context
->
buffer
[
SHA512_SHORT_BLOCK_LENGTH
+8] = context->
bitcount
[0];

927 
	`SHA512_Transform
(
context
, (
sha2_word64
*)context->
buffer
);

928 
	}
}

930 void 
	$SHA512_Final
(
sha2_byte
 
digest
[], 
SHA512_CTX
* 
context
) {

931 
sha2_word64
 *
d
 = (sha2_word64*)
digest
;

934 
	`assert
(
context
 != (
SHA512_CTX
*)0);

937 if (
digest
 != (
sha2_byte
*)0) {

938 
	`SHA512_Last
(
context
);

941 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


944 int 
j
;

945 for (
j
 = 0; j < 8; j++) {

946 
	`REVERSE64
(
context
->
state
[
j
],context->state[j]);

947 *
d
++ = 
context
->
state
[
j
];

951 
	`MEMCPY_BCOPY
(
d
, 
context
->
state
, 
SHA512_DIGEST_LENGTH
);

956 
	`MEMSET_BZERO
(
context
, sizeof(
SHA512_CTX
));

957 
	}
}

959 char *
	$SHA512_End
(
SHA512_CTX
* 
context
, char 
buffer
[]) {

960 
sha2_byte
 
digest
[
SHA512_DIGEST_LENGTH
], *
d
 = digest;

961 int 
i
;

964 
	`assert
(
context
 != (
SHA512_CTX
*)0);

966 if (
buffer
 != (char*)0) {

967 
	`SHA512_Final
(
digest
, 
context
);

969 for (
i
 = 0; i < 
SHA512_DIGEST_LENGTH
; i++) {

970 *
buffer
++ = 
sha2_hex_digits
[(*
d
 & 0xf0) >> 4];

971 *
buffer
++ = 
sha2_hex_digits
[*
d
 & 0x0f];

972 
d
++;

974 *
buffer
 = (char)0;

976 
	`MEMSET_BZERO
(
context
, sizeof(
SHA512_CTX
));

978 
	`MEMSET_BZERO
(
digest
, 
SHA512_DIGEST_LENGTH
);

979 return 
buffer
;

980 
	}
}

982 char* 
	$SHA512_Data
(const 
sha2_byte
* 
data
, 
size_t
 
len
, char 
digest
[
SHA512_DIGEST_STRING_LENGTH
]) {

983 
SHA512_CTX
 
context
;

985 
	`SHA512_Init
(&
context
);

986 
	`SHA512_Update
(&
context
, 
data
, 
len
);

987 return 
	`SHA512_End
(&
context
, 
digest
);

988 
	}
}

992 void 
	$SHA384_Init
(
SHA384_CTX
* 
context
) {

993 if (
context
 == (
SHA384_CTX
*)0) {

996 
	`MEMCPY_BCOPY
(
context
->
state
, 
sha384_initial_hash_value
, 
SHA512_DIGEST_LENGTH
);

997 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA384_BLOCK_LENGTH
);

998 
context
->
bitcount
[0] = context->bitcount[1] = 0;

999 
	}
}

1001 void 
	$SHA384_Update
(
SHA384_CTX
* 
context
, const 
sha2_byte
* 
data
, 
size_t
 
len
) {

1002 
	`SHA512_Update
((
SHA512_CTX
*)
context
, 
data
, 
len
);

1003 
	}
}

1005 void 
	$SHA384_Final
(
sha2_byte
 
digest
[], 
SHA384_CTX
* 
context
) {

1006 
sha2_word64
 *
d
 = (sha2_word64*)
digest
;

1009 
	`assert
(
context
 != (
SHA384_CTX
*)0);

1012 if (
digest
 != (
sha2_byte
*)0) {

1013 
	`SHA512_Last
((
SHA512_CTX
*)
context
);

1016 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


1019 int 
j
;

1020 for (
j
 = 0; j < 6; j++) {

1021 
	`REVERSE64
(
context
->
state
[
j
],context->state[j]);

1022 *
d
++ = 
context
->
state
[
j
];

1026 
	`MEMCPY_BCOPY
(
d
, 
context
->
state
, 
SHA384_DIGEST_LENGTH
);

1031 
	`MEMSET_BZERO
(
context
, sizeof(
SHA384_CTX
));

1032 
	}
}

1034 char *
	$SHA384_End
(
SHA384_CTX
* 
context
, char 
buffer
[]) {

1035 
sha2_byte
 
digest
[
SHA384_DIGEST_LENGTH
], *
d
 = digest;

1036 int 
i
;

1039 
	`assert
(
context
 != (
SHA384_CTX
*)0);

1041 if (
buffer
 != (char*)0) {

1042 
	`SHA384_Final
(
digest
, 
context
);

1044 for (
i
 = 0; i < 
SHA384_DIGEST_LENGTH
; i++) {

1045 *
buffer
++ = 
sha2_hex_digits
[(*
d
 & 0xf0) >> 4];

1046 *
buffer
++ = 
sha2_hex_digits
[*
d
 & 0x0f];

1047 
d
++;

1049 *
buffer
 = (char)0;

1051 
	`MEMSET_BZERO
(
context
, sizeof(
SHA384_CTX
));

1053 
	`MEMSET_BZERO
(
digest
, 
SHA384_DIGEST_LENGTH
);

1054 return 
buffer
;

1055 
	}
}

1057 char* 
	$SHA384_Data
(const 
sha2_byte
* 
data
, 
size_t
 
len
, char 
digest
[
SHA384_DIGEST_STRING_LENGTH
]) {

1058 
SHA384_CTX
 
context
;

1060 
	`SHA384_Init
(&
context
);

1061 
	`SHA384_Update
(&
context
, 
data
, 
len
);

1062 return 
	`SHA384_End
(&
context
, 
digest
);

1063 
	}
}

	@/root/Robux/contrib/sha2/sha2.h

35 #ifndef 
__SHA2_H__


36 #define 
	#__SHA2_H__


	)

38 #ifdef 
__cplusplus


48 #include 
	~<inc/types.h
>

49 #include 
	~<inc/lib.h
>

51 #ifdef 
SHA2_USE_INTTYPES_H


53 #include 
	~<inttypes.h
>

59 #define 
	#SHA2_USE_INTTYPES_H


	)

63 #define 
	#SHA256_BLOCK_LENGTH
 64

	)

64 #define 
	#SHA256_DIGEST_LENGTH
 32

	)

65 #define 
	#SHA256_DIGEST_STRING_LENGTH
 (
SHA256_DIGEST_LENGTH
 * 2 + 1)

	)

66 #define 
	#SHA384_BLOCK_LENGTH
 128

	)

67 #define 
	#SHA384_DIGEST_LENGTH
 48

	)

68 #define 
	#SHA384_DIGEST_STRING_LENGTH
 (
SHA384_DIGEST_LENGTH
 * 2 + 1)

	)

69 #define 
	#SHA512_BLOCK_LENGTH
 128

	)

70 #define 
	#SHA512_DIGEST_LENGTH
 64

	)

71 #define 
	#SHA512_DIGEST_STRING_LENGTH
 (
SHA512_DIGEST_LENGTH
 * 2 + 1)

	)

80 typedef unsigned char 
	tu_int8_t
;

81 typedef unsigned int 
	tu_int32_t
;

82 typedef unsigned long long 
	tu_int64_t
;

100 #ifdef 
SHA2_USE_INTTYPES_H


102 typedef struct 
	s_SHA256_CTX
 {

103 
uint32_t
 
state
[8];

104 
uint64_t
 
bitcount
;

105 
uint8_t
 
buffer
[
SHA256_BLOCK_LENGTH
];

106 } 
	tSHA256_CTX
;

107 typedef struct 
	s_SHA512_CTX
 {

108 
uint64_t
 
state
[8];

109 
uint64_t
 
bitcount
[2];

110 
uint8_t
 
buffer
[
SHA512_BLOCK_LENGTH
];

111 } 
	tSHA512_CTX
;

115 typedef struct 
	s_SHA256_CTX
 {

116 
u_int32_t
 
state
[8];

117 
u_int64_t
 
bitcount
;

118 
u_int8_t
 
buffer
[
SHA256_BLOCK_LENGTH
];

119 } 
	tSHA256_CTX
;

120 typedef struct 
	s_SHA512_CTX
 {

121 
u_int64_t
 
state
[8];

122 
u_int64_t
 
bitcount
[2];

123 
u_int8_t
 
buffer
[
SHA512_BLOCK_LENGTH
];

124 } 
	tSHA512_CTX
;

128 typedef 
SHA512_CTX
 
	tSHA384_CTX
;

132 #ifndef 
NOPROTO


133 #ifdef 
SHA2_USE_INTTYPES_H


135 void 
SHA256_Init
(
SHA256_CTX
 *);

136 void 
SHA256_Update
(
SHA256_CTX
*, const 
uint8_t
*, 
size_t
);

137 void 
SHA256_Final
(
uint8_t
[
SHA256_DIGEST_LENGTH
], 
SHA256_CTX
*);

138 char* 
SHA256_End
(
SHA256_CTX
*, char[
SHA256_DIGEST_STRING_LENGTH
]);

139 char* 
SHA256_Data
(const 
uint8_t
*, 
size_t
, char[
SHA256_DIGEST_STRING_LENGTH
]);

141 void 
SHA384_Init
(
SHA384_CTX
*);

142 void 
SHA384_Update
(
SHA384_CTX
*, const 
uint8_t
*, 
size_t
);

143 void 
SHA384_Final
(
uint8_t
[
SHA384_DIGEST_LENGTH
], 
SHA384_CTX
*);

144 char* 
SHA384_End
(
SHA384_CTX
*, char[
SHA384_DIGEST_STRING_LENGTH
]);

145 char* 
SHA384_Data
(const 
uint8_t
*, 
size_t
, char[
SHA384_DIGEST_STRING_LENGTH
]);

147 void 
SHA512_Init
(
SHA512_CTX
*);

148 void 
SHA512_Update
(
SHA512_CTX
*, const 
uint8_t
*, 
size_t
);

149 void 
SHA512_Final
(
uint8_t
[
SHA512_DIGEST_LENGTH
], 
SHA512_CTX
*);

150 char* 
SHA512_End
(
SHA512_CTX
*, char[
SHA512_DIGEST_STRING_LENGTH
]);

151 char* 
SHA512_Data
(const 
uint8_t
*, 
size_t
, char[
SHA512_DIGEST_STRING_LENGTH
]);

155 void 
SHA256_Init
(
SHA256_CTX
 *);

156 void 
SHA256_Update
(
SHA256_CTX
*, const 
u_int8_t
*, 
size_t
);

157 void 
SHA256_Final
(
u_int8_t
[
SHA256_DIGEST_LENGTH
], 
SHA256_CTX
*);

158 char* 
SHA256_End
(
SHA256_CTX
*, char[
SHA256_DIGEST_STRING_LENGTH
]);

159 char* 
SHA256_Data
(const 
u_int8_t
*, 
size_t
, char[
SHA256_DIGEST_STRING_LENGTH
]);

161 void 
SHA384_Init
(
SHA384_CTX
*);

162 void 
SHA384_Update
(
SHA384_CTX
*, const 
u_int8_t
*, 
size_t
);

163 void 
SHA384_Final
(
u_int8_t
[
SHA384_DIGEST_LENGTH
], 
SHA384_CTX
*);

164 char* 
SHA384_End
(
SHA384_CTX
*, char[
SHA384_DIGEST_STRING_LENGTH
]);

165 char* 
SHA384_Data
(const 
u_int8_t
*, 
size_t
, char[
SHA384_DIGEST_STRING_LENGTH
]);

167 void 
SHA512_Init
(
SHA512_CTX
*);

168 void 
SHA512_Update
(
SHA512_CTX
*, const 
u_int8_t
*, 
size_t
);

169 void 
SHA512_Final
(
u_int8_t
[
SHA512_DIGEST_LENGTH
], 
SHA512_CTX
*);

170 char* 
SHA512_End
(
SHA512_CTX
*, char[
SHA512_DIGEST_STRING_LENGTH
]);

171 char* 
SHA512_Data
(const 
u_int8_t
*, 
size_t
, char[
SHA512_DIGEST_STRING_LENGTH
]);

177 void 
SHA256_Init
();

178 void 
SHA256_Update
();

179 void 
SHA256_Final
();

180 char* 
SHA256_End
();

181 char* 
SHA256_Data
();

183 void 
SHA384_Init
();

184 void 
SHA384_Update
();

185 void 
SHA384_Final
();

186 char* 
SHA384_End
();

187 char* 
SHA384_Data
();

189 void 
SHA512_Init
();

190 void 
SHA512_Update
();

191 void 
SHA512_Final
();

192 char* 
SHA512_End
();

193 char* 
SHA512_Data
();

197 #ifdef 
__cplusplus


	@/root/Robux/contrib/sha2/sha2prog.c

34 #include 
	~<stdio.h
>

35 #include 
	~<stdlib.h
>

36 #include 
	~<sysexits.h
>

37 #include 
	~<sys/types.h
>

38 #include 
	~<sys/uio.h
>

39 #include 
	~<unistd.h
>

41 #include 
	~"sha2.h
"

43 void 
	$usage
(char *
prog
, char *
msg
) {

44 
	`fprintf
(
stderr
, "%s\nUsage:\t%s [options] [<file>]\nOptions:\n\t-256\tGenerate SHA-256 hash\n\t-384\tGenerate SHA-284 hash\n\t-512\tGenerate SHA-512 hash\n\t-ALL\tGenerate all three hashes\n\t-q\tQuiet mode - only output hexadecimal hashes, one per line\n\n", 
msg
, 
prog
);

45 
	`exit
(-1);

46 
	}
}

48 #define 
	#BUFLEN
 16384

	)

50 int 
	$main
(int 
argc
, char **
argv
) {

51 int 
kl
, 
l
, 
fd
, 
ac
;

52 int 
quiet
 = 0, 
hash
 = 0;

53 char *
av
, *
file
 = (char*)0;

54 
FILE
 *
IN
 = (FILE*)0;

55 
SHA256_CTX
 
ctx256
;

56 
SHA384_CTX
 
ctx384
;

57 
SHA512_CTX
 
ctx512
;

58 unsigned char 
buf
[
BUFLEN
];

60 
	`SHA256_Init
(&
ctx256
);

61 
	`SHA384_Init
(&
ctx384
);

62 
	`SHA512_Init
(&
ctx512
);

65 
fd
 = 
	`fileno
(
stdin
);

67 
ac
 = 1;

68 while (
ac
 < 
argc
) {

69 if (*
argv
[
ac
] == '-') {

70 
av
 = 
argv
[
ac
] + 1;

71 if (!
	`strcmp
(
av
, "q")) {

72 
quiet
 = 1;

73 } else if (!
	`strcmp
(
av
, "256")) {

74 
hash
 |= 1;

75 } else if (!
	`strcmp
(
av
, "384")) {

76 
hash
 |= 2;

77 } else if (!
	`strcmp
(
av
, "512")) {

78 
hash
 |= 4;

79 } else if (!
	`strcmp
(
av
, "ALL")) {

80 
hash
 = 7;

82 
	`usage
(
argv
[0], "Invalid option.");

84 
ac
++;

86 
file
 = 
argv
[
ac
++];

87 if (
ac
 != 
argc
) {

88 
	`usage
(
argv
[0], "Too many arguments.");

90 if ((
IN
 = 
	`fopen
(
file
, "r")) == 
NULL
) {

91 
	`perror
(
argv
[0]);

92 
	`exit
(-1);

94 
fd
 = 
	`fileno
(
IN
);

97 if (
hash
 == 0)

98 
hash
 = 7;

100 
kl
 = 0;

101 while ((
l
 = 
	`read
(
fd
,
buf
,
BUFLEN
)) > 0) {

102 
kl
 += 
l
;

103 
	`SHA256_Update
(&
ctx256
, (unsigned char*)
buf
, 
l
);

104 
	`SHA384_Update
(&
ctx384
, (unsigned char*)
buf
, 
l
);

105 
	`SHA512_Update
(&
ctx512
, (unsigned char*)
buf
, 
l
);

107 if (
file
) {

108 
	`fclose
(
IN
);

111 if (
hash
 & 1) {

112 
	`SHA256_End
(&
ctx256
, 
buf
);

113 if (!
quiet
)

114 
	`printf
("SHA-256 (%s) = ", 
file
);

115 
	`printf
("%s\n", 
buf
);

117 if (
hash
 & 2) {

118 
	`SHA384_End
(&
ctx384
, 
buf
);

119 if (!
quiet
)

120 
	`printf
("SHA-384 (%s) = ", 
file
);

121 
	`printf
("%s\n", 
buf
);

123 if (
hash
 & 4) {

124 
	`SHA512_End
(&
ctx512
, 
buf
);

125 if (!
quiet
)

126 
	`printf
("SHA-512 (%s) = ", 
file
);

127 
	`printf
("%s\n", 
buf
);

131 
	}
}

	@/root/Robux/contrib/sha2/sha2speed.c

35 #include 
	~<stdio.h
>

36 #include 
	~<stdlib.h
>

37 #include 
	~<string.h
>

38 #include 
	~<sys/time.h
>

40 #include 
	~"sha2.h
"

42 #define 
	#BUFSIZE
 16384

	)

44 void 
	$usage
(char *
prog
) {

45 
	`fprintf
(
stderr
, "Usage:\t%s [<num-of-bytes>] [<num-of-loops>] [<fill-byte>]\n", 
prog
);

46 
	`exit
(-1);

47 
	}
}

49 void 
	$printspeed
(char *
caption
, unsigned long 
bytes
, double 
time
) {

50 if (
bytes
 / 1073741824UL > 0) {

51 
	`printf
("%s %.4f sec (%.3f GBps)\n", 
caption
, 
time
, (double)
bytes
/1073741824UL/time);

52 } else if (
bytes
 / 1048576 > 0) {

53 
	`printf
("%s %.4f (%.3f MBps)\n", 
caption
, 
time
, (double)
bytes
/1048576/time);

54 } else if (
bytes
 / 1024 > 0) {

55 
	`printf
("%s %.4f (%.3f KBps)\n", 
caption
, 
time
, (double)
bytes
/1024/time);

57 
	`printf
("%s %.4f (%f Bps)\n", 
caption
, 
time
, (double)
bytes
/time);

59 
	}
}

62 int 
	$main
(int 
argc
, char **
argv
) {

63 
SHA256_CTX
 
c256
;

64 
SHA384_CTX
 
c384
;

65 
SHA512_CTX
 
c512
;

66 char 
buf
[
BUFSIZE
];

67 char 
md
[
SHA512_DIGEST_STRING_LENGTH
];

68 int 
bytes
, 
blocks
, 
rep
, 
i
, 
j
;

69 struct 
timeval
 
start
, 
end
;

70 double 
t
, 
ave256
, 
ave384
, 
ave512
;

71 double 
best256
, 
best384
, 
best512
;

73 if (
argc
 > 4) {

74 
	`usage
(
argv
[0]);

78 
bytes
 = 1024 * 1024 * 16;

79 if (
argc
 > 1) {

80 
blocks
 = 
	`atoi
(
argv
[1]);

82 
blocks
 = 
bytes
 / 
BUFSIZE
;

85 
rep
 = 10;

86 if (
argc
 > 2) {

87 
rep
 = 
	`atoi
(
argv
[2]);

91 if (
argc
 > 3) {

92 
	`memset
(
buf
, 
	`atoi
(
argv
[2]), 
BUFSIZE
);

94 
	`memset
(
buf
, 0xb7, 
BUFSIZE
);

97 
ave256
 = 
ave384
 = 
ave512
 = 0;

98 
best256
 = 
best384
 = 
best512
 = 100000;

99 for (
i
 = 0; i < 
rep
; i++) {

100 
	`SHA256_Init
(&
c256
);

101 
	`SHA384_Init
(&
c384
);

102 
	`SHA512_Init
(&
c512
);

104 
	`gettimeofday
(&
start
, (struct 
timezone
*)0);

105 for (
j
 = 0; j < 
blocks
; j++) {

106 
	`SHA256_Update
(&
c256
, (unsigned char*)
buf
, 
BUFSIZE
);

108 if (
bytes
 % 
BUFSIZE
) {

109 
	`SHA256_Update
(&
c256
, (unsigned char*)
buf
, 
bytes
 % 
BUFSIZE
);

111 
	`SHA256_End
(&
c256
, 
md
);

112 
	`gettimeofday
(&
end
, (struct 
timezone
*)0);

113 
t
 = ((
end
.
tv_sec
 - 
start
.tv_sec) * 1000000.0 + (end.
tv_usec
 - start.tv_usec)) / 1000000.0;

114 
ave256
 += 
t
;

115 if (
t
 < 
best256
) {

116 
best256
 = 
t
;

118 
	`printf
("SHA-256[%d] (%.4f/%.4f/%.4f seconds) = 0x%s\n", 
i
+1, 
t
, 
ave256
/(i+1), 
best256
, 
md
);

120 
	`gettimeofday
(&
start
, (struct 
timezone
*)0);

121 for (
j
 = 0; j < 
blocks
; j++) {

122 
	`SHA384_Update
(&
c384
, (unsigned char*)
buf
, 
BUFSIZE
);

124 if (
bytes
 % 
BUFSIZE
) {

125 
	`SHA384_Update
(&
c384
, (unsigned char*)
buf
, 
bytes
 % 
BUFSIZE
);

127 
	`SHA384_End
(&
c384
, 
md
);

128 
	`gettimeofday
(&
end
, (struct 
timezone
*)0);

129 
t
 = ((
end
.
tv_sec
 - 
start
.tv_sec) * 1000000.0 + (end.
tv_usec
 - start.tv_usec)) / 1000000.0;

130 
ave384
 += 
t
;

131 if (
t
 < 
best384
) {

132 
best384
 = 
t
;

134 
	`printf
("SHA-384[%d] (%.4f/%.4f/%.4f seconds) = 0x%s\n", 
i
+1, 
t
, 
ave384
/(i+1), 
best384
, 
md
);

136 
	`gettimeofday
(&
start
, (struct 
timezone
*)0);

137 for (
j
 = 0; j < 
blocks
; j++) {

138 
	`SHA512_Update
(&
c512
, (unsigned char*)
buf
, 
BUFSIZE
);

140 if (
bytes
 % 
BUFSIZE
) {

141 
	`SHA512_Update
(&
c512
, (unsigned char*)
buf
, 
bytes
 % 
BUFSIZE
);

143 
	`SHA512_End
(&
c512
, 
md
);

144 
	`gettimeofday
(&
end
, (struct 
timezone
*)0);

145 
t
 = ((
end
.
tv_sec
 - 
start
.tv_sec) * 1000000.0 + (end.
tv_usec
 - start.tv_usec)) / 1000000.0;

146 
ave512
 += 
t
;

147 if (
t
 < 
best512
) {

148 
best512
 = 
t
;

150 
	`printf
("SHA-512[%d] (%.4f/%.4f/%.4f seconds) = 0x%s\n", 
i
+1, 
t
, 
ave512
/(i+1), 
best512
, 
md
);

152 
ave256
 /= 
rep
;

153 
ave384
 /= 
rep
;

154 
ave512
 /= 
rep
;

155 
	`printf
("\nTEST RESULTS SUMMARY:\nTEST REPETITIONS: %d\n", 
rep
);

156 if (
bytes
 / 1073741824UL > 0) {

157 
	`printf
("TEST SET SIZE: %.3f GB\n", (double)
bytes
/1073741824UL);

158 } else if (
bytes
 / 1048576 > 0) {

159 
	`printf
("TEST SET SIZE: %.3f MB\n", (double)
bytes
/1048576);

160 } else if (
bytes
 /1024 > 0) {

161 
	`printf
("TEST SET SIZE: %.3f KB\n", (double)
bytes
/1024);

163 
	`printf
("TEST SET SIZE: %d B\n", 
bytes
);

165 
	`printspeed
("SHA-256 average:", 
bytes
, 
ave256
);

166 
	`printspeed
("SHA-256 best: ", 
bytes
, 
best256
);

167 
	`printspeed
("SHA-384 average:", 
bytes
, 
ave384
);

168 
	`printspeed
("SHA-384 best: ", 
bytes
, 
best384
);

169 
	`printspeed
("SHA-512 average:", 
bytes
, 
ave512
);

170 
	`printspeed
("SHA-512 best: ", 
bytes
, 
best512
);

173 
	}
}

	@/root/Robux/fs/bc.c

2 #include 
	~"fs.h
"

5 
bool
 
va_is_accessed
(void *
va
);

6 int 
va_get_pte
(void *
va
);

12 #define 
	#BLOCK_CACHE_MAX
 16

	)

15 struct 
	sBlockCacheEntry


18 int 
	mblockno
;

19 struct 
BlockCacheEntry
 *
	mnext
;

20 struct 
BlockCacheEntry
 *
	mprev
;

25 struct 
BlockCacheEntry
 
	gblock_entries
[
BLOCK_CACHE_MAX
];

30 
	$init_block_entries
()

33 int 
i
;

34 for (
i
 = 0; i < 
BLOCK_CACHE_MAX
; i++)

36 struct 
BlockCacheEntry
 *
ent
 = &
block_entries
[
i
];

37 
ent
->
blockno
 = -1;

40 
	}
}

42 struct 
BlockCacheEntry
*

43 
	$alloc_block_entry
(int 
blockno
)

45 
	`assert
(
blockno
 >= 0);

47 int 
i
;

48 for (
i
 = 0; i < 
BLOCK_CACHE_MAX
; i++)

50 struct 
BlockCacheEntry
 *
ent
 = &
block_entries
[
i
];

51 if(
ent
->
blockno
 == -1)

53 
ent
->
blockno
 = blockno;

54 return 
ent
;

58 
	`panic
("Ran out of entries for the block cache\nThis is a kernel bug\n");

59 return 
NULL
;

60 
	}
}

63 
	$free_block_entry
(struct 
BlockCacheEntry
 *
ent
)

65 
ent
->
blockno
 = -1;

66 
	}
}

71 struct 
	sBlockCacheList


73 struct 
BlockCacheEntry
 *
	mhead
;

74 struct 
BlockCacheEntry
 *
	mtail
;

75 int 
	msize
;

76 } 
	gcache
 = {
NULL
, NULL, 0};

84 
	$block_cache_insert
(struct 
BlockCacheEntry
 *
ent
)

87 
	`assert
(
cache
.
size
 != 
BLOCK_CACHE_MAX
);

91 
	`assert
(
ent
->
blockno
 != 1);

95 if (!
cache
.
head
)

98 
cache
.
head
 = cache.
tail
 = 
ent
;

99 
ent
->
next
 = ent->
prev
 = 
NULL
;

106 
ent
->
prev
 = 
cache
.
tail
;

107 
ent
->
next
 = 
NULL
;

110 
cache
.
tail
->
next
 = 
ent
;

113 
cache
.
tail
 = 
ent
;

116 
cache
.
size
++;

117 
	}
}

121 
	$block_cache_remove
(struct 
BlockCacheEntry
 *
ent
)

125 if (
ent
->
prev
)

126 
ent
->
prev
->
next
 = ent->next;

127 if (
ent
->
next
)

128 
ent
->
next
->
prev
 = ent->prev;

131 if (
cache
.
head
 == 
ent
)

132 
cache
.
head
 = 
ent
->
next
;

133 if (
cache
.
tail
 == 
ent
)

134 
cache
.
tail
 = 
ent
->
prev
;

136 
cache
.
size
--;

137 
	}
}

139 struct 
BlockCacheEntry
 *

140 
	$block_cache_find
(int 
blockno
)

142 struct 
BlockCacheEntry
 *
ret
;

143 for (
ret
 = 
cache
.
head
; ret != 
NULL
; ret++)

145 if (
ret
->
blockno
 == blockno)

146 return 
ret
;

149 return 
NULL
;

150 
	}
}

154 
	$block_cache_rotate
()

157 struct 
BlockCacheEntry
 *
super
 = 
NULL
;

159 struct 
BlockCacheEntry
 *
ent
 = 
cache
.
head
;

160 while (
ent
 != 
NULL
)

164 if (
ent
->
blockno
 == 1)

166 
super
 = 
ent
;

167 
ent
 = ent->
next
;

174 void *
addr
 = 
	`diskaddr
(
ent
->
blockno
);

175 if(
	`va_is_accessed
(
addr
))

178 
	`block_cache_remove
(
ent
);

179 
	`block_cache_insert
(
ent
);

180 int 
r
 = 
	`sys_page_map
(
	`sys_getenvid
(), 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

181 
	`sys_getenvid
(), 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

182 
	`va_get_pte
(
addr
) & 
PTE_SYSCALL
 & ~
PTE_A
);

184 
ent
 = 
cache
.
head
;

189 
ent
 = ent->
next
;

194 if(
super
)

196 
	`block_cache_remove
(
super
);

197 
	`block_cache_insert
(
super
);

199 
	}
}

203 
	$block_cache_evict
()

206 
	`assert
(
cache
.
head
);

208 struct 
BlockCacheEntry
 *
ent
 = 
cache
.
head
;

211 
	`block_cache_remove
(
ent
);

214 if(
	`va_is_dirty
(
	`diskaddr
(
ent
->
blockno
)))

216 
	`flush_block
(
	`diskaddr
(
ent
->
blockno
));

220 
	`sys_page_unmap
(
	`sys_getenvid
(), 
	`diskaddr
(
ent
->
blockno
));

223 
	`free_block_entry
(
ent
);

225 
	}
}

231 
	$diskaddr
(
uint32_t
 
blockno
)

233 if (
blockno
 == 0 || (
super
 && blockno >= super->
s_nblocks
))

234 
	`panic
("bad block number %08x in diskaddr", 
blockno
);

235 return (char*) (
DISKMAP
 + 
blockno
 * 
BLKSIZE
);

236 
	}
}

239 
bool


240 
	$va_is_mapped
(void *
va
)

242 return (
vpd
[
	`PDX
(
va
)] & 
PTE_P
) && (
vpt
[
	`PGNUM
(va)] & PTE_P);

243 
	}
}

246 
bool


247 
	$va_is_accessed
(void *
va
)

249 return (
vpt
[
	`PGNUM
(
va
)] & 
PTE_A
) != 0;

250 
	}
}

253 
bool


254 
	$va_is_dirty
(void *
va
)

256 return (
vpt
[
	`PGNUM
(
va
)] & 
PTE_D
) != 0;

257 
	}
}

261 
	$va_get_pte
(void *
va
)

263 return 
vpt
[
	`PGNUM
(
va
)];

264 
	}
}

270 
	$bc_pgfault
(struct 
UTrapframe
 *
utf
)

272 void *
addr
 = (void *) 
utf
->
utf_fault_va
;

273 
uint32_t
 
blockno
 = ((uint32_t)
addr
 - 
DISKMAP
) / 
BLKSIZE
;

274 int 
r
;

278 
	`block_cache_rotate
();

279 if(
cache
.
size
 == 
BLOCK_CACHE_MAX
)

281 
	`block_cache_evict
();

285 if (
addr
 < (void*)
DISKMAP
 || addr >= (void*)(DISKMAP + 
DISKSIZE
))

286 
	`panic
("page fault in FS: eip %08x, va %08x, err %04x",

287 
utf
->
utf_eip
, 
addr
, utf->
utf_err
);

290 if (
super
 && 
blockno
 >= super->
s_nblocks
)

291 
	`panic
("reading non-existent block %08x\n", 
blockno
);

301 
	`sys_page_alloc
(
	`sys_getenvid
(), 
	`ROUNDDOWN
(
addr
, 
PGSIZE
), 
PTE_P
 | 
PTE_W
 | 
PTE_U
);

305 if(
blockno
 != 1)

306 
	`block_cache_insert
(
	`alloc_block_entry
(
blockno
));

309 
	`ide_read
(
blockno
 * 
BLKSECTS
, 
	`ROUNDDOWN
(
addr
, 
PGSIZE
), BLKSECTS);

312 
	`sys_page_map
(
	`sys_getenvid
(), 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

313 
	`sys_getenvid
(), 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

314 
	`va_get_pte
(
addr
) & 
PTE_SYSCALL
 & ~
PTE_D
 & ~
PTE_A
);

319 if (
bitmap
 && 
	`block_is_free
(
blockno
))

320 
	`panic
("reading free block %08x\n", 
blockno
);

321 
	}
}

331 
	$flush_block
(void *
addr
)

333 
uint32_t
 
blockno
 = ((uint32_t)
addr
 - 
DISKMAP
) / 
BLKSIZE
;

335 if (
addr
 < (void*)
DISKMAP
 || addr >= (void*)(DISKMAP + 
DISKSIZE
))

336 
	`panic
("flush_block of bad va %08x", 
addr
);

339 if (
	`va_is_mapped
(
addr
) && 
	`va_is_dirty
(addr))

342 
	`ide_write
(
blockno
 * 
BLKSECTS
, 
	`ROUNDDOWN
(
addr
, 
PGSIZE
), BLKSECTS);

344 
	`sys_page_map
(
	`sys_getenvid
(), 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

345 
	`sys_getenvid
(), 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

346 
	`va_get_pte
(
addr
) & 
PTE_SYSCALL
 & ~
PTE_D
);

348 
	}
}

353 
	$check_bc
(void)

355 struct 
Super
 
backup
;

358 
	`memmove
(&
backup
, 
	`diskaddr
(1), sizeof backup);

361 
	`strcpy
(
	`diskaddr
(1), "OOPS!\n");

362 
	`flush_block
(
	`diskaddr
(1));

363 
	`assert
(
	`va_is_mapped
(
	`diskaddr
(1)));

364 
	`assert
(!
	`va_is_dirty
(
	`diskaddr
(1)));

367 
	`sys_page_unmap
(0, 
	`diskaddr
(1));

368 
	`assert
(!
	`va_is_mapped
(
	`diskaddr
(1)));

371 
	`assert
(
	`strcmp
(
	`diskaddr
(1), "OOPS!\n") == 0);

374 
	`memmove
(
	`diskaddr
(1), &
backup
, sizeof backup);

375 
	`flush_block
(
	`diskaddr
(1));

377 
	`cprintf
("block cache is good\n");

378 
	}
}

381 
	$bc_init
(void)

383 
	`set_pgfault_handler
(
bc_pgfault
);

384 
	`init_block_entries
();

385 
	`check_bc
();

386 
	}
}

	@/root/Robux/fs/fs.c

1 #include 
	~<inc/string.h
>

3 #include 
	~"fs.h
"

11 
	$check_super
(void)

13 if (
super
->
s_magic
 != 
FS_MAGIC
)

14 
	`panic
("bad file system magic number");

16 if (
super
->
s_nblocks
 > 
DISKSIZE
/
BLKSIZE
)

17 
	`panic
("file system is too large");

19 
	`cprintf
("superblock is good\n");

20 
	}
}

28 
bool


29 
	$block_is_free
(
uint32_t
 
blockno
)

31 if (
super
 == 0 || 
blockno
 >= super->
s_nblocks
)

33 if (
bitmap
[
blockno
 / 32] & (1 << (blockno % 32)))

36 
	}
}

40 
	$free_block
(
uint32_t
 
blockno
)

43 if (
blockno
 == 0)

44 
	`panic
("attempt to free zero block");

45 
bitmap
[
blockno
/32] |= 1<<(blockno%32);

46 
	}
}

57 
	$alloc_block
(void)

64 int 
word
;

65 int 
blockno
 = -1;

70 int 
total_words
 = 
super
->
s_nblocks
 / 32 +

71 ((
super
->
s_nblocks
 % 32)?1:0);

74 for (
word
 = 0; word < 
total_words
; word++)

77 if (
bitmap
[
word
] != 0)

83 
uint32_t
 
temp
 = 
bitmap
[
word
];

84 int 
i
 = 0;

85 while ((~
temp
 & 1) || (
word
 == 0 && 
i
 == 0))

87 
temp
 = temp >> 1;

88 
i
++;

93 
blockno
 = 
word
*32 + 
i
;

102 if (
blockno
 != -1)

104 
bitmap
[
blockno
/32] &= ~(1<<(blockno%32));

106 
	`flush_block
(&
bitmap
[
blockno
/32]);

107 return 
blockno
;

110 return -
E_NO_DISK
;

111 
	}
}

118 
	$check_bitmap
(void)

120 
uint32_t
 
i
;

123 for (
i
 = 0; i * 
BLKBITSIZE
 < 
super
->
s_nblocks
; i++)

124 
	`assert
(!
	`block_is_free
(2+
i
));

127 
	`assert
(!
	`block_is_free
(0));

128 
	`assert
(!
	`block_is_free
(1));

130 
	`cprintf
("bitmap is good\n");

131 
	}
}

139 
	$fs_init
(void)

141 
	`static_assert
(sizeof(struct 
File
) == 256);

144 if (
	`ide_probe_disk1
())

145 
	`ide_set_disk
(1);

147 
	`ide_set_disk
(0);

149 
	`bc_init
();

152 
super
 = 
	`diskaddr
(1);

154 
bitmap
 = 
	`diskaddr
(2);

156 
	`check_super
();

157 
	`check_bitmap
();

158 
	}
}

177 
	$file_block_walk
(struct 
File
 *
f
, 
uint32_t
 
filebno
, uint32_t **
ppdiskbno
, 
bool
 
alloc
)

182 if (
filebno
 > 
NDIRECT
 + 
NINDIRECT
)

183 return -
E_INVAL
;

186 if (
filebno
 < 
NDIRECT
)

188 *
ppdiskbno
 = &
f
->
f_direct
[
filebno
];

193 
uint32_t
 *
indirect_block
;

196 if (
f
->
f_indirect
 == 0)

199 if (!
alloc
)

200 return -
E_NOT_FOUND
;

202 int 
block
 = 
	`alloc_block
();

205 if (
block
 < 0)

206 return 
block
;

209 
f
->
f_indirect
 = 
block
;

212 
indirect_block
 = (
uint32_t
*)
	`diskaddr
(
block
);

213 
	`memset
(
indirect_block
, 0, 
BLKSIZE
);

217 
indirect_block
 = (
uint32_t
*)
	`diskaddr
(
f
->
f_indirect
);

221 *
ppdiskbno
 = &
indirect_block
[
filebno
-
NDIRECT
];

223 
	}
}

235 
	$file_get_block
(struct 
File
 *
f
, 
uint32_t
 
filebno
, char **
blk
)

238 
uint32_t
 *
diskblock
;

241 int 
r
;

242 if ((
r
 = 
	`file_block_walk
(
f
, 
filebno
, &
diskblock
, 1)) < 0)

244 return 
r
;

248 if (*
diskblock
 == 0)

250 if ((
r
 = 
	`alloc_block
()) < 0)

251 return 
r
;

254 *
diskblock
 = 
r
;

259 *
blk
 = (char *) 
	`diskaddr
(*
diskblock
);

262 
	}
}

269 
	$dir_lookup
(struct 
File
 *
dir
, const char *
name
, struct File **
file
)

271 int 
r
;

272 
uint32_t
 
i
, 
j
, 
nblock
;

273 char *
blk
;

274 struct 
File
 *
f
;

279 
	`assert
((
dir
->
f_size
 % 
BLKSIZE
) == 0);

280 
nblock
 = 
dir
->
f_size
 / 
BLKSIZE
;

281 for (
i
 = 0; i < 
nblock
; i++) {

282 if ((
r
 = 
	`file_get_block
(
dir
, 
i
, &
blk
)) < 0)

283 return 
r
;

284 
f
 = (struct 
File
*) 
blk
;

285 for (
j
 = 0; j < 
BLKFILES
; j++)

286 if (
	`strcmp
(
f
[
j
].
f_name
, 
name
) == 0) {

287 *
file
 = &
f
[
j
];

291 return -
E_NOT_FOUND
;

292 
	}
}

297 
	$dir_alloc_file
(struct 
File
 *
dir
, struct File **
file
)

299 int 
r
;

300 
uint32_t
 
nblock
, 
i
, 
j
;

301 char *
blk
;

302 struct 
File
 *
f
;

304 
	`assert
((
dir
->
f_size
 % 
BLKSIZE
) == 0);

305 
nblock
 = 
dir
->
f_size
 / 
BLKSIZE
;

306 for (
i
 = 0; i < 
nblock
; i++) {

307 if ((
r
 = 
	`file_get_block
(
dir
, 
i
, &
blk
)) < 0)

308 return 
r
;

309 
f
 = (struct 
File
*) 
blk
;

310 for (
j
 = 0; j < 
BLKFILES
; j++)

311 if (
f
[
j
].
f_name
[0] == '\0') {

312 *
file
 = &
f
[
j
];

316 
dir
->
f_size
 += 
BLKSIZE
;

317 if ((
r
 = 
	`file_get_block
(
dir
, 
i
, &
blk
)) < 0)

318 return 
r
;

319 
f
 = (struct 
File
*) 
blk
;

320 *
file
 = &
f
[0];

322 
	}
}

326 
	$skip_slash
(const char *
p
)

328 while (*
p
 == '/')

329 
p
++;

330 return 
p
;

331 
	}
}

340 
	$walk_path
(const char *
path
, struct 
File
 **
pdir
, struct File **
pf
, char *
lastelem
)

342 const char *
p
;

343 char 
name
[
MAXNAMELEN
];

344 struct 
File
 *
dir
, *
f
;

345 int 
r
;

349 
path
 = 
	`skip_slash
(path);

350 
f
 = &
super
->
s_root
;

351 
dir
 = 0;

352 
name
[0] = 0;

354 if (
pdir
)

355 *
pdir
 = 0;

356 *
pf
 = 0;

357 while (*
path
 != '\0') {

358 
dir
 = 
f
;

359 
p
 = 
path
;

360 while (*
path
 != '/' && *path != '\0')

361 
path
++;

362 if (
path
 - 
p
 >= 
MAXNAMELEN
)

363 return -
E_BAD_PATH
;

364 
	`memmove
(
name
, 
p
, 
path
 - p);

365 
name
[
path
 - 
p
] = '\0';

366 
path
 = 
	`skip_slash
(path);

368 if (
dir
->
f_type
 != 
FTYPE_DIR
)

369 return -
E_NOT_FOUND
;

371 if ((
r
 = 
	`dir_lookup
(
dir
, 
name
, &
f
)) < 0) {

372 if (
r
 == -
E_NOT_FOUND
 && *
path
 == '\0') {

373 if (
pdir
)

374 *
pdir
 = 
dir
;

375 if (
lastelem
)

376 
	`strcpy
(
lastelem
, 
name
);

377 *
pf
 = 0;

379 return 
r
;

383 if (
pdir
)

384 *
pdir
 = 
dir
;

385 *
pf
 = 
f
;

387 
	}
}

396 
	$file_create
(const char *
path
, struct 
File
 **
pf
,
gid_t
 
gid
,
uid_t
 
uid
,unsigned 
perm
)

398 char 
name
[
MAXNAMELEN
];

399 int 
r
;

400 struct 
File
 *
dir
, *
f
;

402 if ((
r
 = 
	`walk_path
(
path
, &
dir
, &
f
, 
name
)) == 0)

403 return -
E_FILE_EXISTS
;

404 if (
r
 != -
E_NOT_FOUND
 || 
dir
 == 0)

405 return 
r
;

406 if ((
r
 = 
	`dir_alloc_file
(
dir
, &
f
)) < 0)

407 return 
r
;

408 
	`strcpy
(
f
->
f_name
, 
name
);

409 
f
->
f_perm
 = 
perm
;

410 
f
->
f_gid
 = 
gid
;

411 
f
->
f_uid
 = 
uid
;

412 *
pf
 = 
f
;

413 
	`file_flush
(
dir
);

415 
	}
}

420 
	$file_open
(const char *
path
, struct 
File
 **
pf
)

422 return 
	`walk_path
(
path
, 0, 
pf
, 0);

423 
	}
}

428 
ssize_t


429 
	$file_read
(struct 
File
 *
f
, void *
buf
, 
size_t
 
count
, 
off_t
 
offset
)

431 int 
r
, 
bn
;

432 
off_t
 
pos
;

433 char *
blk
;

435 if (
offset
 >= 
f
->
f_size
)

438 
count
 = 
	`MIN
(count, 
f
->
f_size
 - 
offset
);

440 for (
pos
 = 
offset
; pos < offset + 
count
; ) {

441 if ((
r
 = 
	`file_get_block
(
f
, 
pos
 / 
BLKSIZE
, &
blk
)) < 0)

442 return 
r
;

443 
bn
 = 
	`MIN
(
BLKSIZE
 - 
pos
 % BLKSIZE, 
offset
 + 
count
 - pos);

444 
	`memmove
(
buf
, 
blk
 + 
pos
 % 
BLKSIZE
, 
bn
);

445 
pos
 += 
bn
;

446 
buf
 += 
bn
;

449 return 
count
;

450 
	}
}

457 
	$file_write
(struct 
File
 *
f
, const void *
buf
, 
size_t
 
count
, 
off_t
 
offset
)

459 int 
r
, 
bn
;

460 
off_t
 
pos
;

461 char *
blk
;

464 if (
offset
 + 
count
 > 
f
->
f_size
)

465 if ((
r
 = 
	`file_set_size
(
f
, 
offset
 + 
count
)) < 0)

466 return 
r
;

468 for (
pos
 = 
offset
; pos < offset + 
count
; ) {

469 if ((
r
 = 
	`file_get_block
(
f
, 
pos
 / 
BLKSIZE
, &
blk
)) < 0)

470 return 
r
;

471 
bn
 = 
	`MIN
(
BLKSIZE
 - 
pos
 % BLKSIZE, 
offset
 + 
count
 - pos);

472 
	`memmove
(
blk
 + 
pos
 % 
BLKSIZE
, 
buf
, 
bn
);

473 
pos
 += 
bn
;

474 
buf
 += 
bn
;

477 return 
count
;

478 
	}
}

483 
	$file_free_block
(struct 
File
 *
f
, 
uint32_t
 
filebno
)

485 int 
r
;

486 
uint32_t
 *
ptr
;

488 if ((
r
 = 
	`file_block_walk
(
f
, 
filebno
, &
ptr
, 0)) < 0)

489 return 
r
;

490 if (*
ptr
) {

491 
	`free_block
(*
ptr
);

492 *
ptr
 = 0;

495 
	}
}

507 
	$file_truncate_blocks
(struct 
File
 *
f
, 
off_t
 
newsize
)

509 int 
r
;

510 
uint32_t
 
bno
, 
old_nblocks
, 
new_nblocks
;

512 
old_nblocks
 = (
f
->
f_size
 + 
BLKSIZE
 - 1) / BLKSIZE;

513 
new_nblocks
 = (
newsize
 + 
BLKSIZE
 - 1) / BLKSIZE;

514 for (
bno
 = 
new_nblocks
; bno < 
old_nblocks
; bno++)

515 if ((
r
 = 
	`file_free_block
(
f
, 
bno
)) < 0)

516 
	`cprintf
("warning: file_free_block: %e", 
r
);

518 if (
new_nblocks
 <= 
NDIRECT
 && 
f
->
f_indirect
) {

519 
	`free_block
(
f
->
f_indirect
);

520 
f
->
f_indirect
 = 0;

522 
	}
}

526 
	$file_set_size
(struct 
File
 *
f
, 
off_t
 
newsize
)

528 if (
f
->
f_size
 > 
newsize
)

529 
	`file_truncate_blocks
(
f
, 
newsize
);

530 
f
->
f_size
 = 
newsize
;

531 
	`flush_block
(
f
);

533 
	}
}

537 
	$file_set_perm
(struct 
File
 *
f
, 
fsperm_t
 
newperm
)

539 
f
->
f_perm
 = 
newperm
;

540 
	`flush_block
(
f
);

542 
	}
}

546 
	$file_set_uid
(struct 
File
 *
f
, 
uid_t
 
uid
)

548 
f
->
f_uid
 = 
uid
;

549 
	`flush_block
(
f
);

551 
	}
}

555 
	$file_set_gid
(struct 
File
 *
f
,
gid_t
 
gid
)

557 
f
->
f_gid
 = 
gid
;

558 
	`flush_block
(
f
);

560 
	}
}

568 
	$file_flush
(struct 
File
 *
f
)

570 int 
i
;

571 
uint32_t
 *
pdiskbno
;

573 for (
i
 = 0; i < (
f
->
f_size
 + 
BLKSIZE
 - 1) / BLKSIZE; i++) {

574 if (
	`file_block_walk
(
f
, 
i
, &
pdiskbno
, 0) < 0 ||

575 
pdiskbno
 == 
NULL
 || *pdiskbno == 0)

577 
	`flush_block
(
	`diskaddr
(*
pdiskbno
));

579 
	`flush_block
(
f
);

580 if (
f
->
f_indirect
)

582 
	`flush_block
(
	`diskaddr
(
f
->
f_indirect
));

584 
	}
}

588 
	$file_remove
(const char *
path
)

590 int 
r
;

591 struct 
File
 *
f
;

593 if ((
r
 = 
	`walk_path
(
path
, 0, &
f
, 0)) < 0)

594 return 
r
;

596 
	`file_truncate_blocks
(
f
, 0);

597 
f
->
f_name
[0] = '\0';

598 
f
->
f_size
 = 0;

599 
	`flush_block
(
f
);

602 
	}
}

606 
	$fs_sync
(void)

608 int 
i
;

609 for (
i
 = 1; i < 
super
->
s_nblocks
; i++)

611 
	`flush_block
(
	`diskaddr
(
i
));

613 
	}
}

	@/root/Robux/fs/fs.h

1 #include 
	~<inc/fs.h
>

2 #include 
	~<inc/lib.h
>

4 #define 
	#SECTSIZE
 512

5 #define 
	#BLKSECTS
 (
BLKSIZE
 / 
SECTSIZE
)

6 

	)

9 #define 
	#DISKMAP
 0x10000000

	)

12 #define 
	#DISKSIZE
 0xC0000000

	)

14 struct 
Super
 *
	gsuper
;

15 
uint32_t
 *
	gbitmap
;

18 
bool
 
ide_probe_disk1
(void);

19 void 
ide_set_disk
(int 
diskno
);

20 int 
ide_read
(
uint32_t
 
secno
, void *
dst
, 
size_t
 
nsecs
);

21 int 
ide_write
(
uint32_t
 
secno
, const void *
src
, 
size_t
 
nsecs
);

24 void* 
diskaddr
(
uint32_t
 
blockno
);

25 
bool
 
va_is_mapped
(void *
va
);

26 
bool
 
va_is_dirty
(void *
va
);

27 void 
flush_block
(void *
addr
);

28 void 
bc_init
(void);

31 void 
fs_init
(void);

32 int 
file_get_block
(struct 
File
 *
f
, 
uint32_t
 
file_blockno
, char **
pblk
);

33 int 
file_create
(const char *
path
, struct 
File
 **
f
,
gid_t
 
gid
,
uid_t
 
uid
,unsigned 
perm
);

34 int 
file_open
(const char *
path
, struct 
File
 **
f
);

35 
ssize_t
 
file_read
(struct 
File
 *
f
, void *
buf
, 
size_t
 
count
, 
off_t
 
offset
);

36 int 
file_write
(struct 
File
 *
f
, const void *
buf
, 
size_t
 
count
, 
off_t
 
offset
);

37 int 
file_set_size
(struct 
File
 *
f
, 
off_t
 
newsize
);

38 void 
file_flush
(struct 
File
 *
f
);

39 int 
file_remove
(const char *
path
);

40 void 
fs_sync
(void);

41 int 
file_set_perm
(struct 
File
 *
f
, 
fsperm_t
 
newperm
);

42 int 
file_set_uid
(struct 
File
 *
f
, 
uid_t
 
uid
);

43 int 
file_set_gid
(struct 
File
 *
f
, 
gid_t
 
gid
);

46 
bool
 
block_is_free
(
uint32_t
 
blockno
);

47 int 
alloc_block
(void);

50 void 
fs_test
(void);

	@/root/Robux/fs/fsformat.c

6 #define 
	#off_t
 
xxx_off_t


	)

7 #define 
	#bool
 
xxx_bool


	)

8 #include 
	~<assert.h
>

9 #include 
	~<errno.h
>

10 #include 
	~<fcntl.h
>

11 #include 
	~<inttypes.h
>

12 #include 
	~<stdarg.h
>

13 #include 
	~<stdio.h
>

14 #include 
	~<stdlib.h
>

15 #include 
	~<string.h
>

16 #include 
	~<unistd.h
>

17 #include 
	~<sys/mman.h
>

18 #include 
	~<sys/stat.h
>

19 #include 
	~<sys/types.h
>

20 #undef 
off_t


21 #undef 
bool


25 #define 
	#JOS_INC_TYPES_H


	)

26 #define 
	#FS_FORMAT_UTIL


	)

28 typedef 
uint32_t
 
	tphysaddr_t
;

29 typedef 
uint32_t
 
	toff_t
;

30 typedef int 
	tbool
;

32 #include 
	~<inc/mmu.h
>

33 #include 
	~<inc/fs.h
>

35 #define 
	#ROUNDUP
(
n
, 
v
) ((n) - 1 + (v) - ((n) - 1) % (v))

	)

36 #define 
	#MAX_DIR_ENTS
 128

	)

38 struct 
	sDir


40 struct 
File
 *
	mf
;

41 struct 
File
 *
	ments
;

42 int 
	mn
;

45 
uint32_t
 
	gnblocks
;

46 char *
	gdiskmap
, *
	gdiskpos
;

47 struct 
Super
 *
	gsuper
;

48 
uint32_t
 *
	gbitmap
;

51 
	$panic
(const char *
fmt
, ...)

53 
va_list
 
ap
;

55 
	`va_start
(
ap
, 
fmt
);

56 
	`vfprintf
(
stderr
, 
fmt
, 
ap
);

57 
	`va_end
(
ap
);

58 
	`fputc
('\n', 
stderr
);

59 
	`abort
();

60 
	}
}

63 
	$readn
(int 
f
, void *
out
, 
size_t
 
n
)

65 
size_t
 
p
 = 0;

66 while (
p
 < 
n
) {

67 
size_t
 
m
 = 
	`read
(
f
, 
out
 + 
p
, 
n
 - p);

68 if (
m
 < 0)

69 
	`panic
("read: %s", 
	`strerror
(
errno
));

70 if (
m
 == 0)

71 
	`panic
("read: Unexpected EOF");

72 
p
 += 
m
;

74 
	}
}

76 
uint32_t


77 
	$blockof
(void *
pos
)

79 return ((char*)
pos
 - 
diskmap
) / 
BLKSIZE
;

80 
	}
}

83 
	$alloc
(
uint32_t
 
bytes
)

85 void *
start
 = 
diskpos
;

86 
diskpos
 += 
	`ROUNDUP
(
bytes
, 
BLKSIZE
);

87 if (
	`blockof
(
diskpos
) >= 
nblocks
)

88 
	`panic
("out of disk blocks");

89 return 
start
;

90 
	}
}

93 
	$opendisk
(const char *
name
)

95 int 
r
, 
diskfd
, 
nbitblocks
;

97 if ((
diskfd
 = 
	`open
(
name
, 
O_RDWR
 | 
O_CREAT
, 0666)) < 0)

98 
	`panic
("open %s: %s", 
name
, 
	`strerror
(
errno
));

100 if ((
r
 = 
	`ftruncate
(
diskfd
, 0)) < 0

101 || (
r
 = 
	`ftruncate
(
diskfd
, 
nblocks
 * 
BLKSIZE
)) < 0)

102 
	`panic
("truncate %s: %s", 
name
, 
	`strerror
(
errno
));

104 if ((
diskmap
 = 
	`mmap
(
NULL
, 
nblocks
 * 
BLKSIZE
, 
PROT_READ
|
PROT_WRITE
,

105 
MAP_SHARED
, 
diskfd
, 0)) == 
MAP_FAILED
)

106 
	`panic
("mmap %s: %s", 
name
, 
	`strerror
(
errno
));

108 
	`close
(
diskfd
);

110 
diskpos
 = 
diskmap
;

111 
	`alloc
(
BLKSIZE
);

112 
super
 = 
	`alloc
(
BLKSIZE
);

113 
super
->
s_magic
 = 
FS_MAGIC
;

114 
super
->
s_nblocks
 = 
nblocks
;

115 
super
->
s_root
.
f_type
 = 
FTYPE_DIR
;

116 
	`strcpy
(
super
->
s_root
.
f_name
, "/");

118 
super
->
s_root
.
f_uid
 = 0;

119 
super
->
s_root
.
f_gid
 = 0;

120 
super
->
s_root
.
f_perm
 = 
DEFAULT_DIR_CREATE_PERM
 | 
FSP_A_R
 | 
FSP_A_W
 | 
FSP_A_X
;

123 
nbitblocks
 = (
nblocks
 + 
BLKBITSIZE
 - 1) / BLKBITSIZE;

124 
bitmap
 = 
	`alloc
(
nbitblocks
 * 
BLKSIZE
);

125 
	`memset
(
bitmap
, 0xFF, 
nbitblocks
 * 
BLKSIZE
);

126 
	}
}

129 
	$finishdisk
(void)

131 int 
r
, 
i
;

133 for (
i
 = 0; i < 
	`blockof
(
diskpos
); ++i)

134 
bitmap
[
i
/32] &= ~(1<<(i%32));

136 if ((
r
 = 
	`msync
(
diskmap
, 
nblocks
 * 
BLKSIZE
, 
MS_SYNC
)) < 0)

137 
	`panic
("msync: %s", 
	`strerror
(
errno
));

138 
	}
}

141 
	$finishfile
(struct 
File
 *
f
, 
uint32_t
 
start
, uint32_t 
len
)

143 int 
i
;

144 
f
->
f_size
 = 
len
;

145 
len
 = 
	`ROUNDUP
(len, 
BLKSIZE
);

146 for (
i
 = 0; i < 
len
 / 
BLKSIZE
 && i < 
NDIRECT
; ++i)

147 
f
->
f_direct
[
i
] = 
start
 + i;

148 if (
i
 == 
NDIRECT
) {

149 
uint32_t
 *
ind
 = 
	`alloc
(
BLKSIZE
);

150 
f
->
f_indirect
 = 
	`blockof
(
ind
);

151 for (; 
i
 < 
len
 / 
BLKSIZE
; ++i)

152 
ind
[
i
 - 
NDIRECT
] = 
start
 + i;

154 
	}
}

157 
	$startdir
(struct 
File
 *
f
, struct 
Dir
 *
dout
)

159 
dout
->
f
 = f;

160 
dout
->
ents
 = 
	`malloc
(
MAX_DIR_ENTS
 * sizeof *dout->ents);

161 
dout
->
n
 = 0;

162 
	}
}

164 struct 
File
 *

165 
	$diradd
(struct 
Dir
 *
d
, 
uint32_t
 
type
, const char *
name
)

167 struct 
File
 *
out
 = &
d
->
ents
[d->
n
++];

168 if (
d
->
n
 > 
MAX_DIR_ENTS
)

169 
	`panic
("too many directory entries");

170 
	`strcpy
(
out
->
f_name
, 
name
);

171 
out
->
f_type
 = 
type
;

172 
out
->
f_uid
 = 0;

173 
out
->
f_gid
 = 0;

174 if(
type
 == 
FTYPE_DIR
)

175 
out
->
f_perm
 = 
DEFAULT_DIR_CREATE_PERM
;

176 else if(
	`strcmp
(
name
, "passwd") != 0)

177 
out
->
f_perm
 = 
DEFAULT_FILE_CREATE_PERM
;

179 
out
->
f_perm
 = 0;

180 return 
out
;

181 
	}
}

184 
	$finishdir
(struct 
Dir
 *
d
)

186 int 
size
 = 
d
->
n
 * sizeof(struct 
File
);

187 struct 
File
 *
start
 = 
	`alloc
(
size
);

188 
	`memmove
(
start
, 
d
->
ents
, 
size
);

189 
	`finishfile
(
d
->
f
, 
	`blockof
(
start
), 
	`ROUNDUP
(
size
, 
BLKSIZE
));

190 
	`free
(
d
->
ents
);

191 
d
->
ents
 = 
NULL
;

192 
	}
}

195 
	$writefile
(struct 
Dir
 *
dir
, const char *
name
)

197 int 
r
, 
fd
;

198 struct 
File
 *
f
;

199 struct 
stat
 
st
;

200 const char *
last
;

201 char *
start
;

203 if ((
fd
 = 
	`open
(
name
, 
O_RDONLY
)) < 0)

204 
	`panic
("open %s: %s", 
name
, 
	`strerror
(
errno
));

205 if ((
r
 = 
	`fstat
(
fd
, &
st
)) < 0)

206 
	`panic
("stat %s: %s", 
name
, 
	`strerror
(
errno
));

207 if (!
	`S_ISREG
(
st
.
st_mode
))

208 
	`panic
("%s is not a regular file", 
name
);

209 if (
st
.
st_size
 >= 
MAXFILESIZE
)

210 
	`panic
("%s too large", 
name
);

212 
last
 = 
	`strrchr
(
name
, '/');

213 if (
last
)

214 
last
++;

216 
last
 = 
name
;

218 
f
 = 
	`diradd
(
dir
, 
FTYPE_REG
, 
last
);

219 
start
 = 
	`alloc
(
st
.
st_size
);

220 
	`readn
(
fd
, 
start
, 
st
.
st_size
);

221 
	`finishfile
(
f
, 
	`blockof
(
start
), 
st
.
st_size
);

222 
	`close
(
fd
);

223 
	}
}

226 
	$usage
(void)

228 
	`fprintf
(
stderr
, "Usage: fsformat fs.img NBLOCKS files...\n");

229 
	`exit
(2);

230 
	}
}

233 
	$main
(int 
argc
, char **
argv
)

235 int 
i
;

236 char *
s
;

237 struct 
Dir
 
root
;

239 
	`assert
(
BLKSIZE
 % sizeof(struct 
File
) == 0);

241 if (
argc
 < 3)

242 
	`usage
();

244 
nblocks
 = 
	`strtol
(
argv
[2], &
s
, 0);

245 if (*
s
 || s == 
argv
[2] || 
nblocks
 < 2 || nblocks > 1024)

246 
	`usage
();

248 
	`opendisk
(
argv
[1]);

250 
	`startdir
(&
super
->
s_root
, &
root
);

251 for (
i
 = 3; i < 
argc
; i++)

252 
	`writefile
(&
root
, 
argv
[
i
]);

253 
	`finishdir
(&
root
);

255 
	`finishdisk
();

257 
	}
}

	@/root/Robux/fs/ide.c

7 #include 
	~"fs.h
"

8 #include 
	~<inc/x86.h
>

10 #define 
	#IDE_BSY
 0x80

	)

11 #define 
	#IDE_DRDY
 0x40

	)

12 #define 
	#IDE_DF
 0x20

	)

13 #define 
	#IDE_ERR
 0x01

	)

15 static int 
	gdiskno
 = 1;

18 
	$ide_wait_ready
(
bool
 
check_error
)

20 int 
r
;

22 while (((
r
 = 
	`inb
(0x1F7)) & (
IDE_BSY
|
IDE_DRDY
)) != IDE_DRDY)

25 if (
check_error
 && (
r
 & (
IDE_DF
|
IDE_ERR
)) != 0)

28 
	}
}

30 
bool


31 
	$ide_probe_disk1
(void)

33 int 
r
, 
x
;

36 
	`ide_wait_ready
(0);

39 
	`outb
(0x1F6, 0xE0 | (1<<4));

42 for (
x
 = 0;

43 
x
 < 1000 && ((
r
 = 
	`inb
(0x1F7)) & (
IDE_BSY
|
IDE_DF
|
IDE_ERR
)) != 0;

44 
x
++)

48 
	`outb
(0x1F6, 0xE0 | (0<<4));

50 
	`cprintf
("Device 1 presence: %d\n", (
x
 < 1000));

51 return (
x
 < 1000);

52 
	}
}

55 
	$ide_set_disk
(int 
d
)

57 if (
d
 != 0 && d != 1)

58 
	`panic
("bad disk number");

59 
diskno
 = 
d
;

60 
	}
}

63 
	$ide_read
(
uint32_t
 
secno
, void *
dst
, 
size_t
 
nsecs
)

65 int 
r
;

67 
	`assert
(
nsecs
 <= 256);

69 
	`ide_wait_ready
(0);

71 
	`outb
(0x1F2, 
nsecs
);

72 
	`outb
(0x1F3, 
secno
 & 0xFF);

73 
	`outb
(0x1F4, (
secno
 >> 8) & 0xFF);

74 
	`outb
(0x1F5, (
secno
 >> 16) & 0xFF);

75 
	`outb
(0x1F6, 0xE0 | ((
diskno
&1)<<4) | ((
secno
>>24)&0x0F));

76 
	`outb
(0x1F7, 0x20);

78 for (; 
nsecs
 > 0; nsecs--, 
dst
 += 
SECTSIZE
) {

79 if ((
r
 = 
	`ide_wait_ready
(1)) < 0)

80 return 
r
;

81 
	`insl
(0x1F0, 
dst
, 
SECTSIZE
/4);

85 
	}
}

88 
	$ide_write
(
uint32_t
 
secno
, const void *
src
, 
size_t
 
nsecs
)

90 int 
r
;

92 
	`assert
(
nsecs
 <= 256);

94 
	`ide_wait_ready
(0);

96 
	`outb
(0x1F2, 
nsecs
);

97 
	`outb
(0x1F3, 
secno
 & 0xFF);

98 
	`outb
(0x1F4, (
secno
 >> 8) & 0xFF);

99 
	`outb
(0x1F5, (
secno
 >> 16) & 0xFF);

100 
	`outb
(0x1F6, 0xE0 | ((
diskno
&1)<<4) | ((
secno
>>24)&0x0F));

101 
	`outb
(0x1F7, 0x30);

103 for (; 
nsecs
 > 0; nsecs--, 
src
 += 
SECTSIZE
) {

104 if ((
r
 = 
	`ide_wait_ready
(1)) < 0)

105 return 
r
;

106 
	`outsl
(0x1F0, 
src
, 
SECTSIZE
/4);

110 
	}
}

	@/root/Robux/fs/serv.c

5 #include 
	~<inc/lib.h
>

6 #include 
	~<inc/x86.h
>

7 #include 
	~<inc/string.h
>

9 #include 
	~"fs.h
"

12 #define 
	#debug
 0

	)

32 struct 
	sOpenFile
 {

33 
uint32_t
 
	mo_fileid
;

34 struct 
File
 *
	mo_file
;

35 int 
	mo_mode
;

36 struct 
Fd
 *
	mo_fd
;

40 #define 
	#MAXOPEN
 1024

	)

41 #define 
	#FILEVA
 0xD0000000

	)

44 struct 
OpenFile
 
	gopentab
[
MAXOPEN
] = {

49 union 
Fsipc
 *
	gfsreq
 = (union Fsipc *)0x0ffff000;

52 
	$serve_init
(void)

54 int 
i
;

55 
uintptr_t
 
va
 = 
FILEVA
;

56 for (
i
 = 0; i < 
MAXOPEN
; i++) {

57 
opentab
[
i
].
o_fileid
 = i;

58 
opentab
[
i
].
o_fd
 = (struct 
Fd
*) 
va
;

59 
va
 += 
PGSIZE
;

61 
	}
}

65 
	$openfile_alloc
(struct 
OpenFile
 **
o
)

67 int 
i
, 
r
;

70 for (
i
 = 0; i < 
MAXOPEN
; i++) {

71 switch (
	`pageref
(
opentab
[
i
].
o_fd
)) {

73 if ((
r
 = 
	`sys_page_alloc
(0, 
opentab
[
i
].
o_fd
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

74 return 
r
;

77 
opentab
[
i
].
o_fileid
 += 
MAXOPEN
;

78 *
o
 = &
opentab
[
i
];

79 
	`memset
(
opentab
[
i
].
o_fd
, 0, 
PGSIZE
);

80 return (*
o
)->
o_fileid
;

83 return -
E_MAX_OPEN
;

84 
	}
}

88 
	$openfile_lookup
(
envid_t
 
envid
, 
uint32_t
 
fileid
, struct 
OpenFile
 **
po
)

90 struct 
OpenFile
 *
o
;

92 
o
 = &
opentab
[
fileid
 % 
MAXOPEN
];

93 if (
	`pageref
(
o
->
o_fd
) == 1 || o->
o_fileid
 != 
fileid
)

94 return -
E_INVAL
;

95 *
po
 = 
o
;

97 
	}
}

103 
	$serve_open
(
envid_t
 
envid
, struct 
Fsreq_open
 *
req
,

104 void **
pg_store
, int *
perm_store
)

106 char 
path
[
MAXPATHLEN
];

107 struct 
File
 *
f
;

108 int 
fileid
;

109 int 
r
;

110 struct 
OpenFile
 *
o
;

111 struct 
Env
 
env
 = 
envs
[
	`ENVX
(
envid
)];

113 if (
debug
)

114 
	`cprintf
("serve_open %08x %s 0x%x\n", 
envid
, 
req
->
req_path
, req->
req_omode
);

117 
	`memmove
(
path
, 
req
->
req_path
, 
MAXPATHLEN
);

118 
path
[
MAXPATHLEN
-1] = 0;

121 if ((
r
 = 
	`openfile_alloc
(&
o
)) < 0) {

122 if (
debug
)

123 
	`cprintf
("openfile_alloc failed: %e", 
r
);

124 return 
r
;

126 
fileid
 = 
r
;

129 if (
req
->
req_omode
 & 
O_CREAT
) {

130 if ((
r
 = 
	`file_create
(
path
, &
f
,
env
.
env_gid
,env.
env_uid
,
DEFAULT_FILE_CREATE_PERM
)) < 0) {

131 if (!(
req
->
req_omode
 & 
O_EXCL
) && 
r
 == -
E_FILE_EXISTS
)

132 goto 
try_open
;

133 if (
debug
)

134 
	`cprintf
("file_create failed: %e", 
r
);

135 return 
r
;

138 
try_open
:

139 if ((
r
 = 
	`file_open
(
path
, &
f
)) < 0) {

140 if (
debug
)

141 
	`cprintf
("file_open failed: %e", 
r
);

142 return 
r
;

147 if (
req
->
req_omode
 & 
O_TRUNC
) {

148 if ((
r
 = 
	`file_set_size
(
f
, 0)) < 0) {

149 if (
debug
)

150 
	`cprintf
("file_set_size failed: %e", 
r
);

151 return 
r
;

156 
o
->
o_file
 = 
f
;

159 
o
->
o_fd
->
fd_file
.
id
 = o->
o_fileid
;

160 
o
->
o_fd
->
fd_omode
 = 
req
->
req_omode
 & 
O_ACCMODE
;

161 
o
->
o_fd
->
fd_dev_id
 = 
devfile
.
dev_id
;

163 
o
->
o_mode
 = 
req
->
req_omode
;

166 
o
->
o_fd
->
perm
 = 
f
->
f_perm
;

167 
o
->
o_fd
->
gid
 = 
f
->
f_gid
;

168 
o
->
o_fd
->
uid
 = 
f
->
f_uid
;

170 if (
debug
)

171 
	`cprintf
("sending success, page %08x\n", (
uintptr_t
) 
o
->
o_fd
);

174 *
pg_store
 = 
o
->
o_fd
;

175 *
perm_store
 = 
PTE_P
|
PTE_U
|
PTE_W
|
PTE_SHARE
;

177 
	}
}

182 
	$serve_set_size
(
envid_t
 
envid
, struct 
Fsreq_set_size
 *
req
)

184 struct 
OpenFile
 *
o
;

185 int 
r
;

187 if (
debug
)

188 
	`cprintf
("serve_set_size %08x %08x %08x\n", 
envid
, 
req
->
req_fileid
, req->
req_size
);

195 if ((
r
 = 
	`openfile_lookup
(
envid
, 
req
->
req_fileid
, &
o
)) < 0)

196 return 
r
;

200 return 
	`file_set_size
(
o
->
o_file
, 
req
->
req_size
);

201 
	}
}

208 
	$serve_read
(
envid_t
 
envid
, union 
Fsipc
 *
ipc
)

210 struct 
Fsreq_read
 *
req
 = &
ipc
->
read
;

211 struct 
Fsret_read
 *
ret
 = &
ipc
->
readRet
;

213 if (
debug
)

214 
	`cprintf
("serve_read %08x %08x %08x\n", 
envid
, 
req
->
req_fileid
, req->
req_n
);

225 struct 
OpenFile
 *
po
;

226 int 
r
;

228 if ((
r
 = 
	`openfile_lookup
(
envid
, 
req
->
req_fileid
, &
po
)) < 0)

229 return 
r
;

231 struct 
File
 *
file
 = 
po
->
o_file
;

232 struct 
Fd
 *
fd
 = 
po
->
o_fd
;

233 if ((
r
 = 
	`file_read
(
file
,

234 
ret
->
ret_buf
,

235 
	`MIN
(
req
->
req_n
, 
PGSIZE
),

236 
fd
->
fd_offset
)) < 0)

238 return 
r
;

242 
fd
->
fd_offset
 += 
r
;

243 return 
r
;

246 
	}
}

253 
	$serve_write
(
envid_t
 
envid
, struct 
Fsreq_write
 *
req
)

255 if (
debug
)

256 
	`cprintf
("serve_write %08x %08x %08x\n", 
envid
, 
req
->
req_fileid
, req->
req_n
);

259 struct 
OpenFile
 *
po
;

260 int 
r
;

262 if ((
r
 = 
	`openfile_lookup
(
envid
, 
req
->
req_fileid
, &
po
)) < 0)

263 return 
r
;

265 struct 
File
 *
file
 = 
po
->
o_file
;

266 struct 
Fd
 *
fd
 = 
po
->
o_fd
;

267 if((
r
 = 
	`file_write
(
file
, 
req
->
req_buf
, req->
req_n
, 
fd
->
fd_offset
)) < 0)

268 return 
r
;

270 
fd
->
fd_offset
 += 
r
;

271 return 
r
;

273 
	}
}

278 
	$serve_stat
(
envid_t
 
envid
, union 
Fsipc
 *
ipc
)

280 struct 
Fsreq_stat
 *
req
 = &
ipc
->
stat
;

281 struct 
Fsret_stat
 *
ret
 = &
ipc
->
statRet
;

282 struct 
OpenFile
 *
o
;

283 int 
r
;

285 if (
debug
)

286 
	`cprintf
("serve_stat %08x %08x\n", 
envid
, 
req
->
req_fileid
);

288 if ((
r
 = 
	`openfile_lookup
(
envid
, 
req
->
req_fileid
, &
o
)) < 0)

289 return 
r
;

291 
	`strcpy
(
ret
->
ret_name
, 
o
->
o_file
->
f_name
);

292 
ret
->
ret_size
 = 
o
->
o_file
->
f_size
;

293 
ret
->
ret_isdir
 = (
o
->
o_file
->
f_type
 == 
FTYPE_DIR
);

294 
ret
->
ret_uid
 = 
o
->
o_file
->
f_uid
;

295 
ret
->
ret_gid
 = 
o
->
o_file
->
f_gid
;

296 
ret
->
ret_perm
 = 
o
->
o_file
->
f_perm
;

299 
	}
}

303 
	$serve_flush
(
envid_t
 
envid
, struct 
Fsreq_flush
 *
req
)

305 struct 
OpenFile
 *
o
;

306 int 
r
;

308 if (
debug
)

309 
	`cprintf
("serve_flush %08x %08x\n", 
envid
, 
req
->
req_fileid
);

311 if ((
r
 = 
	`openfile_lookup
(
envid
, 
req
->
req_fileid
, &
o
)) < 0)

312 return 
r
;

313 
	`file_flush
(
o
->
o_file
);

315 
	}
}

319 
	$serve_remove
(
envid_t
 
envid
, struct 
Fsreq_remove
 *
req
)

321 char 
path
[
MAXPATHLEN
];

322 int 
r
;

324 if (
debug
)

325 
	`cprintf
("serve_remove %08x %s\n", 
envid
, 
req
->
req_path
);

331 
	`memmove
(
path
, 
req
->
req_path
, 
MAXPATHLEN
);

332 
path
[
MAXPATHLEN
-1] = 0;

335 return 
	`file_remove
(
path
);

336 
	}
}

340 
	$serve_sync
(
envid_t
 
envid
, union 
Fsipc
 *
req
)

342 
	`fs_sync
();

344 
	}
}

348 
	$serve_chmod
(
envid_t
 
envid
, union 
Fsipc
 *
req
)

350 struct 
OpenFile
* 
po
;

351 int 
r
;

352 if ((
r
=
	`openfile_lookup
(
envid
, 
req
->
chmod
.
req_fileid
,&
po
))<0)

353 return 
r
;

354 if ((
r
=
	`file_set_perm
(
po
->
o_file
,
req
->
chmod
.
f_perm
))<0)

355 return 
r
;

356 
po
->
o_fd
->
perm
 = 
req
->
chmod
.
f_perm
;

358 
	}
}

362 
	$serve_chown
(
envid_t
 
envid
, union 
Fsipc
 *
req
)

364 struct 
OpenFile
* 
po
;

365 int 
r
;

366 if ((
r
=
	`openfile_lookup
(
envid
, 
req
->
chown
.
req_fileid
,&
po
))<0)

367 return 
r
;

368 if ((
r
=
	`file_set_uid
(
po
->
o_file
,
req
->
chown
.
uid
))<0)

369 return 
r
;

370 
po
->
o_fd
->
uid
 = 
req
->
chown
.uid;

372 
	}
}

376 
	$serve_chgrp
(
envid_t
 
envid
, union 
Fsipc
 *
req
)

378 struct 
OpenFile
* 
po
;

379 int 
r
;

380 if ((
r
=
	`openfile_lookup
(
envid
, 
req
->
chgrp
.
req_fileid
,&
po
))<0)

381 return 
r
;

382 if ((
r
=
	`file_set_gid
(
po
->
o_file
,
req
->
chgrp
.
gid
))<0)

383 return 
r
;

384 
po
->
o_fd
->
gid
 = 
req
->
chgrp
.gid;

386 
	}
}

389 typedef int (*
	tfshandler
)(
	tenvid_t
 
	tenvid
, union 
	tFsipc
 *
	treq
);

391 
fshandler
 
handlers
[] = {

394 [
FSREQ_SET_SIZE
] = (
fshandler
)
serve_set_size
,

395 [
FSREQ_READ
] = 
serve_read
,

396 [
FSREQ_WRITE
] = (
fshandler
)
serve_write
,

397 [
FSREQ_STAT
] = 
serve_stat
,

398 [
FSREQ_FLUSH
] = (
fshandler
)
serve_flush
,

399 [
FSREQ_REMOVE
] = (
fshandler
)
serve_remove
,

400 [
FSREQ_SYNC
] = 
serve_sync
,

401 [
FSREQ_CHMOD
] = 
serve_chmod
,

402 [
FSREQ_CHOWN
] = 
serve_chown
,

403 [
FSREQ_CHGRP
] = 
serve_chgrp


405 
	}
};

406 #define 
	#NHANDLERS
 (sizeof(
handlers
)/sizeof(handlers[0]))

	)

409 
	$has_perm
(
envid_t
 
envid
,union 
Fsipc
 *
fsreq
, 
uint32_t
 
req
) {

410 int 
fileid
;

411 struct 
Env
 
env
;

412 struct 
Fd
 *
fd
;

413 int 
r
;

415 
env
 = 
envs
[
	`ENVX
(
envid
)];

418 if (
env
.
env_uid
==0)

422 if (
req
==
FSREQ_CHOWN
)

423 return -
E_BAD_PERM
;

427 if (
req
==
FSREQ_SYNC
)

432 if (
req
==
FSREQ_OPEN
 || req==
FSREQ_REMOVE
)

434 char 
path
[
MAXPATHLEN
];

435 struct 
File
 *
pf
;

438 switch (
req
)

440 case 
FSREQ_OPEN
:

443 
	`memmove
(
path
, 
fsreq
->
open
.
req_path
, 
MAXPATHLEN
);

444 
path
[
MAXPATHLEN
-1] = 0;

448 if ((
r
=
	`file_open
(
path
,&
pf
))<0 && r!=-
E_NOT_FOUND
)

449 return 
r
;

452 if ((
fsreq
->
open
.
req_omode
&~
O_ACCMODE
)==(
O_CREAT
|
O_TRUNC
) && 
r
==-
E_NOT_FOUND
)

456 if(
r
 == -
E_NOT_FOUND
)

457 return 
r
;

460 switch(
fsreq
->
open
.
req_omode
&
O_ACCMODE
)

462 case 
O_RDONLY
:

463 if ((
pf
->
f_uid
==
env
.
env_uid
 && pf->
f_perm
&
FSP_O_R
) ||

464 (
pf
->
f_gid
==
env
.
env_gid
 && pf->
f_perm
&
FSP_G_R
) ||

465 
pf
->
f_perm
&
FSP_A_R
)

468 return -
E_BAD_PERM
;

470 case 
O_WRONLY
:

471 case 
O_RDWR
:

472 if ((
pf
->
f_uid
==
env
.
env_uid
 && pf->
f_perm
&
FSP_O_W
) ||

473 (
pf
->
f_gid
==
env
.
env_gid
 && pf->
f_perm
&
FSP_G_W
) ||

474 
pf
->
f_perm
&
FSP_A_W
)

477 return -
E_BAD_PERM
;

480 return -
E_INVAL
;

484 case 
FSREQ_REMOVE
:

486 
	`memmove
(
path
, 
fsreq
->
remove
.
req_path
, 
MAXPATHLEN
);

487 
path
[
MAXPATHLEN
-1] = 0;

490 if ((
r
=
	`file_open
(
path
,&
pf
))<0)

491 return 
r
;

493 
	`cprintf
("0x%x %d\n", 
pf
, 
r
);

496 if ((
pf
->
f_uid
==
env
.
env_uid
 && pf->
f_perm
&
FSP_O_W
) ||

497 (
pf
->
f_gid
==
env
.
env_gid
 && pf->
f_perm
&
FSP_G_W
) ||

498 
pf
->
f_perm
&
FSP_A_W
)

501 return -
E_BAD_PERM
;

504 return -
E_INVAL
;

510 switch (
req
)

512 case 
FSREQ_CHGRP
:

513 
fileid
 = 
fsreq
->
chgrp
.
req_fileid
;

515 case 
FSREQ_CHMOD
:

516 
fileid
 = 
fsreq
->
chmod
.
req_fileid
;

518 case 
FSREQ_READ
:

519 
fileid
 = 
fsreq
->
read
.
req_fileid
;

521 case 
FSREQ_STAT
:

522 
fileid
 = 
fsreq
->
stat
.
req_fileid
;

524 case 
FSREQ_SET_SIZE
:

525 
fileid
 = 
fsreq
->
set_size
.
req_fileid
;

527 case 
FSREQ_WRITE
:

528 
fileid
 = 
fsreq
->
write
.
req_fileid
;

530 case 
FSREQ_FLUSH
:

531 
fileid
 = 
fsreq
->
flush
.
req_fileid
;

534 return -
E_INVAL
;

539 struct 
OpenFile
 *
op
;

540 if ((
r
=
	`openfile_lookup
(
envid
,
fileid
,&
op
))<0)

541 return 
r
;

544 
fd
 = 
op
->
o_fd
;

547 switch (
req
)

549 case 
FSREQ_CHGRP
:

550 if (
fd
->
uid
==
env
.
env_uid
 && fd->
gid
==env.
env_gid
)

551 
r
 = 0;

553 
r
 = -
E_BAD_PERM
;

555 case 
FSREQ_CHMOD
:

556 if (
fd
->
uid
==
env
.
env_uid
)

557 
r
 = 0;

559 
r
 = -
E_BAD_PERM
;

562 case 
FSREQ_READ
:

563 case 
FSREQ_STAT
:

564 if ((
fd
->
uid
==
env
.
env_uid
 && fd->
perm
&
FSP_O_R
) ||

565 (
fd
->
gid
==
env
.
env_gid
 && fd->
perm
&
FSP_G_R
) ||

566 
fd
->
perm
&
FSP_A_R
)

567 
r
=0;

569 
r
=-
E_BAD_PERM
;

572 case 
FSREQ_SET_SIZE
:

573 case 
FSREQ_WRITE
:

574 case 
FSREQ_FLUSH
:

575 if ((
fd
->
uid
==
env
.
env_uid
 && fd->
perm
&
FSP_O_W
) ||

576 (
fd
->
gid
==
env
.
env_gid
 && fd->
perm
&
FSP_G_W
) ||

577 
fd
->
perm
&
FSP_A_W
)

578 
r
 = 0;

580 
r
 = -
E_BAD_PERM
;

583 return -
E_INVAL
;

586 return 
r
;

587 
	}
}

591 
	$serve
(void)

593 
uint32_t
 
req
, 
whom
;

594 int 
perm
, 
r
;

595 void *
pg
;

598 
perm
 = 0;

599 
req
 = 
	`ipc_recv
((
int32_t
 *) &
whom
, 
fsreq
, &
perm
);

600 if (
debug
)

601 
	`cprintf
("fs req %d from %08x [page %08x: %s]\n",

602 
req
, 
whom
, 
vpt
[
	`PGNUM
(
fsreq
)], fsreq);

605 if (!(
perm
 & 
PTE_P
)) {

606 
	`cprintf
("Invalid request from %08x: no argument page\n",

607 
whom
);

612 if ((
r
=
	`has_perm
(
whom
,
fsreq
,
req
))==0)

614 
pg
 = 
NULL
;

615 if (
req
 == 
FSREQ_OPEN
) {

616 
r
 = 
	`serve_open
(
whom
, (struct 
Fsreq_open
*)
fsreq
, &
pg
, &
perm
);

617 } else if (
req
 < 
NHANDLERS
 && 
handlers
[req]) {

618 
r
 = 
handlers
[
req
](
whom
, 
fsreq
);

620 
	`cprintf
("Invalid request code %d from %08x\n", 
whom
, 
req
);

621 
r
 = -
E_INVAL
;

625 
	`ipc_send
(
whom
, 
r
, 
pg
, 
perm
);

626 
	`sys_page_unmap
(0, 
fsreq
);

628 
	}
}

632 
	$umain
(int 
argc
, char **
argv
)

635 
binaryname
 = "fs";

636 
	`cprintf
("FS is running\n");

639 
	`outw
(0x8A00, 0x8A00);

640 
	`cprintf
("FS can do I/O\n");

642 
	`serve_init
();

643 
	`fs_init
();

644 
	`serve
();

645 
	}
}

	@/root/Robux/fs/test.c

2 #include 
	~<inc/x86.h
>

3 #include 
	~<inc/string.h
>

5 #include 
	~"fs.h
"

7 static char *
	gmsg
 = "This is the NEW message of the day!\n\n";

10 
	$fs_test
(void)

12 struct 
File
 *
f
;

13 int 
r
;

14 char *
blk
;

15 
uint32_t
 *
bits
;

18 if ((
r
 = 
	`sys_page_alloc
(0, (void*) 
PGSIZE
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

19 
	`panic
("sys_page_alloc: %e", 
r
);

20 
bits
 = (
uint32_t
*) 
PGSIZE
;

21 
	`memmove
(
bits
, 
bitmap
, 
PGSIZE
);

23 if ((
r
 = 
	`alloc_block
()) < 0)

24 
	`panic
("alloc_block: %e", 
r
);

26 
	`assert
(
bits
[
r
/32] & (1 << (r%32)));

28 
	`assert
(!(
bitmap
[
r
/32] & (1 << (r%32))));

29 
	`cprintf
("alloc_block is good\n");

31 if ((
r
 = 
	`file_open
("/not-found", &
f
)) < 0 && r != -
E_NOT_FOUND
)

32 
	`panic
("file_open /not-found: %e", 
r
);

33 else if (
r
 == 0)

34 
	`panic
("file_open /not-found succeeded!");

35 if ((
r
 = 
	`file_open
("/newmotd", &
f
)) < 0)

36 
	`panic
("file_open /newmotd: %e", 
r
);

37 
	`cprintf
("file_open is good\n");

39 if ((
r
 = 
	`file_get_block
(
f
, 0, &
blk
)) < 0)

40 
	`panic
("file_get_block: %e", 
r
);

41 if (
	`strcmp
(
blk
, 
msg
) != 0)

42 
	`panic
("file_get_block returned wrong data");

43 
	`cprintf
("file_get_block is good\n");

45 *(volatile char*)
blk
 = *(volatile char*)blk;

46 
	`assert
((
vpt
[
	`PGNUM
(
blk
)] & 
PTE_D
));

47 
	`file_flush
(
f
);

48 
	`assert
(!(
vpt
[
	`PGNUM
(
blk
)] & 
PTE_D
));

49 
	`cprintf
("file_flush is good\n");

51 if ((
r
 = 
	`file_set_size
(
f
, 0)) < 0)

52 
	`panic
("file_set_size: %e", 
r
);

53 
	`assert
(
f
->
f_direct
[0] == 0);

54 
	`assert
(!(
vpt
[
	`PGNUM
(
f
)] & 
PTE_D
));

55 
	`cprintf
("file_truncate is good\n");

57 if ((
r
 = 
	`file_set_size
(
f
, 
	`strlen
(
msg
))) < 0)

58 
	`panic
("file_set_size 2: %e", 
r
);

59 
	`assert
(!(
vpt
[
	`PGNUM
(
f
)] & 
PTE_D
));

60 if ((
r
 = 
	`file_get_block
(
f
, 0, &
blk
)) < 0)

61 
	`panic
("file_get_block 2: %e", 
r
);

62 
	`strcpy
(
blk
, 
msg
);

63 
	`assert
((
vpt
[
	`PGNUM
(
blk
)] & 
PTE_D
));

64 
	`file_flush
(
f
);

65 
	`assert
(!(
vpt
[
	`PGNUM
(
blk
)] & 
PTE_D
));

66 
	`assert
(!(
vpt
[
	`PGNUM
(
f
)] & 
PTE_D
));

67 
	`cprintf
("file rewrite is good\n");

68 
	}
}

	@/root/Robux/inc/args.h

1 #ifndef 
JOS_INC_ARGS_H


2 #define 
	#JOS_INC_ARGS_H


	)

4 struct 
	gArgstate
;

10 void 
argstart
(int *
argc
, char **
argv
, struct 
Argstate
 *
args
);

24 int 
argnext
(struct 
Argstate
 *);

31 char *
argnextvalue
(struct 
Argstate
 *);

36 char *
argvalue
(struct 
Argstate
 *);

75 struct 
	sArgstate
 {

76 int *
	margc
;

77 const char **
	margv
;

78 const char *
	mcurarg
;

79 const char *
	margvalue
;

	@/root/Robux/inc/assert.h

3 #ifndef 
JOS_INC_ASSERT_H


4 #define 
	#JOS_INC_ASSERT_H


	)

6 #include 
	~<inc/stdio.h
>

8 void 
_warn
(const char*, int, const char*, ...);

9 void 
	$_panic
(const char*, int, const char*, ...) 
	`__attribute__
((
noreturn
));

11 #define 
	#warn
(...) 
	`_warn
(
__FILE__
, 
__LINE__
, 
__VA_ARGS__
)

	)

12 #define 
	#panic
(...) 
	`_panic
(
__FILE__
, 
__LINE__
, 
__VA_ARGS__
)

	)

14 #define 
	#assert
(
x
) \

15 do { if (!(
x
)) 
	`panic
("assertion failed: %s", #x); 
	}
} while (0)

	)

18 #define 
	#static_assert
(
x
) switch (x) case 0: case (x):

	)

	@/root/Robux/inc/elf.h

1 #ifndef 
JOS_INC_ELF_H


2 #define 
	#JOS_INC_ELF_H


	)

4 #define 
	#ELF_MAGIC
 0x464C457FU

	)

6 struct 
	sElf
 {

7 
uint32_t
 
	me_magic
;

8 
uint8_t
 
	me_elf
[12];

9 
uint16_t
 
	me_type
;

10 
uint16_t
 
	me_machine
;

11 
uint32_t
 
	me_version
;

12 
uint32_t
 
	me_entry
;

13 
uint32_t
 
	me_phoff
;

14 
uint32_t
 
	me_shoff
;

15 
uint32_t
 
	me_flags
;

16 
uint16_t
 
	me_ehsize
;

17 
uint16_t
 
	me_phentsize
;

18 
uint16_t
 
	me_phnum
;

19 
uint16_t
 
	me_shentsize
;

20 
uint16_t
 
	me_shnum
;

21 
uint16_t
 
	me_shstrndx
;

24 struct 
	sProghdr
 {

25 
uint32_t
 
	mp_type
;

26 
uint32_t
 
	mp_offset
;

27 
uint32_t
 
	mp_va
;

28 
uint32_t
 
	mp_pa
;

29 
uint32_t
 
	mp_filesz
;

30 
uint32_t
 
	mp_memsz
;

31 
uint32_t
 
	mp_flags
;

32 
uint32_t
 
	mp_align
;

35 struct 
	sSecthdr
 {

36 
uint32_t
 
	msh_name
;

37 
uint32_t
 
	msh_type
;

38 
uint32_t
 
	msh_flags
;

39 
uint32_t
 
	msh_addr
;

40 
uint32_t
 
	msh_offset
;

41 
uint32_t
 
	msh_size
;

42 
uint32_t
 
	msh_link
;

43 
uint32_t
 
	msh_info
;

44 
uint32_t
 
	msh_addralign
;

45 
uint32_t
 
	msh_entsize
;

49 #define 
	#ELF_PROG_LOAD
 1

	)

52 #define 
	#ELF_PROG_FLAG_EXEC
 1

	)

53 #define 
	#ELF_PROG_FLAG_WRITE
 2

	)

54 #define 
	#ELF_PROG_FLAG_READ
 4

	)

57 #define 
	#ELF_SHT_NULL
 0

	)

58 #define 
	#ELF_SHT_PROGBITS
 1

	)

59 #define 
	#ELF_SHT_SYMTAB
 2

	)

60 #define 
	#ELF_SHT_STRTAB
 3

	)

63 #define 
	#ELF_SHN_UNDEF
 0

	)

	@/root/Robux/inc/env.h

3 #ifndef 
JOS_INC_ENV_H


4 #define 
	#JOS_INC_ENV_H


	)

6 #include 
	~<inc/types.h
>

7 #include 
	~<inc/trap.h
>

8 #include 
	~<inc/memlayout.h
>

9 #include 
	~<inc/security.h
>

11 typedef 
int32_t
 
	tenvid_t
;

29 #define 
	#LOG2NENV
 10

	)

30 #define 
	#NENV
 (1 << 
LOG2NENV
)

	)

31 #define 
	#ENVX
(
envid
) ((envid) & (
NENV
 - 1))

	)

35 
	mENV_FREE
 = 0,

36 
	mENV_DYING
,

37 
	mENV_RUNNABLE
,

38 
	mENV_RUNNING
,

39 
	mENV_NOT_RUNNABLE


43 enum 
	eEnvType
 {

44 
	mENV_TYPE_USER
 = 0,

45 
	mENV_TYPE_IDLE
,

46 
	mENV_TYPE_FS
,

47 
	mENV_TYPE_NS
,

48 
	mENV_TYPE_SECURITY
,

52 struct 
	sEnv
 {

53 struct 
Trapframe
 
	menv_tf
;

54 struct 
Env
 *
	menv_link
;

55 
envid_t
 
	menv_id
;

56 
envid_t
 
	menv_parent_id
;

57 enum 
EnvType
 
	menv_type
;

58 unsigned 
	menv_status
;

59 
uint32_t
 
	menv_runs
;

60 int 
	menv_cpunum
;

63 
pde_t
 *
	menv_pgdir
;

66 void *
	menv_pgfault_upcall
;

69 
bool
 
	menv_ipc_recving
;

70 void *
	menv_ipc_dstva
;

71 
uint32_t
 
	menv_ipc_value
;

72 
envid_t
 
	menv_ipc_from
;

73 int 
	menv_ipc_perm
;

76 
envid_t
 
	menv_ipc_send_to
;

77 
uint32_t
 
	menv_ipc_send_value
;

78 void *
	menv_ipc_send_srcva
;

79 unsigned 
	menv_ipc_send_perm
;

82 
uid_t
 
	menv_uid
;

83 
gid_t
 
	menv_gid
;

84 unsigned 
	menv_user_perm
;

	@/root/Robux/inc/error.h

3 #ifndef 
JOS_INC_ERROR_H


4 #define 
	#JOS_INC_ERROR_H


	)

8 
	mE_UNSPECIFIED
 = 1,

9 
	mE_BAD_ENV
 = 2,

11 
	mE_INVAL
 = 3,

12 
	mE_NO_MEM
 = 4,

13 
	mE_NO_FREE_ENV
 = 5,

15 
	mE_FAULT
 = 6,

17 
	mE_IPC_NOT_RECV
 = 7,

18 
	mE_EOF
 = 8,

21 
	mE_NO_DISK
 = 9,

22 
	mE_MAX_OPEN
 = 10,

23 
	mE_NOT_FOUND
 = 11,

24 
	mE_BAD_PATH
 = 12,

25 
	mE_FILE_EXISTS
 = 13,

26 
	mE_NOT_EXEC
 = 14,

27 
	mE_NOT_SUPP
 = 15,

28 
	mE_NET_NOT_RECV
 = 16,

29 
	mE_USER_NOT_FOUND
 = 17,

30 
	mE_BAD_PERM
 = 18,

32 
	mMAXERROR


	@/root/Robux/inc/fd.h

5 #ifndef 
JOS_INC_FD_H


6 #define 
	#JOS_INC_FD_H


	)

8 #include 
	~<inc/types.h
>

9 #include 
	~<inc/fs.h
>

10 #include 
	~<inc/security.h
>

12 struct 
	gFd
;

13 struct 
	gStat
;

14 struct 
	gDev
;

17 struct 
	sDev
 {

18 int 
	mdev_id
;

19 const char *
	mdev_name
;

20 
ssize_t
 (*
dev_read
)(struct 
Fd
 *
	mfd
, void *
	mbuf
, 
size_t
 
	mlen
);

21 
ssize_t
 (*
dev_write
)(struct 
Fd
 *
	mfd
, const void *
	mbuf
, 
size_t
 
	mlen
);

22 int (*
	mdev_close
)(struct 
Fd
 *
	mfd
);

23 int (*
	mdev_stat
)(struct 
Fd
 *
	mfd
, struct 
Stat
 *
	mstat
);

24 int (*
	mdev_trunc
)(struct 
Fd
 *
	mfd
, 
off_t
 
	mlength
);

25 int (*
	mdev_chmod
)(struct 
Fd
 *
	mfd
, 
fsperm_t
 
	mnewperm
);

26 int (*
	mdev_chown
)(struct 
Fd
 *
	mfd
, 
uid_t
 
	muid
);

27 int (*
	mdev_chgrp
)(struct 
Fd
 *
	mfd
, 
gid_t
 
	mgid
);

30 struct 
	sFdFile
 {

31 int 
	mid
;

34 struct 
	sFdSock
 {

35 int 
	msockid
;

38 struct 
	sFd
 {

39 int 
	mfd_dev_id
;

40 
off_t
 
	mfd_offset
;

41 int 
	mfd_omode
;

42 unsigned 
	mperm
;

43 
gid_t
 
	mgid
;

44 
uid_t
 
	muid
;

48 struct 
FdFile
 
	mfd_file
;

50 struct 
FdSock
 
	mfd_sock
;

54 struct 
	sStat
 {

55 char 
	mst_name
[
MAXNAMELEN
];

56 
off_t
 
	mst_size
;

57 int 
	mst_isdir
;

58 struct 
Dev
 *
	mst_dev
;

60 
uid_t
 
	mst_uid
;

61 
gid_t
 
	mst_gid
;

62 
fsperm_t
 
	mst_perm
;

65 char* 
fd2data
(struct 
Fd
 *
fd
);

66 int 
fd2num
(struct 
Fd
 *
fd
);

67 int 
fd_alloc
(struct 
Fd
 **
fd_store
);

68 int 
fd_close
(struct 
Fd
 *
fd
, 
bool
 
must_exist
);

69 int 
fd_lookup
(int 
fdnum
, struct 
Fd
 **
fd_store
);

70 int 
dev_lookup
(int 
devid
, struct 
Dev
 **
dev_store
);

72 extern struct 
Dev
 
devfile
;

73 extern struct 
Dev
 
devsock
;

74 extern struct 
Dev
 
devcons
;

75 extern struct 
Dev
 
devpipe
;

	@/root/Robux/inc/fs.h

3 #ifndef 
JOS_INC_FS_H


4 #define 
	#JOS_INC_FS_H


	)

6 #include 
	~<inc/types.h
>

7 #include 
	~<inc/mmu.h
>

8 #include 
	~<inc/security.h
>

13 #define 
	#BLKSIZE
 
PGSIZE


	)

14 #define 
	#BLKBITSIZE
 (
BLKSIZE
 * 8)

	)

18 #define 
	#MAXNAMELEN
 128

	)

21 #define 
	#MAXPATHLEN
 1024

	)

24 #define 
	#NDIRECT
 10

	)

26 #define 
	#NINDIRECT
 (
BLKSIZE
 / 4)

	)

28 #define 
	#MAXFILESIZE
 ((
NDIRECT
 + 
NINDIRECT
) * 
BLKSIZE
)

	)

30 struct 
	sFile
 {

31 char 
	mf_name
[
MAXNAMELEN
];

32 
off_t
 
	mf_size
;

33 
uint32_t
 
	mf_type
;

37 
uint32_t
 
	mf_direct
[
NDIRECT
];

38 
uint32_t
 
	mf_indirect
;

40 
uid_t
 
	mf_uid
;

41 
gid_t
 
	mf_gid
;

42 
fsperm_t
 
	mf_perm
;

46 
uint8_t
 
	mf_pad
[256 - 
MAXNAMELEN
 - 8 - 4*
NDIRECT
 - 4 - sizeof(
uid_t
) - sizeof(
gid_t
) - sizeof(
fsperm_t
) ];

47 } 
__attribute__
((
packed
));

50 #define 
	#BLKFILES
 (
BLKSIZE
 / sizeof(struct 
File
))

	)

53 #define 
	#FTYPE_REG
 0

54 #define 
	#FTYPE_DIR
 1

55 

	)

59 #define 
	#FS_MAGIC
 0x4A0530AE

60 

	)

61 struct 
	sSuper
 {

62 
uint32_t
 
	ms_magic
;

63 
uint32_t
 
	ms_nblocks
;

64 struct 
File
 
	ms_root
;

69 
	mFSREQ_OPEN
 = 1,

70 
	mFSREQ_SET_SIZE
,

72 
	mFSREQ_READ
,

73 
	mFSREQ_WRITE
,

75 
	mFSREQ_STAT
,

76 
	mFSREQ_FLUSH
,

77 
	mFSREQ_REMOVE
,

78 
	mFSREQ_SYNC
,

79 
	mFSREQ_CHMOD
,

80 
	mFSREQ_CHOWN
,

81 
	mFSREQ_CHGRP


84 union 
	uFsipc
 {

85 struct 
	sFsreq_open
 {

86 char 
	mreq_path
[
MAXPATHLEN
];

87 int 
	mreq_omode
;

88 } 
	mopen
;

89 struct 
	sFsreq_set_size
 {

90 int 
	mreq_fileid
;

91 
off_t
 
	mreq_size
;

92 } 
	mset_size
;

93 struct 
	sFsreq_read
 {

94 int 
	mreq_fileid
;

95 
size_t
 
	mreq_n
;

96 } 
	mread
;

97 struct 
	sFsret_read
 {

98 char 
	mret_buf
[
PGSIZE
];

99 } 
	mreadRet
;

100 struct 
	sFsreq_write
 {

101 int 
	mreq_fileid
;

102 
size_t
 
	mreq_n
;

103 char 
	mreq_buf
[
PGSIZE
 - (sizeof(int) + sizeof(
size_t
))];

104 } 
	mwrite
;

105 struct 
	sFsreq_stat
 {

106 int 
	mreq_fileid
;

107 } 
	mstat
;

108 struct 
	sFsret_stat
 {

109 char 
	mret_name
[
MAXNAMELEN
];

110 
off_t
 
	mret_size
;

111 int 
	mret_isdir
;

112 
uid_t
 
	mret_uid
;

113 
gid_t
 
	mret_gid
;

114 
fsperm_t
 
	mret_perm
;

115 } 
	mstatRet
;

116 struct 
	sFsreq_flush
 {

117 int 
	mreq_fileid
;

118 } 
	mflush
;

119 struct 
	sFsreq_remove
 {

120 char 
	mreq_path
[
MAXPATHLEN
];

121 } 
	mremove
;

122 struct 
	sFsreq_chmod
 {

123 int 
	mreq_fileid
;

124 
fsperm_t
 
	mf_perm
;

125 } 
	mchmod
;

126 struct 
	sFsreq_chown
 {

127 int 
	mreq_fileid
;

128 
uid_t
 
	muid
;

129 } 
	mchown
;

130 struct 
	sFsreq_chgrp
 {

131 int 
	mreq_fileid
;

132 
gid_t
 
	mgid
;

133 } 
	mchgrp
;

137 char 
	m_pad
[
PGSIZE
];

	@/root/Robux/inc/kbdreg.h

1 #ifndef 
JOS_KBDREG_H


2 #define 
	#JOS_KBDREG_H


	)

5 #define 
	#KEY_HOME
 0xE0

	)

6 #define 
	#KEY_END
 0xE1

	)

7 #define 
	#KEY_UP
 0xE2

	)

8 #define 
	#KEY_DN
 0xE3

	)

9 #define 
	#KEY_LF
 0xE4

	)

10 #define 
	#KEY_RT
 0xE5

	)

11 #define 
	#KEY_PGUP
 0xE6

	)

12 #define 
	#KEY_PGDN
 0xE7

	)

13 #define 
	#KEY_INS
 0xE8

	)

14 #define 
	#KEY_DEL
 0xE9

	)

19 #define 
	#KBSTATP
 0x64

	)

20 #define 
	#KBS_DIB
 0x01

	)

21 #define 
	#KBS_IBF
 0x02

	)

22 #define 
	#KBS_WARM
 0x04

	)

23 #define 
	#KBS_OCMD
 0x08

	)

24 #define 
	#KBS_NOSEC
 0x10

	)

25 #define 
	#KBS_TERR
 0x20

	)

26 #define 
	#KBS_RERR
 0x40

	)

27 #define 
	#KBS_PERR
 0x80

	)

29 #define 
	#KBCMDP
 0x64

	)

30 #define 
	#KBC_RAMREAD
 0x20

	)

31 #define 
	#KBC_RAMWRITE
 0x60

	)

32 #define 
	#KBC_AUXDISABLE
 0xa7

	)

33 #define 
	#KBC_AUXENABLE
 0xa8

	)

34 #define 
	#KBC_AUXTEST
 0xa9

	)

35 #define 
	#KBC_KBDECHO
 0xd2

	)

36 #define 
	#KBC_AUXECHO
 0xd3

	)

37 #define 
	#KBC_AUXWRITE
 0xd4

	)

38 #define 
	#KBC_SELFTEST
 0xaa

	)

39 #define 
	#KBC_KBDTEST
 0xab

	)

40 #define 
	#KBC_KBDDISABLE
 0xad

	)

41 #define 
	#KBC_KBDENABLE
 0xae

	)

42 #define 
	#KBC_PULSE0
 0xfe

	)

43 #define 
	#KBC_PULSE1
 0xfd

	)

44 #define 
	#KBC_PULSE2
 0xfb

	)

45 #define 
	#KBC_PULSE3
 0xf7

	)

47 #define 
	#KBDATAP
 0x60

	)

48 #define 
	#KBOUTP
 0x60

	)

50 #define 
	#K_RDCMDBYTE
 0x20

	)

51 #define 
	#K_LDCMDBYTE
 0x60

	)

53 #define 
	#KC8_TRANS
 0x40

	)

54 #define 
	#KC8_MDISABLE
 0x20

	)

55 #define 
	#KC8_KDISABLE
 0x10

	)

56 #define 
	#KC8_IGNSEC
 0x08

	)

57 #define 
	#KC8_CPU
 0x04

	)

58 #define 
	#KC8_MENABLE
 0x02

	)

59 #define 
	#KC8_KENABLE
 0x01

	)

60 #define 
	#CMDBYTE
 (
KC8_TRANS
|
KC8_CPU
|
KC8_MENABLE
|
KC8_KENABLE
)

	)

63 #define 
	#KBC_RESET
 0xFF

	)

64 #define 
	#KBC_RESEND
 0xFE

	)

65 #define 
	#KBC_SETDEFAULT
 0xF6

	)

66 #define 
	#KBC_DISABLE
 0xF5

	)

67 #define 
	#KBC_ENABLE
 0xF4

	)

68 #define 
	#KBC_TYPEMATIC
 0xF3

	)

69 #define 
	#KBC_SETTABLE
 0xF0

	)

70 #define 
	#KBC_MODEIND
 0xED

	)

71 #define 
	#KBC_ECHO
 0xEE

	)

74 #define 
	#KBR_EXTENDED
 0xE0

	)

75 #define 
	#KBR_RESEND
 0xFE

	)

76 #define 
	#KBR_ACK
 0xFA

	)

77 #define 
	#KBR_OVERRUN
 0x00

	)

78 #define 
	#KBR_FAILURE
 0xFD

	)

79 #define 
	#KBR_BREAK
 0xF0

	)

80 #define 
	#KBR_RSTDONE
 0xAA

	)

81 #define 
	#KBR_ECHO
 0xEE

	)

	@/root/Robux/inc/lib.h

7 #ifndef 
JOS_INC_LIB_H


8 #define 
	#JOS_INC_LIB_H
 1

	)

10 #include 
	~<inc/types.h
>

11 #include 
	~<inc/stdio.h
>

12 #include 
	~<inc/stdarg.h
>

13 #include 
	~<inc/string.h
>

14 #include 
	~<inc/error.h
>

15 #include 
	~<inc/assert.h
>

16 #include 
	~<inc/env.h
>

17 #include 
	~<inc/memlayout.h
>

18 #include 
	~<inc/syscall.h
>

19 #include 
	~<inc/trap.h
>

20 #include 
	~<inc/fs.h
>

21 #include 
	~<inc/fd.h
>

22 #include 
	~<inc/args.h
>

23 #include 
	~<inc/malloc.h
>

24 #include 
	~<inc/ns.h
>

25 #include 
	~<inc/security.h
>

27 #define 
	#USED
(
x
) (void)(x)

	)

30 void 
umain
(int 
argc
, char **
argv
);

33 extern const char *
binaryname
;

34 extern const volatile struct 
Env
 *
thisenv
;

35 extern const volatile struct 
Env
 
envs
[
NENV
];

36 extern const volatile struct 
Page
 
pages
[];

39 void 
exit
(void);

42 void 
set_pgfault_handler
(void (*
handler
)(struct 
UTrapframe
 *
utf
));

45 char* 
	`readline_full
(const char *
buf
,int 
echo_override
);

46 char* 
	`readline
(const char *
buf
);

50 void 
	`sys_cputs
(const char *
string
, 
size_t
 
len
);

51 int 
	`sys_cgetc
(void);

52 
envid_t
 
	`sys_getenvid
(void);

53 int 
	`sys_env_destroy
(
envid_t
);

54 void 
	`sys_yield
(void);

55 static 
envid_t
 
	`sys_exofork
(void);

56 int 
	`sys_env_set_status
(
envid_t
 
env
, int 
status
);

57 int 
	`sys_env_set_trapframe
(
envid_t
 
env
, struct 
Trapframe
 *
tf
);

58 int 
	`sys_env_set_pgfault_upcall
(
envid_t
 
env
, void *
upcall
);

59 int 
	`sys_page_alloc
(
envid_t
 
env
, void *
pg
, int 
perm
);

60 int 
	`sys_page_map
(
envid_t
 
src_env
, void *
src_pg
,

61 
envid_t
 
dst_env
, void *
dst_pg
, int 
perm
);

62 int 
	`sys_page_unmap
(
envid_t
 
env
, void *
pg
);

63 int 
	`sys_ipc_try_send
(
envid_t
 
to_env
, 
uint32_t
 
value
, void *
pg
, int 
perm
);

64 int 
	`sys_ipc_recv
(void *
rcv_pg
);

65 unsigned int 
	`sys_time_msec
(void);

66 int 
	`sys_net_send_packet
(void*, 
uint16_t
);

67 int 
	`sys_net_recv_packet
(void*);

68 int 
	`sys_get_mac_addr
(
uint8_t
 [6]);

69 int 
	`sys_set_user_id
(
envid_t
 
to_env
, 
uid_t
 
uid
);

70 int 
	`sys_get_env_user_id
();

71 int 
	`sys_set_group_id
(
envid_t
 
to_env
, 
gid_t
 
gid
);

72 int 
	`sys_get_env_group_id
();

75 static 
__inline
 
envid_t
 
	`__attribute__
((
always_inline
))

76 
	$sys_exofork
(void)

78 
envid_t
 
ret
;

79 
__asm
 
	`__volatile
("int %2"

80 : "=a" (
ret
)

81 : "a" (
SYS_exofork
),

82 "i" (
T_SYSCALL
)

84 return 
ret
;

85 
	}
}

88 void 
ipc_send
(
envid_t
 
to_env
, 
uint32_t
 
value
, void *
pg
, int 
perm
);

89 
int32_t
 
ipc_recv
(
envid_t
 *
from_env_store
, void *
pg
, int *
perm_store
);

90 
envid_t
 
ipc_find_env
(enum 
EnvType
 
type
);

93 #define 
	#PTE_SHARE
 0x400

	)

94 
envid_t
 
fork
(void);

95 
envid_t
 
sfork
(void);

98 int 
close
(int 
fd
);

99 
ssize_t
 
read
(int 
fd
, void *
buf
, 
size_t
 
nbytes
);

100 
ssize_t
 
write
(int 
fd
, const void *
buf
, 
size_t
 
nbytes
);

101 int 
seek
(int 
fd
, 
off_t
 
offset
);

102 void 
close_all
(void);

103 
ssize_t
 
readn
(int 
fd
, void *
buf
, 
size_t
 
nbytes
);

104 int 
dup
(int 
oldfd
, int 
newfd
);

105 int 
fstat
(int 
fd
, struct 
Stat
 *
statbuf
);

106 int 
stat
(const char *
path
, struct 
Stat
 *
statbuf
);

107 int 
isopen
(int 
fd
);

110 int 
open
(const char *
path
, int 
mode
);

111 int 
ftruncate
(int 
fd
, 
off_t
 
size
);

112 int 
fchmod
(int 
fd
,
fsperm_t
 
newperm
);

113 int 
fchown
(int 
fd
,
uid_t
 
uid
);

114 int 
fchgrp
(int 
fd
,
gid_t
 
gid
);

115 int 
remove
(const char *
path
);

116 int 
sync
(void);

119 int 
pageref
(void *
addr
);

122 int 
accept
(int 
s
, struct 
sockaddr
 *
addr
, 
socklen_t
 *
addrlen
);

123 int 
bind
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
);

124 int 
shutdown
(int 
s
, int 
how
);

125 int 
connect
(int 
s
, const struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
);

126 int 
listen
(int 
s
, int 
backlog
);

127 int 
socket
(int 
domain
, int 
type
, int 
protocol
);

130 int 
nsipc_accept
(int 
s
, struct 
sockaddr
 *
addr
, 
socklen_t
 *
addrlen
);

131 int 
nsipc_bind
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
);

132 int 
nsipc_shutdown
(int 
s
, int 
how
);

133 int 
nsipc_close
(int 
s
);

134 int 
nsipc_connect
(int 
s
, const struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
);

135 int 
nsipc_listen
(int 
s
, int 
backlog
);

136 int 
nsipc_recv
(int 
s
, void *
mem
, int 
len
, unsigned int 
flags
);

137 int 
nsipc_send
(int 
s
, const void *
buf
, int 
size
, unsigned int 
flags
);

138 int 
nsipc_socket
(int 
domain
, int 
type
, int 
protocol
);

141 
envid_t
 
spawn
(const char *
program
, const char **
argv
);

142 
envid_t
 
spawn_full
(const char *
program
, const char **
argv
, 
uid_t
 
uid
, 
gid_t
 
gid
);

143 
envid_t
 
spawnl
(const char *
program
, const char *
arg0
, ...);

146 void 
cputchar
(int 
c
);

147 int 
getchar
(void);

148 int 
iscons
(int 
fd
);

149 int 
opencons
(void);

152 int 
pipe
(int 
pipefds
[2]);

153 int 
pipeisclosed
(int 
pipefd
);

156 void 
wait
(
envid_t
 
env
);

159 int 
get_user_by_id
(
uid_t
, struct 
user_info
*);

160 int 
get_user_by_name
(char*, struct 
user_info
*);

161 int 
verify_password
(
uid_t
, char *
pass
);

163 
uid_t
 
getuid
();

164 
gid_t
 
getgid
();

167 void 
base64
(char *, char *, int 
inlen
, int 
outlen
);

170 #define 
	#O_RDONLY
 0x0000

	)

171 #define 
	#O_WRONLY
 0x0001

	)

172 #define 
	#O_RDWR
 0x0002

	)

173 #define 
	#O_ACCMODE
 0x0003

	)

175 #define 
	#O_CREAT
 0x0100

	)

176 #define 
	#O_TRUNC
 0x0200

	)

177 #define 
	#O_EXCL
 0x0400

	)

178 #define 
	#O_MKDIR
 0x0800

	)

	@/root/Robux/inc/malloc.h

1 #ifndef 
JOS_INC_MALLOC_H


2 #define 
	#JOS_INC_MALLOC_H
 1

	)

4 void *
malloc
(
size_t
 
size
);

5 void 
free
(void *
addr
);

	@/root/Robux/inc/memlayout.h

1 #ifndef 
JOS_INC_MEMLAYOUT_H


2 #define 
	#JOS_INC_MEMLAYOUT_H


	)

4 #ifndef 
__ASSEMBLER__


5 #include 
	~<inc/types.h
>

6 #include 
	~<inc/mmu.h
>

15 #define 
	#GD_KT
 0x08

16 #define 
	#GD_KD
 0x10

17 #define 
	#GD_UT
 0x18

18 #define 
	#GD_UD
 0x20

19 #define 
	#GD_TSS0
 0x28

20 

	)

92 #define 
	#KERNBASE
 0xF0000000

	)

97 #define 
	#IOPHYSMEM
 0x0A0000

	)

98 #define 
	#EXTPHYSMEM
 0x100000

	)

101 #define 
	#KSTACKTOP
 (
KERNBASE
 - 
PTSIZE
)

	)

102 #define 
	#KSTKSIZE
 (8*
PGSIZE
)

103 #define 
	#KSTKGAP
 (8*
PGSIZE
)

104 #define 
	#ULIM
 (
KSTACKTOP
 - 
PTSIZE
)

	)

112 #define 
	#UVPT
 (
ULIM
 - 
PTSIZE
)

	)

114 #define 
	#UPAGES
 (
UVPT
 - 
PTSIZE
)

	)

116 #define 
	#UENVS
 (
UPAGES
 - 
PTSIZE
)

	)

123 #define 
	#UTOP
 
UENVS


	)

125 #define 
	#UXSTACKTOP
 
UTOP


	)

128 #define 
	#USTACKTOP
 (
UTOP
 - 2*
PGSIZE
)

	)

131 #define 
	#UTEXT
 (2*
PTSIZE
)

	)

134 #define 
	#UTEMP
 ((void*) 
PTSIZE
)

	)

137 #define 
	#PFTEMP
 (
UTEMP
 + 
PTSIZE
 - 
PGSIZE
)

	)

139 #define 
	#USTABDATA
 (
PTSIZE
 / 2)

	)

142 #define 
	#MPENTRY_PADDR
 0x7000

	)

145 #define 
	#IOMEM_PADDR
 0xfe000000

	)

147 #define 
	#IOMEMBASE
 0xfe000000

	)

149 #define 
	#NETMEMBASE
 0xfd000000

	)

151 #ifndef 
__ASSEMBLER__


153 typedef 
uint32_t
 
	tpte_t
;

154 typedef 
uint32_t
 
	tpde_t
;

156 #if 
JOS_USER


171 extern volatile 
pte_t
 
vpt
[];

172 extern volatile 
pde_t
 
vpd
[];

185 struct 
	sPage
 {

187 struct 
Page
 *
	mpp_link
;

194 
uint16_t
 
	mpp_ref
;

	@/root/Robux/inc/mmu.h

1 #ifndef 
JOS_INC_MMU_H


2 #define 
	#JOS_INC_MMU_H


	)

30 #define 
	#PGNUM
(
la
) (((
uintptr_t
) (la)) >> 
PTXSHIFT
)

	)

33 #define 
	#PDX
(
la
) ((((
uintptr_t
) (la)) >> 
PDXSHIFT
) & 0x3FF)

	)

36 #define 
	#PTX
(
la
) ((((
uintptr_t
) (la)) >> 
PTXSHIFT
) & 0x3FF)

	)

39 #define 
	#PGOFF
(
la
) (((
uintptr_t
) (la)) & 0xFFF)

	)

42 #define 
	#PGADDR
(
d
, 
t
, 
o
) ((void*) ((d) << 
PDXSHIFT
 | (t) << 
PTXSHIFT
 | (o)))

	)

45 #define 
	#NPDENTRIES
 1024

46 #define 
	#NPTENTRIES
 1024

47 

	)

48 #define 
	#PGSIZE
 4096

49 #define 
	#PGSHIFT
 12

50 

	)

51 #define 
	#PTSIZE
 (
PGSIZE
*
NPTENTRIES
)

52 #define 
	#PTSHIFT
 22

53 

	)

54 #define 
	#PTXSHIFT
 12

55 #define 
	#PDXSHIFT
 22

56 

	)

58 #define 
	#PTE_P
 0x001

59 #define 
	#PTE_W
 0x002

60 #define 
	#PTE_U
 0x004

61 #define 
	#PTE_PWT
 0x008

62 #define 
	#PTE_PCD
 0x010

63 #define 
	#PTE_A
 0x020

64 #define 
	#PTE_D
 0x040

65 #define 
	#PTE_PS
 0x080

66 #define 
	#PTE_G
 0x100

67 

	)

70 #define 
	#PTE_AVAIL
 0xE00

71 

	)

73 #define 
	#PTE_SYSCALL
 (
PTE_AVAIL
 | 
PTE_P
 | 
PTE_W
 | 
PTE_U
 | 
PTE_A
 | 
PTE_D
)

	)

76 #define 
	#PTE_ADDR
(
pte
) ((
physaddr_t
) (pte) & ~0xFFF)

	)

79 #define 
	#CR0_PE
 0x00000001

80 #define 
	#CR0_MP
 0x00000002

81 #define 
	#CR0_EM
 0x00000004

82 #define 
	#CR0_TS
 0x00000008

83 #define 
	#CR0_ET
 0x00000010

84 #define 
	#CR0_NE
 0x00000020

85 #define 
	#CR0_WP
 0x00010000

86 #define 
	#CR0_AM
 0x00040000

87 #define 
	#CR0_NW
 0x20000000

88 #define 
	#CR0_CD
 0x40000000

89 #define 
	#CR0_PG
 0x80000000

90 

	)

91 #define 
	#CR4_PCE
 0x00000100

92 #define 
	#CR4_MCE
 0x00000040

93 #define 
	#CR4_PSE
 0x00000010

94 #define 
	#CR4_DE
 0x00000008

95 #define 
	#CR4_TSD
 0x00000004

96 #define 
	#CR4_PVI
 0x00000002

97 #define 
	#CR4_VME
 0x00000001

98 

	)

100 #define 
	#FL_CF
 0x00000001

101 #define 
	#FL_PF
 0x00000004

102 #define 
	#FL_AF
 0x00000010

103 #define 
	#FL_ZF
 0x00000040

104 #define 
	#FL_SF
 0x00000080

105 #define 
	#FL_TF
 0x00000100

106 #define 
	#FL_IF
 0x00000200

107 #define 
	#FL_DF
 0x00000400

108 #define 
	#FL_OF
 0x00000800

109 #define 
	#FL_IOPL_MASK
 0x00003000

110 #define 
	#FL_IOPL_0
 0x00000000

111 #define 
	#FL_IOPL_1
 0x00001000

112 #define 
	#FL_IOPL_2
 0x00002000

113 #define 
	#FL_IOPL_3
 0x00003000

114 #define 
	#FL_NT
 0x00004000

115 #define 
	#FL_RF
 0x00010000

116 #define 
	#FL_VM
 0x00020000

117 #define 
	#FL_AC
 0x00040000

118 #define 
	#FL_VIF
 0x00080000

119 #define 
	#FL_VIP
 0x00100000

120 #define 
	#FL_ID
 0x00200000

121 

	)

123 #define 
	#FEC_PR
 0x1

124 #define 
	#FEC_WR
 0x2

125 #define 
	#FEC_U
 0x4

126 

	)

134 #ifdef 
__ASSEMBLER__


139 #define 
	#SEG_NULL
 \

140 .
word
 0, 0; \

141 .
byte
 0, 0, 0, 0

	)

142 #define 
	#SEG
(
type
,
base
,
lim
) \

143 .
	`word
 (((
lim
) >> 12) & 0xffff), ((
base
) & 0xffff); \

144 .
	`byte
 (((
base
) >> 16) & 0xff), (0x90 | (
type
)), \

145 (0xC0 | (((
lim
) >> 28) & 0xf)), (((
base
) >> 24) & 0xff)

	)

149 #include 
	~<inc/types.h
>

152 struct 
	sSegdesc
 {

153 unsigned 
	msd_lim_15_0
 : 16;

154 unsigned 
	msd_base_15_0
 : 16;

155 unsigned 
	msd_base_23_16
 : 8;

156 unsigned 
	msd_type
 : 4;

157 unsigned 
	msd_s
 : 1;

158 unsigned 
	msd_dpl
 : 2;

159 unsigned 
	msd_p
 : 1;

160 unsigned 
	msd_lim_19_16
 : 4;

161 unsigned 
	msd_avl
 : 1;

162 unsigned 
	msd_rsv1
 : 1;

163 unsigned 
	msd_db
 : 1;

164 unsigned 
	msd_g
 : 1;

165 unsigned 
	msd_base_31_24
 : 8;

168 #define 
	#SEG_NULL
 (struct 
Segdesc
){ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

	)

170 #define 
	#SEG_FAULT
 (struct 
Segdesc
){ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 }

	)

172 #define 
	#SEG
(
type
, 
base
, 
lim
, 
dpl
) (struct 
Segdesc
) \

173 { ((
lim
) >> 12) & 0xffff, (
base
) & 0xffff, ((base) >> 16) & 0xff, \

174 
type
, 1, 
dpl
, 1, (unsigned) (
lim
) >> 28, 0, 0, 1, 1, \

175 (unsigned) (
base
) >> 24 }

	)

176 #define 
	#SEG16
(
type
, 
base
, 
lim
, 
dpl
) (struct 
Segdesc
) \

177 { (
lim
) & 0xffff, (
base
) & 0xffff, ((base) >> 16) & 0xff, \

178 
type
, 1, 
dpl
, 1, (unsigned) (
lim
) >> 16, 0, 0, 1, 0, \

179 (unsigned) (
base
) >> 24 }

	)

184 #define 
	#STA_X
 0x8

185 #define 
	#STA_E
 0x4

186 #define 
	#STA_C
 0x4

187 #define 
	#STA_W
 0x2

188 #define 
	#STA_R
 0x2

189 #define 
	#STA_A
 0x1

190 

	)

192 #define 
	#STS_T16A
 0x1

193 #define 
	#STS_LDT
 0x2

194 #define 
	#STS_T16B
 0x3

195 #define 
	#STS_CG16
 0x4

196 #define 
	#STS_TG
 0x5

197 #define 
	#STS_IG16
 0x6

198 #define 
	#STS_TG16
 0x7

199 #define 
	#STS_T32A
 0x9

200 #define 
	#STS_T32B
 0xB

201 #define 
	#STS_CG32
 0xC

202 #define 
	#STS_IG32
 0xE

203 #define 
	#STS_TG32
 0xF

204 

	)

212 #ifndef 
__ASSEMBLER__


215 struct 
	sTaskstate
 {

216 
uint32_t
 
	mts_link
;

217 
uintptr_t
 
	mts_esp0
;

218 
uint16_t
 
	mts_ss0
;

219 
uint16_t
 
	mts_padding1
;

220 
uintptr_t
 
	mts_esp1
;

221 
uint16_t
 
	mts_ss1
;

222 
uint16_t
 
	mts_padding2
;

223 
uintptr_t
 
	mts_esp2
;

224 
uint16_t
 
	mts_ss2
;

225 
uint16_t
 
	mts_padding3
;

226 
physaddr_t
 
	mts_cr3
;

227 
uintptr_t
 
	mts_eip
;

228 
uint32_t
 
	mts_eflags
;

229 
uint32_t
 
	mts_eax
;

230 
uint32_t
 
	mts_ecx
;

231 
uint32_t
 
	mts_edx
;

232 
uint32_t
 
	mts_ebx
;

233 
uintptr_t
 
	mts_esp
;

234 
uintptr_t
 
	mts_ebp
;

235 
uint32_t
 
	mts_esi
;

236 
uint32_t
 
	mts_edi
;

237 
uint16_t
 
	mts_es
;

238 
uint16_t
 
	mts_padding4
;

239 
uint16_t
 
	mts_cs
;

240 
uint16_t
 
	mts_padding5
;

241 
uint16_t
 
	mts_ss
;

242 
uint16_t
 
	mts_padding6
;

243 
uint16_t
 
	mts_ds
;

244 
uint16_t
 
	mts_padding7
;

245 
uint16_t
 
	mts_fs
;

246 
uint16_t
 
	mts_padding8
;

247 
uint16_t
 
	mts_gs
;

248 
uint16_t
 
	mts_padding9
;

249 
uint16_t
 
	mts_ldt
;

250 
uint16_t
 
	mts_padding10
;

251 
uint16_t
 
	mts_t
;

252 
uint16_t
 
	mts_iomb
;

256 struct 
	sGatedesc
 {

257 unsigned 
	mgd_off_15_0
 : 16;

258 unsigned 
	mgd_sel
 : 16;

259 unsigned 
	mgd_args
 : 5;

260 unsigned 
	mgd_rsv1
 : 3;

261 unsigned 
	mgd_type
 : 4;

262 unsigned 
	mgd_s
 : 1;

263 unsigned 
	mgd_dpl
 : 2;

264 unsigned 
	mgd_p
 : 1;

265 unsigned 
	mgd_off_31_16
 : 16;

282 #define 
	#SETGATE
(
gate
, 
istrap
, 
sel
, 
off
, 
dpl
) \

284 (
gate
).
gd_off_15_0
 = (
uint32_t
) (
off
) & 0xffff; \

285 (
gate
).
gd_sel
 = (
sel
); \

286 (
gate
).
gd_args
 = 0; \

287 (
gate
).
gd_rsv1
 = 0; \

288 (
gate
).
gd_type
 = (
istrap
) ? 
STS_TG32
 : 
STS_IG32
; \

289 (
gate
).
gd_s
 = 0; \

290 (
gate
).
gd_dpl
 = (
dpl
); \

291 (
gate
).
gd_p
 = 1; \

292 (
gate
).
gd_off_31_16
 = (
uint32_t
) (
off
) >> 16; \

293 }

	)

296 #define 
	#SETCALLGATE
(
gate
, 
sel
, 
off
, 
dpl
) \

298 (
gate
).
gd_off_15_0
 = (
uint32_t
) (
off
) & 0xffff; \

299 (
gate
).
gd_sel
 = (
sel
); \

300 (
gate
).
gd_args
 = 0; \

301 (
gate
).
gd_rsv1
 = 0; \

302 (
gate
).
gd_type
 = 
STS_CG32
; \

303 (
gate
).
gd_s
 = 0; \

304 (
gate
).
gd_dpl
 = (
dpl
); \

305 (
gate
).
gd_p
 = 1; \

306 (
gate
).
gd_off_31_16
 = (
uint32_t
) (
off
) >> 16; \

307 }

	)

310 struct 
	sPseudodesc
 {

311 
uint16_t
 
	mpd_lim
;

312 
uint32_t
 
	mpd_base
;

313 } 
__attribute__
 ((
packed
));

	@/root/Robux/inc/ns.h

3 #ifndef 
JOS_INC_NS_H


4 #define 
	#JOS_INC_NS_H


	)

6 #include 
	~<inc/types.h
>

7 #include 
	~<inc/mmu.h
>

8 #include 
	~<lwip/sockets.h
>

10 struct 
	sjif_pkt
 {

11 int 
	mjp_len
;

12 char 
	mjp_data
[0];

19 
	mNSREQ_ACCEPT
 = 1,

20 
	mNSREQ_BIND
,

21 
	mNSREQ_SHUTDOWN
,

22 
	mNSREQ_CLOSE
,

23 
	mNSREQ_CONNECT
,

24 
	mNSREQ_LISTEN
,

26 
	mNSREQ_RECV
,

27 
	mNSREQ_SEND
,

28 
	mNSREQ_SOCKET
,

31 
	mNSREQ_INPUT
,

34 
	mNSREQ_OUTPUT
,

37 
	mNSREQ_TIMER
,

40 union 
	uNsipc
 {

41 struct 
	sNsreq_accept
 {

42 int 
	mreq_s
;

43 } 
	maccept
;

45 struct 
	sNsret_accept
 {

46 struct 
sockaddr
 
	mret_addr
;

47 
socklen_t
 
	mret_addrlen
;

48 } 
	macceptRet
;

50 struct 
	sNsreq_bind
 {

51 int 
	mreq_s
;

52 struct 
sockaddr
 
	mreq_name
;

53 
socklen_t
 
	mreq_namelen
;

54 } 
	mbind
;

56 struct 
	sNsreq_shutdown
 {

57 int 
	mreq_s
;

58 int 
	mreq_how
;

59 } 
	mshutdown
;

61 struct 
	sNsreq_close
 {

62 int 
	mreq_s
;

63 } 
	mclose
;

65 struct 
	sNsreq_connect
 {

66 int 
	mreq_s
;

67 struct 
sockaddr
 
	mreq_name
;

68 
socklen_t
 
	mreq_namelen
;

69 } 
	mconnect
;

71 struct 
	sNsreq_listen
 {

72 int 
	mreq_s
;

73 int 
	mreq_backlog
;

74 } 
	mlisten
;

76 struct 
	sNsreq_recv
 {

77 int 
	mreq_s
;

78 int 
	mreq_len
;

79 unsigned int 
	mreq_flags
;

80 } 
	mrecv
;

82 struct 
	sNsret_recv
 {

83 char 
	mret_buf
[0];

84 } 
	mrecvRet
;

86 struct 
	sNsreq_send
 {

87 int 
	mreq_s
;

88 int 
	mreq_size
;

89 unsigned int 
	mreq_flags
;

90 char 
	mreq_buf
[0];

91 } 
	msend
;

93 struct 
	sNsreq_socket
 {

94 int 
	mreq_domain
;

95 int 
	mreq_type
;

96 int 
	mreq_protocol
;

97 } 
	msocket
;

99 struct 
jif_pkt
 
	mpkt
;

102 char 
	m_pad
[
PGSIZE
];

	@/root/Robux/inc/queue.h

35 #ifndef 
JOS_INC_QUEUE_H


36 #define 
	#JOS_INC_QUEUE_H


	)

52 struct 
	sFrob


54 int 
	mfrobozz
;

55 
LIST_ENTRY
(
Frob
) 
	mfrob_link
;

58 
	$LIST_HEAD
(
Frob_list
, 
Frob
)

60 struct 
Frob_list
 
flist
;

62 
	`LIST_INIT
(&
flist
);

63 
flist
 = 
	`LIST_HEAD_INITIALIZER
(&flist);

65 if(
	$LIST_EMPTY
(&
flist
))

66 
	`printf
("list is empty\n");

68 struct 
Frob
 *
f
 = 
	`LIST_FIRST
(&
flist
);

69 
f
 = 
	`LIST_NEXT
(f, 
frob_link
);

70 
f
 = 
	`LIST_NEXT
(f, 
frob_link
);

72 for(
f
=
	`LIST_FIRST
(&
flist
); f != 0;

73 
f
 = 
	$LIST_NEXT
(
f
, 
frob_link
))

74 
	`printf
("f %d\n", 
f
->
frobozz
);

76 
	$LIST_FOREACH
(
f
, &
flist
, 
frob_link
)

77 
	`printf
("f %d\n", 
f
->
frobozz
);

79 
f
 = 
	`LIST_NEXT
(
	`LIST_FIRST
(&
flist
));

80 
	`LIST_INSERT_AFTER
(
f
, 
g
, 
frob_link
);

81 
	`LIST_REMOVE
(
g
, 
frob_link
);

82 
	`LIST_INSERT_BEFORE
(
f
, 
g
, 
frob_link
);

83 
	`LIST_REMOVE
(
g
, 
frob_link
);

84 
	`LIST_INSERT_HEAD
(&
flist
, 
g
, 
frob_link
);

109 #define 
	#LIST_HEAD
(
name
, 
type
) \

110 struct 
	sname
 { \

111 struct 
type
 *
lh_first
; \

112 }

	)

118 #define 
	#LIST_HEAD_INITIALIZER
(
head
) \

119 { 
NULL
 
	}

	)
}

129 #define 
	#LIST_ENTRY
(
type
) \

131 struct 
type
 *
le_next
; \

132 struct 
type
 **
le_prev
; \

133 }

	)

142 #define 
	#LIST_EMPTY
(
head
) ((head)->
lh_first
 == 
NULL
)

	)

147 #define 
	#LIST_FIRST
(
head
) ((head)->
lh_first
)

	)

153 #define 
	#LIST_NEXT
(
elm
, 
field
) ((elm)->field.
le_next
)

	)

160 #define 
	#LIST_FOREACH
(
var
, 
head
, 
field
) \

161 for ((
var
) = 
	`LIST_FIRST
((
head
)); \

162 (
var
); \

163 (
var
) = 
	`LIST_NEXT
((var), 
field
))

	)

168 #define 
	#LIST_INIT
(
head
) do { \

169 
	`LIST_FIRST
((
head
)) = 
NULL
; \

170 } while (0)

	)

177 #define 
	#LIST_INSERT_AFTER
(
listelm
, 
elm
, 
field
) do { \

178 if ((
	`LIST_NEXT
((
elm
), 
field
) = LIST_NEXT((
listelm
), field)) != 
NULL
)\

179 
	`LIST_NEXT
((
listelm
), 
field
)->field.
le_prev
 = \

180 &
	`LIST_NEXT
((
elm
), 
field
); \

181 
	`LIST_NEXT
((
listelm
), 
field
) = (
elm
); \

182 (
elm
)->
field
.
le_prev
 = &
	`LIST_NEXT
((
listelm
), field); \

183 } while (0)

	)

190 #define 
	#LIST_INSERT_BEFORE
(
listelm
, 
elm
, 
field
) do { \

191 (
elm
)->
field
.
le_prev
 = (
listelm
)->field.le_prev; \

192 
	`LIST_NEXT
((
elm
), 
field
) = (
listelm
); \

193 *(
listelm
)->
field
.
le_prev
 = (
elm
); \

194 (
listelm
)->
field
.
le_prev
 = &
	`LIST_NEXT
((
elm
), field); \

195 } while (0)

	)

201 #define 
	#LIST_INSERT_HEAD
(
head
, 
elm
, 
field
) do { \

202 if ((
	`LIST_NEXT
((
elm
), 
field
) = 
	`LIST_FIRST
((
head
))) != 
NULL
) \

203 
	`LIST_FIRST
((
head
))->
field
.
le_prev
 = &
	`LIST_NEXT
((
elm
), field);\

204 
	`LIST_FIRST
((
head
)) = (
elm
); \

205 (
elm
)->
field
.
le_prev
 = &
	`LIST_FIRST
((
head
)); \

206 } while (0)

	)

212 #define 
	#LIST_REMOVE
(
elm
, 
field
) do { \

213 if (
	`LIST_NEXT
((
elm
), 
field
) != 
NULL
) \

214 
	`LIST_NEXT
((
elm
), 
field
)->field.
le_prev
 = \

215 (
elm
)->
field
.
le_prev
; \

216 *(
elm
)->
field
.
le_prev
 = 
	`LIST_NEXT
((elm), field); \

217 } while (0)

	)

	@/root/Robux/inc/security.h

1 #ifndef 
JOS_INC_SECURITY_H


2 #define 
	#JOS_INC_SECURITY_H


	)

5 #define 
	#NAME_LEN
 32

	)

6 #define 
	#PASS_LEN
 128

	)

8 #define 
	#COMMENT_LEN
 256

	)

9 #define 
	#PATH_LEN
 256

	)

14 #ifndef 
FS_FORMAT_UTIL


15 typedef 
uint16_t
 
	tuid_t
;

16 typedef 
uint16_t
 
	tgid_t
;

17 typedef 
uint16_t
 
	tfsperm_t
;

19 #define 
	#uid_t
 
uint16_t


	)

20 #define 
	#gid_t
 
uint16_t


	)

21 #define 
	#fsperm_t
 
uint16_t


	)

24 #define 
	#FSP_A_X
 0001

	)

25 #define 
	#FSP_A_W
 0002

	)

26 #define 
	#FSP_A_R
 0004

	)

28 #define 
	#FSP_G_X
 0010

	)

29 #define 
	#FSP_G_W
 0020

	)

30 #define 
	#FSP_G_R
 0040

	)

32 #define 
	#FSP_O_X
 0100

	)

33 #define 
	#FSP_O_W
 0200

	)

34 #define 
	#FSP_O_R
 0400

	)

37 #define 
	#DEFAULT_FILE_CREATE_PERM
 
FSP_O_W
 | 
FSP_O_R
 | 
FSP_G_R
 | 
FSP_A_R
 | 
FSP_A_X
 | 
FSP_G_X
 | 
FSP_O_X


	)

38 #define 
	#DEFAULT_DIR_CREATE_PERM
 
FSP_O_W
 | 
FSP_O_R
 | 
FSP_O_X
 | 
FSP_G_R
 | 
FSP_G_W
 | 
FSP_A_R
 | FSP_O_X | 
FSP_G_X
 | 
FSP_A_X


	)

40 struct 
	suser_info


42 char 
	mui_name
[
NAME_LEN
];

43 char 
	mui_pass
[
PASS_LEN
];

44 
uid_t
 
	mui_uid
;

45 
gid_t
 
	mui_gid
;

46 char 
	mui_comment
[
COMMENT_LEN
];

47 char 
	mui_home
[
PATH_LEN
];

48 char 
	mui_shell
[
PATH_LEN
];

	@/root/Robux/inc/stab.h

1 #ifndef 
JOS_STAB_H


2 #define 
	#JOS_STAB_H


	)

3 #include 
	~<inc/types.h
>

15 #define 
	#N_GSYM
 0x20

16 #define 
	#N_FNAME
 0x22

17 #define 
	#N_FUN
 0x24

18 #define 
	#N_STSYM
 0x26

19 #define 
	#N_LCSYM
 0x28

20 #define 
	#N_MAIN
 0x2a

21 #define 
	#N_PC
 0x30

22 #define 
	#N_RSYM
 0x40

23 #define 
	#N_SLINE
 0x44

24 #define 
	#N_DSLINE
 0x46

25 #define 
	#N_BSLINE
 0x48

26 #define 
	#N_SSYM
 0x60

27 #define 
	#N_SO
 0x64

28 #define 
	#N_LSYM
 0x80

29 #define 
	#N_BINCL
 0x82

30 #define 
	#N_SOL
 0x84

31 #define 
	#N_PSYM
 0xa0

32 #define 
	#N_EINCL
 0xa2

33 #define 
	#N_ENTRY
 0xa4

34 #define 
	#N_LBRAC
 0xc0

35 #define 
	#N_EXCL
 0xc2

36 #define 
	#N_RBRAC
 0xe0

37 #define 
	#N_BCOMM
 0xe2

38 #define 
	#N_ECOMM
 0xe4

39 #define 
	#N_ECOML
 0xe8

40 #define 
	#N_LENG
 0xfe

41 

	)

43 struct 
	sStab
 {

44 
uint32_t
 
	mn_strx
;

45 
uint8_t
 
	mn_type
;

46 
uint8_t
 
	mn_other
;

47 
uint16_t
 
	mn_desc
;

48 
uintptr_t
 
	mn_value
;

	@/root/Robux/inc/stdarg.h

3 #ifndef 
JOS_INC_STDARG_H


4 #define 
	#JOS_INC_STDARG_H


	)

6 typedef 
__builtin_va_list
 
	tva_list
;

8 #define 
	#va_start
(
ap
, 
last
) 
	`__builtin_va_start
(ap, last)

	)

10 #define 
	#va_arg
(
ap
, 
type
) 
	`__builtin_va_arg
(ap, type)

	)

12 #define 
	#va_end
(
ap
) 
	`__builtin_va_end
(ap)

	)

	@/root/Robux/inc/stdio.h

1 #ifndef 
JOS_INC_STDIO_H


2 #define 
	#JOS_INC_STDIO_H


	)

4 #include 
	~<inc/stdarg.h
>

6 #ifndef 
NULL


7 #define 
	#NULL
 ((void *) 0)

	)

11 void 
cputchar
(int 
c
);

12 int 
getchar
(void);

13 int 
iscons
(int 
fd
);

16 void 
printfmt
(void (*
putch
)(int, void*), void *
putdat
, const char *
fmt
, ...);

17 void 
	`vprintfmt
(void (*
putch
)(int, void*), void *
putdat
, const char *
fmt
, 
va_list
);

18 int 
	`snprintf
(char *
str
, int 
size
, const char *
fmt
, ...);

19 int 
	`vsnprintf
(char *
str
, int 
size
, const char *
fmt
, 
va_list
);

22 int 
	`cprintf
(const char *
fmt
, ...);

23 int 
	`vcprintf
(const char *
fmt
, 
va_list
);

26 int 
	`printf
(const char *
fmt
, ...);

27 int 
	`fprintf
(int 
fd
, const char *
fmt
, ...);

28 int 
	`vfprintf
(int 
fd
, const char *
fmt
, 
va_list
);

31 char* 
	`readline
(const char *
prompt
);

	@/root/Robux/inc/string.h

1 #ifndef 
JOS_INC_STRING_H


2 #define 
	#JOS_INC_STRING_H


	)

4 #include 
	~<inc/types.h
>

6 int 
strlen
(const char *
s
);

7 int 
strnlen
(const char *
s
, 
size_t
 
size
);

8 char * 
strcpy
(char *
dst
, const char *
src
);

9 char * 
strncpy
(char *
dst
, const char *
src
, 
size_t
 
size
);

10 char * 
strcat
(char *
dst
, const char *
src
);

11 
size_t
 
strlcpy
(char *
dst
, const char *
src
, size_t 
size
);

12 int 
strcmp
(const char *
s1
, const char *
s2
);

13 int 
strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
size
);

14 char * 
strchr
(const char *
s
, char 
c
);

15 char * 
strfind
(const char *
s
, char 
c
);

17 void * 
memset
(void *
dst
, int 
c
, 
size_t
 
len
);

19 void * 
memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

20 int 
memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
len
);

21 void * 
memfind
(const void *
s
, int 
c
, 
size_t
 
len
);

23 long 
strtol
(const char *
s
, char **
endptr
, int 
base
);

25 int 
atoi
(const char *
str
);

	@/root/Robux/inc/syscall.h

1 #ifndef 
JOS_INC_SYSCALL_H


2 #define 
	#JOS_INC_SYSCALL_H


	)

6 
	mSYS_cputs
 = 0,

7 
	mSYS_cgetc
,

8 
	mSYS_getenvid
,

9 
	mSYS_env_destroy
,

10 
	mSYS_page_alloc
,

11 
	mSYS_page_map
,

12 
	mSYS_page_unmap
,

13 
	mSYS_exofork
,

14 
	mSYS_env_set_status
,

15 
	mSYS_env_set_trapframe
,

16 
	mSYS_env_set_pgfault_upcall
,

17 
	mSYS_yield
,

18 
	mSYS_ipc_try_send
,

19 
	mSYS_ipc_recv
,

20 
	mSYS_time_msec
,

21 
	mSYS_net_send_packet
,

22 
	mSYS_net_recv_packet
,

23 
	mSYS_get_mac_addr
,

24 
	mSYS_get_env_user_id
,

25 
	mSYS_set_user_id
,

26 
	mSYS_get_env_group_id
,

27 
	mSYS_set_group_id
,

28 
	mNSYSCALLS


	@/root/Robux/inc/trap.h

1 #ifndef 
JOS_INC_TRAP_H


2 #define 
	#JOS_INC_TRAP_H


	)

6 #define 
	#T_DIVIDE
 0

7 #define 
	#T_DEBUG
 1

8 #define 
	#T_NMI
 2

9 #define 
	#T_BRKPT
 3

10 #define 
	#T_OFLOW
 4

11 #define 
	#T_BOUND
 5

12 #define 
	#T_ILLOP
 6

13 #define 
	#T_DEVICE
 7

14 #define 
	#T_DBLFLT
 8

16 #define 
	#T_TSS
 10

17 #define 
	#T_SEGNP
 11

18 #define 
	#T_STACK
 12

19 #define 
	#T_GPFLT
 13

20 #define 
	#T_PGFLT
 14

22 #define 
	#T_FPERR
 16

23 #define 
	#T_ALIGN
 17

24 #define 
	#T_MCHK
 18

25 #define 
	#T_SIMDERR
 19

26 

	)

29 #define 
	#T_SYSCALL
 48

30 #define 
	#T_DEFAULT
 500

31 

	)

32 #define 
	#IRQ_OFFSET
 32

33 

	)

35 #define 
	#IRQ_TIMER
 0

	)

36 #define 
	#IRQ_KBD
 1

	)

37 #define 
	#IRQ_SERIAL
 4

	)

38 #define 
	#IRQ_SPURIOUS
 7

	)

39 #define 
	#IRQ_IDE
 14

	)

40 #define 
	#IRQ_ERROR
 19

	)

42 #ifndef 
__ASSEMBLER__


44 #include 
	~<inc/types.h
>

46 struct 
	sPushRegs
 {

48 
uint32_t
 
	mreg_edi
;

49 
uint32_t
 
	mreg_esi
;

50 
uint32_t
 
	mreg_ebp
;

51 
uint32_t
 
	mreg_oesp
;

52 
uint32_t
 
	mreg_ebx
;

53 
uint32_t
 
	mreg_edx
;

54 
uint32_t
 
	mreg_ecx
;

55 
uint32_t
 
	mreg_eax
;

56 } 
__attribute__
((
packed
));

58 struct 
	sTrapframe
 {

59 struct 
PushRegs
 
	mtf_regs
;

60 
uint16_t
 
	mtf_es
;

61 
uint16_t
 
	mtf_padding1
;

62 
uint16_t
 
	mtf_ds
;

63 
uint16_t
 
	mtf_padding2
;

64 
uint32_t
 
	mtf_trapno
;

66 
uint32_t
 
	mtf_err
;

67 
uintptr_t
 
	mtf_eip
;

68 
uint16_t
 
	mtf_cs
;

69 
uint16_t
 
	mtf_padding3
;

70 
uint32_t
 
	mtf_eflags
;

72 
uintptr_t
 
	mtf_esp
;

73 
uint16_t
 
	mtf_ss
;

74 
uint16_t
 
	mtf_padding4
;

75 } 
__attribute__
((
packed
));

77 struct 
	sUTrapframe
 {

79 
uint32_t
 
	mutf_fault_va
;

80 
uint32_t
 
	mutf_err
;

82 struct 
PushRegs
 
	mutf_regs
;

83 
uintptr_t
 
	mutf_eip
;

84 
uint32_t
 
	mutf_eflags
;

86 
uintptr_t
 
	mutf_esp
;

87 } 
__attribute__
((
packed
));

89 void 
trap0
(void);

90 void 
trap1
(void);

91 void 
trap2
(void);

92 void 
trap3
(void);

93 void 
trap4
(void);

94 void 
trap5
(void);

95 void 
trap6
(void);

96 void 
trap7
(void);

97 void 
trap8
(void);

98 void 
trap9
(void);

99 void 
trap10
(void);

100 void 
trap11
(void);

101 void 
trap12
(void);

102 void 
trap13
(void);

103 void 
trap14
(void);

104 void 
trap15
(void);

105 void 
trap16
(void);

106 void 
trap17
(void);

107 void 
trap18
(void);

108 void 
trap19
(void);

109 void 
trap20
(void);

110 void 
trap21
(void);

111 void 
trap22
(void);

112 void 
trap23
(void);

113 void 
trap24
(void);

114 void 
trap25
(void);

115 void 
trap26
(void);

116 void 
trap27
(void);

117 void 
trap28
(void);

118 void 
trap29
(void);

119 void 
trap30
(void);

120 void 
trap31
(void);

122 void 
trap32
(void);

123 void 
trap33
(void);

124 void 
trap34
(void);

125 void 
trap35
(void);

126 void 
trap36
(void);

127 void 
trap37
(void);

128 void 
trap38
(void);

129 void 
trap39
(void);

130 void 
trap40
(void);

131 void 
trap41
(void);

132 void 
trap42
(void);

133 void 
trap43
(void);

134 void 
trap44
(void);

135 void 
trap45
(void);

136 void 
trap46
(void);

137 void 
trap47
(void);

139 void 
trap_sysc
(void);

141 void 
sysenter_handler
(void);

	@/root/Robux/inc/types.h

1 #ifndef 
JOS_INC_TYPES_H


2 #define 
	#JOS_INC_TYPES_H


	)

4 #ifndef 
NULL


5 #define 
	#NULL
 ((void*) 0)

	)

9 typedef int 
	tbool
;

12 typedef 
__signed
 char 
	tint8_t
;

13 typedef unsigned char 
	tuint8_t
;

14 typedef short 
	tint16_t
;

15 typedef unsigned short 
	tuint16_t
;

16 typedef int 
	tint32_t
;

17 typedef unsigned int 
	tuint32_t
;

18 typedef long long 
	tint64_t
;

19 typedef unsigned long long 
	tuint64_t
;

25 typedef 
int32_t
 
	tintptr_t
;

26 typedef 
uint32_t
 
	tuintptr_t
;

27 typedef 
uint32_t
 
	tphysaddr_t
;

30 typedef 
uint32_t
 
	tppn_t
;

33 typedef 
uint32_t
 
	tsize_t
;

36 typedef 
int32_t
 
	tssize_t
;

39 typedef 
int32_t
 
	toff_t
;

42 #define 
	#MIN
(
_a
, 
_b
) \

44 
	`typeof
(
_a
) 
__a
 = (_a); \

45 
	`typeof
(
_b
) 
__b
 = (_b); \

46 
__a
 <= 
__b
 ? __a : __b; \

47 })

	)

48 #define 
	#MAX
(
_a
, 
_b
) \

50 
	`typeof
(
_a
) 
__a
 = (_a); \

51 
	`typeof
(
_b
) 
__b
 = (_b); \

52 
__a
 >= 
__b
 ? __a : __b; \

53 })

	)

57 #define 
	#ROUNDDOWN
(
a
, 
n
) \

59 
uint32_t
 
__a
 = (uint32_t) (
a
); \

60 (
	`typeof
(
a
)) (
__a
 - __a % (
n
)); \

61 })

	)

63 #define 
	#ROUNDUP
(
a
, 
n
) \

65 
uint32_t
 
__n
 = (uint32_t) (
n
); \

66 (
	`typeof
(
a
)) (
	`ROUNDDOWN
((
uint32_t
) (a) + 
__n
 - 1, __n)); \

67 })

	)

70 #define 
	#offsetof
(
type
, 
member
) ((
size_t
) (&((type*)0)->member))

	)

	@/root/Robux/inc/x86.h

1 #ifndef 
JOS_INC_X86_H


2 #define 
	#JOS_INC_X86_H


	)

4 #include 
	~<inc/types.h
>

6 static 
__inline
 void 
	$breakpoint
(void) 
	`__attribute__
((
always_inline
));

7 static 
__inline
 
uint8_t
 
	$inb
(int 
port
) 
	`__attribute__
((
always_inline
));

8 static 
__inline
 void 
	$insb
(int 
port
, void *
addr
, int 
cnt
) 
	`__attribute__
((
always_inline
));

9 static 
__inline
 
uint16_t
 
	$inw
(int 
port
) 
	`__attribute__
((
always_inline
));

10 static 
__inline
 void 
	$insw
(int 
port
, void *
addr
, int 
cnt
) 
	`__attribute__
((
always_inline
));

11 static 
__inline
 
uint32_t
 
	$inl
(int 
port
) 
	`__attribute__
((
always_inline
));

12 static 
__inline
 void 
	$insl
(int 
port
, void *
addr
, int 
cnt
) 
	`__attribute__
((
always_inline
));

13 static 
__inline
 void 
	$outb
(int 
port
, 
uint8_t
 
data
) 
	`__attribute__
((
always_inline
));

14 static 
__inline
 void 
	$outsb
(int 
port
, const void *
addr
, int 
cnt
) 
	`__attribute__
((
always_inline
));

15 static 
__inline
 void 
	$outw
(int 
port
, 
uint16_t
 
data
) 
	`__attribute__
((
always_inline
));

16 static 
__inline
 void 
	$outsw
(int 
port
, const void *
addr
, int 
cnt
) 
	`__attribute__
((
always_inline
));

17 static 
__inline
 void 
	$outsl
(int 
port
, const void *
addr
, int 
cnt
) 
	`__attribute__
((
always_inline
));

18 static 
__inline
 void 
	$outl
(int 
port
, 
uint32_t
 
data
) 
	`__attribute__
((
always_inline
));

19 static 
__inline
 void 
	$invlpg
(void *
addr
) 
	`__attribute__
((
always_inline
));

20 static 
__inline
 void 
	$lidt
(void *
p
) 
	`__attribute__
((
always_inline
));

21 static 
__inline
 void 
	$lldt
(
uint16_t
 
sel
) 
	`__attribute__
((
always_inline
));

22 static 
__inline
 void 
	$ltr
(
uint16_t
 
sel
) 
	`__attribute__
((
always_inline
));

23 static 
__inline
 void 
	$lcr0
(
uint32_t
 
val
) 
	`__attribute__
((
always_inline
));

24 static 
__inline
 
uint32_t
 
	$rcr0
(void) 
	`__attribute__
((
always_inline
));

25 static 
__inline
 
uint32_t
 
	$rcr2
(void) 
	`__attribute__
((
always_inline
));

26 static 
__inline
 void 
	$lcr3
(
uint32_t
 
val
) 
	`__attribute__
((
always_inline
));

27 static 
__inline
 
uint32_t
 
	$rcr3
(void) 
	`__attribute__
((
always_inline
));

28 static 
__inline
 void 
	$lcr4
(
uint32_t
 
val
) 
	`__attribute__
((
always_inline
));

29 static 
__inline
 
uint32_t
 
	$rcr4
(void) 
	`__attribute__
((
always_inline
));

30 static 
__inline
 void 
	$tlbflush
(void) 
	`__attribute__
((
always_inline
));

31 static 
__inline
 
uint32_t
 
	$read_eflags
(void) 
	`__attribute__
((
always_inline
));

32 static 
__inline
 void 
	$write_eflags
(
uint32_t
 
eflags
) 
	`__attribute__
((
always_inline
));

33 static 
__inline
 
uint32_t
 
	$read_ebp
(void) 
	`__attribute__
((
always_inline
));

34 static 
__inline
 
uint32_t
 
	$read_esp
(void) 
	`__attribute__
((
always_inline
));

35 static 
__inline
 void 
	`cpuid
(
uint32_t
 
info
, uint32_t *
eaxp
, uint32_t *
ebxp
, uint32_t *
ecxp
, uint32_t *
edxp
);

36 static 
__inline
 
uint64_t
 
	$read_tsc
(void) 
	`__attribute__
((
always_inline
));

38 static 
__inline
 void

39 
	$breakpoint
(void)

41 
__asm
 
	`__volatile
("int3");

42 
	}
}

44 static 
__inline
 
uint8_t


45 
	$inb
(int 
port
)

47 
uint8_t
 
data
;

48 
__asm
 
	`__volatile
("inb %w1,%0" : "=a" (
data
) : "d" (
port
));

49 return 
data
;

50 
	}
}

52 static 
__inline
 void

53 
	$insb
(int 
port
, void *
addr
, int 
cnt
)

55 
__asm
 
	`__volatile
("cld\n\trepne\n\tinsb" :

56 "=D" (
addr
), "=c" (
cnt
) :

57 "d" (
port
), "0" (
addr
), "1" (
cnt
) :

59 
	}
}

61 static 
__inline
 
uint16_t


62 
	$inw
(int 
port
)

64 
uint16_t
 
data
;

65 
__asm
 
	`__volatile
("inw %w1,%0" : "=a" (
data
) : "d" (
port
));

66 return 
data
;

67 
	}
}

69 static 
__inline
 void

70 
	$insw
(int 
port
, void *
addr
, int 
cnt
)

72 
__asm
 
	`__volatile
("cld\n\trepne\n\tinsw" :

73 "=D" (
addr
), "=c" (
cnt
) :

74 "d" (
port
), "0" (
addr
), "1" (
cnt
) :

76 
	}
}

78 static 
__inline
 
uint32_t


79 
	$inl
(int 
port
)

81 
uint32_t
 
data
;

82 
__asm
 
	`__volatile
("inl %w1,%0" : "=a" (
data
) : "d" (
port
));

83 return 
data
;

84 
	}
}

86 static 
__inline
 void

87 
	$insl
(int 
port
, void *
addr
, int 
cnt
)

89 
__asm
 
	`__volatile
("cld\n\trepne\n\tinsl" :

90 "=D" (
addr
), "=c" (
cnt
) :

91 "d" (
port
), "0" (
addr
), "1" (
cnt
) :

93 
	}
}

95 static 
__inline
 void

96 
	$outb
(int 
port
, 
uint8_t
 
data
)

98 
__asm
 
	`__volatile
("outb %0,%w1" : : "a" (
data
), "d" (
port
));

99 
	}
}

101 static 
__inline
 void

102 
	$outsb
(int 
port
, const void *
addr
, int 
cnt
)

104 
__asm
 
	`__volatile
("cld\n\trepne\n\toutsb" :

105 "=S" (
addr
), "=c" (
cnt
) :

106 "d" (
port
), "0" (
addr
), "1" (
cnt
) :

108 
	}
}

110 static 
__inline
 void

111 
	$outw
(int 
port
, 
uint16_t
 
data
)

113 
__asm
 
	`__volatile
("outw %0,%w1" : : "a" (
data
), "d" (
port
));

114 
	}
}

116 static 
__inline
 void

117 
	$outsw
(int 
port
, const void *
addr
, int 
cnt
)

119 
__asm
 
	`__volatile
("cld\n\trepne\n\toutsw" :

120 "=S" (
addr
), "=c" (
cnt
) :

121 "d" (
port
), "0" (
addr
), "1" (
cnt
) :

123 
	}
}

125 static 
__inline
 void

126 
	$outsl
(int 
port
, const void *
addr
, int 
cnt
)

128 
__asm
 
	`__volatile
("cld\n\trepne\n\toutsl" :

129 "=S" (
addr
), "=c" (
cnt
) :

130 "d" (
port
), "0" (
addr
), "1" (
cnt
) :

132 
	}
}

134 static 
__inline
 void

135 
	$outl
(int 
port
, 
uint32_t
 
data
)

137 
__asm
 
	`__volatile
("outl %0,%w1" : : "a" (
data
), "d" (
port
));

138 
	}
}

140 static 
__inline
 void

141 
	$invlpg
(void *
addr
)

143 
__asm
 
	`__volatile
("invlpg (%0)" : : "r" (
addr
) : "memory");

144 
	}
}

146 static 
__inline
 void

147 
	$lidt
(void *
p
)

149 
__asm
 
	`__volatile
("lidt (%0)" : : "r" (
p
));

150 
	}
}

152 static 
__inline
 void

153 
	$lgdt
(void *
p
)

155 
__asm
 
	`__volatile
("lgdt (%0)" : : "r" (
p
));

156 
	}
}

158 static 
__inline
 void

159 
	$lldt
(
uint16_t
 
sel
)

161 
__asm
 
	`__volatile
("lldt %0" : : "r" (
sel
));

162 
	}
}

164 static 
__inline
 void

165 
	$ltr
(
uint16_t
 
sel
)

167 
__asm
 
	`__volatile
("ltr %0" : : "r" (
sel
));

168 
	}
}

170 static 
__inline
 void

171 
	$lcr0
(
uint32_t
 
val
)

173 
__asm
 
	`__volatile
("movl %0,%%cr0" : : "r" (
val
));

174 
	}
}

176 static 
__inline
 
uint32_t


177 
	$rcr0
(void)

179 
uint32_t
 
val
;

180 
__asm
 
	`__volatile
("movl %%cr0,%0" : "=r" (
val
));

181 return 
val
;

182 
	}
}

184 static 
__inline
 
uint32_t


185 
	$rcr2
(void)

187 
uint32_t
 
val
;

188 
__asm
 
	`__volatile
("movl %%cr2,%0" : "=r" (
val
));

189 return 
val
;

190 
	}
}

192 static 
__inline
 void

193 
	$lcr3
(
uint32_t
 
val
)

195 
__asm
 
	`__volatile
("movl %0,%%cr3" : : "r" (
val
));

196 
	}
}

198 static 
__inline
 
uint32_t


199 
	$rcr3
(void)

201 
uint32_t
 
val
;

202 
__asm
 
	`__volatile
("movl %%cr3,%0" : "=r" (
val
));

203 return 
val
;

204 
	}
}

206 static 
__inline
 void

207 
	$lcr4
(
uint32_t
 
val
)

209 
__asm
 
	`__volatile
("movl %0,%%cr4" : : "r" (
val
));

210 
	}
}

212 static 
__inline
 
uint32_t


213 
	$rcr4
(void)

215 
uint32_t
 
cr4
;

216 
__asm
 
	`__volatile
("movl %%cr4,%0" : "=r" (
cr4
));

217 return 
cr4
;

218 
	}
}

220 static 
__inline
 void

221 
	$tlbflush
(void)

223 
uint32_t
 
cr3
;

224 
__asm
 
	`__volatile
("movl %%cr3,%0" : "=r" (
cr3
));

225 
__asm
 
	`__volatile
("movl %0,%%cr3" : : "r" (
cr3
));

226 
	}
}

228 static 
__inline
 
uint32_t


229 
	$read_eflags
(void)

231 
uint32_t
 
eflags
;

232 
__asm
 
	`__volatile
("pushfl; popl %0" : "=r" (
eflags
));

233 return 
eflags
;

234 
	}
}

236 static 
__inline
 void

237 
	$write_eflags
(
uint32_t
 
eflags
)

239 
__asm
 
	`__volatile
("pushl %0; popfl" : : "r" (
eflags
));

240 
	}
}

242 static 
__inline
 
uint32_t


243 
	$read_ebp
(void)

245 
uint32_t
 
ebp
;

246 
__asm
 
	`__volatile
("movl %%ebp,%0" : "=r" (
ebp
));

247 return 
ebp
;

248 
	}
}

250 static 
__inline
 
uint32_t


251 
	$read_esp
(void)

253 
uint32_t
 
esp
;

254 
__asm
 
	`__volatile
("movl %%esp,%0" : "=r" (
esp
));

255 return 
esp
;

256 
	}
}

258 static 
__inline
 void

259 
	$cpuid
(
uint32_t
 
info
, uint32_t *
eaxp
, uint32_t *
ebxp
, uint32_t *
ecxp
, uint32_t *
edxp
)

261 
uint32_t
 
eax
, 
ebx
, 
ecx
, 
edx
;

262 
asm
 volatile("cpuid"

263 : "=a" (
eax
), "=b" (
ebx
), "=c" (
ecx
), "=d" (
edx
)

264 : "a" (
info
));

265 if (
eaxp
)

266 *
eaxp
 = 
eax
;

267 if (
ebxp
)

268 *
ebxp
 = 
ebx
;

269 if (
ecxp
)

270 *
ecxp
 = 
ecx
;

271 if (
edxp
)

272 *
edxp
 = 
edx
;

273 
	}
}

275 static 
__inline
 
uint64_t


276 
	$read_tsc
(void)

278 
uint64_t
 
tsc
;

279 
__asm
 
	`__volatile
("rdtsc" : "=A" (
tsc
));

280 return 
tsc
;

281 
	}
}

283 #define 
	#CPUID_FLAG_SEP
 0x800

	)

284 #define 
	#CPUID_FLAG_PSE
 0x8

	)

287 static 
inline
 
uint32_t


288 
	$cpu_get_features
(void)

290 
uint32_t
 
features
;

291 
	`asm
("movl $1, %%eax\n\t"

294 : "=r"(
features
)

298 return 
features
;

299 
	}
}

303 #define 
	#rdmsr
(
msr
,
val1
,
val2
) \

304 
__asm__
 
	`__volatile__
("rdmsr" \

305 : "=a" (
val1
), "=d" (
val2
) \

306 : "c" (
msr
))

	)

308 #define 
	#wrmsr
(
msr
,
val1
,
val2
) \

309 
__asm__
 
	`__volatile__
("wrmsr" \

311 : "c" (
msr
), "a" (
val1
), "d" (
val2
))

	)

313 #define 
	#SYSENTER_CS
 0x174

	)

314 #define 
	#SYSENTER_ESP
 0x175

	)

315 #define 
	#SYSENTER_EIP
 0x176

	)

317 static 
inline
 
uint32_t


318 
	$xchg
(volatile 
uint32_t
 *
addr
, uint32_t 
newval
)

320 
uint32_t
 
result
;

323 
asm
 volatile("lock; xchgl %0, %1" :

324 "+m" (*
addr
), "=a" (
result
) :

325 "1" (
newval
) :

327 return 
result
;

328 
	}
}

	@/root/Robux/kern/console.c

3 #include 
	~<inc/x86.h
>

4 #include 
	~<inc/memlayout.h
>

5 #include 
	~<inc/kbdreg.h
>

6 #include 
	~<inc/string.h
>

7 #include 
	~<inc/assert.h
>

9 #include 
	~<kern/console.h
>

10 #include 
	~<kern/picirq.h
>

12 static void 
cons_intr
(int (*
proc
)(void));

13 static void 
	`cons_putc
(int 
c
);

17 
	$delay
(void)

19 
	`inb
(0x84);

20 
	`inb
(0x84);

21 
	`inb
(0x84);

22 
	`inb
(0x84);

23 
	}
}

27 #define 
	#COM1
 0x3F8

	)

29 #define 
	#COM_RX
 0

30 #define 
	#COM_TX
 0

31 #define 
	#COM_DLL
 0

32 #define 
	#COM_DLM
 1

33 #define 
	#COM_IER
 1

34 #define 
	#COM_IER_RDI
 0x01

35 #define 
	#COM_IIR
 2

36 #define 
	#COM_FCR
 2

37 #define 
	#COM_LCR
 3

38 #define 
	#COM_LCR_DLAB
 0x80

39 #define 
	#COM_LCR_WLEN8
 0x03

40 #define 
	#COM_MCR
 4

41 #define 
	#COM_MCR_RTS
 0x02

42 #define 
	#COM_MCR_DTR
 0x01

43 #define 
	#COM_MCR_OUT2
 0x08

44 #define 
	#COM_LSR
 5

45 #define 
	#COM_LSR_DATA
 0x01

46 #define 
	#COM_LSR_TXRDY
 0x20

47 #define 
	#COM_LSR_TSRE
 0x40

48 

	)

49 static 
bool
 
	gserial_exists
;

52 
	$serial_proc_data
(void)

54 if (!(
	`inb
(
COM1
+
COM_LSR
) & 
COM_LSR_DATA
))

56 return 
	`inb
(
COM1
+
COM_RX
);

57 
	}
}

60 
	$serial_intr
(void)

62 if (
serial_exists
)

63 
	`cons_intr
(
serial_proc_data
);

64 
	}
}

67 
	$serial_putc
(int 
c
)

69 int 
i
;

71 for (
i
 = 0;

72 !(
	`inb
(
COM1
 + 
COM_LSR
) & 
COM_LSR_TXRDY
) && 
i
 < 12800;

73 
i
++)

74 
	`delay
();

76 
	`outb
(
COM1
 + 
COM_TX
, 
c
);

77 
	}
}

80 
	$serial_init
(void)

83 
	`outb
(
COM1
+
COM_FCR
, 0);

86 
	`outb
(
COM1
+
COM_LCR
, 
COM_LCR_DLAB
);

87 
	`outb
(
COM1
+
COM_DLL
, (
uint8_t
) (115200 / 9600));

88 
	`outb
(
COM1
+
COM_DLM
, 0);

91 
	`outb
(
COM1
+
COM_LCR
, 
COM_LCR_WLEN8
 & ~
COM_LCR_DLAB
);

94 
	`outb
(
COM1
+
COM_MCR
, 0);

96 
	`outb
(
COM1
+
COM_IER
, 
COM_IER_RDI
);

100 
serial_exists
 = (
	`inb
(
COM1
+
COM_LSR
) != 0xFF);

101 (void) 
	`inb
(
COM1
+
COM_IIR
);

102 (void) 
	`inb
(
COM1
+
COM_RX
);

105 if (
serial_exists
)

106 
	`irq_setmask_8259A
(
irq_mask_8259A
 & ~(1<<4));

107 
	}
}

116 
	$lpt_putc
(int 
c
)

118 int 
i
;

120 for (
i
 = 0; !(
	`inb
(0x378+1) & 0x80) && i < 12800; i++)

121 
	`delay
();

122 
	`outb
(0x378+0, 
c
);

123 
	`outb
(0x378+2, 0x08|0x04|0x01);

124 
	`outb
(0x378+2, 0x08);

125 
	}
}

132 static unsigned 
	gaddr_6845
;

133 static 
uint16_t
 *
	gcrt_buf
;

134 static 
uint16_t
 
	gcrt_pos
;

137 
	$cga_init
(void)

139 volatile 
uint16_t
 *
cp
;

140 
uint16_t
 
was
;

141 unsigned 
pos
;

143 
cp
 = (
uint16_t
*) (
KERNBASE
 + 
CGA_BUF
);

144 
was
 = *
cp
;

145 *
cp
 = (
uint16_t
) 0xA55A;

146 if (*
cp
 != 0xA55A) {

147 
cp
 = (
uint16_t
*) (
KERNBASE
 + 
MONO_BUF
);

148 
addr_6845
 = 
MONO_BASE
;

150 *
cp
 = 
was
;

151 
addr_6845
 = 
CGA_BASE
;

155 
	`outb
(
addr_6845
, 14);

156 
pos
 = 
	`inb
(
addr_6845
 + 1) << 8;

157 
	`outb
(
addr_6845
, 15);

158 
pos
 |= 
	`inb
(
addr_6845
 + 1);

160 
crt_buf
 = (
uint16_t
*) 
cp
;

161 
crt_pos
 = 
pos
;

162 
	}
}

167 
	$cga_putc
(int 
c
)

170 if (!(
c
 & ~0xFF))

171 
c
 |= 0x0700;

173 switch (
c
 & 0xff) {

175 if (
crt_pos
 > 0) {

176 
crt_pos
--;

177 
crt_buf
[
crt_pos
] = (
c
 & ~0xff) | ' ';

181 
crt_pos
 += 
CRT_COLS
;

184 
crt_pos
 -= (crt_pos % 
CRT_COLS
);

187 
	`cons_putc
(' ');

188 
	`cons_putc
(' ');

189 
	`cons_putc
(' ');

190 
	`cons_putc
(' ');

191 
	`cons_putc
(' ');

194 
crt_buf
[
crt_pos
++] = 
c
;

205 if (
crt_pos
 >= 
CRT_SIZE
) {

206 int 
i
;

208 
	`memmove
(
crt_buf
, crt_buf + 
CRT_COLS
, (
CRT_SIZE
 - CRT_COLS) * sizeof(
uint16_t
));

209 for (
i
 = 
CRT_SIZE
 - 
CRT_COLS
; i < CRT_SIZE; i++)

210 
crt_buf
[
i
] = 0x0700 | ' ';

211 
crt_pos
 -= 
CRT_COLS
;

215 
	`outb
(
addr_6845
, 14);

216 
	`outb
(
addr_6845
 + 1, 
crt_pos
 >> 8);

217 
	`outb
(
addr_6845
, 15);

218 
	`outb
(
addr_6845
 + 1, 
crt_pos
);

219 
	}
}

224 #define 
	#NO
 0

	)

226 #define 
	#SHIFT
 (1<<0)

	)

227 #define 
	#CTL
 (1<<1)

	)

228 #define 
	#ALT
 (1<<2)

	)

230 #define 
	#CAPSLOCK
 (1<<3)

	)

231 #define 
	#NUMLOCK
 (1<<4)

	)

232 #define 
	#SCROLLLOCK
 (1<<5)

	)

234 #define 
	#E0ESC
 (1<<6)

	)

236 static 
uint8_t
 
	gshiftcode
[256] =

238 [0x1D] = 
CTL
,

239 [0x2A] = 
SHIFT
,

240 [0x36] = 
SHIFT
,

241 [0x38] = 
ALT
,

242 [0x9D] = 
CTL
,

243 [0xB8] = 
ALT


246 static 
uint8_t
 
	gtogglecode
[256] =

248 [0x3A] = 
CAPSLOCK
,

249 [0x45] = 
NUMLOCK
,

250 [0x46] = 
SCROLLLOCK


253 static 
uint8_t
 
	gnormalmap
[256] =

255 
NO
, 0x1B, '1', '2', '3', '4', '5', '6',

258 'o', 'p', '[', ']', '\n', 
NO
, 'a', 's',

260 '\'', '`', 
NO
, '\\', 'z', 'x', 'c', 'v',

261 'b', 'n', 'm', ',', '.', '/', 
NO
, '*',

262 
NO
, ' ', NO, NO, NO, NO, NO, NO,

263 
NO
, NO, NO, NO, NO, NO, NO, '7',

265 '2', '3', '0', '.', 
NO
, NO, NO, NO,

266 [0xC7] = 
KEY_HOME
, [0x9C] = '\n' ,

267 [0xB5] = '/' , [0xC8] = 
KEY_UP
,

268 [0xC9] = 
KEY_PGUP
, [0xCB] = 
KEY_LF
,

269 [0xCD] = 
KEY_RT
, [0xCF] = 
KEY_END
,

270 [0xD0] = 
KEY_DN
, [0xD1] = 
KEY_PGDN
,

271 [0xD2] = 
KEY_INS
, [0xD3] = 
KEY_DEL


274 static 
uint8_t
 
	gshiftmap
[256] =

276 
NO
, 033, '!', '@', '#', '$', '%', '^',

279 'O', 'P', '{', '}', '\n', 
NO
, 'A', 'S',

281 '"', '~', 
NO
, '|', 'Z', 'X', 'C', 'V',

282 'B', 'N', 'M', '<', '>', '?', 
NO
, '*',

283 
NO
, ' ', NO, NO, NO, NO, NO, NO,

284 
NO
, NO, NO, NO, NO, NO, NO, '7',

286 '2', '3', '0', '.', 
NO
, NO, NO, NO,

287 [0xC7] = 
KEY_HOME
, [0x9C] = '\n' ,

288 [0xB5] = '/' , [0xC8] = 
KEY_UP
,

289 [0xC9] = 
KEY_PGUP
, [0xCB] = 
KEY_LF
,

290 [0xCD] = 
KEY_RT
, [0xCF] = 
KEY_END
,

291 [0xD0] = 
KEY_DN
, [0xD1] = 
KEY_PGDN
,

292 [0xD2] = 
KEY_INS
, [0xD3] = 
KEY_DEL


295 #define 
	#C
(
x
) (x - '@')

	)

297 static 
uint8_t
 
	gctlmap
[256] =

299 
NO
, NO, NO, NO, NO, NO, NO, NO,

300 
NO
, NO, NO, NO, NO, NO, NO, NO,

301 
C
('Q'), C('W'), C('E'), C('R'), C('T'), C('Y'), C('U'), C('I'),

302 
C
('O'), C('P'), 
NO
, NO, '\r', NO, C('A'), C('S'),

303 
C
('D'), C('F'), C('G'), C('H'), C('J'), C('K'), C('L'), 
NO
,

304 
NO
, NO, NO, 
C
('\\'), C('Z'), C('X'), C('C'), C('V'),

305 
C
('B'), C('N'), C('M'), 
NO
, NO, C('/'), NO, NO,

306 [0x97] = 
KEY_HOME
,

307 [0xB5] = 
C
('/'), [0xC8] = 
KEY_UP
,

308 [0xC9] = 
KEY_PGUP
, [0xCB] = 
KEY_LF
,

309 [0xCD] = 
KEY_RT
, [0xCF] = 
KEY_END
,

310 [0xD0] = 
KEY_DN
, [0xD1] = 
KEY_PGDN
,

311 [0xD2] = 
KEY_INS
, [0xD3] = 
KEY_DEL


314 static 
uint8_t
 *
	gcharcode
[4] = {

315 
normalmap
,

316 
shiftmap
,

317 
ctlmap
,

318 
ctlmap


326 
	$kbd_proc_data
(void)

328 int 
c
;

329 
uint8_t
 
data
;

330 static 
uint32_t
 
shift
;

332 if ((
	`inb
(
KBSTATP
) & 
KBS_DIB
) == 0)

335 
data
 = 
	`inb
(
KBDATAP
);

337 if (
data
 == 0xE0) {

339 
shift
 |= 
E0ESC
;

341 } else if (
data
 & 0x80) {

343 
data
 = (
shift
 & 
E0ESC
 ? data : data & 0x7F);

344 
shift
 &= ~(
shiftcode
[
data
] | 
E0ESC
);

346 } else if (
shift
 & 
E0ESC
) {

348 
data
 |= 0x80;

349 
shift
 &= ~
E0ESC
;

352 
shift
 |= 
shiftcode
[
data
];

353 
shift
 ^= 
togglecode
[
data
];

355 
c
 = 
charcode
[
shift
 & (
CTL
 | 
SHIFT
)][
data
];

356 if (
shift
 & 
CAPSLOCK
) {

357 if ('a' <= 
c
 && c <= 'z')

358 
c
 += 'A' - 'a';

359 else if ('A' <= 
c
 && c <= 'Z')

360 
c
 += 'a' - 'A';

365 if (!(~
shift
 & (
CTL
 | 
ALT
)) && 
c
 == 
KEY_DEL
) {

366 
	`cprintf
("Rebooting!\n");

367 
	`outb
(0x92, 0x3);

370 return 
c
;

371 
	}
}

374 
	$kbd_intr
(void)

376 
	`cons_intr
(
kbd_proc_data
);

377 
	}
}

380 
	$kbd_init
(void)

383 
	`kbd_intr
();

384 
	`irq_setmask_8259A
(
irq_mask_8259A
 & ~(1<<1));

385 
	}
}

394 #define 
	#CONSBUFSIZE
 512

	)

397 
uint8_t
 
	mbuf
[
CONSBUFSIZE
];

398 
uint32_t
 
	mrpos
;

399 
uint32_t
 
	mwpos
;

400 } 
	gcons
;

405 
cons_intr
(int (*
proc
)(void))

407 int 
c
;

409 while ((
c
 = (*
proc
)()) != -1) {

410 if (
c
 == 0)

413 
cons
.
buf
[cons.
wpos
++] = (
c
 == '\r')?'\n':c;

414 if (
cons
.
wpos
 == 
CONSBUFSIZE
)

415 
cons
.
wpos
 = 0;

417 
	}
}

421 
	$cons_getc
(void)

423 int 
c
;

428 
	`serial_intr
();

429 
	`kbd_intr
();

432 if (
cons
.
rpos
 != cons.
wpos
) {

433 
c
 = 
cons
.
buf
[cons.
rpos
++];

434 if (
cons
.
rpos
 == 
CONSBUFSIZE
)

435 
cons
.
rpos
 = 0;

436 return 
c
;

439 
	}
}

443 
	$cons_putc
(int 
c
)

445 
	`serial_putc
(
c
);

446 
	`lpt_putc
(
c
);

447 
	`cga_putc
(
c
);

448 
	}
}

452 
	$cons_init
(void)

454 
	`cga_init
();

455 
	`kbd_init
();

456 
	`serial_init
();

458 if (!
serial_exists
)

459 
	`cprintf
("Serial port does not exist!\n");

460 
	}
}

466 
	$cputchar
(int 
c
)

468 
	`cons_putc
(
c
);

469 
	}
}

472 
	$getchar
(void)

474 int 
c
;

476 while ((
c
 = 
	`cons_getc
()) == 0)

478 return 
c
;

479 
	}
}

482 
	$iscons
(int 
fdnum
)

486 
	}
}

	@/root/Robux/kern/console.h

3 #ifndef 
_CONSOLE_H_


4 #define 
	#_CONSOLE_H_


	)

5 #ifndef 
JOS_KERNEL


9 #include 
	~<inc/types.h
>

11 #define 
	#MONO_BASE
 0x3B4

	)

12 #define 
	#MONO_BUF
 0xB0000

	)

13 #define 
	#CGA_BASE
 0x3D4

	)

14 #define 
	#CGA_BUF
 0xB8000

	)

16 #define 
	#CRT_ROWS
 25

	)

17 #define 
	#CRT_COLS
 80

	)

18 #define 
	#CRT_SIZE
 (
CRT_ROWS
 * 
CRT_COLS
)

	)

20 void 
cons_init
(void);

21 int 
cons_getc
(void);

23 void 
kbd_intr
(void);

24 void 
serial_intr
(void);

	@/root/Robux/kern/cpu.h

2 #ifndef 
JOS_INC_CPU_H


3 #define 
	#JOS_INC_CPU_H


	)

5 #include 
	~<inc/types.h
>

6 #include 
	~<inc/memlayout.h
>

7 #include 
	~<inc/mmu.h
>

8 #include 
	~<inc/env.h
>

11 #define 
	#NCPU
 8

	)

15 
	mCPU_UNUSED
 = 0,

16 
	mCPU_STARTED
,

20 struct 
	sCpu
 {

21 
uint8_t
 
	mcpu_id
;

22 volatile unsigned 
	mcpu_status
;

23 struct 
Env
 *
	mcpu_env
;

24 struct 
Taskstate
 
	mcpu_ts
;

28 extern struct 
Cpu
 
cpus
[
NCPU
];

29 extern int 
ncpu
;

30 extern struct 
Cpu
 *
bootcpu
;

31 extern volatile 
uint32_t
 *
lapic
;

34 extern unsigned char 
percpu_kstacks
[
NCPU
][
KSTKSIZE
];

36 int 
cpunum
(void);

37 #define 
	#thiscpu
 (&
cpus
[
	`cpunum
()])

	)

39 void 
mp_init
(void);

40 void 
lapic_init
(void);

41 void 
lapic_startap
(
uint8_t
 
apicid
, 
uint32_t
 
addr
);

42 void 
lapic_eoi
(void);

43 void 
lapic_ipi
(int 
vector
);

	@/root/Robux/kern/e1000.c

1 #include 
	~<kern/e1000.h
>

2 #include 
	~<inc/types.h
>

3 #include 
	~<kern/pmap.h
>

4 #include 
	~<inc/error.h
>

5 #include 
	~<inc/string.h
>

12 volatile 
uint32_t
 *
	ge1000
;

14 volatile struct 
tx_desc
 
	gtx_desc_arr
[
E1000_NUM_DESC
] 
__attribute__
 ((
aligned
(4096)));

16 volatile struct 
rx_desc
 
	grx_desc_arr
[
E1000_NUM_DESC
] 
__attribute__
 ((
aligned
(4096)));

18 struct 
Page
 *
	grbufs
[
E1000_NUM_DESC
];

22 
	$e1000_init_tx_desc_arr
(void)

25 
	`memset
((void*)
tx_desc_arr
, 0, sizeof(struct 
tx_desc
)*
E1000_NUM_DESC
);

29 int 
i
;

30 for(
i
=0; i<
E1000_NUM_DESC
; i++)

32 
tx_desc_arr
[
i
].
status
 |= 
TXD_STATUS_DD
;

34 
	}
}

37 
	$e1000_init_rx_desc_arr
(void)

40 
	`memset
((void*)
rx_desc_arr
, 0, sizeof(struct 
rx_desc
)*
E1000_NUM_DESC
);

44 int 
i
;

45 for(
i
=0; i<
E1000_NUM_DESC
; i++)

47 
rbufs
[
i
] = 
	`page_alloc
(
ALLOC_ZERO
);

48 
rbufs
[
i
]->
pp_ref
++;

50 
rx_desc_arr
[
i
].
addr
 = 
	`page2pa
(
rbufs
[i]);

53 
	}
}

70 
	$e1000_send_packet
(void *
addr
, 
uint16_t
 
length
)

72 volatile struct 
tx_desc
 *
tail
 = &
tx_desc_arr
[
e1000
[
	`E1000_INDEX
(
E1000_TDT
)]];

74 if((
uint32_t
)
addr
 / 
PGSIZE
 != ((uint32_t)addr+
length
)/PGSIZE)

75 return -
E_INVAL
;

77 
retry
:

78 if(!(
tail
->
status
 & 
TXD_STATUS_DD
))

79 goto 
retry
;

81 
	`memset
((void*)
tail
, 0, sizeof(struct 
tx_desc
));

83 
tail
->
addr
 = 
	`PADDR
(addr);

84 
tail
->
length
 = length;

85 
tail
->
cmd
 = 
TXD_CMD_RS
 | 
TXD_CMD_EOP
;

87 
e1000
[
	`E1000_INDEX
(
E1000_TDT
)] = (e1000[E1000_INDEX(E1000_TDT)] + 1) % 
E1000_NUM_DESC
;

90 
	}
}

108 
	$e1000_recv_packet
(void *
addr
, 
uint16_t
 *
length
)

110 
uint16_t
 
index
 = (
e1000
[
	`E1000_INDEX
(
E1000_RDT
)]+1) % 
E1000_NUM_DESC
;

111 volatile struct 
rx_desc
 *
next_desc
 = &
rx_desc_arr
[
index
];

113 if(!(
next_desc
->
status
 & 
RXD_STATUS_DD
))

114 return -
E_NET_NOT_RECV
;

116 if(!(
next_desc
->
status
 & 
RXD_STATUS_EOP
))

117 
	`panic
("Received a jumbo frame (we cannot handle jumbo frames)\n");

120 *
length
 = 
next_desc
->length;

121 
	`memmove
(
addr
, 
	`page2kva
(
rbufs
[
index
]), 
next_desc
->
length
);

124 
next_desc
->
status
 = 0;

126 
e1000
[
	`E1000_INDEX
(
E1000_RDT
)] = 
index
;

129 
	}
}

138 
	$e1000_read_mac
(
uint8_t
 
arr
[6])

140 
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] = 
E1000_EERD_ADDR_LOW2
 | 
E1000_EERD_START
;

141 while(!(
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] & 
E1000_EERD_DONE
))

143 
uint16_t
 
dat
 = 
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] >> 
E1000_EERD_DATA_SHIFT
;

144 
arr
[0] = 
dat
 & 0xFF;

145 
arr
[1] = 
dat
 >> 8;

147 
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] = 
E1000_EERD_ADDR_MID2
 | 
E1000_EERD_START
;

148 while(!(
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] & 
E1000_EERD_DONE
))

150 
dat
 = 
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] >> 
E1000_EERD_DATA_SHIFT
;

151 
arr
[2] = 
dat
 & 0xFF;

152 
arr
[3] = 
dat
 >> 8;

154 
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] = 
E1000_EERD_ADDR_HIG2
 | 
E1000_EERD_START
;

155 while(!(
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] & 
E1000_EERD_DONE
))

157 
dat
 = 
e1000
[
	`E1000_INDEX
(
E1000_EERD
)] >> 
E1000_EERD_DATA_SHIFT
;

158 
arr
[4] = 
dat
 & 0xFF;

159 
arr
[5] = 
dat
 >> 8;

160 
	}
}

	@/root/Robux/kern/e1000.h

1 #ifndef 
JOS_KERN_E1000_H


2 #define 
	#JOS_KERN_E1000_H


	)

4 #include 
	~<inc/types.h
>

7 #define 
	#E1000_VENDOR_ID
 0x8086

	)

8 #define 
	#E1000_DEVICE_ID
 0x100E

	)

11 #define 
	#E1000_INDEX
(
num
) (num / sizeof(
uint32_t
))

	)

28 #define 
	#E1000_CTRL
 0x00000

	)

29 #define 
	#E1000_CTRL_DUP
 0x00004

	)

30 #define 
	#E1000_STATUS
 0x00008

	)

31 #define 
	#E1000_EECD
 0x00010

	)

32 #define 
	#E1000_EERD
 0x00014

	)

33 #define 
	#E1000_CTRL_EXT
 0x00018

	)

34 #define 
	#E1000_FLA
 0x0001C

	)

35 #define 
	#E1000_MDIC
 0x00020

	)

36 #define 
	#E1000_SCTL
 0x00024

	)

37 #define 
	#E1000_FEXTNVM
 0x00028

	)

38 #define 
	#E1000_FCAL
 0x00028

	)

39 #define 
	#E1000_FCAH
 0x0002C

	)

40 #define 
	#E1000_FCT
 0x00030

	)

41 #define 
	#E1000_VET
 0x00038

	)

42 #define 
	#E1000_ICR
 0x000C0

	)

43 #define 
	#E1000_ITR
 0x000C4

	)

44 #define 
	#E1000_ICS
 0x000C8

	)

45 #define 
	#E1000_IMS
 0x000D0

	)

46 #define 
	#E1000_IMC
 0x000D8

	)

47 #define 
	#E1000_IAM
 0x000E0

	)

48 #define 
	#E1000_RCTL
 0x00100

	)

49 #define 
	#E1000_RDTR1
 0x02820

	)

50 #define 
	#E1000_RDBAL1
 0x02900

	)

51 #define 
	#E1000_RDBAH1
 0x02904

	)

52 #define 
	#E1000_RDLEN1
 0x02908

	)

53 #define 
	#E1000_RDH1
 0x02910

	)

54 #define 
	#E1000_RDT1
 0x02918

	)

55 #define 
	#E1000_FCTTV
 0x00170

	)

56 #define 
	#E1000_TXCW
 0x00178

	)

57 #define 
	#E1000_RXCW
 0x00180

	)

58 #define 
	#E1000_TCTL
 0x00400

	)

59 #define 
	#E1000_TCTL_EXT
 0x00404

	)

60 #define 
	#E1000_TIPG
 0x00410

	)

61 #define 
	#E1000_TBT
 0x00448

	)

62 #define 
	#E1000_AIT
 0x00458

	)

64 #define 
	#E1000_RDBAL
 0x02800

	)

65 #define 
	#E1000_RDBAH
 0x02804

	)

66 #define 
	#E1000_RDLEN
 0x02808

	)

67 #define 
	#E1000_RDH
 0x02810

	)

68 #define 
	#E1000_RDT
 0x02818

	)

69 #define 
	#E1000_RDTR
 0x02820

	)

70 #define 
	#E1000_RDBAL0
 
E1000_RDBAL


	)

71 #define 
	#E1000_RDBAH0
 
E1000_RDBAH


	)

72 #define 
	#E1000_RDLEN0
 
E1000_RDLEN


	)

73 #define 
	#E1000_RDH0
 
E1000_RDH


	)

74 #define 
	#E1000_RDT0
 
E1000_RDT


	)

75 #define 
	#E1000_RDTR0
 
E1000_RDTR


	)

76 #define 
	#E1000_RXDCTL
 0x02828

	)

79 #define 
	#E1000_TDBAL
 0x03800

	)

80 #define 
	#E1000_TDBAH
 0x03804

	)

81 #define 
	#E1000_TDLEN
 0x03808

	)

82 #define 
	#E1000_TDH
 0x03810

	)

83 #define 
	#E1000_TDT
 0x03818

	)

85 #define 
	#E1000_EERD_ADDR_LOW2
 (0x00 << 8)

	)

86 #define 
	#E1000_EERD_ADDR_MID2
 (0x01 << 8)

	)

87 #define 
	#E1000_EERD_ADDR_HIG2
 (0x02 << 8)

	)

88 #define 
	#E1000_EERD_START
 (0x1)

	)

89 #define 
	#E1000_EERD_DONE
 (1 << 4)

	)

90 #define 
	#E1000_EERD_DATA_SHIFT
 16

	)

92 #define 
	#E1000_RAH_AV
 0x80000000

	)

93 #define 
	#E1000_RAH
 0x05404

	)

94 #define 
	#E1000_RAL
 0x05400

	)

96 #define 
	#E1000_RCTL_EN_FLAG
 0x02

	)

97 #define 
	#E1000_RCTL_BSIZE_256
 (0x11 << 16)

	)

98 #define 
	#E1000_RCTL_BSEX
 (0x1 << 25)

	)

99 #define 
	#E1000_RCTL_SECRC
 (0x1 << 26)

	)

102 #define 
	#E1000_TCTL_EN_FLAG
 0x02

	)

103 #define 
	#E1000_TCTL_PSP_FLAG
 0x08

	)

104 #define 
	#E1000_TCTL_CT_DEFAULT
 (0x10 << 4)

	)

105 #define 
	#E1000_TCTL_COLD_FULLD
 ((0x40) << 12)

	)

106 #define 
	#E1000_TCTL_COLD_HALFD
 ((0x200) << 12)

	)

108 #define 
	#E1000_TIPG_IEEE8023_DEFAULT
 ((0x10) | (0x8 << 10) | (0x6 << 20))

	)

112 struct 
	stx_desc


114 
uint64_t
 
	maddr
;

115 
uint16_t
 
	mlength
;

116 
uint8_t
 
	mcso
;

117 
uint8_t
 
	mcmd
;

118 
uint8_t
 
	mstatus
;

119 
uint8_t
 
	mcss
;

120 
uint16_t
 
	mspecial
;

123 struct 
	srx_desc


125 
uint64_t
 
	maddr
;

126 
uint16_t
 
	mlength
;

127 
uint16_t
 
	mchecksum
;

128 
uint8_t
 
	mstatus
;

129 
uint8_t
 
	merrors
;

130 
uint16_t
 
	mspecial
;

133 #define 
	#TXD_CMD_RS
 0x8

	)

134 #define 
	#TXD_CMD_EOP
 0x1

	)

135 #define 
	#TXD_STATUS_DD
 0x1

	)

137 #define 
	#RXD_STATUS_DD
 0x1

	)

138 #define 
	#RXD_STATUS_EOP
 0x2

	)

140 #define 
	#E1000_NUM_DESC
 32

	)

142 extern volatile struct 
tx_desc
 
tx_desc_arr
[];

144 extern volatile struct 
rx_desc
 
rx_desc_arr
[];

148 void 
e1000_init_tx_desc_arr
();

149 void 
e1000_init_rx_desc_arr
();

151 int 
e1000_send_packet
(void *
addr
, 
uint16_t
 
length
);

152 int 
e1000_recv_packet
(void *
addr
, 
uint16_t
 *
length
);

155 void 
e1000_read_mac
(
uint8_t
 
arr
[6]);

	@/root/Robux/kern/entrypgdir.c

1 #include 
	~<inc/mmu.h
>

2 #include 
	~<inc/memlayout.h
>

4 
pte_t
 
	gentry_pgtable
[
NPTENTRIES
];

20 
__attribute__
((
	$__aligned__
(
PGSIZE
)))

21 
pde_t
 
entry_pgdir
[
NPDENTRIES
] = {

24 = ((
uintptr_t
)
entry_pgtable
 - 
KERNBASE
) + 
PTE_P
,

26 [
KERNBASE
>>
PDXSHIFT
]

27 = ((
uintptr_t
)
entry_pgtable
 - 
KERNBASE
) + 
PTE_P
 + 
PTE_W


28 
	}
};

32 
__attribute__
((
	$__aligned__
(
PGSIZE
)))

33 
pte_t
 
entry_pgtable
[
NPTENTRIES
] = {

34 0x000000 | 
PTE_P
 | 
PTE_W
,

35 0x001000 | 
PTE_P
 | 
PTE_W
,

36 0x002000 | 
PTE_P
 | 
PTE_W
,

37 0x003000 | 
PTE_P
 | 
PTE_W
,

38 0x004000 | 
PTE_P
 | 
PTE_W
,

39 0x005000 | 
PTE_P
 | 
PTE_W
,

40 0x006000 | 
PTE_P
 | 
PTE_W
,

41 0x007000 | 
PTE_P
 | 
PTE_W
,

42 0x008000 | 
PTE_P
 | 
PTE_W
,

43 0x009000 | 
PTE_P
 | 
PTE_W
,

44 0x00a000 | 
PTE_P
 | 
PTE_W
,

45 0x00b000 | 
PTE_P
 | 
PTE_W
,

46 0x00c000 | 
PTE_P
 | 
PTE_W
,

47 0x00d000 | 
PTE_P
 | 
PTE_W
,

48 0x00e000 | 
PTE_P
 | 
PTE_W
,

49 0x00f000 | 
PTE_P
 | 
PTE_W
,

50 0x010000 | 
PTE_P
 | 
PTE_W
,

51 0x011000 | 
PTE_P
 | 
PTE_W
,

52 0x012000 | 
PTE_P
 | 
PTE_W
,

53 0x013000 | 
PTE_P
 | 
PTE_W
,

54 0x014000 | 
PTE_P
 | 
PTE_W
,

55 0x015000 | 
PTE_P
 | 
PTE_W
,

56 0x016000 | 
PTE_P
 | 
PTE_W
,

57 0x017000 | 
PTE_P
 | 
PTE_W
,

58 0x018000 | 
PTE_P
 | 
PTE_W
,

59 0x019000 | 
PTE_P
 | 
PTE_W
,

60 0x01a000 | 
PTE_P
 | 
PTE_W
,

61 0x01b000 | 
PTE_P
 | 
PTE_W
,

62 0x01c000 | 
PTE_P
 | 
PTE_W
,

63 0x01d000 | 
PTE_P
 | 
PTE_W
,

64 0x01e000 | 
PTE_P
 | 
PTE_W
,

65 0x01f000 | 
PTE_P
 | 
PTE_W
,

66 0x020000 | 
PTE_P
 | 
PTE_W
,

67 0x021000 | 
PTE_P
 | 
PTE_W
,

68 0x022000 | 
PTE_P
 | 
PTE_W
,

69 0x023000 | 
PTE_P
 | 
PTE_W
,

70 0x024000 | 
PTE_P
 | 
PTE_W
,

71 0x025000 | 
PTE_P
 | 
PTE_W
,

72 0x026000 | 
PTE_P
 | 
PTE_W
,

73 0x027000 | 
PTE_P
 | 
PTE_W
,

74 0x028000 | 
PTE_P
 | 
PTE_W
,

75 0x029000 | 
PTE_P
 | 
PTE_W
,

76 0x02a000 | 
PTE_P
 | 
PTE_W
,

77 0x02b000 | 
PTE_P
 | 
PTE_W
,

78 0x02c000 | 
PTE_P
 | 
PTE_W
,

79 0x02d000 | 
PTE_P
 | 
PTE_W
,

80 0x02e000 | 
PTE_P
 | 
PTE_W
,

81 0x02f000 | 
PTE_P
 | 
PTE_W
,

82 0x030000 | 
PTE_P
 | 
PTE_W
,

83 0x031000 | 
PTE_P
 | 
PTE_W
,

84 0x032000 | 
PTE_P
 | 
PTE_W
,

85 0x033000 | 
PTE_P
 | 
PTE_W
,

86 0x034000 | 
PTE_P
 | 
PTE_W
,

87 0x035000 | 
PTE_P
 | 
PTE_W
,

88 0x036000 | 
PTE_P
 | 
PTE_W
,

89 0x037000 | 
PTE_P
 | 
PTE_W
,

90 0x038000 | 
PTE_P
 | 
PTE_W
,

91 0x039000 | 
PTE_P
 | 
PTE_W
,

92 0x03a000 | 
PTE_P
 | 
PTE_W
,

93 0x03b000 | 
PTE_P
 | 
PTE_W
,

94 0x03c000 | 
PTE_P
 | 
PTE_W
,

95 0x03d000 | 
PTE_P
 | 
PTE_W
,

96 0x03e000 | 
PTE_P
 | 
PTE_W
,

97 0x03f000 | 
PTE_P
 | 
PTE_W
,

98 0x040000 | 
PTE_P
 | 
PTE_W
,

99 0x041000 | 
PTE_P
 | 
PTE_W
,

100 0x042000 | 
PTE_P
 | 
PTE_W
,

101 0x043000 | 
PTE_P
 | 
PTE_W
,

102 0x044000 | 
PTE_P
 | 
PTE_W
,

103 0x045000 | 
PTE_P
 | 
PTE_W
,

104 0x046000 | 
PTE_P
 | 
PTE_W
,

105 0x047000 | 
PTE_P
 | 
PTE_W
,

106 0x048000 | 
PTE_P
 | 
PTE_W
,

107 0x049000 | 
PTE_P
 | 
PTE_W
,

108 0x04a000 | 
PTE_P
 | 
PTE_W
,

109 0x04b000 | 
PTE_P
 | 
PTE_W
,

110 0x04c000 | 
PTE_P
 | 
PTE_W
,

111 0x04d000 | 
PTE_P
 | 
PTE_W
,

112 0x04e000 | 
PTE_P
 | 
PTE_W
,

113 0x04f000 | 
PTE_P
 | 
PTE_W
,

114 0x050000 | 
PTE_P
 | 
PTE_W
,

115 0x051000 | 
PTE_P
 | 
PTE_W
,

116 0x052000 | 
PTE_P
 | 
PTE_W
,

117 0x053000 | 
PTE_P
 | 
PTE_W
,

118 0x054000 | 
PTE_P
 | 
PTE_W
,

119 0x055000 | 
PTE_P
 | 
PTE_W
,

120 0x056000 | 
PTE_P
 | 
PTE_W
,

121 0x057000 | 
PTE_P
 | 
PTE_W
,

122 0x058000 | 
PTE_P
 | 
PTE_W
,

123 0x059000 | 
PTE_P
 | 
PTE_W
,

124 0x05a000 | 
PTE_P
 | 
PTE_W
,

125 0x05b000 | 
PTE_P
 | 
PTE_W
,

126 0x05c000 | 
PTE_P
 | 
PTE_W
,

127 0x05d000 | 
PTE_P
 | 
PTE_W
,

128 0x05e000 | 
PTE_P
 | 
PTE_W
,

129 0x05f000 | 
PTE_P
 | 
PTE_W
,

130 0x060000 | 
PTE_P
 | 
PTE_W
,

131 0x061000 | 
PTE_P
 | 
PTE_W
,

132 0x062000 | 
PTE_P
 | 
PTE_W
,

133 0x063000 | 
PTE_P
 | 
PTE_W
,

134 0x064000 | 
PTE_P
 | 
PTE_W
,

135 0x065000 | 
PTE_P
 | 
PTE_W
,

136 0x066000 | 
PTE_P
 | 
PTE_W
,

137 0x067000 | 
PTE_P
 | 
PTE_W
,

138 0x068000 | 
PTE_P
 | 
PTE_W
,

139 0x069000 | 
PTE_P
 | 
PTE_W
,

140 0x06a000 | 
PTE_P
 | 
PTE_W
,

141 0x06b000 | 
PTE_P
 | 
PTE_W
,

142 0x06c000 | 
PTE_P
 | 
PTE_W
,

143 0x06d000 | 
PTE_P
 | 
PTE_W
,

144 0x06e000 | 
PTE_P
 | 
PTE_W
,

145 0x06f000 | 
PTE_P
 | 
PTE_W
,

146 0x070000 | 
PTE_P
 | 
PTE_W
,

147 0x071000 | 
PTE_P
 | 
PTE_W
,

148 0x072000 | 
PTE_P
 | 
PTE_W
,

149 0x073000 | 
PTE_P
 | 
PTE_W
,

150 0x074000 | 
PTE_P
 | 
PTE_W
,

151 0x075000 | 
PTE_P
 | 
PTE_W
,

152 0x076000 | 
PTE_P
 | 
PTE_W
,

153 0x077000 | 
PTE_P
 | 
PTE_W
,

154 0x078000 | 
PTE_P
 | 
PTE_W
,

155 0x079000 | 
PTE_P
 | 
PTE_W
,

156 0x07a000 | 
PTE_P
 | 
PTE_W
,

157 0x07b000 | 
PTE_P
 | 
PTE_W
,

158 0x07c000 | 
PTE_P
 | 
PTE_W
,

159 0x07d000 | 
PTE_P
 | 
PTE_W
,

160 0x07e000 | 
PTE_P
 | 
PTE_W
,

161 0x07f000 | 
PTE_P
 | 
PTE_W
,

162 0x080000 | 
PTE_P
 | 
PTE_W
,

163 0x081000 | 
PTE_P
 | 
PTE_W
,

164 0x082000 | 
PTE_P
 | 
PTE_W
,

165 0x083000 | 
PTE_P
 | 
PTE_W
,

166 0x084000 | 
PTE_P
 | 
PTE_W
,

167 0x085000 | 
PTE_P
 | 
PTE_W
,

168 0x086000 | 
PTE_P
 | 
PTE_W
,

169 0x087000 | 
PTE_P
 | 
PTE_W
,

170 0x088000 | 
PTE_P
 | 
PTE_W
,

171 0x089000 | 
PTE_P
 | 
PTE_W
,

172 0x08a000 | 
PTE_P
 | 
PTE_W
,

173 0x08b000 | 
PTE_P
 | 
PTE_W
,

174 0x08c000 | 
PTE_P
 | 
PTE_W
,

175 0x08d000 | 
PTE_P
 | 
PTE_W
,

176 0x08e000 | 
PTE_P
 | 
PTE_W
,

177 0x08f000 | 
PTE_P
 | 
PTE_W
,

178 0x090000 | 
PTE_P
 | 
PTE_W
,

179 0x091000 | 
PTE_P
 | 
PTE_W
,

180 0x092000 | 
PTE_P
 | 
PTE_W
,

181 0x093000 | 
PTE_P
 | 
PTE_W
,

182 0x094000 | 
PTE_P
 | 
PTE_W
,

183 0x095000 | 
PTE_P
 | 
PTE_W
,

184 0x096000 | 
PTE_P
 | 
PTE_W
,

185 0x097000 | 
PTE_P
 | 
PTE_W
,

186 0x098000 | 
PTE_P
 | 
PTE_W
,

187 0x099000 | 
PTE_P
 | 
PTE_W
,

188 0x09a000 | 
PTE_P
 | 
PTE_W
,

189 0x09b000 | 
PTE_P
 | 
PTE_W
,

190 0x09c000 | 
PTE_P
 | 
PTE_W
,

191 0x09d000 | 
PTE_P
 | 
PTE_W
,

192 0x09e000 | 
PTE_P
 | 
PTE_W
,

193 0x09f000 | 
PTE_P
 | 
PTE_W
,

194 0x0a0000 | 
PTE_P
 | 
PTE_W
,

195 0x0a1000 | 
PTE_P
 | 
PTE_W
,

196 0x0a2000 | 
PTE_P
 | 
PTE_W
,

197 0x0a3000 | 
PTE_P
 | 
PTE_W
,

198 0x0a4000 | 
PTE_P
 | 
PTE_W
,

199 0x0a5000 | 
PTE_P
 | 
PTE_W
,

200 0x0a6000 | 
PTE_P
 | 
PTE_W
,

201 0x0a7000 | 
PTE_P
 | 
PTE_W
,

202 0x0a8000 | 
PTE_P
 | 
PTE_W
,

203 0x0a9000 | 
PTE_P
 | 
PTE_W
,

204 0x0aa000 | 
PTE_P
 | 
PTE_W
,

205 0x0ab000 | 
PTE_P
 | 
PTE_W
,

206 0x0ac000 | 
PTE_P
 | 
PTE_W
,

207 0x0ad000 | 
PTE_P
 | 
PTE_W
,

208 0x0ae000 | 
PTE_P
 | 
PTE_W
,

209 0x0af000 | 
PTE_P
 | 
PTE_W
,

210 0x0b0000 | 
PTE_P
 | 
PTE_W
,

211 0x0b1000 | 
PTE_P
 | 
PTE_W
,

212 0x0b2000 | 
PTE_P
 | 
PTE_W
,

213 0x0b3000 | 
PTE_P
 | 
PTE_W
,

214 0x0b4000 | 
PTE_P
 | 
PTE_W
,

215 0x0b5000 | 
PTE_P
 | 
PTE_W
,

216 0x0b6000 | 
PTE_P
 | 
PTE_W
,

217 0x0b7000 | 
PTE_P
 | 
PTE_W
,

218 0x0b8000 | 
PTE_P
 | 
PTE_W
,

219 0x0b9000 | 
PTE_P
 | 
PTE_W
,

220 0x0ba000 | 
PTE_P
 | 
PTE_W
,

221 0x0bb000 | 
PTE_P
 | 
PTE_W
,

222 0x0bc000 | 
PTE_P
 | 
PTE_W
,

223 0x0bd000 | 
PTE_P
 | 
PTE_W
,

224 0x0be000 | 
PTE_P
 | 
PTE_W
,

225 0x0bf000 | 
PTE_P
 | 
PTE_W
,

226 0x0c0000 | 
PTE_P
 | 
PTE_W
,

227 0x0c1000 | 
PTE_P
 | 
PTE_W
,

228 0x0c2000 | 
PTE_P
 | 
PTE_W
,

229 0x0c3000 | 
PTE_P
 | 
PTE_W
,

230 0x0c4000 | 
PTE_P
 | 
PTE_W
,

231 0x0c5000 | 
PTE_P
 | 
PTE_W
,

232 0x0c6000 | 
PTE_P
 | 
PTE_W
,

233 0x0c7000 | 
PTE_P
 | 
PTE_W
,

234 0x0c8000 | 
PTE_P
 | 
PTE_W
,

235 0x0c9000 | 
PTE_P
 | 
PTE_W
,

236 0x0ca000 | 
PTE_P
 | 
PTE_W
,

237 0x0cb000 | 
PTE_P
 | 
PTE_W
,

238 0x0cc000 | 
PTE_P
 | 
PTE_W
,

239 0x0cd000 | 
PTE_P
 | 
PTE_W
,

240 0x0ce000 | 
PTE_P
 | 
PTE_W
,

241 0x0cf000 | 
PTE_P
 | 
PTE_W
,

242 0x0d0000 | 
PTE_P
 | 
PTE_W
,

243 0x0d1000 | 
PTE_P
 | 
PTE_W
,

244 0x0d2000 | 
PTE_P
 | 
PTE_W
,

245 0x0d3000 | 
PTE_P
 | 
PTE_W
,

246 0x0d4000 | 
PTE_P
 | 
PTE_W
,

247 0x0d5000 | 
PTE_P
 | 
PTE_W
,

248 0x0d6000 | 
PTE_P
 | 
PTE_W
,

249 0x0d7000 | 
PTE_P
 | 
PTE_W
,

250 0x0d8000 | 
PTE_P
 | 
PTE_W
,

251 0x0d9000 | 
PTE_P
 | 
PTE_W
,

252 0x0da000 | 
PTE_P
 | 
PTE_W
,

253 0x0db000 | 
PTE_P
 | 
PTE_W
,

254 0x0dc000 | 
PTE_P
 | 
PTE_W
,

255 0x0dd000 | 
PTE_P
 | 
PTE_W
,

256 0x0de000 | 
PTE_P
 | 
PTE_W
,

257 0x0df000 | 
PTE_P
 | 
PTE_W
,

258 0x0e0000 | 
PTE_P
 | 
PTE_W
,

259 0x0e1000 | 
PTE_P
 | 
PTE_W
,

260 0x0e2000 | 
PTE_P
 | 
PTE_W
,

261 0x0e3000 | 
PTE_P
 | 
PTE_W
,

262 0x0e4000 | 
PTE_P
 | 
PTE_W
,

263 0x0e5000 | 
PTE_P
 | 
PTE_W
,

264 0x0e6000 | 
PTE_P
 | 
PTE_W
,

265 0x0e7000 | 
PTE_P
 | 
PTE_W
,

266 0x0e8000 | 
PTE_P
 | 
PTE_W
,

267 0x0e9000 | 
PTE_P
 | 
PTE_W
,

268 0x0ea000 | 
PTE_P
 | 
PTE_W
,

269 0x0eb000 | 
PTE_P
 | 
PTE_W
,

270 0x0ec000 | 
PTE_P
 | 
PTE_W
,

271 0x0ed000 | 
PTE_P
 | 
PTE_W
,

272 0x0ee000 | 
PTE_P
 | 
PTE_W
,

273 0x0ef000 | 
PTE_P
 | 
PTE_W
,

274 0x0f0000 | 
PTE_P
 | 
PTE_W
,

275 0x0f1000 | 
PTE_P
 | 
PTE_W
,

276 0x0f2000 | 
PTE_P
 | 
PTE_W
,

277 0x0f3000 | 
PTE_P
 | 
PTE_W
,

278 0x0f4000 | 
PTE_P
 | 
PTE_W
,

279 0x0f5000 | 
PTE_P
 | 
PTE_W
,

280 0x0f6000 | 
PTE_P
 | 
PTE_W
,

281 0x0f7000 | 
PTE_P
 | 
PTE_W
,

282 0x0f8000 | 
PTE_P
 | 
PTE_W
,

283 0x0f9000 | 
PTE_P
 | 
PTE_W
,

284 0x0fa000 | 
PTE_P
 | 
PTE_W
,

285 0x0fb000 | 
PTE_P
 | 
PTE_W
,

286 0x0fc000 | 
PTE_P
 | 
PTE_W
,

287 0x0fd000 | 
PTE_P
 | 
PTE_W
,

288 0x0fe000 | 
PTE_P
 | 
PTE_W
,

289 0x0ff000 | 
PTE_P
 | 
PTE_W
,

290 0x100000 | 
PTE_P
 | 
PTE_W
,

291 0x101000 | 
PTE_P
 | 
PTE_W
,

292 0x102000 | 
PTE_P
 | 
PTE_W
,

293 0x103000 | 
PTE_P
 | 
PTE_W
,

294 0x104000 | 
PTE_P
 | 
PTE_W
,

295 0x105000 | 
PTE_P
 | 
PTE_W
,

296 0x106000 | 
PTE_P
 | 
PTE_W
,

297 0x107000 | 
PTE_P
 | 
PTE_W
,

298 0x108000 | 
PTE_P
 | 
PTE_W
,

299 0x109000 | 
PTE_P
 | 
PTE_W
,

300 0x10a000 | 
PTE_P
 | 
PTE_W
,

301 0x10b000 | 
PTE_P
 | 
PTE_W
,

302 0x10c000 | 
PTE_P
 | 
PTE_W
,

303 0x10d000 | 
PTE_P
 | 
PTE_W
,

304 0x10e000 | 
PTE_P
 | 
PTE_W
,

305 0x10f000 | 
PTE_P
 | 
PTE_W
,

306 0x110000 | 
PTE_P
 | 
PTE_W
,

307 0x111000 | 
PTE_P
 | 
PTE_W
,

308 0x112000 | 
PTE_P
 | 
PTE_W
,

309 0x113000 | 
PTE_P
 | 
PTE_W
,

310 0x114000 | 
PTE_P
 | 
PTE_W
,

311 0x115000 | 
PTE_P
 | 
PTE_W
,

312 0x116000 | 
PTE_P
 | 
PTE_W
,

313 0x117000 | 
PTE_P
 | 
PTE_W
,

314 0x118000 | 
PTE_P
 | 
PTE_W
,

315 0x119000 | 
PTE_P
 | 
PTE_W
,

316 0x11a000 | 
PTE_P
 | 
PTE_W
,

317 0x11b000 | 
PTE_P
 | 
PTE_W
,

318 0x11c000 | 
PTE_P
 | 
PTE_W
,

319 0x11d000 | 
PTE_P
 | 
PTE_W
,

320 0x11e000 | 
PTE_P
 | 
PTE_W
,

321 0x11f000 | 
PTE_P
 | 
PTE_W
,

322 0x120000 | 
PTE_P
 | 
PTE_W
,

323 0x121000 | 
PTE_P
 | 
PTE_W
,

324 0x122000 | 
PTE_P
 | 
PTE_W
,

325 0x123000 | 
PTE_P
 | 
PTE_W
,

326 0x124000 | 
PTE_P
 | 
PTE_W
,

327 0x125000 | 
PTE_P
 | 
PTE_W
,

328 0x126000 | 
PTE_P
 | 
PTE_W
,

329 0x127000 | 
PTE_P
 | 
PTE_W
,

330 0x128000 | 
PTE_P
 | 
PTE_W
,

331 0x129000 | 
PTE_P
 | 
PTE_W
,

332 0x12a000 | 
PTE_P
 | 
PTE_W
,

333 0x12b000 | 
PTE_P
 | 
PTE_W
,

334 0x12c000 | 
PTE_P
 | 
PTE_W
,

335 0x12d000 | 
PTE_P
 | 
PTE_W
,

336 0x12e000 | 
PTE_P
 | 
PTE_W
,

337 0x12f000 | 
PTE_P
 | 
PTE_W
,

338 0x130000 | 
PTE_P
 | 
PTE_W
,

339 0x131000 | 
PTE_P
 | 
PTE_W
,

340 0x132000 | 
PTE_P
 | 
PTE_W
,

341 0x133000 | 
PTE_P
 | 
PTE_W
,

342 0x134000 | 
PTE_P
 | 
PTE_W
,

343 0x135000 | 
PTE_P
 | 
PTE_W
,

344 0x136000 | 
PTE_P
 | 
PTE_W
,

345 0x137000 | 
PTE_P
 | 
PTE_W
,

346 0x138000 | 
PTE_P
 | 
PTE_W
,

347 0x139000 | 
PTE_P
 | 
PTE_W
,

348 0x13a000 | 
PTE_P
 | 
PTE_W
,

349 0x13b000 | 
PTE_P
 | 
PTE_W
,

350 0x13c000 | 
PTE_P
 | 
PTE_W
,

351 0x13d000 | 
PTE_P
 | 
PTE_W
,

352 0x13e000 | 
PTE_P
 | 
PTE_W
,

353 0x13f000 | 
PTE_P
 | 
PTE_W
,

354 0x140000 | 
PTE_P
 | 
PTE_W
,

355 0x141000 | 
PTE_P
 | 
PTE_W
,

356 0x142000 | 
PTE_P
 | 
PTE_W
,

357 0x143000 | 
PTE_P
 | 
PTE_W
,

358 0x144000 | 
PTE_P
 | 
PTE_W
,

359 0x145000 | 
PTE_P
 | 
PTE_W
,

360 0x146000 | 
PTE_P
 | 
PTE_W
,

361 0x147000 | 
PTE_P
 | 
PTE_W
,

362 0x148000 | 
PTE_P
 | 
PTE_W
,

363 0x149000 | 
PTE_P
 | 
PTE_W
,

364 0x14a000 | 
PTE_P
 | 
PTE_W
,

365 0x14b000 | 
PTE_P
 | 
PTE_W
,

366 0x14c000 | 
PTE_P
 | 
PTE_W
,

367 0x14d000 | 
PTE_P
 | 
PTE_W
,

368 0x14e000 | 
PTE_P
 | 
PTE_W
,

369 0x14f000 | 
PTE_P
 | 
PTE_W
,

370 0x150000 | 
PTE_P
 | 
PTE_W
,

371 0x151000 | 
PTE_P
 | 
PTE_W
,

372 0x152000 | 
PTE_P
 | 
PTE_W
,

373 0x153000 | 
PTE_P
 | 
PTE_W
,

374 0x154000 | 
PTE_P
 | 
PTE_W
,

375 0x155000 | 
PTE_P
 | 
PTE_W
,

376 0x156000 | 
PTE_P
 | 
PTE_W
,

377 0x157000 | 
PTE_P
 | 
PTE_W
,

378 0x158000 | 
PTE_P
 | 
PTE_W
,

379 0x159000 | 
PTE_P
 | 
PTE_W
,

380 0x15a000 | 
PTE_P
 | 
PTE_W
,

381 0x15b000 | 
PTE_P
 | 
PTE_W
,

382 0x15c000 | 
PTE_P
 | 
PTE_W
,

383 0x15d000 | 
PTE_P
 | 
PTE_W
,

384 0x15e000 | 
PTE_P
 | 
PTE_W
,

385 0x15f000 | 
PTE_P
 | 
PTE_W
,

386 0x160000 | 
PTE_P
 | 
PTE_W
,

387 0x161000 | 
PTE_P
 | 
PTE_W
,

388 0x162000 | 
PTE_P
 | 
PTE_W
,

389 0x163000 | 
PTE_P
 | 
PTE_W
,

390 0x164000 | 
PTE_P
 | 
PTE_W
,

391 0x165000 | 
PTE_P
 | 
PTE_W
,

392 0x166000 | 
PTE_P
 | 
PTE_W
,

393 0x167000 | 
PTE_P
 | 
PTE_W
,

394 0x168000 | 
PTE_P
 | 
PTE_W
,

395 0x169000 | 
PTE_P
 | 
PTE_W
,

396 0x16a000 | 
PTE_P
 | 
PTE_W
,

397 0x16b000 | 
PTE_P
 | 
PTE_W
,

398 0x16c000 | 
PTE_P
 | 
PTE_W
,

399 0x16d000 | 
PTE_P
 | 
PTE_W
,

400 0x16e000 | 
PTE_P
 | 
PTE_W
,

401 0x16f000 | 
PTE_P
 | 
PTE_W
,

402 0x170000 | 
PTE_P
 | 
PTE_W
,

403 0x171000 | 
PTE_P
 | 
PTE_W
,

404 0x172000 | 
PTE_P
 | 
PTE_W
,

405 0x173000 | 
PTE_P
 | 
PTE_W
,

406 0x174000 | 
PTE_P
 | 
PTE_W
,

407 0x175000 | 
PTE_P
 | 
PTE_W
,

408 0x176000 | 
PTE_P
 | 
PTE_W
,

409 0x177000 | 
PTE_P
 | 
PTE_W
,

410 0x178000 | 
PTE_P
 | 
PTE_W
,

411 0x179000 | 
PTE_P
 | 
PTE_W
,

412 0x17a000 | 
PTE_P
 | 
PTE_W
,

413 0x17b000 | 
PTE_P
 | 
PTE_W
,

414 0x17c000 | 
PTE_P
 | 
PTE_W
,

415 0x17d000 | 
PTE_P
 | 
PTE_W
,

416 0x17e000 | 
PTE_P
 | 
PTE_W
,

417 0x17f000 | 
PTE_P
 | 
PTE_W
,

418 0x180000 | 
PTE_P
 | 
PTE_W
,

419 0x181000 | 
PTE_P
 | 
PTE_W
,

420 0x182000 | 
PTE_P
 | 
PTE_W
,

421 0x183000 | 
PTE_P
 | 
PTE_W
,

422 0x184000 | 
PTE_P
 | 
PTE_W
,

423 0x185000 | 
PTE_P
 | 
PTE_W
,

424 0x186000 | 
PTE_P
 | 
PTE_W
,

425 0x187000 | 
PTE_P
 | 
PTE_W
,

426 0x188000 | 
PTE_P
 | 
PTE_W
,

427 0x189000 | 
PTE_P
 | 
PTE_W
,

428 0x18a000 | 
PTE_P
 | 
PTE_W
,

429 0x18b000 | 
PTE_P
 | 
PTE_W
,

430 0x18c000 | 
PTE_P
 | 
PTE_W
,

431 0x18d000 | 
PTE_P
 | 
PTE_W
,

432 0x18e000 | 
PTE_P
 | 
PTE_W
,

433 0x18f000 | 
PTE_P
 | 
PTE_W
,

434 0x190000 | 
PTE_P
 | 
PTE_W
,

435 0x191000 | 
PTE_P
 | 
PTE_W
,

436 0x192000 | 
PTE_P
 | 
PTE_W
,

437 0x193000 | 
PTE_P
 | 
PTE_W
,

438 0x194000 | 
PTE_P
 | 
PTE_W
,

439 0x195000 | 
PTE_P
 | 
PTE_W
,

440 0x196000 | 
PTE_P
 | 
PTE_W
,

441 0x197000 | 
PTE_P
 | 
PTE_W
,

442 0x198000 | 
PTE_P
 | 
PTE_W
,

443 0x199000 | 
PTE_P
 | 
PTE_W
,

444 0x19a000 | 
PTE_P
 | 
PTE_W
,

445 0x19b000 | 
PTE_P
 | 
PTE_W
,

446 0x19c000 | 
PTE_P
 | 
PTE_W
,

447 0x19d000 | 
PTE_P
 | 
PTE_W
,

448 0x19e000 | 
PTE_P
 | 
PTE_W
,

449 0x19f000 | 
PTE_P
 | 
PTE_W
,

450 0x1a0000 | 
PTE_P
 | 
PTE_W
,

451 0x1a1000 | 
PTE_P
 | 
PTE_W
,

452 0x1a2000 | 
PTE_P
 | 
PTE_W
,

453 0x1a3000 | 
PTE_P
 | 
PTE_W
,

454 0x1a4000 | 
PTE_P
 | 
PTE_W
,

455 0x1a5000 | 
PTE_P
 | 
PTE_W
,

456 0x1a6000 | 
PTE_P
 | 
PTE_W
,

457 0x1a7000 | 
PTE_P
 | 
PTE_W
,

458 0x1a8000 | 
PTE_P
 | 
PTE_W
,

459 0x1a9000 | 
PTE_P
 | 
PTE_W
,

460 0x1aa000 | 
PTE_P
 | 
PTE_W
,

461 0x1ab000 | 
PTE_P
 | 
PTE_W
,

462 0x1ac000 | 
PTE_P
 | 
PTE_W
,

463 0x1ad000 | 
PTE_P
 | 
PTE_W
,

464 0x1ae000 | 
PTE_P
 | 
PTE_W
,

465 0x1af000 | 
PTE_P
 | 
PTE_W
,

466 0x1b0000 | 
PTE_P
 | 
PTE_W
,

467 0x1b1000 | 
PTE_P
 | 
PTE_W
,

468 0x1b2000 | 
PTE_P
 | 
PTE_W
,

469 0x1b3000 | 
PTE_P
 | 
PTE_W
,

470 0x1b4000 | 
PTE_P
 | 
PTE_W
,

471 0x1b5000 | 
PTE_P
 | 
PTE_W
,

472 0x1b6000 | 
PTE_P
 | 
PTE_W
,

473 0x1b7000 | 
PTE_P
 | 
PTE_W
,

474 0x1b8000 | 
PTE_P
 | 
PTE_W
,

475 0x1b9000 | 
PTE_P
 | 
PTE_W
,

476 0x1ba000 | 
PTE_P
 | 
PTE_W
,

477 0x1bb000 | 
PTE_P
 | 
PTE_W
,

478 0x1bc000 | 
PTE_P
 | 
PTE_W
,

479 0x1bd000 | 
PTE_P
 | 
PTE_W
,

480 0x1be000 | 
PTE_P
 | 
PTE_W
,

481 0x1bf000 | 
PTE_P
 | 
PTE_W
,

482 0x1c0000 | 
PTE_P
 | 
PTE_W
,

483 0x1c1000 | 
PTE_P
 | 
PTE_W
,

484 0x1c2000 | 
PTE_P
 | 
PTE_W
,

485 0x1c3000 | 
PTE_P
 | 
PTE_W
,

486 0x1c4000 | 
PTE_P
 | 
PTE_W
,

487 0x1c5000 | 
PTE_P
 | 
PTE_W
,

488 0x1c6000 | 
PTE_P
 | 
PTE_W
,

489 0x1c7000 | 
PTE_P
 | 
PTE_W
,

490 0x1c8000 | 
PTE_P
 | 
PTE_W
,

491 0x1c9000 | 
PTE_P
 | 
PTE_W
,

492 0x1ca000 | 
PTE_P
 | 
PTE_W
,

493 0x1cb000 | 
PTE_P
 | 
PTE_W
,

494 0x1cc000 | 
PTE_P
 | 
PTE_W
,

495 0x1cd000 | 
PTE_P
 | 
PTE_W
,

496 0x1ce000 | 
PTE_P
 | 
PTE_W
,

497 0x1cf000 | 
PTE_P
 | 
PTE_W
,

498 0x1d0000 | 
PTE_P
 | 
PTE_W
,

499 0x1d1000 | 
PTE_P
 | 
PTE_W
,

500 0x1d2000 | 
PTE_P
 | 
PTE_W
,

501 0x1d3000 | 
PTE_P
 | 
PTE_W
,

502 0x1d4000 | 
PTE_P
 | 
PTE_W
,

503 0x1d5000 | 
PTE_P
 | 
PTE_W
,

504 0x1d6000 | 
PTE_P
 | 
PTE_W
,

505 0x1d7000 | 
PTE_P
 | 
PTE_W
,

506 0x1d8000 | 
PTE_P
 | 
PTE_W
,

507 0x1d9000 | 
PTE_P
 | 
PTE_W
,

508 0x1da000 | 
PTE_P
 | 
PTE_W
,

509 0x1db000 | 
PTE_P
 | 
PTE_W
,

510 0x1dc000 | 
PTE_P
 | 
PTE_W
,

511 0x1dd000 | 
PTE_P
 | 
PTE_W
,

512 0x1de000 | 
PTE_P
 | 
PTE_W
,

513 0x1df000 | 
PTE_P
 | 
PTE_W
,

514 0x1e0000 | 
PTE_P
 | 
PTE_W
,

515 0x1e1000 | 
PTE_P
 | 
PTE_W
,

516 0x1e2000 | 
PTE_P
 | 
PTE_W
,

517 0x1e3000 | 
PTE_P
 | 
PTE_W
,

518 0x1e4000 | 
PTE_P
 | 
PTE_W
,

519 0x1e5000 | 
PTE_P
 | 
PTE_W
,

520 0x1e6000 | 
PTE_P
 | 
PTE_W
,

521 0x1e7000 | 
PTE_P
 | 
PTE_W
,

522 0x1e8000 | 
PTE_P
 | 
PTE_W
,

523 0x1e9000 | 
PTE_P
 | 
PTE_W
,

524 0x1ea000 | 
PTE_P
 | 
PTE_W
,

525 0x1eb000 | 
PTE_P
 | 
PTE_W
,

526 0x1ec000 | 
PTE_P
 | 
PTE_W
,

527 0x1ed000 | 
PTE_P
 | 
PTE_W
,

528 0x1ee000 | 
PTE_P
 | 
PTE_W
,

529 0x1ef000 | 
PTE_P
 | 
PTE_W
,

530 0x1f0000 | 
PTE_P
 | 
PTE_W
,

531 0x1f1000 | 
PTE_P
 | 
PTE_W
,

532 0x1f2000 | 
PTE_P
 | 
PTE_W
,

533 0x1f3000 | 
PTE_P
 | 
PTE_W
,

534 0x1f4000 | 
PTE_P
 | 
PTE_W
,

535 0x1f5000 | 
PTE_P
 | 
PTE_W
,

536 0x1f6000 | 
PTE_P
 | 
PTE_W
,

537 0x1f7000 | 
PTE_P
 | 
PTE_W
,

538 0x1f8000 | 
PTE_P
 | 
PTE_W
,

539 0x1f9000 | 
PTE_P
 | 
PTE_W
,

540 0x1fa000 | 
PTE_P
 | 
PTE_W
,

541 0x1fb000 | 
PTE_P
 | 
PTE_W
,

542 0x1fc000 | 
PTE_P
 | 
PTE_W
,

543 0x1fd000 | 
PTE_P
 | 
PTE_W
,

544 0x1fe000 | 
PTE_P
 | 
PTE_W
,

545 0x1ff000 | 
PTE_P
 | 
PTE_W
,

546 0x200000 | 
PTE_P
 | 
PTE_W
,

547 0x201000 | 
PTE_P
 | 
PTE_W
,

548 0x202000 | 
PTE_P
 | 
PTE_W
,

549 0x203000 | 
PTE_P
 | 
PTE_W
,

550 0x204000 | 
PTE_P
 | 
PTE_W
,

551 0x205000 | 
PTE_P
 | 
PTE_W
,

552 0x206000 | 
PTE_P
 | 
PTE_W
,

553 0x207000 | 
PTE_P
 | 
PTE_W
,

554 0x208000 | 
PTE_P
 | 
PTE_W
,

555 0x209000 | 
PTE_P
 | 
PTE_W
,

556 0x20a000 | 
PTE_P
 | 
PTE_W
,

557 0x20b000 | 
PTE_P
 | 
PTE_W
,

558 0x20c000 | 
PTE_P
 | 
PTE_W
,

559 0x20d000 | 
PTE_P
 | 
PTE_W
,

560 0x20e000 | 
PTE_P
 | 
PTE_W
,

561 0x20f000 | 
PTE_P
 | 
PTE_W
,

562 0x210000 | 
PTE_P
 | 
PTE_W
,

563 0x211000 | 
PTE_P
 | 
PTE_W
,

564 0x212000 | 
PTE_P
 | 
PTE_W
,

565 0x213000 | 
PTE_P
 | 
PTE_W
,

566 0x214000 | 
PTE_P
 | 
PTE_W
,

567 0x215000 | 
PTE_P
 | 
PTE_W
,

568 0x216000 | 
PTE_P
 | 
PTE_W
,

569 0x217000 | 
PTE_P
 | 
PTE_W
,

570 0x218000 | 
PTE_P
 | 
PTE_W
,

571 0x219000 | 
PTE_P
 | 
PTE_W
,

572 0x21a000 | 
PTE_P
 | 
PTE_W
,

573 0x21b000 | 
PTE_P
 | 
PTE_W
,

574 0x21c000 | 
PTE_P
 | 
PTE_W
,

575 0x21d000 | 
PTE_P
 | 
PTE_W
,

576 0x21e000 | 
PTE_P
 | 
PTE_W
,

577 0x21f000 | 
PTE_P
 | 
PTE_W
,

578 0x220000 | 
PTE_P
 | 
PTE_W
,

579 0x221000 | 
PTE_P
 | 
PTE_W
,

580 0x222000 | 
PTE_P
 | 
PTE_W
,

581 0x223000 | 
PTE_P
 | 
PTE_W
,

582 0x224000 | 
PTE_P
 | 
PTE_W
,

583 0x225000 | 
PTE_P
 | 
PTE_W
,

584 0x226000 | 
PTE_P
 | 
PTE_W
,

585 0x227000 | 
PTE_P
 | 
PTE_W
,

586 0x228000 | 
PTE_P
 | 
PTE_W
,

587 0x229000 | 
PTE_P
 | 
PTE_W
,

588 0x22a000 | 
PTE_P
 | 
PTE_W
,

589 0x22b000 | 
PTE_P
 | 
PTE_W
,

590 0x22c000 | 
PTE_P
 | 
PTE_W
,

591 0x22d000 | 
PTE_P
 | 
PTE_W
,

592 0x22e000 | 
PTE_P
 | 
PTE_W
,

593 0x22f000 | 
PTE_P
 | 
PTE_W
,

594 0x230000 | 
PTE_P
 | 
PTE_W
,

595 0x231000 | 
PTE_P
 | 
PTE_W
,

596 0x232000 | 
PTE_P
 | 
PTE_W
,

597 0x233000 | 
PTE_P
 | 
PTE_W
,

598 0x234000 | 
PTE_P
 | 
PTE_W
,

599 0x235000 | 
PTE_P
 | 
PTE_W
,

600 0x236000 | 
PTE_P
 | 
PTE_W
,

601 0x237000 | 
PTE_P
 | 
PTE_W
,

602 0x238000 | 
PTE_P
 | 
PTE_W
,

603 0x239000 | 
PTE_P
 | 
PTE_W
,

604 0x23a000 | 
PTE_P
 | 
PTE_W
,

605 0x23b000 | 
PTE_P
 | 
PTE_W
,

606 0x23c000 | 
PTE_P
 | 
PTE_W
,

607 0x23d000 | 
PTE_P
 | 
PTE_W
,

608 0x23e000 | 
PTE_P
 | 
PTE_W
,

609 0x23f000 | 
PTE_P
 | 
PTE_W
,

610 0x240000 | 
PTE_P
 | 
PTE_W
,

611 0x241000 | 
PTE_P
 | 
PTE_W
,

612 0x242000 | 
PTE_P
 | 
PTE_W
,

613 0x243000 | 
PTE_P
 | 
PTE_W
,

614 0x244000 | 
PTE_P
 | 
PTE_W
,

615 0x245000 | 
PTE_P
 | 
PTE_W
,

616 0x246000 | 
PTE_P
 | 
PTE_W
,

617 0x247000 | 
PTE_P
 | 
PTE_W
,

618 0x248000 | 
PTE_P
 | 
PTE_W
,

619 0x249000 | 
PTE_P
 | 
PTE_W
,

620 0x24a000 | 
PTE_P
 | 
PTE_W
,

621 0x24b000 | 
PTE_P
 | 
PTE_W
,

622 0x24c000 | 
PTE_P
 | 
PTE_W
,

623 0x24d000 | 
PTE_P
 | 
PTE_W
,

624 0x24e000 | 
PTE_P
 | 
PTE_W
,

625 0x24f000 | 
PTE_P
 | 
PTE_W
,

626 0x250000 | 
PTE_P
 | 
PTE_W
,

627 0x251000 | 
PTE_P
 | 
PTE_W
,

628 0x252000 | 
PTE_P
 | 
PTE_W
,

629 0x253000 | 
PTE_P
 | 
PTE_W
,

630 0x254000 | 
PTE_P
 | 
PTE_W
,

631 0x255000 | 
PTE_P
 | 
PTE_W
,

632 0x256000 | 
PTE_P
 | 
PTE_W
,

633 0x257000 | 
PTE_P
 | 
PTE_W
,

634 0x258000 | 
PTE_P
 | 
PTE_W
,

635 0x259000 | 
PTE_P
 | 
PTE_W
,

636 0x25a000 | 
PTE_P
 | 
PTE_W
,

637 0x25b000 | 
PTE_P
 | 
PTE_W
,

638 0x25c000 | 
PTE_P
 | 
PTE_W
,

639 0x25d000 | 
PTE_P
 | 
PTE_W
,

640 0x25e000 | 
PTE_P
 | 
PTE_W
,

641 0x25f000 | 
PTE_P
 | 
PTE_W
,

642 0x260000 | 
PTE_P
 | 
PTE_W
,

643 0x261000 | 
PTE_P
 | 
PTE_W
,

644 0x262000 | 
PTE_P
 | 
PTE_W
,

645 0x263000 | 
PTE_P
 | 
PTE_W
,

646 0x264000 | 
PTE_P
 | 
PTE_W
,

647 0x265000 | 
PTE_P
 | 
PTE_W
,

648 0x266000 | 
PTE_P
 | 
PTE_W
,

649 0x267000 | 
PTE_P
 | 
PTE_W
,

650 0x268000 | 
PTE_P
 | 
PTE_W
,

651 0x269000 | 
PTE_P
 | 
PTE_W
,

652 0x26a000 | 
PTE_P
 | 
PTE_W
,

653 0x26b000 | 
PTE_P
 | 
PTE_W
,

654 0x26c000 | 
PTE_P
 | 
PTE_W
,

655 0x26d000 | 
PTE_P
 | 
PTE_W
,

656 0x26e000 | 
PTE_P
 | 
PTE_W
,

657 0x26f000 | 
PTE_P
 | 
PTE_W
,

658 0x270000 | 
PTE_P
 | 
PTE_W
,

659 0x271000 | 
PTE_P
 | 
PTE_W
,

660 0x272000 | 
PTE_P
 | 
PTE_W
,

661 0x273000 | 
PTE_P
 | 
PTE_W
,

662 0x274000 | 
PTE_P
 | 
PTE_W
,

663 0x275000 | 
PTE_P
 | 
PTE_W
,

664 0x276000 | 
PTE_P
 | 
PTE_W
,

665 0x277000 | 
PTE_P
 | 
PTE_W
,

666 0x278000 | 
PTE_P
 | 
PTE_W
,

667 0x279000 | 
PTE_P
 | 
PTE_W
,

668 0x27a000 | 
PTE_P
 | 
PTE_W
,

669 0x27b000 | 
PTE_P
 | 
PTE_W
,

670 0x27c000 | 
PTE_P
 | 
PTE_W
,

671 0x27d000 | 
PTE_P
 | 
PTE_W
,

672 0x27e000 | 
PTE_P
 | 
PTE_W
,

673 0x27f000 | 
PTE_P
 | 
PTE_W
,

674 0x280000 | 
PTE_P
 | 
PTE_W
,

675 0x281000 | 
PTE_P
 | 
PTE_W
,

676 0x282000 | 
PTE_P
 | 
PTE_W
,

677 0x283000 | 
PTE_P
 | 
PTE_W
,

678 0x284000 | 
PTE_P
 | 
PTE_W
,

679 0x285000 | 
PTE_P
 | 
PTE_W
,

680 0x286000 | 
PTE_P
 | 
PTE_W
,

681 0x287000 | 
PTE_P
 | 
PTE_W
,

682 0x288000 | 
PTE_P
 | 
PTE_W
,

683 0x289000 | 
PTE_P
 | 
PTE_W
,

684 0x28a000 | 
PTE_P
 | 
PTE_W
,

685 0x28b000 | 
PTE_P
 | 
PTE_W
,

686 0x28c000 | 
PTE_P
 | 
PTE_W
,

687 0x28d000 | 
PTE_P
 | 
PTE_W
,

688 0x28e000 | 
PTE_P
 | 
PTE_W
,

689 0x28f000 | 
PTE_P
 | 
PTE_W
,

690 0x290000 | 
PTE_P
 | 
PTE_W
,

691 0x291000 | 
PTE_P
 | 
PTE_W
,

692 0x292000 | 
PTE_P
 | 
PTE_W
,

693 0x293000 | 
PTE_P
 | 
PTE_W
,

694 0x294000 | 
PTE_P
 | 
PTE_W
,

695 0x295000 | 
PTE_P
 | 
PTE_W
,

696 0x296000 | 
PTE_P
 | 
PTE_W
,

697 0x297000 | 
PTE_P
 | 
PTE_W
,

698 0x298000 | 
PTE_P
 | 
PTE_W
,

699 0x299000 | 
PTE_P
 | 
PTE_W
,

700 0x29a000 | 
PTE_P
 | 
PTE_W
,

701 0x29b000 | 
PTE_P
 | 
PTE_W
,

702 0x29c000 | 
PTE_P
 | 
PTE_W
,

703 0x29d000 | 
PTE_P
 | 
PTE_W
,

704 0x29e000 | 
PTE_P
 | 
PTE_W
,

705 0x29f000 | 
PTE_P
 | 
PTE_W
,

706 0x2a0000 | 
PTE_P
 | 
PTE_W
,

707 0x2a1000 | 
PTE_P
 | 
PTE_W
,

708 0x2a2000 | 
PTE_P
 | 
PTE_W
,

709 0x2a3000 | 
PTE_P
 | 
PTE_W
,

710 0x2a4000 | 
PTE_P
 | 
PTE_W
,

711 0x2a5000 | 
PTE_P
 | 
PTE_W
,

712 0x2a6000 | 
PTE_P
 | 
PTE_W
,

713 0x2a7000 | 
PTE_P
 | 
PTE_W
,

714 0x2a8000 | 
PTE_P
 | 
PTE_W
,

715 0x2a9000 | 
PTE_P
 | 
PTE_W
,

716 0x2aa000 | 
PTE_P
 | 
PTE_W
,

717 0x2ab000 | 
PTE_P
 | 
PTE_W
,

718 0x2ac000 | 
PTE_P
 | 
PTE_W
,

719 0x2ad000 | 
PTE_P
 | 
PTE_W
,

720 0x2ae000 | 
PTE_P
 | 
PTE_W
,

721 0x2af000 | 
PTE_P
 | 
PTE_W
,

722 0x2b0000 | 
PTE_P
 | 
PTE_W
,

723 0x2b1000 | 
PTE_P
 | 
PTE_W
,

724 0x2b2000 | 
PTE_P
 | 
PTE_W
,

725 0x2b3000 | 
PTE_P
 | 
PTE_W
,

726 0x2b4000 | 
PTE_P
 | 
PTE_W
,

727 0x2b5000 | 
PTE_P
 | 
PTE_W
,

728 0x2b6000 | 
PTE_P
 | 
PTE_W
,

729 0x2b7000 | 
PTE_P
 | 
PTE_W
,

730 0x2b8000 | 
PTE_P
 | 
PTE_W
,

731 0x2b9000 | 
PTE_P
 | 
PTE_W
,

732 0x2ba000 | 
PTE_P
 | 
PTE_W
,

733 0x2bb000 | 
PTE_P
 | 
PTE_W
,

734 0x2bc000 | 
PTE_P
 | 
PTE_W
,

735 0x2bd000 | 
PTE_P
 | 
PTE_W
,

736 0x2be000 | 
PTE_P
 | 
PTE_W
,

737 0x2bf000 | 
PTE_P
 | 
PTE_W
,

738 0x2c0000 | 
PTE_P
 | 
PTE_W
,

739 0x2c1000 | 
PTE_P
 | 
PTE_W
,

740 0x2c2000 | 
PTE_P
 | 
PTE_W
,

741 0x2c3000 | 
PTE_P
 | 
PTE_W
,

742 0x2c4000 | 
PTE_P
 | 
PTE_W
,

743 0x2c5000 | 
PTE_P
 | 
PTE_W
,

744 0x2c6000 | 
PTE_P
 | 
PTE_W
,

745 0x2c7000 | 
PTE_P
 | 
PTE_W
,

746 0x2c8000 | 
PTE_P
 | 
PTE_W
,

747 0x2c9000 | 
PTE_P
 | 
PTE_W
,

748 0x2ca000 | 
PTE_P
 | 
PTE_W
,

749 0x2cb000 | 
PTE_P
 | 
PTE_W
,

750 0x2cc000 | 
PTE_P
 | 
PTE_W
,

751 0x2cd000 | 
PTE_P
 | 
PTE_W
,

752 0x2ce000 | 
PTE_P
 | 
PTE_W
,

753 0x2cf000 | 
PTE_P
 | 
PTE_W
,

754 0x2d0000 | 
PTE_P
 | 
PTE_W
,

755 0x2d1000 | 
PTE_P
 | 
PTE_W
,

756 0x2d2000 | 
PTE_P
 | 
PTE_W
,

757 0x2d3000 | 
PTE_P
 | 
PTE_W
,

758 0x2d4000 | 
PTE_P
 | 
PTE_W
,

759 0x2d5000 | 
PTE_P
 | 
PTE_W
,

760 0x2d6000 | 
PTE_P
 | 
PTE_W
,

761 0x2d7000 | 
PTE_P
 | 
PTE_W
,

762 0x2d8000 | 
PTE_P
 | 
PTE_W
,

763 0x2d9000 | 
PTE_P
 | 
PTE_W
,

764 0x2da000 | 
PTE_P
 | 
PTE_W
,

765 0x2db000 | 
PTE_P
 | 
PTE_W
,

766 0x2dc000 | 
PTE_P
 | 
PTE_W
,

767 0x2dd000 | 
PTE_P
 | 
PTE_W
,

768 0x2de000 | 
PTE_P
 | 
PTE_W
,

769 0x2df000 | 
PTE_P
 | 
PTE_W
,

770 0x2e0000 | 
PTE_P
 | 
PTE_W
,

771 0x2e1000 | 
PTE_P
 | 
PTE_W
,

772 0x2e2000 | 
PTE_P
 | 
PTE_W
,

773 0x2e3000 | 
PTE_P
 | 
PTE_W
,

774 0x2e4000 | 
PTE_P
 | 
PTE_W
,

775 0x2e5000 | 
PTE_P
 | 
PTE_W
,

776 0x2e6000 | 
PTE_P
 | 
PTE_W
,

777 0x2e7000 | 
PTE_P
 | 
PTE_W
,

778 0x2e8000 | 
PTE_P
 | 
PTE_W
,

779 0x2e9000 | 
PTE_P
 | 
PTE_W
,

780 0x2ea000 | 
PTE_P
 | 
PTE_W
,

781 0x2eb000 | 
PTE_P
 | 
PTE_W
,

782 0x2ec000 | 
PTE_P
 | 
PTE_W
,

783 0x2ed000 | 
PTE_P
 | 
PTE_W
,

784 0x2ee000 | 
PTE_P
 | 
PTE_W
,

785 0x2ef000 | 
PTE_P
 | 
PTE_W
,

786 0x2f0000 | 
PTE_P
 | 
PTE_W
,

787 0x2f1000 | 
PTE_P
 | 
PTE_W
,

788 0x2f2000 | 
PTE_P
 | 
PTE_W
,

789 0x2f3000 | 
PTE_P
 | 
PTE_W
,

790 0x2f4000 | 
PTE_P
 | 
PTE_W
,

791 0x2f5000 | 
PTE_P
 | 
PTE_W
,

792 0x2f6000 | 
PTE_P
 | 
PTE_W
,

793 0x2f7000 | 
PTE_P
 | 
PTE_W
,

794 0x2f8000 | 
PTE_P
 | 
PTE_W
,

795 0x2f9000 | 
PTE_P
 | 
PTE_W
,

796 0x2fa000 | 
PTE_P
 | 
PTE_W
,

797 0x2fb000 | 
PTE_P
 | 
PTE_W
,

798 0x2fc000 | 
PTE_P
 | 
PTE_W
,

799 0x2fd000 | 
PTE_P
 | 
PTE_W
,

800 0x2fe000 | 
PTE_P
 | 
PTE_W
,

801 0x2ff000 | 
PTE_P
 | 
PTE_W
,

802 0x300000 | 
PTE_P
 | 
PTE_W
,

803 0x301000 | 
PTE_P
 | 
PTE_W
,

804 0x302000 | 
PTE_P
 | 
PTE_W
,

805 0x303000 | 
PTE_P
 | 
PTE_W
,

806 0x304000 | 
PTE_P
 | 
PTE_W
,

807 0x305000 | 
PTE_P
 | 
PTE_W
,

808 0x306000 | 
PTE_P
 | 
PTE_W
,

809 0x307000 | 
PTE_P
 | 
PTE_W
,

810 0x308000 | 
PTE_P
 | 
PTE_W
,

811 0x309000 | 
PTE_P
 | 
PTE_W
,

812 0x30a000 | 
PTE_P
 | 
PTE_W
,

813 0x30b000 | 
PTE_P
 | 
PTE_W
,

814 0x30c000 | 
PTE_P
 | 
PTE_W
,

815 0x30d000 | 
PTE_P
 | 
PTE_W
,

816 0x30e000 | 
PTE_P
 | 
PTE_W
,

817 0x30f000 | 
PTE_P
 | 
PTE_W
,

818 0x310000 | 
PTE_P
 | 
PTE_W
,

819 0x311000 | 
PTE_P
 | 
PTE_W
,

820 0x312000 | 
PTE_P
 | 
PTE_W
,

821 0x313000 | 
PTE_P
 | 
PTE_W
,

822 0x314000 | 
PTE_P
 | 
PTE_W
,

823 0x315000 | 
PTE_P
 | 
PTE_W
,

824 0x316000 | 
PTE_P
 | 
PTE_W
,

825 0x317000 | 
PTE_P
 | 
PTE_W
,

826 0x318000 | 
PTE_P
 | 
PTE_W
,

827 0x319000 | 
PTE_P
 | 
PTE_W
,

828 0x31a000 | 
PTE_P
 | 
PTE_W
,

829 0x31b000 | 
PTE_P
 | 
PTE_W
,

830 0x31c000 | 
PTE_P
 | 
PTE_W
,

831 0x31d000 | 
PTE_P
 | 
PTE_W
,

832 0x31e000 | 
PTE_P
 | 
PTE_W
,

833 0x31f000 | 
PTE_P
 | 
PTE_W
,

834 0x320000 | 
PTE_P
 | 
PTE_W
,

835 0x321000 | 
PTE_P
 | 
PTE_W
,

836 0x322000 | 
PTE_P
 | 
PTE_W
,

837 0x323000 | 
PTE_P
 | 
PTE_W
,

838 0x324000 | 
PTE_P
 | 
PTE_W
,

839 0x325000 | 
PTE_P
 | 
PTE_W
,

840 0x326000 | 
PTE_P
 | 
PTE_W
,

841 0x327000 | 
PTE_P
 | 
PTE_W
,

842 0x328000 | 
PTE_P
 | 
PTE_W
,

843 0x329000 | 
PTE_P
 | 
PTE_W
,

844 0x32a000 | 
PTE_P
 | 
PTE_W
,

845 0x32b000 | 
PTE_P
 | 
PTE_W
,

846 0x32c000 | 
PTE_P
 | 
PTE_W
,

847 0x32d000 | 
PTE_P
 | 
PTE_W
,

848 0x32e000 | 
PTE_P
 | 
PTE_W
,

849 0x32f000 | 
PTE_P
 | 
PTE_W
,

850 0x330000 | 
PTE_P
 | 
PTE_W
,

851 0x331000 | 
PTE_P
 | 
PTE_W
,

852 0x332000 | 
PTE_P
 | 
PTE_W
,

853 0x333000 | 
PTE_P
 | 
PTE_W
,

854 0x334000 | 
PTE_P
 | 
PTE_W
,

855 0x335000 | 
PTE_P
 | 
PTE_W
,

856 0x336000 | 
PTE_P
 | 
PTE_W
,

857 0x337000 | 
PTE_P
 | 
PTE_W
,

858 0x338000 | 
PTE_P
 | 
PTE_W
,

859 0x339000 | 
PTE_P
 | 
PTE_W
,

860 0x33a000 | 
PTE_P
 | 
PTE_W
,

861 0x33b000 | 
PTE_P
 | 
PTE_W
,

862 0x33c000 | 
PTE_P
 | 
PTE_W
,

863 0x33d000 | 
PTE_P
 | 
PTE_W
,

864 0x33e000 | 
PTE_P
 | 
PTE_W
,

865 0x33f000 | 
PTE_P
 | 
PTE_W
,

866 0x340000 | 
PTE_P
 | 
PTE_W
,

867 0x341000 | 
PTE_P
 | 
PTE_W
,

868 0x342000 | 
PTE_P
 | 
PTE_W
,

869 0x343000 | 
PTE_P
 | 
PTE_W
,

870 0x344000 | 
PTE_P
 | 
PTE_W
,

871 0x345000 | 
PTE_P
 | 
PTE_W
,

872 0x346000 | 
PTE_P
 | 
PTE_W
,

873 0x347000 | 
PTE_P
 | 
PTE_W
,

874 0x348000 | 
PTE_P
 | 
PTE_W
,

875 0x349000 | 
PTE_P
 | 
PTE_W
,

876 0x34a000 | 
PTE_P
 | 
PTE_W
,

877 0x34b000 | 
PTE_P
 | 
PTE_W
,

878 0x34c000 | 
PTE_P
 | 
PTE_W
,

879 0x34d000 | 
PTE_P
 | 
PTE_W
,

880 0x34e000 | 
PTE_P
 | 
PTE_W
,

881 0x34f000 | 
PTE_P
 | 
PTE_W
,

882 0x350000 | 
PTE_P
 | 
PTE_W
,

883 0x351000 | 
PTE_P
 | 
PTE_W
,

884 0x352000 | 
PTE_P
 | 
PTE_W
,

885 0x353000 | 
PTE_P
 | 
PTE_W
,

886 0x354000 | 
PTE_P
 | 
PTE_W
,

887 0x355000 | 
PTE_P
 | 
PTE_W
,

888 0x356000 | 
PTE_P
 | 
PTE_W
,

889 0x357000 | 
PTE_P
 | 
PTE_W
,

890 0x358000 | 
PTE_P
 | 
PTE_W
,

891 0x359000 | 
PTE_P
 | 
PTE_W
,

892 0x35a000 | 
PTE_P
 | 
PTE_W
,

893 0x35b000 | 
PTE_P
 | 
PTE_W
,

894 0x35c000 | 
PTE_P
 | 
PTE_W
,

895 0x35d000 | 
PTE_P
 | 
PTE_W
,

896 0x35e000 | 
PTE_P
 | 
PTE_W
,

897 0x35f000 | 
PTE_P
 | 
PTE_W
,

898 0x360000 | 
PTE_P
 | 
PTE_W
,

899 0x361000 | 
PTE_P
 | 
PTE_W
,

900 0x362000 | 
PTE_P
 | 
PTE_W
,

901 0x363000 | 
PTE_P
 | 
PTE_W
,

902 0x364000 | 
PTE_P
 | 
PTE_W
,

903 0x365000 | 
PTE_P
 | 
PTE_W
,

904 0x366000 | 
PTE_P
 | 
PTE_W
,

905 0x367000 | 
PTE_P
 | 
PTE_W
,

906 0x368000 | 
PTE_P
 | 
PTE_W
,

907 0x369000 | 
PTE_P
 | 
PTE_W
,

908 0x36a000 | 
PTE_P
 | 
PTE_W
,

909 0x36b000 | 
PTE_P
 | 
PTE_W
,

910 0x36c000 | 
PTE_P
 | 
PTE_W
,

911 0x36d000 | 
PTE_P
 | 
PTE_W
,

912 0x36e000 | 
PTE_P
 | 
PTE_W
,

913 0x36f000 | 
PTE_P
 | 
PTE_W
,

914 0x370000 | 
PTE_P
 | 
PTE_W
,

915 0x371000 | 
PTE_P
 | 
PTE_W
,

916 0x372000 | 
PTE_P
 | 
PTE_W
,

917 0x373000 | 
PTE_P
 | 
PTE_W
,

918 0x374000 | 
PTE_P
 | 
PTE_W
,

919 0x375000 | 
PTE_P
 | 
PTE_W
,

920 0x376000 | 
PTE_P
 | 
PTE_W
,

921 0x377000 | 
PTE_P
 | 
PTE_W
,

922 0x378000 | 
PTE_P
 | 
PTE_W
,

923 0x379000 | 
PTE_P
 | 
PTE_W
,

924 0x37a000 | 
PTE_P
 | 
PTE_W
,

925 0x37b000 | 
PTE_P
 | 
PTE_W
,

926 0x37c000 | 
PTE_P
 | 
PTE_W
,

927 0x37d000 | 
PTE_P
 | 
PTE_W
,

928 0x37e000 | 
PTE_P
 | 
PTE_W
,

929 0x37f000 | 
PTE_P
 | 
PTE_W
,

930 0x380000 | 
PTE_P
 | 
PTE_W
,

931 0x381000 | 
PTE_P
 | 
PTE_W
,

932 0x382000 | 
PTE_P
 | 
PTE_W
,

933 0x383000 | 
PTE_P
 | 
PTE_W
,

934 0x384000 | 
PTE_P
 | 
PTE_W
,

935 0x385000 | 
PTE_P
 | 
PTE_W
,

936 0x386000 | 
PTE_P
 | 
PTE_W
,

937 0x387000 | 
PTE_P
 | 
PTE_W
,

938 0x388000 | 
PTE_P
 | 
PTE_W
,

939 0x389000 | 
PTE_P
 | 
PTE_W
,

940 0x38a000 | 
PTE_P
 | 
PTE_W
,

941 0x38b000 | 
PTE_P
 | 
PTE_W
,

942 0x38c000 | 
PTE_P
 | 
PTE_W
,

943 0x38d000 | 
PTE_P
 | 
PTE_W
,

944 0x38e000 | 
PTE_P
 | 
PTE_W
,

945 0x38f000 | 
PTE_P
 | 
PTE_W
,

946 0x390000 | 
PTE_P
 | 
PTE_W
,

947 0x391000 | 
PTE_P
 | 
PTE_W
,

948 0x392000 | 
PTE_P
 | 
PTE_W
,

949 0x393000 | 
PTE_P
 | 
PTE_W
,

950 0x394000 | 
PTE_P
 | 
PTE_W
,

951 0x395000 | 
PTE_P
 | 
PTE_W
,

952 0x396000 | 
PTE_P
 | 
PTE_W
,

953 0x397000 | 
PTE_P
 | 
PTE_W
,

954 0x398000 | 
PTE_P
 | 
PTE_W
,

955 0x399000 | 
PTE_P
 | 
PTE_W
,

956 0x39a000 | 
PTE_P
 | 
PTE_W
,

957 0x39b000 | 
PTE_P
 | 
PTE_W
,

958 0x39c000 | 
PTE_P
 | 
PTE_W
,

959 0x39d000 | 
PTE_P
 | 
PTE_W
,

960 0x39e000 | 
PTE_P
 | 
PTE_W
,

961 0x39f000 | 
PTE_P
 | 
PTE_W
,

962 0x3a0000 | 
PTE_P
 | 
PTE_W
,

963 0x3a1000 | 
PTE_P
 | 
PTE_W
,

964 0x3a2000 | 
PTE_P
 | 
PTE_W
,

965 0x3a3000 | 
PTE_P
 | 
PTE_W
,

966 0x3a4000 | 
PTE_P
 | 
PTE_W
,

967 0x3a5000 | 
PTE_P
 | 
PTE_W
,

968 0x3a6000 | 
PTE_P
 | 
PTE_W
,

969 0x3a7000 | 
PTE_P
 | 
PTE_W
,

970 0x3a8000 | 
PTE_P
 | 
PTE_W
,

971 0x3a9000 | 
PTE_P
 | 
PTE_W
,

972 0x3aa000 | 
PTE_P
 | 
PTE_W
,

973 0x3ab000 | 
PTE_P
 | 
PTE_W
,

974 0x3ac000 | 
PTE_P
 | 
PTE_W
,

975 0x3ad000 | 
PTE_P
 | 
PTE_W
,

976 0x3ae000 | 
PTE_P
 | 
PTE_W
,

977 0x3af000 | 
PTE_P
 | 
PTE_W
,

978 0x3b0000 | 
PTE_P
 | 
PTE_W
,

979 0x3b1000 | 
PTE_P
 | 
PTE_W
,

980 0x3b2000 | 
PTE_P
 | 
PTE_W
,

981 0x3b3000 | 
PTE_P
 | 
PTE_W
,

982 0x3b4000 | 
PTE_P
 | 
PTE_W
,

983 0x3b5000 | 
PTE_P
 | 
PTE_W
,

984 0x3b6000 | 
PTE_P
 | 
PTE_W
,

985 0x3b7000 | 
PTE_P
 | 
PTE_W
,

986 0x3b8000 | 
PTE_P
 | 
PTE_W
,

987 0x3b9000 | 
PTE_P
 | 
PTE_W
,

988 0x3ba000 | 
PTE_P
 | 
PTE_W
,

989 0x3bb000 | 
PTE_P
 | 
PTE_W
,

990 0x3bc000 | 
PTE_P
 | 
PTE_W
,

991 0x3bd000 | 
PTE_P
 | 
PTE_W
,

992 0x3be000 | 
PTE_P
 | 
PTE_W
,

993 0x3bf000 | 
PTE_P
 | 
PTE_W
,

994 0x3c0000 | 
PTE_P
 | 
PTE_W
,

995 0x3c1000 | 
PTE_P
 | 
PTE_W
,

996 0x3c2000 | 
PTE_P
 | 
PTE_W
,

997 0x3c3000 | 
PTE_P
 | 
PTE_W
,

998 0x3c4000 | 
PTE_P
 | 
PTE_W
,

999 0x3c5000 | 
PTE_P
 | 
PTE_W
,

1000 0x3c6000 | 
PTE_P
 | 
PTE_W
,

1001 0x3c7000 | 
PTE_P
 | 
PTE_W
,

1002 0x3c8000 | 
PTE_P
 | 
PTE_W
,

1003 0x3c9000 | 
PTE_P
 | 
PTE_W
,

1004 0x3ca000 | 
PTE_P
 | 
PTE_W
,

1005 0x3cb000 | 
PTE_P
 | 
PTE_W
,

1006 0x3cc000 | 
PTE_P
 | 
PTE_W
,

1007 0x3cd000 | 
PTE_P
 | 
PTE_W
,

1008 0x3ce000 | 
PTE_P
 | 
PTE_W
,

1009 0x3cf000 | 
PTE_P
 | 
PTE_W
,

1010 0x3d0000 | 
PTE_P
 | 
PTE_W
,

1011 0x3d1000 | 
PTE_P
 | 
PTE_W
,

1012 0x3d2000 | 
PTE_P
 | 
PTE_W
,

1013 0x3d3000 | 
PTE_P
 | 
PTE_W
,

1014 0x3d4000 | 
PTE_P
 | 
PTE_W
,

1015 0x3d5000 | 
PTE_P
 | 
PTE_W
,

1016 0x3d6000 | 
PTE_P
 | 
PTE_W
,

1017 0x3d7000 | 
PTE_P
 | 
PTE_W
,

1018 0x3d8000 | 
PTE_P
 | 
PTE_W
,

1019 0x3d9000 | 
PTE_P
 | 
PTE_W
,

1020 0x3da000 | 
PTE_P
 | 
PTE_W
,

1021 0x3db000 | 
PTE_P
 | 
PTE_W
,

1022 0x3dc000 | 
PTE_P
 | 
PTE_W
,

1023 0x3dd000 | 
PTE_P
 | 
PTE_W
,

1024 0x3de000 | 
PTE_P
 | 
PTE_W
,

1025 0x3df000 | 
PTE_P
 | 
PTE_W
,

1026 0x3e0000 | 
PTE_P
 | 
PTE_W
,

1027 0x3e1000 | 
PTE_P
 | 
PTE_W
,

1028 0x3e2000 | 
PTE_P
 | 
PTE_W
,

1029 0x3e3000 | 
PTE_P
 | 
PTE_W
,

1030 0x3e4000 | 
PTE_P
 | 
PTE_W
,

1031 0x3e5000 | 
PTE_P
 | 
PTE_W
,

1032 0x3e6000 | 
PTE_P
 | 
PTE_W
,

1033 0x3e7000 | 
PTE_P
 | 
PTE_W
,

1034 0x3e8000 | 
PTE_P
 | 
PTE_W
,

1035 0x3e9000 | 
PTE_P
 | 
PTE_W
,

1036 0x3ea000 | 
PTE_P
 | 
PTE_W
,

1037 0x3eb000 | 
PTE_P
 | 
PTE_W
,

1038 0x3ec000 | 
PTE_P
 | 
PTE_W
,

1039 0x3ed000 | 
PTE_P
 | 
PTE_W
,

1040 0x3ee000 | 
PTE_P
 | 
PTE_W
,

1041 0x3ef000 | 
PTE_P
 | 
PTE_W
,

1042 0x3f0000 | 
PTE_P
 | 
PTE_W
,

1043 0x3f1000 | 
PTE_P
 | 
PTE_W
,

1044 0x3f2000 | 
PTE_P
 | 
PTE_W
,

1045 0x3f3000 | 
PTE_P
 | 
PTE_W
,

1046 0x3f4000 | 
PTE_P
 | 
PTE_W
,

1047 0x3f5000 | 
PTE_P
 | 
PTE_W
,

1048 0x3f6000 | 
PTE_P
 | 
PTE_W
,

1049 0x3f7000 | 
PTE_P
 | 
PTE_W
,

1050 0x3f8000 | 
PTE_P
 | 
PTE_W
,

1051 0x3f9000 | 
PTE_P
 | 
PTE_W
,

1052 0x3fa000 | 
PTE_P
 | 
PTE_W
,

1053 0x3fb000 | 
PTE_P
 | 
PTE_W
,

1054 0x3fc000 | 
PTE_P
 | 
PTE_W
,

1055 0x3fd000 | 
PTE_P
 | 
PTE_W
,

1056 0x3fe000 | 
PTE_P
 | 
PTE_W
,

1057 0x3ff000 | 
PTE_P
 | 
PTE_W
,

1058 
	}
};

	@/root/Robux/kern/env.c

3 #include 
	~<inc/x86.h
>

4 #include 
	~<inc/mmu.h
>

5 #include 
	~<inc/error.h
>

6 #include 
	~<inc/string.h
>

7 #include 
	~<inc/assert.h
>

8 #include 
	~<inc/elf.h
>

10 #include 
	~<kern/env.h
>

11 #include 
	~<kern/pmap.h
>

12 #include 
	~<kern/trap.h
>

13 #include 
	~<kern/monitor.h
>

14 #include 
	~<kern/sched.h
>

15 #include 
	~<kern/cpu.h
>

16 #include 
	~<kern/spinlock.h
>

18 struct 
Env
 *
	genvs
 = 
NULL
;

19 static struct 
Env
 *
	genv_free_list
;

22 #define 
	#ENVGENSHIFT
 12

23 

	)

39 struct 
Segdesc
 
	ggdt
[
NCPU
 + 5] =

42 
SEG_NULL
,

45 [
GD_KT
 >> 3] = 
SEG
(
STA_X
 | 
STA_R
, 0x0, 0xffffffff, 0),

48 [
GD_KD
 >> 3] = 
SEG
(
STA_W
, 0x0, 0xffffffff, 0),

51 [
GD_UT
 >> 3] = 
SEG
(
STA_X
 | 
STA_R
, 0x0, 0xffffffff, 3),

54 [
GD_UD
 >> 3] = 
SEG
(
STA_W
, 0x0, 0xffffffff, 3),

58 [
GD_TSS0
 >> 3] = 
SEG_NULL


61 struct 
Pseudodesc
 
	ggdt_pd
 = {

62 sizeof(
gdt
) - 1, (unsigned long) gdt

76 
	$envid2env
(
envid_t
 
envid
, struct 
Env
 **
env_store
, 
bool
 
checkperm
)

78 struct 
Env
 *
e
;

81 if (
envid
 == 0) {

82 *
env_store
 = 
curenv
;

91 
e
 = &
envs
[
	`ENVX
(
envid
)];

92 if (
e
->
env_status
 == 
ENV_FREE
 || e->
env_id
 != 
envid
) {

93 *
env_store
 = 0;

94 return -
E_BAD_ENV
;

102 if (
checkperm
 && 
e
 != 
curenv
 && e->
env_parent_id
 != curenv->
env_id
) {

103 *
env_store
 = 0;

104 return -
E_BAD_ENV
;

107 *
env_store
 = 
e
;

109 
	}
}

118 
	$env_init
(void)

125 
	`memset
(
envs
, 0x00, sizeof(struct 
Env
)*
NENV
);

126 
env_free_list
 = 
NULL
;

127 int 
i
;

128 for (
i
=
NENV
-1; i>=0; i--)

130 
envs
[
i
].
env_status
 = 
ENV_FREE
;

131 
envs
[
i
].
env_link
 = 
env_free_list
;

132 
env_free_list
 = &
envs
[
i
];

136 
	`env_init_percpu
();

137 
	}
}

141 
	$env_init_percpu
(void)

143 
	`lgdt
(&
gdt_pd
);

146 
asm
 volatile("movw %%ax,%%gs" :: "a" (
GD_UD
|3));

147 
asm
 volatile("movw %%ax,%%fs" :: "a" (
GD_UD
|3));

150 
asm
 volatile("movw %%ax,%%es" :: "a" (
GD_KD
));

151 
asm
 volatile("movw %%ax,%%ds" :: "a" (
GD_KD
));

152 
asm
 volatile("movw %%ax,%%ss" :: "a" (
GD_KD
));

154 
asm
 volatile("ljmp %0,$1f\n 1:\n" :: "i" (
GD_KT
));

157 
	`lldt
(0);

158 
	}
}

171 
	$env_setup_vm
(struct 
Env
 *
e
)

173 int 
i
;

174 struct 
Page
 *
p
 = 
NULL
;

177 if (!(
p
 = 
	`page_alloc
(
ALLOC_ZERO
)))

178 return -
E_NO_MEM
;

200 
p
->
pp_ref
++;

203 
e
->
env_pgdir
 = 
	`page2kva
(
p
);

207 for (
i
=
	`PDX
(
UTOP
); i<=PDX(0xfffff000); i++)

209 ((
pde_t
*)
e
->
env_pgdir
)[
i
] = 
kern_pgdir
[i];

215 
e
->
env_pgdir
[
	`PDX
(
UVPT
)] = 
	`page2pa
(
p
) | 
PTE_P
 | 
PTE_U
;

218 
	}
}

229 
	$env_alloc
(struct 
Env
 **
newenv_store
, 
envid_t
 
parent_id
)

231 
int32_t
 
generation
;

232 int 
r
;

233 struct 
Env
 *
e
;

235 if (!(
e
 = 
env_free_list
))

236 return -
E_NO_FREE_ENV
;

239 if ((
r
 = 
	`env_setup_vm
(
e
)) < 0)

240 return 
r
;

243 
generation
 = (
e
->
env_id
 + (1 << 
ENVGENSHIFT
)) & ~(
NENV
 - 1);

244 if (
generation
 <= 0)

245 
generation
 = 1 << 
ENVGENSHIFT
;

246 
e
->
env_id
 = 
generation
 | (e - 
envs
);

249 
e
->
env_parent_id
 = 
parent_id
;

250 
e
->
env_type
 = 
ENV_TYPE_USER
;

251 
e
->
env_status
 = 
ENV_RUNNABLE
;

252 
e
->
env_runs
 = 0;

258 
	`memset
(&
e
->
env_tf
, 0, sizeof(e->env_tf));

268 
e
->
env_tf
.
tf_ds
 = 
GD_UD
 | 3;

269 
e
->
env_tf
.
tf_es
 = 
GD_UD
 | 3;

270 
e
->
env_tf
.
tf_ss
 = 
GD_UD
 | 3;

271 
e
->
env_tf
.
tf_esp
 = 
USTACKTOP
;

272 
e
->
env_tf
.
tf_cs
 = 
GD_UT
 | 3;

277 
e
->
env_tf
.
tf_eflags
 |= 
FL_IF
;

280 
e
->
env_pgfault_upcall
 = 0;

283 
e
->
env_ipc_recving
 = 0;

285 
e
->
env_ipc_send_to
 = 0;

288 
e
->
env_uid
 = 0;

289 
e
->
env_gid
 = 0;

290 
e
->
env_user_perm
 = 0;

293 
env_free_list
 = 
e
->
env_link
;

294 *
newenv_store
 = 
e
;

298 
	}
}

308 
	$region_alloc
(struct 
Env
 *
e
, void *
va
, 
size_t
 
len
)

314 void *
start_va
 = 
	`ROUNDDOWN
(
va
, 
PGSIZE
);

315 void *
cur_va
 = 
start_va
;

319 for (; 
cur_va
 < 
	`ROUNDUP
(
va
+
len
, 
PGSIZE
); cur_va += PGSIZE)

321 struct 
Page
 *
p
 = 
	`page_alloc
(0);

322 
	`page_insert
(
e
->
env_pgdir
, 
p
, 
cur_va
, 
PTE_U
 | 
PTE_W
);

329 
	}
}

354 
	$load_icode
(struct 
Env
 *
e
, 
uint8_t
 *
binary
, 
size_t
 
size
)

385 struct 
Elf
 *
prog
 = (struct Elf *) 
binary
;

386 struct 
Proghdr
 *
ph
, *
eph
;

389 if (
prog
->
e_magic
 != 
ELF_MAGIC
)

390 
	`panic
("Invalid ELF header\n");

393 
ph
 = (struct 
Proghdr
 *) (
binary
 + 
prog
->
e_phoff
);

394 
eph
 = 
ph
 + 
prog
->
e_phnum
;

398 
	`lcr3
((
uint32_t
) 
	`PADDR
(
e
->
env_pgdir
));

401 for (; 
ph
 < 
eph
; ph++)

404 if (
ph
->
p_type
 != 
ELF_PROG_LOAD
)

410 
	`region_alloc
(
e
, (void*)
ph
->
p_va
, ph->
p_memsz
);

412 
	`memmove
((void*)
ph
->
p_va
, 
binary
+ph->
p_offset
, ph->
p_filesz
);

413 
	`memset
((void*)
ph
->
p_va
+ph->
p_filesz
, 0x00, ph->
p_memsz
-ph->p_filesz);

417 
	`lcr3
((
uint32_t
) 
	`PADDR
(
kern_pgdir
));

425 struct 
Page
 *
stkp
 = 
	`page_alloc
(
ALLOC_ZERO
);

426 
	`page_insert
(
e
->
env_pgdir
, 
stkp
, (void*)
USTACKTOP
-
PGSIZE
, 
PTE_W
 | 
PTE_U
);

429 
e
->
env_tf
.
tf_eip
 = 
prog
->
e_entry
;

430 
	}
}

440 
	$env_create
(
uint8_t
 *
binary
, 
size_t
 
size
, enum 
EnvType
 
type
)

446 if (
type
 == 
ENV_TYPE_FS
)

448 int 
i
;

449 for (
i
 = 0; i < 
NENV
; i++)

451 if (
envs
[
i
].
env_status
 != 
ENV_FREE
 &&

452 
envs
[
i
].
env_type
 == 
ENV_TYPE_FS
)

454 
	`panic
("Already have a FS environment\n");

459 struct 
Env
 *
env
;

460 int 
err
;

461 if ((
err
 = 
	`env_alloc
(&
env
, 0)) < 0)

463 
	`panic
("env_alloc error: %e\n", 
err
);

468 
env
->
env_type
 = 
type
;

470 if (
type
 == 
ENV_TYPE_FS
)

472 
env
->
env_tf
.
tf_eflags
 |= 
FL_IOPL_3
;

475 
	`load_icode
(
env
, 
binary
, 
size
);

476 
	}
}

482 
	$env_free
(struct 
Env
 *
e
)

484 
pte_t
 *
pt
;

485 
uint32_t
 
pdeno
, 
pteno
;

486 
physaddr_t
 
pa
;

491 if (
e
 == 
curenv
)

492 
	`lcr3
(
	`PADDR
(
kern_pgdir
));

498 
	`static_assert
(
UTOP
 % 
PTSIZE
 == 0);

499 for (
pdeno
 = 0; pdeno < 
	`PDX
(
UTOP
); pdeno++) {

502 if (!(
e
->
env_pgdir
[
pdeno
] & 
PTE_P
))

506 
pa
 = 
	`PTE_ADDR
(
e
->
env_pgdir
[
pdeno
]);

507 
pt
 = (
pte_t
*) 
	`KADDR
(
pa
);

510 for (
pteno
 = 0; pteno <= 
	`PTX
(~0); pteno++) {

511 if (
pt
[
pteno
] & 
PTE_P
)

512 
	`page_remove
(
e
->
env_pgdir
, 
	`PGADDR
(
pdeno
, 
pteno
, 0));

516 
e
->
env_pgdir
[
pdeno
] = 0;

517 
	`page_decref
(
	`pa2page
(
pa
));

521 
pa
 = 
	`PADDR
(
e
->
env_pgdir
);

522 
e
->
env_pgdir
 = 0;

523 
	`page_decref
(
	`pa2page
(
pa
));

526 
e
->
env_status
 = 
ENV_FREE
;

527 
e
->
env_link
 = 
env_free_list
;

528 
env_free_list
 = 
e
;

529 
	}
}

537 
	$env_destroy
(struct 
Env
 *
e
)

542 if (
e
->
env_status
 == 
ENV_RUNNING
 && 
curenv
 != e) {

543 
e
->
env_status
 = 
ENV_DYING
;

547 
	`env_free
(
e
);

549 if (
curenv
 == 
e
) {

550 
curenv
 = 
NULL
;

551 
	`sched_yield
();

553 
	}
}

563 
	$env_pop_tf
(struct 
Trapframe
 *
tf
)

566 
curenv
->
env_cpunum
 = 
	`cpunum
();

568 
__asm
 
	`__volatile
("movl %0,%%esp\n"

574 : : "g" (
tf
) : "memory");

575 
	`panic
("iret failed");

576 
	}
}

585 
	$env_run
(struct 
Env
 *
e
)

608 if (
curenv
 && curenv->
env_status
 == 
ENV_RUNNING
)

609 
curenv
->
env_status
 = 
ENV_RUNNABLE
;

611 
curenv
 = 
e
;

613 
curenv
->
env_status
 = 
ENV_RUNNING
;

614 
curenv
->
env_runs
++;

617 
	`lcr3
((
uint32_t
)
	`PADDR
(
e
->
env_pgdir
));

619 
	`unlock_kernel
();

620 
	`env_pop_tf
(&
e
->
env_tf
);

621 
	}
}

	@/root/Robux/kern/env.h

3 #ifndef 
JOS_KERN_ENV_H


4 #define 
	#JOS_KERN_ENV_H


	)

6 #include 
	~<inc/env.h
>

7 #include 
	~<kern/cpu.h
>

9 extern struct 
Env
 *
envs
;

10 #define 
	#curenv
 (
thiscpu
->
cpu_env
)

11 extern struct 
Segdesc
 
gdt
[];

	)

13 void 
env_init
(void);

14 void 
env_init_percpu
(void);

15 int 
env_alloc
(struct 
Env
 **
e
, 
envid_t
 
parent_id
);

16 void 
env_free
(struct 
Env
 *
e
);

17 void 
env_create
(
uint8_t
 *
binary
, 
size_t
 
size
, enum 
EnvType
 
type
);

18 void 
env_destroy
(struct 
Env
 *
e
);

20 int 
envid2env
(
envid_t
 
envid
, struct 
Env
 **
env_store
, 
bool
 
checkperm
);

22 void 
	$env_run
(struct 
Env
 *
e
) 
	`__attribute__
((
noreturn
));

23 void 
	$env_pop_tf
(struct 
Trapframe
 *
tf
) 
	`__attribute__
((
noreturn
));

27 #define 
	#ENV_PASTE3
(
x
, 
y
, 
z
) x ## y ## 
	)
z

29 #define 
	#ENV_CREATE
(
x
, 
type
) \

31 extern 
uint8_t
 
	`ENV_PASTE3
(
_binary_obj_
, 
x
, 
_start
)[], \

32 
	`ENV_PASTE3
(
_binary_obj_
, 
x
, 
_size
)[]; \

33 
	`env_create
(
	`ENV_PASTE3
(
_binary_obj_
, 
x
, 
_start
), \

34 (int)
	`ENV_PASTE3
(
_binary_obj_
, 
x
, 
_size
), \

35 
type
); \

36 
	}
} while (0)

	)

	@/root/Robux/kern/init.c

3 #include 
	~<inc/stdio.h
>

4 #include 
	~<inc/string.h
>

5 #include 
	~<inc/assert.h
>

7 #include 
	~<kern/monitor.h
>

8 #include 
	~<kern/console.h
>

9 #include 
	~<kern/pmap.h
>

10 #include 
	~<kern/kclock.h
>

11 #include 
	~<kern/env.h
>

12 #include 
	~<kern/trap.h
>

13 #include 
	~<kern/sched.h
>

14 #include 
	~<kern/picirq.h
>

15 #include 
	~<kern/cpu.h
>

16 #include 
	~<kern/spinlock.h
>

17 #include 
	~<kern/time.h
>

18 #include 
	~<kern/pci.h
>

20 static void 
boot_aps
(void);

24 
	$i386_init
(void)

26 extern char 
edata
[], 
end
[];

31 
	`memset
(
edata
, 0, 
end
 - edata);

37 
	`cons_init
();

39 
	`cprintf
("6828 decimal is %o octal!\n", 6828);

42 
	`mem_init
();

45 
	`env_init
();

46 
	`trap_init
();

49 
	`mp_init
();

50 
	`lapic_init
();

53 
	`pic_init
();

56 
	`time_init
();

57 
	`pci_init
();

61 
	`lock_kernel
();

64 
	`boot_aps
();

67 int 
i
;

68 for (
i
 = 0; i < 
NCPU
; i++)

69 
	`ENV_CREATE
(
user_idle
, 
ENV_TYPE_IDLE
);

72 
	`ENV_CREATE
(
fs_fs
, 
ENV_TYPE_FS
);

74 #if !
	`defined
(
TEST_NO_NS
)

76 
	`ENV_CREATE
(
net_ns
, 
ENV_TYPE_NS
);

80 
	`ENV_CREATE
(
security_secserv
, 
ENV_TYPE_SECURITY
);

85 #if 
	`defined
(
TEST
)

87 
	`ENV_CREATE
(
TEST
, 
ENV_TYPE_USER
);

94 
	`kbd_intr
();

97 
	`sched_yield
();

98 
	}
}

103 void *
	gmpentry_kstack
;

107 
	$boot_aps
(void)

109 extern unsigned char 
mpentry_start
[], 
mpentry_end
[];

110 void *
code
;

111 struct 
Cpu
 *
c
;

114 
code
 = 
	`KADDR
(
MPENTRY_PADDR
);

115 
	`memmove
(
code
, 
mpentry_start
, 
mpentry_end
 - mpentry_start);

118 for (
c
 = 
cpus
; c < cpus + 
ncpu
; c++) {

119 if (
c
 == 
cpus
 + 
	`cpunum
())

123 
mpentry_kstack
 = 
percpu_kstacks
[
c
 - 
cpus
] + 
KSTKSIZE
;

125 
	`lapic_startap
(
c
->
cpu_id
, 
	`PADDR
(
code
));

127 while(
c
->
cpu_status
 != 
CPU_STARTED
)

130 
	}
}

134 
	$mp_main
(void)

137 if (
	`cpu_has_pse
())

138 
	`cpu_activate_pse
();

141 
	`lcr3
(
	`PADDR
(
kern_pgdir
));

142 
	`cprintf
("SMP: CPU %d starting\n", 
	`cpunum
());

144 
	`lapic_init
();

145 
	`env_init_percpu
();

146 
	`trap_init_percpu
();

147 
	`xchg
(&
thiscpu
->
cpu_status
, 
CPU_STARTED
);

154 
	`lock_kernel
();

155 
	`sched_yield
();

159 
	}
}

165 const char *
	gpanicstr
;

172 
	$_panic
(const char *
file
, int 
line
, const char *
fmt
,...)

174 
va_list
 
ap
;

176 if (
panicstr
)

177 goto 
dead
;

178 
panicstr
 = 
fmt
;

181 
__asm
 
	`__volatile
("cli; cld");

183 
	`va_start
(
ap
, 
fmt
);

184 
	`cprintf
("kernel panic on CPU %d at %s:%d: ", 
	`cpunum
(), 
file
, 
line
);

185 
	`vcprintf
(
fmt
, 
ap
);

186 
	`cprintf
("\n");

187 
	`va_end
(
ap
);

189 
dead
:

192 
	`monitor
(
NULL
);

193 
	}
}

197 
	$_warn
(const char *
file
, int 
line
, const char *
fmt
,...)

199 
va_list
 
ap
;

201 
	`va_start
(
ap
, 
fmt
);

202 
	`cprintf
("kernel warning at %s:%d: ", 
file
, 
line
);

203 
	`vcprintf
(
fmt
, 
ap
);

204 
	`cprintf
("\n");

205 
	`va_end
(
ap
);

206 
	}
}

	@/root/Robux/kern/kclock.c

5 #include 
	~<inc/x86.h
>

7 #include 
	~<kern/kclock.h
>

11 
	$mc146818_read
(unsigned 
reg
)

13 
	`outb
(
IO_RTC
, 
reg
);

14 return 
	`inb
(
IO_RTC
+1);

15 
	}
}

18 
	$mc146818_write
(unsigned 
reg
, unsigned 
datum
)

20 
	`outb
(
IO_RTC
, 
reg
);

21 
	`outb
(
IO_RTC
+1, 
datum
);

22 
	}
}

	@/root/Robux/kern/kclock.h

3 #ifndef 
JOS_KERN_KCLOCK_H


4 #define 
	#JOS_KERN_KCLOCK_H


	)

5 #ifndef 
JOS_KERNEL


9 #define 
	#IO_RTC
 0x070

	)

11 #define 
	#MC_NVRAM_START
 0xe

	)

12 #define 
	#MC_NVRAM_SIZE
 50

	)

15 #define 
	#NVRAM_BASELO
 (
MC_NVRAM_START
 + 7)

	)

16 #define 
	#NVRAM_BASEHI
 (
MC_NVRAM_START
 + 8)

	)

19 #define 
	#NVRAM_EXTLO
 (
MC_NVRAM_START
 + 9)

	)

20 #define 
	#NVRAM_EXTHI
 (
MC_NVRAM_START
 + 10)

	)

23 #define 
	#NVRAM_PEXTLO
 (
MC_NVRAM_START
 + 34)

	)

24 #define 
	#NVRAM_PEXTHI
 (
MC_NVRAM_START
 + 35)

	)

27 #define 
	#NVRAM_CENTURY
 (
MC_NVRAM_START
 + 36)

	)

29 unsigned 
mc146818_read
(unsigned 
reg
);

30 void 
mc146818_write
(unsigned 
reg
, unsigned 
datum
);

	@/root/Robux/kern/kdebug.c

1 #include 
	~<inc/stab.h
>

2 #include 
	~<inc/string.h
>

3 #include 
	~<inc/memlayout.h
>

4 #include 
	~<inc/assert.h
>

6 #include 
	~<kern/kdebug.h
>

7 #include 
	~<kern/pmap.h
>

8 #include 
	~<kern/env.h
>

10 extern const struct 
Stab
 
__STAB_BEGIN__
[];

11 extern const struct 
Stab
 
__STAB_END__
[];

12 extern const char 
__STABSTR_BEGIN__
[];

13 extern const char 
__STABSTR_END__
[];

15 struct 
	sUserStabData
 {

16 const struct 
Stab
 *
	mstabs
;

17 const struct 
Stab
 *
	mstab_end
;

18 const char *
	mstabstr
;

19 const char *
	mstabstr_end
;

60 
	$stab_binsearch
(const struct 
Stab
 *
stabs
, int *
region_left
, int *
region_right
,

61 int 
type
, 
uintptr_t
 
addr
)

63 int 
l
 = *
region_left
, 
r
 = *
region_right
, 
any_matches
 = 0;

65 while (
l
 <= 
r
) {

66 int 
true_m
 = (
l
 + 
r
) / 2, 
m
 = true_m;

69 while (
m
 >= 
l
 && 
stabs
[m].
n_type
 != 
type
)

70 
m
--;

71 if (
m
 < 
l
) {

72 
l
 = 
true_m
 + 1;

77 
any_matches
 = 1;

78 if (
stabs
[
m
].
n_value
 < 
addr
) {

79 *
region_left
 = 
m
;

80 
l
 = 
true_m
 + 1;

81 } else if (
stabs
[
m
].
n_value
 > 
addr
) {

82 *
region_right
 = 
m
 - 1;

83 
r
 = 
m
 - 1;

87 *
region_left
 = 
m
;

88 
l
 = 
m
;

89 
addr
++;

93 if (!
any_matches
)

94 *
region_right
 = *
region_left
 - 1;

97 for (
l
 = *
region_right
;

98 
l
 > *
region_left
 && 
stabs
[l].
n_type
 != 
type
;

99 
l
--)

101 *
region_left
 = 
l
;

103 
	}
}

114 
	$debuginfo_eip
(
uintptr_t
 
addr
, struct 
Eipdebuginfo
 *
info
)

116 const struct 
Stab
 *
stabs
, *
stab_end
;

117 const char *
stabstr
, *
stabstr_end
;

118 int 
lfile
, 
rfile
, 
lfun
, 
rfun
, 
lline
, 
rline
;

121 
info
->
eip_file
 = "<unknown>";

122 
info
->
eip_line
 = 0;

123 
info
->
eip_fn_name
 = "<unknown>";

124 
info
->
eip_fn_namelen
 = 9;

125 
info
->
eip_fn_addr
 = 
addr
;

126 
info
->
eip_fn_narg
 = 0;

129 if (
addr
 >= 
ULIM
) {

130 
stabs
 = 
__STAB_BEGIN__
;

131 
stab_end
 = 
__STAB_END__
;

132 
stabstr
 = 
__STABSTR_BEGIN__
;

133 
stabstr_end
 = 
__STABSTR_END__
;

140 const struct 
UserStabData
 *
usd
 = (const struct UserStabData *) 
USTABDATA
;

146 
stabs
 = 
usd
->stabs;

147 
stab_end
 = 
usd
->stab_end;

148 
stabstr
 = 
usd
->stabstr;

149 
stabstr_end
 = 
usd
->stabstr_end;

156 if (
stabstr_end
 <= 
stabstr
 || stabstr_end[-1] != 0)

165 
lfile
 = 0;

166 
rfile
 = (
stab_end
 - 
stabs
) - 1;

167 
	`stab_binsearch
(
stabs
, &
lfile
, &
rfile
, 
N_SO
, 
addr
);

168 if (
lfile
 == 0)

173 
lfun
 = 
lfile
;

174 
rfun
 = 
rfile
;

175 
	`stab_binsearch
(
stabs
, &
lfun
, &
rfun
, 
N_FUN
, 
addr
);

177 if (
lfun
 <= 
rfun
) {

180 if (
stabs
[
lfun
].
n_strx
 < 
stabstr_end
 - 
stabstr
)

181 
info
->
eip_fn_name
 = 
stabstr
 + 
stabs
[
lfun
].
n_strx
;

182 
info
->
eip_fn_addr
 = 
stabs
[
lfun
].
n_value
;

183 
addr
 -= 
info
->
eip_fn_addr
;

185 
lline
 = 
lfun
;

186 
rline
 = 
rfun
;

190 
info
->
eip_fn_addr
 = 
addr
;

191 
lline
 = 
lfile
;

192 
rline
 = 
rfile
;

195 
info
->
eip_fn_namelen
 = 
	`strfind
(info->
eip_fn_name
, ':') - info->eip_fn_name;

206 
	`stab_binsearch
(
stabs
, &
lline
, &
rline
, 
N_SLINE
, 
addr
);

207 if (
lline
 <= 
rline
)

209 
info
->
eip_line
 = 
stabs
[
lline
].
n_desc
;

222 while (
lline
 >= 
lfile


223 && 
stabs
[
lline
].
n_type
 != 
N_SOL


224 && (
stabs
[
lline
].
n_type
 != 
N_SO
 || !stabs[lline].
n_value
))

225 
lline
--;

226 if (
lline
 >= 
lfile
 && 
stabs
[lline].
n_strx
 < 
stabstr_end
 - 
stabstr
)

227 
info
->
eip_file
 = 
stabstr
 + 
stabs
[
lline
].
n_strx
;

232 if (
lfun
 < 
rfun
)

233 for (
lline
 = 
lfun
 + 1;

234 
lline
 < 
rfun
 && 
stabs
[lline].
n_type
 == 
N_PSYM
;

235 
lline
++)

236 
info
->
eip_fn_narg
++;

239 
	}
}

	@/root/Robux/kern/kdebug.h

1 #ifndef 
JOS_KERN_KDEBUG_H


2 #define 
	#JOS_KERN_KDEBUG_H


	)

4 #include 
	~<inc/types.h
>

7 struct 
	sEipdebuginfo
 {

8 const char *
	meip_file
;

9 int 
	meip_line
;

11 const char *
	meip_fn_name
;

13 int 
	meip_fn_namelen
;

14 
uintptr_t
 
	meip_fn_addr
;

15 int 
	meip_fn_narg
;

18 int 
debuginfo_eip
(
uintptr_t
 
eip
, struct 
Eipdebuginfo
 *
info
);

	@/root/Robux/kern/lapic.c

4 #include 
	~<inc/types.h
>

5 #include 
	~<inc/memlayout.h
>

6 #include 
	~<inc/trap.h
>

7 #include 
	~<inc/mmu.h
>

8 #include 
	~<inc/stdio.h
>

9 #include 
	~<inc/x86.h
>

10 #include 
	~<kern/pmap.h
>

11 #include 
	~<kern/cpu.h
>

14 #define 
	#ID
 (0x0020/4)

15 #define 
	#VER
 (0x0030/4)

16 #define 
	#TPR
 (0x0080/4)

17 #define 
	#EOI
 (0x00B0/4)

18 #define 
	#SVR
 (0x00F0/4)

19 #define 
	#ENABLE
 0x00000100

20 #define 
	#ESR
 (0x0280/4)

21 #define 
	#ICRLO
 (0x0300/4)

22 #define 
	#INIT
 0x00000500

23 #define 
	#STARTUP
 0x00000600

24 #define 
	#DELIVS
 0x00001000

25 #define 
	#ASSERT
 0x00004000

26 #define 
	#DEASSERT
 0x00000000

	)

27 #define 
	#LEVEL
 0x00008000

28 #define 
	#BCAST
 0x00080000

29 #define 
	#OTHERS
 0x000C0000

30 #define 
	#BUSY
 0x00001000

	)

31 #define 
	#FIXED
 0x00000000

	)

32 #define 
	#ICRHI
 (0x0310/4)

33 #define 
	#TIMER
 (0x0320/4)

34 #define 
	#X1
 0x0000000B

35 #define 
	#PERIODIC
 0x00020000

36 #define 
	#PCINT
 (0x0340/4)

37 #define 
	#LINT0
 (0x0350/4)

38 #define 
	#LINT1
 (0x0360/4)

39 #define 
	#ERROR
 (0x0370/4)

40 #define 
	#MASKED
 0x00010000

41 #define 
	#TICR
 (0x0380/4)

42 #define 
	#TCCR
 (0x0390/4)

43 #define 
	#TDCR
 (0x03E0/4)

44 

	)

45 volatile 
uint32_t
 *
	glapic
;

48 
	$lapicw
(int 
index
, int 
value
)

50 
lapic
[
index
] = 
value
;

51 
lapic
[
ID
];

52 
	}
}

55 
	$lapic_init
(void)

57 if (!
lapic
)

61 
	`lapicw
(
SVR
, 
ENABLE
 | (
IRQ_OFFSET
 + 
IRQ_SPURIOUS
));

67 
	`lapicw
(
TDCR
, 
X1
);

68 
	`lapicw
(
TIMER
, 
PERIODIC
 | (
IRQ_OFFSET
 + 
IRQ_TIMER
));

69 
	`lapicw
(
TICR
, 10000000);

78 if (
thiscpu
 != 
bootcpu
)

79 
	`lapicw
(
LINT0
, 
MASKED
);

82 
	`lapicw
(
LINT1
, 
MASKED
);

86 if (((
lapic
[
VER
]>>16) & 0xFF) >= 4)

87 
	`lapicw
(
PCINT
, 
MASKED
);

90 
	`lapicw
(
ERROR
, 
IRQ_OFFSET
 + 
IRQ_ERROR
);

93 
	`lapicw
(
ESR
, 0);

94 
	`lapicw
(
ESR
, 0);

97 
	`lapicw
(
EOI
, 0);

100 
	`lapicw
(
ICRHI
, 0);

101 
	`lapicw
(
ICRLO
, 
BCAST
 | 
INIT
 | 
LEVEL
);

102 while(
lapic
[
ICRLO
] & 
DELIVS
)

106 
	`lapicw
(
TPR
, 0);

107 
	}
}

110 
	$cpunum
(void)

112 if (
lapic
)

113 return 
lapic
[
ID
] >> 24;

115 
	}
}

119 
	$lapic_eoi
(void)

121 if (
lapic
)

122 
	`lapicw
(
EOI
, 0);

123 
	}
}

128 
	$microdelay
(int 
us
)

130 
	}
}

132 #define 
	#IO_RTC
 0x70

	)

137 
	$lapic_startap
(
uint8_t
 
apicid
, 
uint32_t
 
addr
)

139 int 
i
;

140 
uint16_t
 *
wrv
;

145 
	`outb
(
IO_RTC
, 0xF);

146 
	`outb
(
IO_RTC
+1, 0x0A);

147 
wrv
 = (
uint16_t
 *)
	`KADDR
((0x40 << 4 | 0x67));

148 
wrv
[0] = 0;

149 
wrv
[1] = 
addr
 >> 4;

153 
	`lapicw
(
ICRHI
, 
apicid
 << 24);

154 
	`lapicw
(
ICRLO
, 
INIT
 | 
LEVEL
 | 
ASSERT
);

155 
	`microdelay
(200);

156 
	`lapicw
(
ICRLO
, 
INIT
 | 
LEVEL
);

157 
	`microdelay
(100);

164 for (
i
 = 0; i < 2; i++) {

165 
	`lapicw
(
ICRHI
, 
apicid
 << 24);

166 
	`lapicw
(
ICRLO
, 
STARTUP
 | (
addr
 >> 12));

167 
	`microdelay
(200);

169 
	}
}

172 
	$lapic_ipi
(int 
vector
)

174 
	`lapicw
(
ICRLO
, 
OTHERS
 | 
FIXED
 | 
vector
);

175 while (
lapic
[
ICRLO
] & 
DELIVS
)

177 
	}
}

	@/root/Robux/kern/monitor.c

4 #include 
	~<inc/stdio.h
>

5 #include 
	~<inc/string.h
>

6 #include 
	~<inc/memlayout.h
>

7 #include 
	~<inc/assert.h
>

8 #include 
	~<inc/x86.h
>

10 #include 
	~<kern/console.h
>

11 #include 
	~<kern/monitor.h
>

12 #include 
	~<kern/kdebug.h
>

13 #include 
	~<kern/trap.h
>

15 #define 
	#CMDBUF_SIZE
 80

16 

	)

18 struct 
	sCommand
 {

19 const char *
	mname
;

20 const char *
	mdesc
;

22 int (*
	mfunc
)(int 
	margc
, char** 
	margv
, struct 
Trapframe
* 
	mtf
);

25 static struct 
Command
 
	gcommands
[] = {

26 { "help", "Display this list of commands", 
mon_help
 },

27 { "kerninfo", "Display information about the kernel", 
mon_kerninfo
 },

28 { "backtrace", "Display backtrace information", 
mon_backtrace
}

30 #define 
	#NCOMMANDS
 (sizeof(
commands
)/sizeof(commands[0]))

	)

32 unsigned 
read_eip
();

37 
	$mon_help
(int 
argc
, char **
argv
, struct 
Trapframe
 *
tf
)

39 int 
i
;

41 for (
i
 = 0; i < 
NCOMMANDS
; i++)

42 
	`cprintf
("%s - %s\n", 
commands
[
i
].
name
, commands[i].
desc
);

44 
	}
}

47 
	$mon_kerninfo
(int 
argc
, char **
argv
, struct 
Trapframe
 *
tf
)

49 extern char 
entry
[], 
etext
[], 
edata
[], 
end
[];

51 
	`cprintf
("Special kernel symbols:\n");

52 
	`cprintf
(" entry %08x (virt) %08x (phys)\n", 
entry
, entry - 
KERNBASE
);

53 
	`cprintf
(" etext %08x (virt) %08x (phys)\n", 
etext
, etext - 
KERNBASE
);

54 
	`cprintf
(" edata %08x (virt) %08x (phys)\n", 
edata
, edata - 
KERNBASE
);

55 
	`cprintf
(" end %08x (virt) %08x (phys)\n", 
end
, end - 
KERNBASE
);

56 
	`cprintf
("Kernel executable memory footprint: %dKB\n",

57 (
end
-
entry
+1023)/1024);

59 
	}
}

62 
	$mon_backtrace
(int 
argc
, char **
argv
, struct 
Trapframe
 *
tf
)

75 int *
ebp
 = (int*)
	`read_ebp
();

76 int *
eip
;

77 int 
i
;

78 int *
args
[5];

80 
	`cprintf
("Stack backtrace:\n");

84 
eip
 = (int*)
ebp
[1];

85 for (
i
=0; i<5; i++)

90 
args
[
i
] = (int*)
ebp
[2+i];

94 
	`cprintf
(" ebp %08x eip %08x args %08x %08x %08x %08x %08x\n", 
ebp
,

95 
eip
, 
args
[0], args[1], args[2], args[3], args[4]);

98 struct 
Eipdebuginfo
 
info
;

99 if (
	`debuginfo_eip
((int)
eip
, &
info
) == 0)

102 char 
name
[
info
.
eip_fn_namelen
+1];

103 
	`strncpy
(
name
, 
info
.
eip_fn_name
, info.
eip_fn_namelen
);

104 
name
[
info
.
eip_fn_namelen
]=0;

106 
	`cprintf
(" %s:%d: %s+%d\n", 
info
.
eip_file
, info.
eip_line
, 
name
, (int)
eip
 - info.
eip_fn_addr
);

110 
	`cprintf
("Error reading debuginfo\n");

114 
ebp
 = (int*)(*ebp);

116 } while (
ebp
 != 0);

119 
	}
}

125 #define 
	#WHITESPACE
 "\t\r\n "

	)

126 #define 
	#MAXARGS
 16

	)

129 
	$runcmd
(char *
buf
, struct 
Trapframe
 *
tf
)

131 int 
argc
;

132 char *
argv
[
MAXARGS
];

133 int 
i
;

136 
argc
 = 0;

137 
argv
[
argc
] = 0;

140 while (*
buf
 && 
	`strchr
(
WHITESPACE
, *buf))

141 *
buf
++ = 0;

142 if (*
buf
 == 0)

146 if (
argc
 == 
MAXARGS
-1) {

147 
	`cprintf
("Too many arguments (max %d)\n", 
MAXARGS
);

150 
argv
[
argc
++] = 
buf
;

151 while (*
buf
 && !
	`strchr
(
WHITESPACE
, *buf))

152 
buf
++;

154 
argv
[
argc
] = 0;

157 if (
argc
 == 0)

159 for (
i
 = 0; i < 
NCOMMANDS
; i++) {

160 if (
	`strcmp
(
argv
[0], 
commands
[
i
].
name
) == 0)

161 return 
commands
[
i
].
	`func
(
argc
, 
argv
, 
tf
);

163 
	`cprintf
("Unknown command '%s'\n", 
argv
[0]);

165 
	}
}

168 
	$monitor
(struct 
Trapframe
 *
tf
)

170 char *
buf
;

172 
	`cprintf
("Welcome to the JOS kernel monitor!\n");

173 
	`cprintf
("Type 'help' for a list of commands.\n");

175 if (
tf
 != 
NULL
)

176 
	`print_trapframe
(
tf
);

179 
buf
 = 
	`readline
("K> ");

180 if (
buf
 != 
NULL
)

181 if (
	`runcmd
(
buf
, 
tf
) < 0)

184 
	}
}

190 
	$read_eip
()

192 
uint32_t
 
callerpc
;

193 
__asm
 
	`__volatile
("movl 4(%%ebp), %0" : "=r" (
callerpc
));

194 return 
callerpc
;

195 
	}
}

	@/root/Robux/kern/monitor.h

1 #ifndef 
JOS_KERN_MONITOR_H


2 #define 
	#JOS_KERN_MONITOR_H


	)

3 #ifndef 
JOS_KERNEL


7 struct 
	gTrapframe
;

12 void 
monitor
(struct 
Trapframe
 *
tf
);

15 int 
mon_help
(int 
argc
, char **
argv
, struct 
Trapframe
 *
tf
);

16 int 
mon_kerninfo
(int 
argc
, char **
argv
, struct 
Trapframe
 *
tf
);

17 int 
mon_backtrace
(int 
argc
, char **
argv
, struct 
Trapframe
 *
tf
);

	@/root/Robux/kern/mpconfig.c

4 #include 
	~<inc/types.h
>

5 #include 
	~<inc/string.h
>

6 #include 
	~<inc/memlayout.h
>

7 #include 
	~<inc/x86.h
>

8 #include 
	~<inc/mmu.h
>

9 #include 
	~<inc/env.h
>

10 #include 
	~<kern/cpu.h
>

11 #include 
	~<kern/pmap.h
>

13 struct 
Cpu
 
	gcpus
[
NCPU
];

14 struct 
Cpu
 *
	gbootcpu
;

15 int 
	gismp
;

16 int 
	gncpu
;

19 unsigned char 
	gpercpu_kstacks
[
NCPU
][
KSTKSIZE
]

20 
__attribute__
 ((
aligned
(
PGSIZE
)));

25 struct 
	smp
 {

26 
uint8_t
 
	msignature
[4];

27 
physaddr_t
 
	mphysaddr
;

28 
uint8_t
 
	mlength
;

29 
uint8_t
 
	mspecrev
;

30 
uint8_t
 
	mchecksum
;

31 
uint8_t
 
	mtype
;

32 
uint8_t
 
	mimcrp
;

33 
uint8_t
 
	mreserved
[3];

34 } 
__attribute__
((
__packed__
));

36 struct 
	smpconf
 {

37 
uint8_t
 
	msignature
[4];

38 
uint16_t
 
	mlength
;

39 
uint8_t
 
	mversion
;

40 
uint8_t
 
	mchecksum
;

41 
uint8_t
 
	mproduct
[20];

42 
physaddr_t
 
	moemtable
;

43 
uint16_t
 
	moemlength
;

44 
uint16_t
 
	mentry
;

45 
physaddr_t
 
	mlapicaddr
;

46 
uint16_t
 
	mxlength
;

47 
uint8_t
 
	mxchecksum
;

48 
uint8_t
 
	mreserved
;

49 
uint8_t
 
	mentries
[0];

50 } 
__attribute__
((
__packed__
));

52 struct 
	smpproc
 {

53 
uint8_t
 
	mtype
;

54 
uint8_t
 
	mapicid
;

55 
uint8_t
 
	mversion
;

56 
uint8_t
 
	mflags
;

57 
uint8_t
 
	msignature
[4];

58 
uint32_t
 
	mfeature
;

59 
uint8_t
 
	mreserved
[8];

60 } 
__attribute__
((
__packed__
));

63 #define 
	#MPPROC_BOOT
 0x02

64 

	)

66 #define 
	#MPPROC
 0x00

67 #define 
	#MPBUS
 0x01

68 #define 
	#MPIOAPIC
 0x02

69 #define 
	#MPIOINTR
 0x03

70 #define 
	#MPLINTR
 0x04

71 

	)

72 static 
uint8_t


73 
	$sum
(void *
addr
, int 
len
)

75 int 
i
, 
sum
;

77 
sum
 = 0;

78 for (
i
 = 0; i < 
len
; i++)

79 
sum
 += ((
uint8_t
 *)
addr
)[
i
];

80 return 
sum
;

81 
	}
}

84 static struct 
mp
 *

85 
	$mpsearch1
(
physaddr_t
 
a
, int 
len
)

87 struct 
mp
 *mp = 
	`KADDR
(
a
), *
end
 = KADDR(a + 
len
);

89 for (; 
mp
 < 
end
; mp++)

90 if (
	`memcmp
(
mp
->
signature
, "_MP_", 4) == 0 &&

91 
	`sum
(
mp
, sizeof(*mp)) == 0)

92 return 
mp
;

93 return 
NULL
;

94 
	}
}

101 static struct 
mp
 *

102 
	$mpsearch
(void)

104 
uint8_t
 *
bda
;

105 
uint32_t
 
p
;

106 struct 
mp
 *mp;

108 
	`static_assert
(sizeof(*
mp
) == 16);

111 
bda
 = (
uint8_t
 *) 
	`KADDR
(0x40 << 4);

115 if ((
p
 = *(
uint16_t
 *) (
bda
 + 0x0E))) {

116 
p
 <<= 4;

117 if ((
mp
 = 
	`mpsearch1
(
p
, 1024)))

118 return 
mp
;

122 
p
 = *(
uint16_t
 *) (
bda
 + 0x13) * 1024;

123 if ((
mp
 = 
	`mpsearch1
(
p
 - 1024, 1024)))

124 return 
mp
;

126 return 
	`mpsearch1
(0xF0000, 0x10000);

127 
	}
}

132 static struct 
mpconf
 *

133 
	$mpconfig
(struct 
mp
 **
pmp
)

135 struct 
mpconf
 *
conf
;

136 struct 
mp
 *mp;

138 if ((
mp
 = 
	`mpsearch
()) == 0)

139 return 
NULL
;

140 if (
mp
->
physaddr
 == 0 || mp->
type
 != 0) {

141 
	`cprintf
("SMP: Default configurations not implemented\n");

142 return 
NULL
;

144 
conf
 = (struct 
mpconf
 *) 
	`KADDR
(
mp
->
physaddr
);

145 if (
	`memcmp
(
conf
, "PCMP", 4) != 0) {

146 
	`cprintf
("SMP: Incorrect MP configuration table signature\n");

147 return 
NULL
;

149 if (
	`sum
(
conf
, conf->
length
) != 0) {

150 
	`cprintf
("SMP: Bad MP configuration checksum\n");

151 return 
NULL
;

153 if (
conf
->
version
 != 1 && conf->version != 4) {

154 
	`cprintf
("SMP: Unsupported MP version %d\n", 
conf
->
version
);

155 return 
NULL
;

157 if (
	`sum
((
uint8_t
 *)
conf
 + conf->
length
, conf->
xlength
) != conf->
xchecksum
) {

158 
	`cprintf
("SMP: Bad MP configuration extended checksum\n");

159 return 
NULL
;

161 *
pmp
 = 
mp
;

162 return 
conf
;

163 
	}
}

166 
	$mp_init
(void)

168 struct 
mp
 *mp;

169 struct 
mpconf
 *
conf
;

170 struct 
mpproc
 *
proc
;

171 
uint8_t
 *
p
;

172 unsigned int 
i
;

174 
bootcpu
 = &
cpus
[0];

175 if ((
conf
 = 
	`mpconfig
(&
mp
)) == 0)

177 
ismp
 = 1;

178 
lapic
 = (
uint32_t
 *)
conf
->
lapicaddr
;

180 for (
p
 = 
conf
->
entries
, 
i
 = 0; i < conf->
entry
; i++) {

181 switch (*
p
) {

182 case 
MPPROC
:

183 
proc
 = (struct 
mpproc
 *)
p
;

184 if (
proc
->
flags
 & 
MPPROC_BOOT
)

185 
bootcpu
 = &
cpus
[
ncpu
];

186 if (
ncpu
 < 
NCPU
) {

187 
cpus
[
ncpu
].
cpu_id
 = ncpu;

188 
ncpu
++;

190 
	`cprintf
("SMP: too many CPUs, CPU %d disabled\n",

191 
proc
->
apicid
);

193 
p
 += sizeof(struct 
mpproc
);

195 case 
MPBUS
:

196 case 
MPIOAPIC
:

197 case 
MPIOINTR
:

198 case 
MPLINTR
:

199 
p
 += 8;

202 
	`cprintf
("mpinit: unknown config type %x\n", *
p
);

203 
ismp
 = 0;

204 
i
 = 
conf
->
entry
;

208 
bootcpu
->
cpu_status
 = 
CPU_STARTED
;

209 if (!
ismp
) {

211 
ncpu
 = 1;

212 
lapic
 = 
NULL
;

213 
	`cprintf
("SMP: configuration not found, SMP disabled\n");

216 
	`cprintf
("SMP: CPU %d found %d CPU(s)\n", 
bootcpu
->
cpu_id
, 
ncpu
);

218 if (
mp
->
imcrp
) {

221 
	`cprintf
("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");

222 
	`outb
(0x22, 0x70);

223 
	`outb
(0x23, 
	`inb
(0x23) | 1);

225 
	}
}

	@/root/Robux/kern/pci.c

1 #include 
	~<inc/x86.h
>

2 #include 
	~<inc/assert.h
>

3 #include 
	~<inc/string.h
>

4 #include 
	~<kern/pci.h
>

5 #include 
	~<kern/pcireg.h
>

6 #include 
	~<kern/e1000.h
>

7 #include 
	~<kern/pmap.h
>

10 static int 
	gpci_show_devs
 = 1;

11 static int 
	gpci_show_addrs
 = 0;

14 static 
uint32_t
 
	gpci_conf1_addr_ioport
 = 0x0cf8;

15 static 
uint32_t
 
	gpci_conf1_data_ioport
 = 0x0cfc;

18 static int 
pci_bridge_attach
(struct 
pci_func
 *
pcif
);

19 static int 
pci_network_attach
(struct 
pci_func
 *
pcif
);

22 struct 
	spci_driver
 {

23 
uint32_t
 
	mkey1
, 
	mkey2
;

24 int (*
	mattachfn
) (struct 
pci_func
 *
	mpcif
);

28 struct 
pci_driver
 
	gpci_attach_class
[] = {

29 { 
PCI_CLASS_BRIDGE
, 
PCI_SUBCLASS_BRIDGE_PCI
, &
pci_bridge_attach
 },

34 struct 
pci_driver
 
	gpci_attach_vendor
[] = {

35 { 
E1000_VENDOR_ID
, 
E1000_DEVICE_ID
, &
pci_network_attach
},

40 
	$pci_conf1_set_addr
(
uint32_t
 
bus
,

41 
uint32_t
 
dev
,

42 
uint32_t
 
func
,

43 
uint32_t
 
offset
)

45 
	`assert
(
bus
 < 256);

46 
	`assert
(
dev
 < 32);

47 
	`assert
(
func
 < 8);

48 
	`assert
(
offset
 < 256);

49 
	`assert
((
offset
 & 0x3) == 0);

51 
uint32_t
 
v
 = (1 << 31) |

52 (
bus
 << 16) | (
dev
 << 11) | (
func
 << 8) | (
offset
);

53 
	`outl
(
pci_conf1_addr_ioport
, 
v
);

54 
	}
}

56 static 
uint32_t


57 
	$pci_conf_read
(struct 
pci_func
 *
f
, 
uint32_t
 
off
)

59 
	`pci_conf1_set_addr
(
f
->
bus
->
busno
, f->
dev
, f->
func
, 
off
);

60 return 
	`inl
(
pci_conf1_data_ioport
);

61 
	}
}

64 
	$pci_conf_write
(struct 
pci_func
 *
f
, 
uint32_t
 
off
, uint32_t 
v
)

66 
	`pci_conf1_set_addr
(
f
->
bus
->
busno
, f->
dev
, f->
func
, 
off
);

67 
	`outl
(
pci_conf1_data_ioport
, 
v
);

68 
	}
}

70 static int 
__attribute__
((
warn_unused_result
))

71 
	$pci_attach_match
(
uint32_t
 
key1
, uint32_t 
key2
,

72 struct 
pci_driver
 *
list
, struct 
pci_func
 *
pcif
)

74 
uint32_t
 
i
;

76 for (
i
 = 0; 
list
[i].
attachfn
; i++) {

77 if (
list
[
i
].
key1
 == key1 && list[i].
key2
 == key2) {

78 int 
r
 = 
list
[
i
].
	`attachfn
(
pcif
);

79 if (
r
 > 0)

80 return 
r
;

81 if (
r
 < 0)

82 
	`cprintf
("pci_attach_match: attaching "

84 
key1
, 
key2
, 
list
[
i
].
attachfn
, 
r
);

88 
	}
}

91 
	$pci_attach
(struct 
pci_func
 *
f
)

94 
	`pci_attach_match
(
	`PCI_CLASS
(
f
->
dev_class
),

95 
	`PCI_SUBCLASS
(
f
->
dev_class
),

96 &
pci_attach_class
[0], 
f
) ||

97 
	`pci_attach_match
(
	`PCI_VENDOR
(
f
->
dev_id
),

98 
	`PCI_PRODUCT
(
f
->
dev_id
),

99 &
pci_attach_vendor
[0], 
f
);

100 
	}
}

102 static const char *
	gpci_class
[] =

114 
	$pci_print_func
(struct 
pci_func
 *
f
)

116 const char *
class
 = 
pci_class
[0];

117 if (
	`PCI_CLASS
(
f
->
dev_class
) < sizeof(
pci_class
) / sizeof(pci_class[0]))

118 
class
 = 
pci_class
[
	`PCI_CLASS
(
f
->
dev_class
)];

120 
	`cprintf
("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",

121 
f
->
bus
->
busno
, f->
dev
, f->
func
,

122 
	`PCI_VENDOR
(
f
->
dev_id
), 
	`PCI_PRODUCT
(f->dev_id),

123 
	`PCI_CLASS
(
f
->
dev_class
), 
	`PCI_SUBCLASS
(f->dev_class), 
class
,

124 
f
->
irq_line
);

125 
	}
}

128 
	$pci_scan_bus
(struct 
pci_bus
 *
bus
)

130 int 
totaldev
 = 0;

131 struct 
pci_func
 
df
;

132 
	`memset
(&
df
, 0, sizeof(df));

133 
df
.
bus
 = bus;

135 for (
df
.
dev
 = 0; df.dev < 32; df.dev++) {

136 
uint32_t
 
bhlc
 = 
	`pci_conf_read
(&
df
, 
PCI_BHLC_REG
);

137 if (
	`PCI_HDRTYPE_TYPE
(
bhlc
) > 1)

140 
totaldev
++;

142 struct 
pci_func
 
f
 = 
df
;

143 for (
f
.
func
 = 0; f.func < (
	`PCI_HDRTYPE_MULTIFN
(
bhlc
) ? 8 : 1);

144 
f
.
func
++) {

145 struct 
pci_func
 
af
 = 
f
;

147 
af
.
dev_id
 = 
	`pci_conf_read
(&
f
, 
PCI_ID_REG
);

148 if (
	`PCI_VENDOR
(
af
.
dev_id
) == 0xffff)

151 
uint32_t
 
intr
 = 
	`pci_conf_read
(&
af
, 
PCI_INTERRUPT_REG
);

152 
af
.
irq_line
 = 
	`PCI_INTERRUPT_LINE
(
intr
);

154 
af
.
dev_class
 = 
	`pci_conf_read
(&af, 
PCI_CLASS_REG
);

155 if (
pci_show_devs
)

156 
	`pci_print_func
(&
af
);

157 
	`pci_attach
(&
af
);

161 return 
totaldev
;

162 
	}
}

165 
	$pci_bridge_attach
(struct 
pci_func
 *
pcif
)

167 
uint32_t
 
ioreg
 = 
	`pci_conf_read
(
pcif
, 
PCI_BRIDGE_STATIO_REG
);

168 
uint32_t
 
busreg
 = 
	`pci_conf_read
(
pcif
, 
PCI_BRIDGE_BUS_REG
);

170 if (
	`PCI_BRIDGE_IO_32BITS
(
ioreg
)) {

171 
	`cprintf
("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",

172 
pcif
->
bus
->
busno
, pcif->
dev
, pcif->
func
);

176 struct 
pci_bus
 
nbus
;

177 
	`memset
(&
nbus
, 0, sizeof(nbus));

178 
nbus
.
parent_bridge
 = 
pcif
;

179 
nbus
.
busno
 = (
busreg
 >> 
PCI_BRIDGE_BUS_SECONDARY_SHIFT
) & 0xff;

181 if (
pci_show_devs
)

182 
	`cprintf
("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",

183 
pcif
->
bus
->
busno
, pcif->
dev
, pcif->
func
,

184 
nbus
.
busno
,

185 (
busreg
 >> 
PCI_BRIDGE_BUS_SUBORDINATE_SHIFT
) & 0xff);

187 
	`pci_scan_bus
(&
nbus
);

189 
	}
}

194 extern volatile 
uint32_t
 *
e1000
;

197 
	$pci_network_attach
(struct 
pci_func
 *
pcif
)

199 
	`pci_func_enable
(
pcif
);

201 
	`cprintf
("Mapping va 0x%08x to phys 0x%08x size = %d (0x%x)\n", 
NETMEMBASE
, 
pcif
->
reg_base
[0], pcif->
reg_size
[0], pcif->reg_size[0]);

204 
	`boot_unmap_region
(
kern_pgdir
, 
NETMEMBASE
, 
	`ROUNDUP
(
pcif
->
reg_size
[0], 
PGSIZE
));

206 
	`boot_map_region
(
kern_pgdir
, 
NETMEMBASE
,

207 
	`ROUNDUP
(
pcif
->
reg_size
[0], 
PGSIZE
*1024),

208 
pcif
->
reg_base
[0],

209 
PTE_W
|
PTE_PCD
|
PTE_PWT
);

212 
e1000
 = (
uint32_t
*)
NETMEMBASE
;

214 
	`e1000_init_tx_desc_arr
();

215 
	`e1000_init_rx_desc_arr
();

217 
	`cprintf
("Check 0x%08x\n", 
e1000
[
	`E1000_INDEX
(
E1000_STATUS
)]);

220 
e1000
[
	`E1000_INDEX
(
E1000_TDBAL
)] = 
	`PADDR
((void*)
tx_desc_arr
);

221 
e1000
[
	`E1000_INDEX
(
E1000_TDLEN
)] = 
E1000_NUM_DESC
*sizeof(struct 
tx_desc
);

222 
e1000
[
	`E1000_INDEX
(
E1000_TDH
)] = 0x00;

223 
e1000
[
	`E1000_INDEX
(
E1000_TDT
)] = 0x00;

226 
e1000
[
	`E1000_INDEX
(
E1000_TCTL
)] |= 
E1000_TCTL_EN_FLAG
;

227 
e1000
[
	`E1000_INDEX
(
E1000_TCTL
)] |= 
E1000_TCTL_PSP_FLAG
;

228 
e1000
[
	`E1000_INDEX
(
E1000_TCTL
)] |= 
E1000_TCTL_CT_DEFAULT
;

229 
e1000
[
	`E1000_INDEX
(
E1000_TCTL
)] |= 
E1000_TCTL_COLD_FULLD
;

231 
e1000
[
	`E1000_INDEX
(
E1000_TIPG
)] = 
E1000_TIPG_IEEE8023_DEFAULT
;

234 
e1000
[
	`E1000_INDEX
(
E1000_RDBAL
)] = 
	`PADDR
((void*)
rx_desc_arr
);

235 
e1000
[
	`E1000_INDEX
(
E1000_RDLEN
)] = 
E1000_NUM_DESC
*sizeof(struct 
rx_desc
);

236 
e1000
[
	`E1000_INDEX
(
E1000_RDH
)] = 0x00;

237 
e1000
[
	`E1000_INDEX
(
E1000_RDT
)] = 
E1000_NUM_DESC
 - 1;

240 
uint8_t
 
mac
[6];

241 
	`e1000_read_mac
(
mac
);

242 
e1000
[
	`E1000_INDEX
(
E1000_RAL
)] = 
mac
[3] << 24 |

243 
mac
[2] << 16 |

244 
mac
[1] << 8 |

245 
mac
[0];

246 
e1000
[
	`E1000_INDEX
(
E1000_RAH
)] = 
mac
[5]<<8 | mac[4] | 
E1000_RAH_AV
;

251 
e1000
[
	`E1000_INDEX
(
E1000_RCTL
)] = 
E1000_RCTL_EN_FLAG
 |

252 
E1000_RCTL_BSIZE_256
 |

253 
E1000_RCTL_BSEX
 |

254 
E1000_RCTL_SECRC
;

258 
	}
}

263 
	$pci_func_enable
(struct 
pci_func
 *
f
)

265 
	`pci_conf_write
(
f
, 
PCI_COMMAND_STATUS_REG
,

266 
PCI_COMMAND_IO_ENABLE
 |

267 
PCI_COMMAND_MEM_ENABLE
 |

268 
PCI_COMMAND_MASTER_ENABLE
);

270 
uint32_t
 
bar_width
;

271 
uint32_t
 
bar
;

272 for (
bar
 = 
PCI_MAPREG_START
; bar < 
PCI_MAPREG_END
;

273 
bar
 += 
bar_width
)

275 
uint32_t
 
oldv
 = 
	`pci_conf_read
(
f
, 
bar
);

277 
bar_width
 = 4;

278 
	`pci_conf_write
(
f
, 
bar
, 0xffffffff);

279 
uint32_t
 
rv
 = 
	`pci_conf_read
(
f
, 
bar
);

281 if (
rv
 == 0)

284 int 
regnum
 = 
	`PCI_MAPREG_NUM
(
bar
);

285 
uint32_t
 
base
, 
size
;

286 if (
	`PCI_MAPREG_TYPE
(
rv
) == 
PCI_MAPREG_TYPE_MEM
) {

287 if (
	`PCI_MAPREG_MEM_TYPE
(
rv
) == 
PCI_MAPREG_MEM_TYPE_64BIT
)

288 
bar_width
 = 8;

290 
size
 = 
	`PCI_MAPREG_MEM_SIZE
(
rv
);

291 
base
 = 
	`PCI_MAPREG_MEM_ADDR
(
oldv
);

292 if (
pci_show_addrs
)

293 
	`cprintf
(" mem region %d: %d bytes at 0x%x\n",

294 
regnum
, 
size
, 
base
);

296 
size
 = 
	`PCI_MAPREG_IO_SIZE
(
rv
);

297 
base
 = 
	`PCI_MAPREG_IO_ADDR
(
oldv
);

298 if (
pci_show_addrs
)

299 
	`cprintf
(" io region %d: %d bytes at 0x%x\n",

300 
regnum
, 
size
, 
base
);

303 
	`pci_conf_write
(
f
, 
bar
, 
oldv
);

304 
f
->
reg_base
[
regnum
] = 
base
;

305 
f
->
reg_size
[
regnum
] = 
size
;

307 if (
size
 && !
base
)

308 
	`cprintf
("PCI device %02x:%02x.%d (%04x:%04x) "

311 
f
->
bus
->
busno
, f->
dev
, f->
func
,

312 
	`PCI_VENDOR
(
f
->
dev_id
), 
	`PCI_PRODUCT
(f->dev_id),

313 
regnum
, 
base
, 
size
);

316 
	`cprintf
("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",

317 
f
->
bus
->
busno
, f->
dev
, f->
func
,

318 
	`PCI_VENDOR
(
f
->
dev_id
), 
	`PCI_PRODUCT
(f->dev_id));

319 
	}
}

322 
	$pci_init
(void)

324 static struct 
pci_bus
 
root_bus
;

325 
	`memset
(&
root_bus
, 0, sizeof(root_bus));

327 return 
	`pci_scan_bus
(&
root_bus
);

328 
	}
}

	@/root/Robux/kern/pci.h

1 #ifndef 
JOS_KERN_PCI_H


2 #define 
	#JOS_KERN_PCI_H


	)

4 #include 
	~<inc/types.h
>

7 enum { 
	mpci_res_bus
, 
	mpci_res_mem
, 
	mpci_res_io
, 
	mpci_res_max
 };

9 struct 
	gpci_bus
;

11 struct 
	spci_func
 {

12 struct 
pci_bus
 *
	mbus
;

14 
uint32_t
 
	mdev
;

15 
uint32_t
 
	mfunc
;

17 
uint32_t
 
	mdev_id
;

18 
uint32_t
 
	mdev_class
;

20 
uint32_t
 
	mreg_base
[6];

21 
uint32_t
 
	mreg_size
[6];

22 
uint8_t
 
	mirq_line
;

25 struct 
	spci_bus
 {

26 struct 
pci_func
 *
	mparent_bridge
;

27 
uint32_t
 
	mbusno
;

30 int 
pci_init
(void);

31 void 
pci_func_enable
(struct 
pci_func
 *
f
);

	@/root/Robux/kern/pcireg.h

34 #ifndef 
_DEV_PCI_PCIREG_H_


35 #define 
	#_DEV_PCI_PCIREG_H_


	)

43 #include 
	~<inc/types.h
>

48 #define 
	#PCI_ID_REG
 0x00

	)

50 typedef 
uint16_t
 
	tpci_vendor_id_t
;

51 typedef 
uint16_t
 
	tpci_product_id_t
;

53 #define 
	#PCI_VENDOR_SHIFT
 0

	)

54 #define 
	#PCI_VENDOR_MASK
 0xffff

	)

55 #define 
	#PCI_VENDOR
(
id
) \

56 (((
id
) >> 
PCI_VENDOR_SHIFT
) & 
PCI_VENDOR_MASK
)

	)

58 #define 
	#PCI_PRODUCT_SHIFT
 16

	)

59 #define 
	#PCI_PRODUCT_MASK
 0xffff

	)

60 #define 
	#PCI_PRODUCT
(
id
) \

61 (((
id
) >> 
PCI_PRODUCT_SHIFT
) & 
PCI_PRODUCT_MASK
)

	)

63 #define 
	#PCI_ID_CODE
(
vid
,
pid
) \

64 ((((
vid
) & 
PCI_VENDOR_MASK
) << 
PCI_VENDOR_SHIFT
) | \

65 (((
pid
) & 
PCI_PRODUCT_MASK
) << 
PCI_PRODUCT_SHIFT
)) \

66 

	)

70 #define 
	#PCI_COMMAND_STATUS_REG
 0x04

	)

71 #define 
	#PCI_COMMAND_SHIFT
 0

	)

72 #define 
	#PCI_COMMAND_MASK
 0xffff

	)

73 #define 
	#PCI_STATUS_SHIFT
 16

	)

74 #define 
	#PCI_STATUS_MASK
 0xffff

	)

76 #define 
	#PCI_COMMAND_STATUS_CODE
(
cmd
,
stat
) \

77 ((((
cmd
) & 
PCI_COMMAND_MASK
) >> 
PCI_COMMAND_SHIFT
) | \

78 (((
stat
) & 
PCI_STATUS_MASK
) >> 
PCI_STATUS_SHIFT
)) \

79 

	)

80 #define 
	#PCI_COMMAND_IO_ENABLE
 0x00000001

	)

81 #define 
	#PCI_COMMAND_MEM_ENABLE
 0x00000002

	)

82 #define 
	#PCI_COMMAND_MASTER_ENABLE
 0x00000004

	)

83 #define 
	#PCI_COMMAND_SPECIAL_ENABLE
 0x00000008

	)

84 #define 
	#PCI_COMMAND_INVALIDATE_ENABLE
 0x00000010

	)

85 #define 
	#PCI_COMMAND_PALETTE_ENABLE
 0x00000020

	)

86 #define 
	#PCI_COMMAND_PARITY_ENABLE
 0x00000040

	)

87 #define 
	#PCI_COMMAND_STEPPING_ENABLE
 0x00000080

	)

88 #define 
	#PCI_COMMAND_SERR_ENABLE
 0x00000100

	)

89 #define 
	#PCI_COMMAND_BACKTOBACK_ENABLE
 0x00000200

	)

91 #define 
	#PCI_STATUS_CAPLIST_SUPPORT
 0x00100000

	)

92 #define 
	#PCI_STATUS_66MHZ_SUPPORT
 0x00200000

	)

93 #define 
	#PCI_STATUS_UDF_SUPPORT
 0x00400000

	)

94 #define 
	#PCI_STATUS_BACKTOBACK_SUPPORT
 0x00800000

	)

95 #define 
	#PCI_STATUS_PARITY_ERROR
 0x01000000

	)

96 #define 
	#PCI_STATUS_DEVSEL_FAST
 0x00000000

	)

97 #define 
	#PCI_STATUS_DEVSEL_MEDIUM
 0x02000000

	)

98 #define 
	#PCI_STATUS_DEVSEL_SLOW
 0x04000000

	)

99 #define 
	#PCI_STATUS_DEVSEL_MASK
 0x06000000

	)

100 #define 
	#PCI_STATUS_TARGET_TARGET_ABORT
 0x08000000

	)

101 #define 
	#PCI_STATUS_MASTER_TARGET_ABORT
 0x10000000

	)

102 #define 
	#PCI_STATUS_MASTER_ABORT
 0x20000000

	)

103 #define 
	#PCI_STATUS_SPECIAL_ERROR
 0x40000000

	)

104 #define 
	#PCI_STATUS_PARITY_DETECT
 0x80000000

	)

109 #define 
	#PCI_CLASS_REG
 0x08

	)

111 typedef 
uint8_t
 
	tpci_class_t
;

112 typedef 
uint8_t
 
	tpci_subclass_t
;

113 typedef 
uint8_t
 
	tpci_interface_t
;

114 typedef 
uint8_t
 
	tpci_revision_t
;

116 #define 
	#PCI_CLASS_SHIFT
 24

	)

117 #define 
	#PCI_CLASS_MASK
 0xff

	)

118 #define 
	#PCI_CLASS
(
cr
) \

119 (((
cr
) >> 
PCI_CLASS_SHIFT
) & 
PCI_CLASS_MASK
)

	)

121 #define 
	#PCI_SUBCLASS_SHIFT
 16

	)

122 #define 
	#PCI_SUBCLASS_MASK
 0xff

	)

123 #define 
	#PCI_SUBCLASS
(
cr
) \

124 (((
cr
) >> 
PCI_SUBCLASS_SHIFT
) & 
PCI_SUBCLASS_MASK
)

	)

126 #define 
	#PCI_INTERFACE_SHIFT
 8

	)

127 #define 
	#PCI_INTERFACE_MASK
 0xff

	)

128 #define 
	#PCI_INTERFACE
(
cr
) \

129 (((
cr
) >> 
PCI_INTERFACE_SHIFT
) & 
PCI_INTERFACE_MASK
)

	)

131 #define 
	#PCI_REVISION_SHIFT
 0

	)

132 #define 
	#PCI_REVISION_MASK
 0xff

	)

133 #define 
	#PCI_REVISION
(
cr
) \

134 (((
cr
) >> 
PCI_REVISION_SHIFT
) & 
PCI_REVISION_MASK
)

	)

136 #define 
	#PCI_CLASS_CODE
(
mainclass
, 
subclass
, 
interface
) \

137 ((((
mainclass
) & 
PCI_CLASS_MASK
) << 
PCI_CLASS_SHIFT
) | \

138 (((
subclass
) & 
PCI_SUBCLASS_MASK
) << 
PCI_SUBCLASS_SHIFT
) | \

139 (((
interface
) & 
PCI_INTERFACE_MASK
) << 
PCI_INTERFACE_SHIFT
))

	)

142 #define 
	#PCI_CLASS_PREHISTORIC
 0x00

	)

143 #define 
	#PCI_CLASS_MASS_STORAGE
 0x01

	)

144 #define 
	#PCI_CLASS_NETWORK
 0x02

	)

145 #define 
	#PCI_CLASS_DISPLAY
 0x03

	)

146 #define 
	#PCI_CLASS_MULTIMEDIA
 0x04

	)

147 #define 
	#PCI_CLASS_MEMORY
 0x05

	)

148 #define 
	#PCI_CLASS_BRIDGE
 0x06

	)

149 #define 
	#PCI_CLASS_COMMUNICATIONS
 0x07

	)

150 #define 
	#PCI_CLASS_SYSTEM
 0x08

	)

151 #define 
	#PCI_CLASS_INPUT
 0x09

	)

152 #define 
	#PCI_CLASS_DOCK
 0x0a

	)

153 #define 
	#PCI_CLASS_PROCESSOR
 0x0b

	)

154 #define 
	#PCI_CLASS_SERIALBUS
 0x0c

	)

155 #define 
	#PCI_CLASS_WIRELESS
 0x0d

	)

156 #define 
	#PCI_CLASS_I2O
 0x0e

	)

157 #define 
	#PCI_CLASS_SATCOM
 0x0f

	)

158 #define 
	#PCI_CLASS_CRYPTO
 0x10

	)

159 #define 
	#PCI_CLASS_DASP
 0x11

	)

160 #define 
	#PCI_CLASS_UNDEFINED
 0xff

	)

163 #define 
	#PCI_SUBCLASS_PREHISTORIC_MISC
 0x00

	)

164 #define 
	#PCI_SUBCLASS_PREHISTORIC_VGA
 0x01

	)

167 #define 
	#PCI_SUBCLASS_MASS_STORAGE_SCSI
 0x00

	)

168 #define 
	#PCI_SUBCLASS_MASS_STORAGE_IDE
 0x01

	)

169 #define 
	#PCI_SUBCLASS_MASS_STORAGE_FLOPPY
 0x02

	)

170 #define 
	#PCI_SUBCLASS_MASS_STORAGE_IPI
 0x03

	)

171 #define 
	#PCI_SUBCLASS_MASS_STORAGE_RAID
 0x04

	)

172 #define 
	#PCI_SUBCLASS_MASS_STORAGE_ATA
 0x05

	)

173 #define 
	#PCI_SUBCLASS_MASS_STORAGE_SATA
 0x06

	)

174 #define 
	#PCI_SUBCLASS_MASS_STORAGE_MISC
 0x80

	)

177 #define 
	#PCI_SUBCLASS_NETWORK_ETHERNET
 0x00

	)

178 #define 
	#PCI_SUBCLASS_NETWORK_TOKENRING
 0x01

	)

179 #define 
	#PCI_SUBCLASS_NETWORK_FDDI
 0x02

	)

180 #define 
	#PCI_SUBCLASS_NETWORK_ATM
 0x03

	)

181 #define 
	#PCI_SUBCLASS_NETWORK_ISDN
 0x04

	)

182 #define 
	#PCI_SUBCLASS_NETWORK_WORLDFIP
 0x05

	)

183 #define 
	#PCI_SUBCLASS_NETWORK_PCIMGMULTICOMP
 0x06

	)

184 #define 
	#PCI_SUBCLASS_NETWORK_MISC
 0x80

	)

187 #define 
	#PCI_SUBCLASS_DISPLAY_VGA
 0x00

	)

188 #define 
	#PCI_SUBCLASS_DISPLAY_XGA
 0x01

	)

189 #define 
	#PCI_SUBCLASS_DISPLAY_3D
 0x02

	)

190 #define 
	#PCI_SUBCLASS_DISPLAY_MISC
 0x80

	)

193 #define 
	#PCI_SUBCLASS_MULTIMEDIA_VIDEO
 0x00

	)

194 #define 
	#PCI_SUBCLASS_MULTIMEDIA_AUDIO
 0x01

	)

195 #define 
	#PCI_SUBCLASS_MULTIMEDIA_TELEPHONY
 0x02

	)

196 #define 
	#PCI_SUBCLASS_MULTIMEDIA_MISC
 0x80

	)

199 #define 
	#PCI_SUBCLASS_MEMORY_RAM
 0x00

	)

200 #define 
	#PCI_SUBCLASS_MEMORY_FLASH
 0x01

	)

201 #define 
	#PCI_SUBCLASS_MEMORY_MISC
 0x80

	)

204 #define 
	#PCI_SUBCLASS_BRIDGE_HOST
 0x00

	)

205 #define 
	#PCI_SUBCLASS_BRIDGE_ISA
 0x01

	)

206 #define 
	#PCI_SUBCLASS_BRIDGE_EISA
 0x02

	)

207 #define 
	#PCI_SUBCLASS_BRIDGE_MC
 0x03

	)

208 #define 
	#PCI_SUBCLASS_BRIDGE_PCI
 0x04

	)

209 #define 
	#PCI_SUBCLASS_BRIDGE_PCMCIA
 0x05

	)

210 #define 
	#PCI_SUBCLASS_BRIDGE_NUBUS
 0x06

	)

211 #define 
	#PCI_SUBCLASS_BRIDGE_CARDBUS
 0x07

	)

212 #define 
	#PCI_SUBCLASS_BRIDGE_RACEWAY
 0x08

	)

213 #define 
	#PCI_SUBCLASS_BRIDGE_STPCI
 0x09

	)

214 #define 
	#PCI_SUBCLASS_BRIDGE_INFINIBAND
 0x0a

	)

215 #define 
	#PCI_SUBCLASS_BRIDGE_MISC
 0x80

	)

218 #define 
	#PCI_SUBCLASS_COMMUNICATIONS_SERIAL
 0x00

	)

219 #define 
	#PCI_SUBCLASS_COMMUNICATIONS_PARALLEL
 0x01

	)

220 #define 
	#PCI_SUBCLASS_COMMUNICATIONS_MPSERIAL
 0x02

	)

221 #define 
	#PCI_SUBCLASS_COMMUNICATIONS_MODEM
 0x03

	)

222 #define 
	#PCI_SUBCLASS_COMMUNICATIONS_GPIB
 0x04

	)

223 #define 
	#PCI_SUBCLASS_COMMUNICATIONS_SMARTCARD
 0x05

	)

224 #define 
	#PCI_SUBCLASS_COMMUNICATIONS_MISC
 0x80

	)

227 #define 
	#PCI_SUBCLASS_SYSTEM_PIC
 0x00

	)

228 #define 
	#PCI_SUBCLASS_SYSTEM_DMA
 0x01

	)

229 #define 
	#PCI_SUBCLASS_SYSTEM_TIMER
 0x02

	)

230 #define 
	#PCI_SUBCLASS_SYSTEM_RTC
 0x03

	)

231 #define 
	#PCI_SUBCLASS_SYSTEM_PCIHOTPLUG
 0x04

	)

232 #define 
	#PCI_SUBCLASS_SYSTEM_MISC
 0x80

	)

235 #define 
	#PCI_SUBCLASS_INPUT_KEYBOARD
 0x00

	)

236 #define 
	#PCI_SUBCLASS_INPUT_DIGITIZER
 0x01

	)

237 #define 
	#PCI_SUBCLASS_INPUT_MOUSE
 0x02

	)

238 #define 
	#PCI_SUBCLASS_INPUT_SCANNER
 0x03

	)

239 #define 
	#PCI_SUBCLASS_INPUT_GAMEPORT
 0x04

	)

240 #define 
	#PCI_SUBCLASS_INPUT_MISC
 0x80

	)

243 #define 
	#PCI_SUBCLASS_DOCK_GENERIC
 0x00

	)

244 #define 
	#PCI_SUBCLASS_DOCK_MISC
 0x80

	)

247 #define 
	#PCI_SUBCLASS_PROCESSOR_386
 0x00

	)

248 #define 
	#PCI_SUBCLASS_PROCESSOR_486
 0x01

	)

249 #define 
	#PCI_SUBCLASS_PROCESSOR_PENTIUM
 0x02

	)

250 #define 
	#PCI_SUBCLASS_PROCESSOR_ALPHA
 0x10

	)

251 #define 
	#PCI_SUBCLASS_PROCESSOR_POWERPC
 0x20

	)

252 #define 
	#PCI_SUBCLASS_PROCESSOR_MIPS
 0x30

	)

253 #define 
	#PCI_SUBCLASS_PROCESSOR_COPROC
 0x40

	)

256 #define 
	#PCI_SUBCLASS_SERIALBUS_FIREWIRE
 0x00

	)

257 #define 
	#PCI_SUBCLASS_SERIALBUS_ACCESS
 0x01

	)

258 #define 
	#PCI_SUBCLASS_SERIALBUS_SSA
 0x02

	)

259 #define 
	#PCI_SUBCLASS_SERIALBUS_USB
 0x03

	)

260 #define 
	#PCI_SUBCLASS_SERIALBUS_FIBER
 0x04

	)

261 #define 
	#PCI_SUBCLASS_SERIALBUS_SMBUS
 0x05

	)

262 #define 
	#PCI_SUBCLASS_SERIALBUS_INFINIBAND
 0x06

	)

263 #define 
	#PCI_SUBCLASS_SERIALBUS_IPMI
 0x07

	)

264 #define 
	#PCI_SUBCLASS_SERIALBUS_SERCOS
 0x08

	)

265 #define 
	#PCI_SUBCLASS_SERIALBUS_CANBUS
 0x09

	)

268 #define 
	#PCI_SUBCLASS_WIRELESS_IRDA
 0x00

	)

269 #define 
	#PCI_SUBCLASS_WIRELESS_CONSUMERIR
 0x01

	)

270 #define 
	#PCI_SUBCLASS_WIRELESS_RF
 0x10

	)

271 #define 
	#PCI_SUBCLASS_WIRELESS_BLUETOOTH
 0x11

	)

272 #define 
	#PCI_SUBCLASS_WIRELESS_BROADBAND
 0x12

	)

273 #define 
	#PCI_SUBCLASS_WIRELESS_802_11A
 0x20

	)

274 #define 
	#PCI_SUBCLASS_WIRELESS_802_11B
 0x21

	)

275 #define 
	#PCI_SUBCLASS_WIRELESS_MISC
 0x80

	)

278 #define 
	#PCI_SUBCLASS_I2O_STANDARD
 0x00

	)

282 #define 
	#PCI_SUBCLASS_SATCOM_TV
 0x01

	)

283 #define 
	#PCI_SUBCLASS_SATCOM_AUDIO
 0x02

	)

284 #define 
	#PCI_SUBCLASS_SATCOM_VOICE
 0x03

	)

285 #define 
	#PCI_SUBCLASS_SATCOM_DATA
 0x04

	)

288 #define 
	#PCI_SUBCLASS_CRYPTO_NETCOMP
 0x00

	)

289 #define 
	#PCI_SUBCLASS_CRYPTO_ENTERTAINMENT
 0x10

	)

290 #define 
	#PCI_SUBCLASS_CRYPTO_MISC
 0x80

	)

293 #define 
	#PCI_SUBCLASS_DASP_DPIO
 0x00

	)

294 #define 
	#PCI_SUBCLASS_DASP_TIMEFREQ
 0x01

	)

295 #define 
	#PCI_SUBCLASS_DASP_SYNC
 0x10

	)

296 #define 
	#PCI_SUBCLASS_DASP_MGMT
 0x20

	)

297 #define 
	#PCI_SUBCLASS_DASP_MISC
 0x80

	)

302 #define 
	#PCI_BHLC_REG
 0x0c

	)

304 #define 
	#PCI_BIST_SHIFT
 24

	)

305 #define 
	#PCI_BIST_MASK
 0xff

	)

306 #define 
	#PCI_BIST
(
bhlcr
) \

307 (((
bhlcr
) >> 
PCI_BIST_SHIFT
) & 
PCI_BIST_MASK
)

	)

309 #define 
	#PCI_HDRTYPE_SHIFT
 16

	)

310 #define 
	#PCI_HDRTYPE_MASK
 0xff

	)

311 #define 
	#PCI_HDRTYPE
(
bhlcr
) \

312 (((
bhlcr
) >> 
PCI_HDRTYPE_SHIFT
) & 
PCI_HDRTYPE_MASK
)

	)

314 #define 
	#PCI_HDRTYPE_TYPE
(
bhlcr
) \

315 (
	`PCI_HDRTYPE
(
bhlcr
) & 0x7f)

	)

316 #define 
	#PCI_HDRTYPE_MULTIFN
(
bhlcr
) \

317 ((
	`PCI_HDRTYPE
(
bhlcr
) & 0x80) != 0)

	)

319 #define 
	#PCI_LATTIMER_SHIFT
 8

	)

320 #define 
	#PCI_LATTIMER_MASK
 0xff

	)

321 #define 
	#PCI_LATTIMER
(
bhlcr
) \

322 (((
bhlcr
) >> 
PCI_LATTIMER_SHIFT
) & 
PCI_LATTIMER_MASK
)

	)

324 #define 
	#PCI_CACHELINE_SHIFT
 0

	)

325 #define 
	#PCI_CACHELINE_MASK
 0xff

	)

326 #define 
	#PCI_CACHELINE
(
bhlcr
) \

327 (((
bhlcr
) >> 
PCI_CACHELINE_SHIFT
) & 
PCI_CACHELINE_MASK
)

	)

329 #define 
	#PCI_BHLC_CODE
(
bist
,
type
,
multi
,
latency
,
cacheline
) \

330 ((((
bist
) & 
PCI_BIST_MASK
) << 
PCI_BIST_SHIFT
) | \

331 (((
type
) & 
PCI_HDRTYPE_MASK
) << 
PCI_HDRTYPE_SHIFT
) | \

332 (((
multi
)?0x80:0) << 
PCI_HDRTYPE_SHIFT
) | \

333 (((
latency
) & 
PCI_LATTIMER_MASK
) << 
PCI_LATTIMER_SHIFT
) | \

334 (((
cacheline
) & 
PCI_CACHELINE_MASK
) << 
PCI_CACHELINE_SHIFT
))

	)

339 #define 
	#PCI_HDRTYPE_DEVICE
 0

	)

340 #define 
	#PCI_HDRTYPE_PPB
 1

	)

341 #define 
	#PCI_HDRTYPE_PCB
 2

	)

346 #define 
	#PCI_MAPREG_START
 0x10

	)

347 #define 
	#PCI_MAPREG_END
 0x28

	)

348 #define 
	#PCI_MAPREG_ROM
 0x30

	)

349 #define 
	#PCI_MAPREG_PPB_END
 0x18

	)

350 #define 
	#PCI_MAPREG_PCB_END
 0x14

	)

352 #define 
	#PCI_MAPREG_TYPE
(
mr
) \

353 ((
mr
) & 
PCI_MAPREG_TYPE_MASK
)

	)

354 #define 
	#PCI_MAPREG_TYPE_MASK
 0x00000001

	)

356 #define 
	#PCI_MAPREG_TYPE_MEM
 0x00000000

	)

357 #define 
	#PCI_MAPREG_TYPE_IO
 0x00000001

	)

358 #define 
	#PCI_MAPREG_ROM_ENABLE
 0x00000001

	)

360 #define 
	#PCI_MAPREG_MEM_TYPE
(
mr
) \

361 ((
mr
) & 
PCI_MAPREG_MEM_TYPE_MASK
)

	)

362 #define 
	#PCI_MAPREG_MEM_TYPE_MASK
 0x00000006

	)

364 #define 
	#PCI_MAPREG_MEM_TYPE_32BIT
 0x00000000

	)

365 #define 
	#PCI_MAPREG_MEM_TYPE_32BIT_1M
 0x00000002

	)

366 #define 
	#PCI_MAPREG_MEM_TYPE_64BIT
 0x00000004

	)

368 #define 
	#PCI_MAPREG_MEM_PREFETCHABLE
(
mr
) \

369 (((
mr
) & 
PCI_MAPREG_MEM_PREFETCHABLE_MASK
) != 0)

	)

370 #define 
	#PCI_MAPREG_MEM_PREFETCHABLE_MASK
 0x00000008

	)

372 #define 
	#PCI_MAPREG_MEM_ADDR
(
mr
) \

373 ((
mr
) & 
PCI_MAPREG_MEM_ADDR_MASK
)

	)

374 #define 
	#PCI_MAPREG_MEM_SIZE
(
mr
) \

375 (
	`PCI_MAPREG_MEM_ADDR
(
mr
) & -PCI_MAPREG_MEM_ADDR(mr))

	)

376 #define 
	#PCI_MAPREG_MEM_ADDR_MASK
 0xfffffff0

	)

378 #define 
	#PCI_MAPREG_MEM64_ADDR
(
mr
) \

379 ((
mr
) & 
PCI_MAPREG_MEM64_ADDR_MASK
)

	)

380 #define 
	#PCI_MAPREG_MEM64_SIZE
(
mr
) \

381 (
	`PCI_MAPREG_MEM64_ADDR
(
mr
) & -PCI_MAPREG_MEM64_ADDR(mr))

	)

382 #define 
	#PCI_MAPREG_MEM64_ADDR_MASK
 0xfffffffffffffff0ULL

	)

384 #define 
	#PCI_MAPREG_IO_ADDR
(
mr
) \

385 ((
mr
) & 
PCI_MAPREG_IO_ADDR_MASK
)

	)

386 #define 
	#PCI_MAPREG_IO_SIZE
(
mr
) \

387 (
	`PCI_MAPREG_IO_ADDR
(
mr
) & -PCI_MAPREG_IO_ADDR(mr))

	)

388 #define 
	#PCI_MAPREG_IO_ADDR_MASK
 0xfffffffc

	)

390 #define 
	#PCI_MAPREG_SIZE_TO_MASK
(
size
) \

391 (-(
size
))

	)

393 #define 
	#PCI_MAPREG_NUM
(
offset
) \

394 (((unsigned)(
offset
)-
PCI_MAPREG_START
)/4)

	)

400 #define 
	#PCI_CARDBUS_CIS_REG
 0x28

	)

407 #define 
	#PCI_SUBSYS_ID_REG
 0x2c

	)

412 #define 
	#PCI_CAPLISTPTR_REG
 0x34

	)

413 #define 
	#PCI_CARDBUS_CAPLISTPTR_REG
 0x14

	)

414 #define 
	#PCI_CAPLIST_PTR
(
cpr
) ((cpr) & 0xff)

	)

415 #define 
	#PCI_CAPLIST_NEXT
(
cr
) (((cr) >> 8) & 0xff)

	)

416 #define 
	#PCI_CAPLIST_CAP
(
cr
) ((cr) & 0xff)

	)

418 #define 
	#PCI_CAP_RESERVED0
 0x00

	)

419 #define 
	#PCI_CAP_PWRMGMT
 0x01

	)

420 #define 
	#PCI_CAP_AGP
 0x02

	)

421 #define 
	#PCI_CAP_AGP_MAJOR
(
cr
) (((cr) >> 20) & 0xf)

	)

422 #define 
	#PCI_CAP_AGP_MINOR
(
cr
) (((cr) >> 16) & 0xf)

	)

423 #define 
	#PCI_CAP_VPD
 0x03

	)

424 #define 
	#PCI_CAP_SLOTID
 0x04

	)

425 #define 
	#PCI_CAP_MSI
 0x05

	)

426 #define 
	#PCI_CAP_CPCI_HOTSWAP
 0x06

	)

427 #define 
	#PCI_CAP_PCIX
 0x07

	)

428 #define 
	#PCI_CAP_LDT
 0x08

	)

429 #define 
	#PCI_CAP_VENDSPEC
 0x09

	)

430 #define 
	#PCI_CAP_DEBUGPORT
 0x0a

	)

431 #define 
	#PCI_CAP_CPCI_RSRCCTL
 0x0b

	)

432 #define 
	#PCI_CAP_HOTPLUG
 0x0c

	)

433 #define 
	#PCI_CAP_AGP8
 0x0e

	)

434 #define 
	#PCI_CAP_SECURE
 0x0f

	)

435 #define 
	#PCI_CAP_PCIEXPRESS
 0x10

	)

436 #define 
	#PCI_CAP_MSIX
 0x11

	)

441 #define 
	#PCI_VPD_ADDRESS_MASK
 0x7fff

	)

442 #define 
	#PCI_VPD_ADDRESS_SHIFT
 16

	)

443 #define 
	#PCI_VPD_ADDRESS
(
ofs
) \

444 (((
ofs
) & 
PCI_VPD_ADDRESS_MASK
) << 
PCI_VPD_ADDRESS_SHIFT
)

	)

445 #define 
	#PCI_VPD_DATAREG
(
ofs
) ((ofs) + 4)

	)

446 #define 
	#PCI_VPD_OPFLAG
 0x80000000

	)

453 #define 
	#PCI_PMCR
 0x02

	)

454 #define 
	#PCI_PMCR_D1SUPP
 0x0200

	)

455 #define 
	#PCI_PMCR_D2SUPP
 0x0400

	)

457 #define 
	#PCI_PMCSR
 0x04

	)

458 #define 
	#PCI_PMCSR_STATE_MASK
 0x03

	)

459 #define 
	#PCI_PMCSR_STATE_D0
 0x00

	)

460 #define 
	#PCI_PMCSR_STATE_D1
 0x01

	)

461 #define 
	#PCI_PMCSR_STATE_D2
 0x02

	)

462 #define 
	#PCI_PMCSR_STATE_D3
 0x03

	)

477 #define 
	#PCI_PCIX_CMD
 0x00

	)

478 #define 
	#PCI_PCIX_CMD_PERR_RECOVER
 0x00010000

	)

479 #define 
	#PCI_PCIX_CMD_RELAXED_ORDER
 0x00020000

	)

480 #define 
	#PCI_PCIX_CMD_BYTECNT_MASK
 0x000c0000

	)

481 #define 
	#PCI_PCIX_CMD_BYTECNT_SHIFT
 18

	)

482 #define 
	#PCI_PCIX_CMD_BCNT_512
 0x00000000

	)

483 #define 
	#PCI_PCIX_CMD_BCNT_1024
 0x00040000

	)

484 #define 
	#PCI_PCIX_CMD_BCNT_2048
 0x00080000

	)

485 #define 
	#PCI_PCIX_CMD_BCNT_4096
 0x000c0000

	)

486 #define 
	#PCI_PCIX_CMD_SPLTRANS_MASK
 0x00700000

	)

487 #define 
	#PCI_PCIX_CMD_SPLTRANS_1
 0x00000000

	)

488 #define 
	#PCI_PCIX_CMD_SPLTRANS_2
 0x00100000

	)

489 #define 
	#PCI_PCIX_CMD_SPLTRANS_3
 0x00200000

	)

490 #define 
	#PCI_PCIX_CMD_SPLTRANS_4
 0x00300000

	)

491 #define 
	#PCI_PCIX_CMD_SPLTRANS_8
 0x00400000

	)

492 #define 
	#PCI_PCIX_CMD_SPLTRANS_12
 0x00500000

	)

493 #define 
	#PCI_PCIX_CMD_SPLTRANS_16
 0x00600000

	)

494 #define 
	#PCI_PCIX_CMD_SPLTRANS_32
 0x00700000

	)

499 #define 
	#PCI_PCIX_STATUS
 0x04

	)

500 #define 
	#PCI_PCIX_STATUS_FN_MASK
 0x00000007

	)

501 #define 
	#PCI_PCIX_STATUS_DEV_MASK
 0x000000f8

	)

502 #define 
	#PCI_PCIX_STATUS_BUS_MASK
 0x0000ff00

	)

503 #define 
	#PCI_PCIX_STATUS_64BIT
 0x00010000

	)

504 #define 
	#PCI_PCIX_STATUS_133
 0x00020000

	)

505 #define 
	#PCI_PCIX_STATUS_SPLDISC
 0x00040000

	)

506 #define 
	#PCI_PCIX_STATUS_SPLUNEX
 0x00080000

	)

507 #define 
	#PCI_PCIX_STATUS_DEVCPLX
 0x00100000

	)

508 #define 
	#PCI_PCIX_STATUS_MAXB_MASK
 0x00600000

	)

509 #define 
	#PCI_PCIX_STATUS_MAXB_SHIFT
 21

	)

510 #define 
	#PCI_PCIX_STATUS_MAXB_512
 0x00000000

	)

511 #define 
	#PCI_PCIX_STATUS_MAXB_1024
 0x00200000

	)

512 #define 
	#PCI_PCIX_STATUS_MAXB_2048
 0x00400000

	)

513 #define 
	#PCI_PCIX_STATUS_MAXB_4096
 0x00600000

	)

514 #define 
	#PCI_PCIX_STATUS_MAXST_MASK
 0x03800000

	)

515 #define 
	#PCI_PCIX_STATUS_MAXST_1
 0x00000000

	)

516 #define 
	#PCI_PCIX_STATUS_MAXST_2
 0x00800000

	)

517 #define 
	#PCI_PCIX_STATUS_MAXST_3
 0x01000000

	)

518 #define 
	#PCI_PCIX_STATUS_MAXST_4
 0x01800000

	)

519 #define 
	#PCI_PCIX_STATUS_MAXST_8
 0x02000000

	)

520 #define 
	#PCI_PCIX_STATUS_MAXST_12
 0x02800000

	)

521 #define 
	#PCI_PCIX_STATUS_MAXST_16
 0x03000000

	)

522 #define 
	#PCI_PCIX_STATUS_MAXST_32
 0x03800000

	)

523 #define 
	#PCI_PCIX_STATUS_MAXRS_MASK
 0x1c000000

	)

524 #define 
	#PCI_PCIX_STATUS_MAXRS_1K
 0x00000000

	)

525 #define 
	#PCI_PCIX_STATUS_MAXRS_2K
 0x04000000

	)

526 #define 
	#PCI_PCIX_STATUS_MAXRS_4K
 0x08000000

	)

527 #define 
	#PCI_PCIX_STATUS_MAXRS_8K
 0x0c000000

	)

528 #define 
	#PCI_PCIX_STATUS_MAXRS_16K
 0x10000000

	)

529 #define 
	#PCI_PCIX_STATUS_MAXRS_32K
 0x14000000

	)

530 #define 
	#PCI_PCIX_STATUS_MAXRS_64K
 0x18000000

	)

531 #define 
	#PCI_PCIX_STATUS_MAXRS_128K
 0x1c000000

	)

532 #define 
	#PCI_PCIX_STATUS_SCERR
 0x20000000

	)

538 #define 
	#PCI_INTERRUPT_REG
 0x3c

	)

540 typedef 
uint8_t
 
	tpci_intr_latency_t
;

541 typedef 
uint8_t
 
	tpci_intr_grant_t
;

542 typedef 
uint8_t
 
	tpci_intr_pin_t
;

543 typedef 
uint8_t
 
	tpci_intr_line_t
;

545 #define 
	#PCI_MAX_LAT_SHIFT
 24

	)

546 #define 
	#PCI_MAX_LAT_MASK
 0xff

	)

547 #define 
	#PCI_MAX_LAT
(
icr
) \

548 (((
icr
) >> 
PCI_MAX_LAT_SHIFT
) & 
PCI_MAX_LAT_MASK
)

	)

550 #define 
	#PCI_MIN_GNT_SHIFT
 16

	)

551 #define 
	#PCI_MIN_GNT_MASK
 0xff

	)

552 #define 
	#PCI_MIN_GNT
(
icr
) \

553 (((
icr
) >> 
PCI_MIN_GNT_SHIFT
) & 
PCI_MIN_GNT_MASK
)

	)

555 #define 
	#PCI_INTERRUPT_GRANT_SHIFT
 24

	)

556 #define 
	#PCI_INTERRUPT_GRANT_MASK
 0xff

	)

557 #define 
	#PCI_INTERRUPT_GRANT
(
icr
) \

558 (((
icr
) >> 
PCI_INTERRUPT_GRANT_SHIFT
) & 
PCI_INTERRUPT_GRANT_MASK
)

	)

560 #define 
	#PCI_INTERRUPT_LATENCY_SHIFT
 16

	)

561 #define 
	#PCI_INTERRUPT_LATENCY_MASK
 0xff

	)

562 #define 
	#PCI_INTERRUPT_LATENCY
(
icr
) \

563 (((
icr
) >> 
PCI_INTERRUPT_LATENCY_SHIFT
) & 
PCI_INTERRUPT_LATENCY_MASK
)

	)

565 #define 
	#PCI_INTERRUPT_PIN_SHIFT
 8

	)

566 #define 
	#PCI_INTERRUPT_PIN_MASK
 0xff

	)

567 #define 
	#PCI_INTERRUPT_PIN
(
icr
) \

568 (((
icr
) >> 
PCI_INTERRUPT_PIN_SHIFT
) & 
PCI_INTERRUPT_PIN_MASK
)

	)

570 #define 
	#PCI_INTERRUPT_LINE_SHIFT
 0

	)

571 #define 
	#PCI_INTERRUPT_LINE_MASK
 0xff

	)

572 #define 
	#PCI_INTERRUPT_LINE
(
icr
) \

573 (((
icr
) >> 
PCI_INTERRUPT_LINE_SHIFT
) & 
PCI_INTERRUPT_LINE_MASK
)

	)

575 #define 
	#PCI_INTERRUPT_CODE
(
lat
,
gnt
,
pin
,
line
) \

576 ((((
lat
)&
PCI_INTERRUPT_LATENCY_MASK
)<<
PCI_INTERRUPT_LATENCY_SHIFT
)| \

577 (((
gnt
)&
PCI_INTERRUPT_GRANT_MASK
) <<
PCI_INTERRUPT_GRANT_SHIFT
) | \

578 (((
pin
)&
PCI_INTERRUPT_PIN_MASK
) <<
PCI_INTERRUPT_PIN_SHIFT
) | \

579 (((
line
)&
PCI_INTERRUPT_LINE_MASK
) <<
PCI_INTERRUPT_LINE_SHIFT
))

	)

581 #define 
	#PCI_INTERRUPT_PIN_NONE
 0x00

	)

582 #define 
	#PCI_INTERRUPT_PIN_A
 0x01

	)

583 #define 
	#PCI_INTERRUPT_PIN_B
 0x02

	)

584 #define 
	#PCI_INTERRUPT_PIN_C
 0x03

	)

585 #define 
	#PCI_INTERRUPT_PIN_D
 0x04

	)

586 #define 
	#PCI_INTERRUPT_PIN_MAX
 0x04

	)

589 #define 
	#PCI_BRIDGE_BUS_REG
 0x18

	)

590 #define 
	#PCI_BRIDGE_BUS_PRIMARY_SHIFT
 0

	)

591 #define 
	#PCI_BRIDGE_BUS_SECONDARY_SHIFT
 8

	)

592 #define 
	#PCI_BRIDGE_BUS_SUBORDINATE_SHIFT
 16

	)

594 #define 
	#PCI_BRIDGE_STATIO_REG
 0x1C

	)

595 #define 
	#PCI_BRIDGE_STATIO_IOBASE_SHIFT
 0

	)

596 #define 
	#PCI_BRIDGE_STATIO_IOLIMIT_SHIFT
 8

	)

597 #define 
	#PCI_BRIDGE_STATIO_STATUS_SHIFT
 16

	)

598 #define 
	#PCI_BRIDGE_STATIO_IOBASE_MASK
 0xf0

	)

599 #define 
	#PCI_BRIDGE_STATIO_IOLIMIT_MASK
 0xf0

	)

600 #define 
	#PCI_BRIDGE_STATIO_STATUS_MASK
 0xffff

	)

601 #define 
	#PCI_BRIDGE_IO_32BITS
(
reg
) (((reg) & 0xf) == 1)

	)

603 #define 
	#PCI_BRIDGE_MEMORY_REG
 0x20

	)

604 #define 
	#PCI_BRIDGE_MEMORY_BASE_SHIFT
 4

	)

605 #define 
	#PCI_BRIDGE_MEMORY_LIMIT_SHIFT
 20

	)

606 #define 
	#PCI_BRIDGE_MEMORY_BASE_MASK
 0xffff

	)

607 #define 
	#PCI_BRIDGE_MEMORY_LIMIT_MASK
 0xffff

	)

609 #define 
	#PCI_BRIDGE_PREFETCHMEM_REG
 0x24

	)

610 #define 
	#PCI_BRIDGE_PREFETCHMEM_BASE_SHIFT
 4

	)

611 #define 
	#PCI_BRIDGE_PREFETCHMEM_LIMIT_SHIFT
 20

	)

612 #define 
	#PCI_BRIDGE_PREFETCHMEM_BASE_MASK
 0xffff

	)

613 #define 
	#PCI_BRIDGE_PREFETCHMEM_LIMIT_MASK
 0xffff

	)

614 #define 
	#PCI_BRIDGE_PREFETCHMEM_64BITS
(
reg
) ((reg) & 0xf)

	)

616 #define 
	#PCI_BRIDGE_PREFETCHBASE32_REG
 0x28

	)

617 #define 
	#PCI_BRIDGE_PREFETCHLIMIT32_REG
 0x2C

	)

619 #define 
	#PCI_BRIDGE_IOHIGH_REG
 0x30

	)

620 #define 
	#PCI_BRIDGE_IOHIGH_BASE_SHIFT
 0

	)

621 #define 
	#PCI_BRIDGE_IOHIGH_LIMIT_SHIFT
 16

	)

622 #define 
	#PCI_BRIDGE_IOHIGH_BASE_MASK
 0xffff

	)

623 #define 
	#PCI_BRIDGE_IOHIGH_LIMIT_MASK
 0xffff

	)

625 #define 
	#PCI_BRIDGE_CONTROL_REG
 0x3C

	)

626 #define 
	#PCI_BRIDGE_CONTROL_SHIFT
 16

	)

627 #define 
	#PCI_BRIDGE_CONTROL_MASK
 0xffff

	)

628 #define 
	#PCI_BRIDGE_CONTROL_PERE
 (1 << 0)

	)

629 #define 
	#PCI_BRIDGE_CONTROL_SERR
 (1 << 1)

	)

630 #define 
	#PCI_BRIDGE_CONTROL_ISA
 (1 << 2)

	)

631 #define 
	#PCI_BRIDGE_CONTROL_VGA
 (1 << 3)

	)

633 #define 
	#PCI_BRIDGE_CONTROL_MABRT
 (1 << 5)

	)

634 #define 
	#PCI_BRIDGE_CONTROL_SECBR
 (1 << 6)

	)

635 #define 
	#PCI_BRIDGE_CONTROL_SECFASTB2B
 (1 << 7)

	)

636 #define 
	#PCI_BRIDGE_CONTROL_PRI_DISC_TIMER
 (1 << 8)

	)

637 #define 
	#PCI_BRIDGE_CONTROL_SEC_DISC_TIMER
 (1 << 9)

	)

638 #define 
	#PCI_BRIDGE_CONTROL_DISC_TIMER_STAT
 (1 << 10)

	)

639 #define 
	#PCI_BRIDGE_CONTROL_DISC_TIMER_SERR
 (1 << 11)

	)

645 struct 
	spci_vpd_smallres
 {

646 
uint8_t
 
	mvpdres_byte0
;

648 } 
__attribute__
((
__packed__
));

650 struct 
	spci_vpd_largeres
 {

651 
uint8_t
 
	mvpdres_byte0
;

652 
uint8_t
 
	mvpdres_len_lsb
;

653 
uint8_t
 
	mvpdres_len_msb
;

655 } 
__attribute__
((
__packed__
));

657 #define 
	#PCI_VPDRES_ISLARGE
(
x
) ((x) & 0x80)

	)

659 #define 
	#PCI_VPDRES_SMALL_LENGTH
(
x
) ((x) & 0x7)

	)

660 #define 
	#PCI_VPDRES_SMALL_NAME
(
x
) (((x) >> 3) & 0xf)

	)

662 #define 
	#PCI_VPDRES_LARGE_NAME
(
x
) ((x) & 0x7f)

	)

664 #define 
	#PCI_VPDRES_TYPE_COMPATIBLE_DEVICE_ID
 0x3

	)

665 #define 
	#PCI_VPDRES_TYPE_VENDOR_DEFINED
 0xe

	)

666 #define 
	#PCI_VPDRES_TYPE_END_TAG
 0xf

	)

668 #define 
	#PCI_VPDRES_TYPE_IDENTIFIER_STRING
 0x02

	)

669 #define 
	#PCI_VPDRES_TYPE_VPD
 0x10

	)

671 struct 
	spci_vpd
 {

672 
uint8_t
 
	mvpd_key0
;

673 
uint8_t
 
	mvpd_key1
;

674 
uint8_t
 
	mvpd_len
;

676 } 
__attribute__
((
__packed__
));

708 #define 
	#PCI32_DMA_BOUNCE_THRESHOLD
 0x100000000ULL

	)

	@/root/Robux/kern/picirq.c

3 #include 
	~<inc/assert.h
>

4 #include 
	~<inc/trap.h
>

6 #include 
	~<kern/picirq.h
>

11 
uint16_t
 
	girq_mask_8259A
 = 0xFFFF & ~(1<<
IRQ_SLAVE
);

12 static 
bool
 
	gdidinit
;

16 
	$pic_init
(void)

18 
didinit
 = 1;

21 
	`outb
(
IO_PIC1
+1, 0xFF);

22 
	`outb
(
IO_PIC2
+1, 0xFF);

30 
	`outb
(
IO_PIC1
, 0x11);

33 
	`outb
(
IO_PIC1
+1, 
IRQ_OFFSET
);

37 
	`outb
(
IO_PIC1
+1, 1<<
IRQ_SLAVE
);

47 
	`outb
(
IO_PIC1
+1, 0x3);

50 
	`outb
(
IO_PIC2
, 0x11);

51 
	`outb
(
IO_PIC2
+1, 
IRQ_OFFSET
 + 8);

52 
	`outb
(
IO_PIC2
+1, 
IRQ_SLAVE
);

55 
	`outb
(
IO_PIC2
+1, 0x01);

61 
	`outb
(
IO_PIC1
, 0x68);

62 
	`outb
(
IO_PIC1
, 0x0a);

64 
	`outb
(
IO_PIC2
, 0x68);

65 
	`outb
(
IO_PIC2
, 0x0a);

67 if (
irq_mask_8259A
 != 0xFFFF)

68 
	`irq_setmask_8259A
(
irq_mask_8259A
);

69 
	}
}

72 
	$irq_setmask_8259A
(
uint16_t
 
mask
)

74 int 
i
;

75 
irq_mask_8259A
 = 
mask
;

76 if (!
didinit
)

78 
	`outb
(
IO_PIC1
+1, (char)
mask
);

79 
	`outb
(
IO_PIC2
+1, (char)(
mask
 >> 8));

80 
	`cprintf
("enabled interrupts:");

81 for (
i
 = 0; i < 16; i++)

82 if (~
mask
 & (1<<
i
))

83 
	`cprintf
(" %d", 
i
);

84 
	`cprintf
("\n");

85 
	}
}

88 
	$irq_eoi
(void)

95 
	`outb
(
IO_PIC1
, 0x20);

96 
	`outb
(
IO_PIC2
, 0x20);

97 
	}
}

	@/root/Robux/kern/picirq.h

3 #ifndef 
JOS_KERN_PICIRQ_H


4 #define 
	#JOS_KERN_PICIRQ_H


	)

5 #ifndef 
JOS_KERNEL


9 #define 
	#MAX_IRQS
 16

10 

	)

12 #define 
	#IO_PIC1
 0x20

13 #define 
	#IO_PIC2
 0xA0

14 

	)

15 #define 
	#IRQ_SLAVE
 2

16 

	)

18 #ifndef 
__ASSEMBLER__


20 #include 
	~<inc/types.h
>

21 #include 
	~<inc/x86.h
>

23 extern 
uint16_t
 
irq_mask_8259A
;

24 void 
pic_init
(void);

25 void 
irq_setmask_8259A
(
uint16_t
 
mask
);

26 void 
irq_eoi
(void);

	@/root/Robux/kern/pmap.c

3 #include 
	~<inc/x86.h
>

4 #include 
	~<inc/mmu.h
>

5 #include 
	~<inc/error.h
>

6 #include 
	~<inc/string.h
>

7 #include 
	~<inc/assert.h
>

9 #include 
	~<kern/pmap.h
>

10 #include 
	~<kern/kclock.h
>

11 #include 
	~<kern/env.h
>

12 #include 
	~<kern/cpu.h
>

15 
size_t
 
	gnpages
;

16 static 
size_t
 
	gnpages_basemem
;

19 
pde_t
 *
	gkern_pgdir
;

20 struct 
Page
 *
	gpages
;

21 static struct 
Page
 *
	gpage_free_list
;

29 
	$nvram_read
(int 
r
)

31 return 
	`mc146818_read
(
r
) | (mc146818_read(r + 1) << 8);

32 
	}
}

35 
	$i386_detect_memory
(void)

37 
size_t
 
npages_extmem
;

41 
npages_basemem
 = (
	`nvram_read
(
NVRAM_BASELO
) * 1024) / 
PGSIZE
;

42 
npages_extmem
 = (
	`nvram_read
(
NVRAM_EXTLO
) * 1024) / 
PGSIZE
;

46 if (
npages_extmem
)

47 
npages
 = (
EXTPHYSMEM
 / 
PGSIZE
) + 
npages_extmem
;

49 
npages
 = 
npages_basemem
;

51 
	`cprintf
("Physical memory: %uK available, base = %uK, extended = %uK\n",

52 
npages
 * 
PGSIZE
 / 1024,

53 
npages_basemem
 * 
PGSIZE
 / 1024,

54 
npages_extmem
 * 
PGSIZE
 / 1024);

55 
	}
}

62 static void 
mem_init_mp
(void);

63 static void 
check_page_free_list
(
bool
 
only_low_memory
);

64 static void 
check_page_alloc
(void);

65 static void 
check_kern_pgdir
(void);

66 static 
physaddr_t
 
check_va2pa
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
);

67 static void 
check_page
(void);

68 static void 
check_page_installed_pgdir
(void);

83 
	$boot_alloc
(
uint32_t
 
n
)

85 static char *
nextfree
;

93 if (!
nextfree
) {

94 extern char 
end
[];

95 
nextfree
 = 
	`ROUNDUP
((char *) 
end
, 
PGSIZE
);

98 if (
n
 == 0)

99 return 
nextfree
;

101 if ((
uint32_t
)(
	`PADDR
(
nextfree
)+
n
) > 
npages
*
PGSIZE
)

102 
	`panic
("Not enough memory");

110 char *
ret
 = 
nextfree
;

111 
nextfree
 += 
	`ROUNDUP
(
n
, 
PGSIZE
);

113 return 
ret
;

114 
	}
}

126 
	$mem_init
(void)

128 
uint32_t
 
cr0
;

129 
size_t
 
n
;

132 
	`i386_detect_memory
();

139 
kern_pgdir
 = (
pde_t
 *) 
	`boot_alloc
(
PGSIZE
);

140 
	`memset
(
kern_pgdir
, 0, 
PGSIZE
);

149 
kern_pgdir
[
	`PDX
(
UVPT
)] = 
	`PADDR
(kern_pgdir) | 
PTE_U
 | 
PTE_P
;

157 
pages
 = (struct 
Page
*) 
	`boot_alloc
(sizeof(struct Page) * 
npages
);

163 
envs
 = (struct 
Env
*) 
	`boot_alloc
(sizeof(struct Env) * 
NENV
);

171 
	`page_init
();

173 
	`check_page_free_list
(1);

174 
	`check_page_alloc
();

175 
	`check_page
();

186 
	`boot_map_region
(
kern_pgdir
,

187 
UPAGES
,

188 
	`ROUNDUP
(
npages
*sizeof(struct 
Page
), 
PGSIZE
),

189 
	`PADDR
(
pages
),

190 
PTE_U
);

200 
	`boot_map_region
(
kern_pgdir
,

201 
UENVS
,

202 
	`ROUNDUP
(
NENV
*sizeof(struct 
Env
), 
PGSIZE
),

203 
	`PADDR
(
envs
),

204 
PTE_U
);

216 
uint32_t
 
i
;

217 for (
i
 = 0; i < 
KSTKSIZE
; i+=
PGSIZE
)

219 struct 
Page
 *
page
 = 
	`pa2page
(
	`PADDR
(
bootstack
)+
i
);

220 if (!
page
)

221 
	`panic
("Out of memory for kernel stack\n");

222 if (
	`page_insert
(
kern_pgdir
, 
page
, (void*)(
KSTACKTOP
-
KSTKSIZE
 + 
i
), 
PTE_W
) < 0)

223 
	`panic
("Failed to allocate page table\n");

226 void *
va
;

227 for (
va
 = (void*)
KSTACKTOP
-
PTSIZE
; va < (void*)KSTACKTOP-
KSTKSIZE
; va += 
PGSIZE
)

229 
	`page_remove
(
kern_pgdir
, 
va
);

242 if (!
	`cpu_has_pse
())

245 
	`boot_map_region
(
kern_pgdir
,

246 
KERNBASE
,

247 (0xFFFFF000 - 
KERNBASE
 ),

249 
PTE_W
);

253 
	`cpu_activate_pse
();

256 
	`boot_map_region_pse
(
kern_pgdir
,

257 
KERNBASE
,

258 (0xFFFFF000 - 
KERNBASE
 ),

260 
PTE_W
);

264 
	`mem_init_mp
();

267 
	`check_kern_pgdir
();

276 
	`lcr3
(
	`PADDR
(
kern_pgdir
));

278 
	`check_page_free_list
(0);

282 
cr0
 = 
	`rcr0
();

283 
cr0
 |= 
CR0_PE
|
CR0_PG
|
CR0_AM
|
CR0_WP
|
CR0_NE
|
CR0_MP
;

284 
cr0
 &= ~(
CR0_TS
|
CR0_EM
);

285 
	`lcr0
(
cr0
);

288 
	`check_page_installed_pgdir
();

289 
	}
}

297 
	$mem_init_mp
(void)

302 if (
	`cpu_has_pse
())

304 
	`boot_map_region_pse
(
kern_pgdir
, 
IOMEMBASE
, -IOMEMBASE - 
PGSIZE
, 
IOMEM_PADDR
, 
PTE_W
);

308 
	`boot_map_region
(
kern_pgdir
, 
IOMEMBASE
, -IOMEMBASE - 
PGSIZE
, 
IOMEM_PADDR
, 
PTE_W
);

326 
uint32_t
 
i
;

327 
uint32_t
 
j
;

328 for (
i
 = 0; i < 
NCPU
; i++)

330 
uint32_t
 
kstacktop_i
 = 
KSTACKTOP
 - 
i
 * (
KSTKSIZE
 + 
KSTKGAP
);

331 for (
j
 = 0; j < 
KSTKSIZE
; j+=
PGSIZE
)

333 struct 
Page
 *
page
 = 
	`pa2page
(
	`PADDR
(
percpu_kstacks
[
i
])+
j
);

334 if (!
page
)

335 
	`panic
("Out of memory for CPU %d kstack\n", 
i
);

336 if (
	`page_insert
(
kern_pgdir
, 
page
,

337 (void*)(
kstacktop_i
-
KSTKSIZE
 + 
j
), 
PTE_W
) < 0)

338 
	`panic
("Failed to allocate page table for CPU %d kstack alloc\n", 
i
);

341 void *
va
;

342 for (
va
 = (void*)
kstacktop_i
-(
KSTKSIZE
 + 
KSTKGAP
);

343 
va
 < (void*)
kstacktop_i
-
KSTKSIZE
; va += 
PGSIZE
)

345 
	`page_remove
(
kern_pgdir
, 
va
);

349 
	}
}

355 
	$boot_unmap_region
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
, 
size_t
 
size
)

357 
uintptr_t
 
virt
;

358 for(
virt
 = 
va
; virt < va+
size
; virt += 
PGSIZE
)

360 
pde_t
 *
entry
 = &
pgdir
[
	`PDX
(
virt
)];

362 if(!(*
entry
 & 
PTE_P
))

366 if(*
entry
 & 
PTE_PS
)

368 *
entry
 = 0;

373 
pte_t
 *
pte
 = 
	`pgdir_walk
(
pgdir
, (void*)
virt
, 0);

374 *
pte
 = 0;

377 
	}
}

392 
	$page_init
(void)

416 
page_free_list
 = 0;

418 
size_t
 
i
;

420 for (
i
 = 0; i < 
npages
; i++) {

430 if (
i
 == 0 ||

431 (
i
 >= 
IOPHYSMEM
/
PGSIZE
 && i < 
EXTPHYSMEM
/PGSIZE) ||

432 (
i
 >= 
EXTPHYSMEM
/
PGSIZE
 && (i < 
	`PADDR
(
	`boot_alloc
(0))/PGSIZE)) ||

433 (
i
 == 
MPENTRY_PADDR
/
PGSIZE
))

436 
pages
[
i
].
pp_ref
 = 1;

437 
pages
[
i
].
pp_link
 = 0;

441 
pages
[
i
].
pp_ref
 = 0;

442 
pages
[
i
].
pp_link
 = 
page_free_list
;

443 
page_free_list
 = &
pages
[
i
];

446 
	}
}

457 struct 
Page
 *

458 
	$page_alloc
(int 
alloc_flags
)

462 if (
page_free_list
 == 
NULL
)

463 return 
NULL
;

467 struct 
Page
 *
ret
 = 
page_free_list
;

468 
page_free_list
 = page_free_list->
pp_link
;

471 if (
alloc_flags
 & 
ALLOC_ZERO
)

473 
	`memset
(
	`page2kva
(
ret
), '\0', 
PGSIZE
);

476 return 
ret
;

477 
	}
}

484 
	$page_free
(struct 
Page
 *
pp
)

488 
pp
->
pp_link
 = 
page_free_list
;

489 
page_free_list
 = 
pp
;

490 
	}
}

497 
	$page_decref
(struct 
Page
* 
pp
)

499 if (--
pp
->
pp_ref
 == 0)

500 
	`page_free
(
pp
);

501 
	}
}

525 
pte_t
 *

526 
	$pgdir_walk
(
pde_t
 *
pgdir
, const void *
va
, int 
create
)

531 if (!(
pgdir
[
	`PDX
(
va
)] & 
PTE_P
) && 
create
)

533 struct 
Page
 *
new_page
 = 
	`page_alloc
(
ALLOC_ZERO
);

535 if (
new_page
 == 
NULL
)

537 return 
NULL
;

540 
new_page
->
pp_ref
 += 1;

542 
pgdir
[
	`PDX
(
va
)] = 
	`page2pa
(
new_page
) | 
PTE_P
 | 
PTE_W
 | 
PTE_U
;

545 if (
pgdir
[
	`PDX
(
va
)] & 
PTE_P
)

548 
pte_t
 *
pgtab
 = 
	`KADDR
(
	`PTE_ADDR
(
pgdir
[
	`PDX
(
va
)]));

551 return &
pgtab
[
	`PTX
(
va
)];

555 return 
NULL
;

558 
	}
}

571 
	$boot_map_region
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
, 
size_t
 
size
, 
physaddr_t
 
pa
, int 
perm
)

573 
uintptr_t
 
virt
;

574 
physaddr_t
 
phys
;

576 for (
virt
=
va
, 
phys
=
pa
; virt < va+
size
; virt += 
PGSIZE
, phys+= PGSIZE)

579 
pte_t
 *
pte
 = 
	`pgdir_walk
(
pgdir
, (void*)
virt
, 1);

580 if (!
pte
)

581 
	`panic
("Failed to allocate page table");

582 *
pte
 = (
phys
 & (~0xFFF)) | 
perm
 | 
PTE_P
;

584 
	}
}

592 
	$boot_map_region_pse
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
, 
size_t
 
size
, 
physaddr_t
 
pa
, int 
perm
)

594 
uintptr_t
 
virt
;

595 
physaddr_t
 
phys
;

598 
	`cprintf
("PSE MAPPING [0x%08x, 0x%08x] to [0x%08x, 0x%08x]\n", 
pa
, 
	`ROUNDUP
(pa+
size
, 
PGSIZE
*1024)-1, 
va
, ROUNDUP(va+size, PGSIZE*1024)-1);

600 for (
virt
=
va
, 
phys
=
pa
; virt < va+
size
; virt += 
PGSIZE
, phys+= PGSIZE)

602 
pde_t
 *
entry
 = &
pgdir
[
	`PDX
(
virt
)];

603 *
entry
 = (
phys
 & 0xFFC00000) | 
perm
 | 
PTE_PS
 | 
PTE_P
;

605 
	}
}

633 
	$page_insert
(
pde_t
 *
pgdir
, struct 
Page
 *
pp
, void *
va
, int 
perm
)

635 
pte_t
 *
pte
 = 
	`pgdir_walk
(
pgdir
, 
va
, 1);

636 if (!
pte
)

637 return -
E_NO_MEM
;

642 
pp
->
pp_ref
 += 1;

643 
	`page_remove
(
pgdir
, 
va
);

645 *
pte
 = 
	`page2pa
(
pp
) | 
PTE_P
 | 
perm
;

647 
	}
}

660 struct 
Page
 *

661 
	$page_lookup
(
pde_t
 *
pgdir
, void *
va
, 
pte_t
 **
pte_store
)

667 
pte_t
 *
pte
 = 
	`pgdir_walk
(
pgdir
, 
va
, 0);

669 if (
pte_store
)

671 *
pte_store
 = 
pte
;

676 if ((!
pte
) || !(*pte & 
PTE_P
))

678 return 
NULL
;

682 return 
	`pa2page
(
	`PTE_ADDR
(*
pte
));

685 
	}
}

703 
	$page_remove
(
pde_t
 *
pgdir
, void *
va
)

705 
pte_t
 *
pte
;

706 struct 
Page
 *
page
 = 
	`page_lookup
(
pgdir
, 
va
, &
pte
);

708 if (
page
)

710 
	`page_decref
(
page
);

711 *
pte
 = 0;

712 
	`tlb_invalidate
(
pgdir
, 
va
);

714 
	}
}

721 
	$tlb_invalidate
(
pde_t
 *
pgdir
, void *
va
)

724 if (!
curenv
 || curenv->
env_pgdir
 == 
pgdir
)

725 
	`invlpg
(
va
);

726 
	}
}

728 static 
uintptr_t
 
	guser_mem_check_addr
;

731 #define 
	#ADDRMAX
(
a
, 
b
) ((
uint32_t
)a < (uint32_t)b)?(uint32_t)b:(uint32_t)
	)
a

752 
	$user_mem_check
(struct 
Env
 *
env
, const void *
va
, 
size_t
 
len
, int 
perm
)

757 
uint32_t
 
current
 = 
	`ROUNDDOWN
((uint32_t)
va
, 
PGSIZE
);

758 
pde_t
 *
pagedir
 = 
env
->
env_pgdir
;

761 
perm
 |= 
PTE_P
;

764 for (; 
current
 < 
	`ROUNDUP
((
uint32_t
)
va
 + 
len
, 
PGSIZE
); current += PGSIZE)

768 if (
current
 >= 
ULIM
)

773 
user_mem_check_addr
 = 
	`ADDRMAX
(
va
, 
current
);

774 return -
E_FAULT
;

777 
pde_t
 
pde
 = 
pagedir
[
	`PDX
(
current
)];

780 if ((
pde
 & 
perm
) != perm)

782 
user_mem_check_addr
 = 
	`ADDRMAX
(
va
, 
current
);

783 return -
E_FAULT
;

788 if (!(
pde
 & 
PTE_PS
))

790 
pte_t
 
pte
 = ((pte_t *)
	`KADDR
(
	`PTE_ADDR
(
pde
)))[
	`PTX
(
current
)];

792 if ((
pte
 & 
perm
) != perm)

794 
user_mem_check_addr
 = 
	`ADDRMAX
(
va
, 
current
);

795 return -
E_FAULT
;

801 
	}
}

811 
	$user_mem_assert
(struct 
Env
 *
env
, const void *
va
, 
size_t
 
len
, int 
perm
)

813 if (
	`user_mem_check
(
env
, 
va
, 
len
, 
perm
 | 
PTE_U
) < 0) {

814 
	`cprintf
("[%08x] user_mem_check assertion failure for "

815 "va %08x\n", 
env
->
env_id
, 
user_mem_check_addr
);

816 
	`env_destroy
(
env
);

818 
	}
}

829 
	$check_page_free_list
(
bool
 
only_low_memory
)

831 struct 
Page
 *
pp
;

832 unsigned 
pdx_limit
 = 
only_low_memory
 ? 1 : 
NPDENTRIES
;

833 int 
nfree_basemem
 = 0, 
nfree_extmem
 = 0;

834 char *
first_free_page
;

836 if (!
page_free_list
)

837 
	`panic
("'page_free_list' is a null pointer!");

839 if (
only_low_memory
) {

842 struct 
Page
 *
pp1
, *
pp2
;

843 struct 
Page
 **
tp
[2] = { &
pp1
, &
pp2
 };

844 for (
pp
 = 
page_free_list
; pp; pp = pp->
pp_link
) {

845 int 
pagetype
 = 
	`PDX
(
	`page2pa
(
pp
)) >= 
pdx_limit
;

846 *
tp
[
pagetype
] = 
pp
;

847 
tp
[
pagetype
] = &
pp
->
pp_link
;

849 *
tp
[1] = 0;

850 *
tp
[0] = 
pp2
;

851 
page_free_list
 = 
pp1
;

856 for (
pp
 = 
page_free_list
; pp; pp = pp->
pp_link
)

857 if (
	`PDX
(
	`page2pa
(
pp
)) < 
pdx_limit
)

858 
	`memset
(
	`page2kva
(
pp
), 0x97, 128);

860 
first_free_page
 = (char *) 
	`boot_alloc
(0);

861 for (
pp
 = 
page_free_list
; pp; pp = pp->
pp_link
) {

863 
	`assert
(
pp
 >= 
pages
);

864 
	`assert
(
pp
 < 
pages
 + 
npages
);

865 
	`assert
(((char *) 
pp
 - (char *) 
pages
) % sizeof(*pp) == 0);

868 
	`assert
(
	`page2pa
(
pp
) != 0);

869 
	`assert
(
	`page2pa
(
pp
) != 
IOPHYSMEM
);

870 
	`assert
(
	`page2pa
(
pp
) != 
EXTPHYSMEM
 - 
PGSIZE
);

871 
	`assert
(
	`page2pa
(
pp
) != 
EXTPHYSMEM
);

872 
	`assert
(
	`page2pa
(
pp
) < 
EXTPHYSMEM
 || (char *) 
	`page2kva
(pp) >= 
first_free_page
);

874 
	`assert
(
	`page2pa
(
pp
) != 
MPENTRY_PADDR
);

876 if (
	`page2pa
(
pp
) < 
EXTPHYSMEM
)

877 ++
nfree_basemem
;

879 ++
nfree_extmem
;

882 
	`assert
(
nfree_basemem
 > 0);

883 
	`assert
(
nfree_extmem
 > 0);

884 
	}
}

891 
	$check_page_alloc
(void)

893 struct 
Page
 *
pp
, *
pp0
, *
pp1
, *
pp2
;

894 int 
nfree
;

895 struct 
Page
 *
fl
;

896 char *
c
;

897 int 
i
;

899 if (!
pages
)

900 
	`panic
("'pages' is a null pointer!");

903 for (
pp
 = 
page_free_list
, 
nfree
 = 0; pp; pp = pp->
pp_link
)

904 ++
nfree
;

907 
pp0
 = 
pp1
 = 
pp2
 = 0;

908 
	`assert
((
pp0
 = 
	`page_alloc
(0)));

909 
	`assert
((
pp1
 = 
	`page_alloc
(0)));

910 
	`assert
((
pp2
 = 
	`page_alloc
(0)));

912 
	`assert
(
pp0
);

913 
	`assert
(
pp1
 && pp1 != 
pp0
);

914 
	`assert
(
pp2
 && pp2 != 
pp1
 && pp2 != 
pp0
);

915 
	`assert
(
	`page2pa
(
pp0
) < 
npages
*
PGSIZE
);

916 
	`assert
(
	`page2pa
(
pp1
) < 
npages
*
PGSIZE
);

917 
	`assert
(
	`page2pa
(
pp2
) < 
npages
*
PGSIZE
);

920 
fl
 = 
page_free_list
;

921 
page_free_list
 = 0;

924 
	`assert
(!
	`page_alloc
(0));

927 
	`page_free
(
pp0
);

928 
	`page_free
(
pp1
);

929 
	`page_free
(
pp2
);

930 
pp0
 = 
pp1
 = 
pp2
 = 0;

931 
	`assert
((
pp0
 = 
	`page_alloc
(0)));

932 
	`assert
((
pp1
 = 
	`page_alloc
(0)));

933 
	`assert
((
pp2
 = 
	`page_alloc
(0)));

934 
	`assert
(
pp0
);

935 
	`assert
(
pp1
 && pp1 != 
pp0
);

936 
	`assert
(
pp2
 && pp2 != 
pp1
 && pp2 != 
pp0
);

937 
	`assert
(!
	`page_alloc
(0));

940 
	`memset
(
	`page2kva
(
pp0
), 1, 
PGSIZE
);

941 
	`page_free
(
pp0
);

942 
	`assert
((
pp
 = 
	`page_alloc
(
ALLOC_ZERO
)));

943 
	`assert
(
pp
 && 
pp0
 == pp);

944 
c
 = 
	`page2kva
(
pp
);

945 for (
i
 = 0; i < 
PGSIZE
; i++)

946 
	`assert
(
c
[
i
] == 0);

949 
page_free_list
 = 
fl
;

952 
	`page_free
(
pp0
);

953 
	`page_free
(
pp1
);

954 
	`page_free
(
pp2
);

957 for (
pp
 = 
page_free_list
; pp; pp = pp->
pp_link
)

958 --
nfree
;

959 
	`assert
(
nfree
 == 0);

961 
	`cprintf
("check_page_alloc() succeeded!\n");

962 
	}
}

973 
	$check_kern_pgdir
(void)

975 
uint32_t
 
i
, 
n
;

976 
pde_t
 *
pgdir
;

978 
pgdir
 = 
kern_pgdir
;

981 
n
 = 
	`ROUNDUP
(
npages
*sizeof(struct 
Page
), 
PGSIZE
);

982 for (
i
 = 0; i < 
n
; i += 
PGSIZE
)

983 
	`assert
(
	`check_va2pa
(
pgdir
, 
UPAGES
 + 
i
) == 
	`PADDR
(
pages
) + i);

986 
n
 = 
	`ROUNDUP
(
NENV
*sizeof(struct 
Env
), 
PGSIZE
);

987 for (
i
 = 0; i < 
n
; i += 
PGSIZE
)

988 
	`assert
(
	`check_va2pa
(
pgdir
, 
UENVS
 + 
i
) == 
	`PADDR
(
envs
) + i);

991 for (
i
 = 0; i < 
npages
 * 
PGSIZE
; i += PGSIZE)

992 
	`assert
(
	`check_va2pa
(
pgdir
, 
KERNBASE
 + 
i
) == i);

995 for (
i
 = 
IOMEMBASE
; i < -
PGSIZE
; i += PGSIZE)

996 
	`assert
(
	`check_va2pa
(
pgdir
, 
i
) == i);

1000 for (
n
 = 0; n < 
NCPU
; n++) {

1001 
uint32_t
 
base
 = 
KSTACKTOP
 - (
KSTKSIZE
 + 
KSTKGAP
) * (
n
 + 1);

1002 for (
i
 = 0; i < 
KSTKSIZE
; i += 
PGSIZE
)

1003 
	`assert
(
	`check_va2pa
(
pgdir
, 
base
 + 
KSTKGAP
 + 
i
)

1004 == 
	`PADDR
(
percpu_kstacks
[
n
]) + 
i
);

1005 for (
i
 = 0; i < 
KSTKGAP
; i += 
PGSIZE
)

1006 
	`assert
(
	`check_va2pa
(
pgdir
, 
base
 + 
i
) == ~0);

1010 for (
i
 = 0; i < 
NPDENTRIES
; i++) {

1011 switch (
i
) {

1012 case 
	`PDX
(
UVPT
):

1013 case 
	`PDX
(
KSTACKTOP
-1):

1014 case 
	`PDX
(
UPAGES
):

1015 case 
	`PDX
(
UENVS
):

1016 
	`assert
(
pgdir
[
i
] & 
PTE_P
);

1019 if (
i
 >= 
	`PDX
(
KERNBASE
)) {

1020 
	`assert
(
pgdir
[
i
] & 
PTE_P
);

1021 
	`assert
(
pgdir
[
i
] & 
PTE_W
);

1023 
	`assert
(
pgdir
[
i
] == 0);

1027 
	`cprintf
("check_kern_pgdir() succeeded!\n");

1028 
	}
}

1035 static 
physaddr_t


1036 
	$check_va2pa
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
)

1038 
pte_t
 *
p
;

1040 
pgdir
 = &pgdir[
	`PDX
(
va
)];

1041 if (!(*
pgdir
 & 
PTE_P
))

1045 if (*
pgdir
 & 
PTE_PS
)

1046 return (*
pgdir
 & 0xFFC00000) + (
va
 & 0x003FF000);

1048 
p
 = (
pte_t
*) 
	`KADDR
(
	`PTE_ADDR
(*
pgdir
));

1049 if (!(
p
[
	`PTX
(
va
)] & 
PTE_P
))

1051 return 
	`PTE_ADDR
(
p
[
	`PTX
(
va
)]);

1052 
	}
}

1057 
	$check_page
(void)

1059 struct 
Page
 *
pp
, *
pp0
, *
pp1
, *
pp2
;

1060 struct 
Page
 *
fl
;

1061 
pte_t
 *
ptep
, *
ptep1
;

1062 void *
va
;

1063 int 
i
;

1064 extern 
pde_t
 
entry_pgdir
[];

1067 
pp0
 = 
pp1
 = 
pp2
 = 0;

1068 
	`assert
((
pp0
 = 
	`page_alloc
(0)));

1069 
	`assert
((
pp1
 = 
	`page_alloc
(0)));

1070 
	`assert
((
pp2
 = 
	`page_alloc
(0)));

1072 
	`assert
(
pp0
);

1073 
	`assert
(
pp1
 && pp1 != 
pp0
);

1074 
	`assert
(
pp2
 && pp2 != 
pp1
 && pp2 != 
pp0
);

1077 
fl
 = 
page_free_list
;

1078 
page_free_list
 = 0;

1081 
	`assert
(!
	`page_alloc
(0));

1084 
	`assert
(
	`page_lookup
(
kern_pgdir
, (void *) 0x0, &
ptep
) == 
NULL
);

1087 
	`assert
(
	`page_insert
(
kern_pgdir
, 
pp1
, 0x0, 
PTE_W
) < 0);

1090 
	`page_free
(
pp0
);

1091 
	`assert
(
	`page_insert
(
kern_pgdir
, 
pp1
, 0x0, 
PTE_W
) == 0);

1092 
	`assert
(
	`PTE_ADDR
(
kern_pgdir
[0]) == 
	`page2pa
(
pp0
));

1093 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 0x0) == 
	`page2pa
(
pp1
));

1094 
	`assert
(
pp1
->
pp_ref
 == 1);

1095 
	`assert
(
pp0
->
pp_ref
 == 1);

1098 
	`assert
(
	`page_insert
(
kern_pgdir
, 
pp2
, (void*) 
PGSIZE
, 
PTE_W
) == 0);

1099 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 
PGSIZE
) == 
	`page2pa
(
pp2
));

1100 
	`assert
(
pp2
->
pp_ref
 == 1);

1103 
	`assert
(!
	`page_alloc
(0));

1106 
	`assert
(
	`page_insert
(
kern_pgdir
, 
pp2
, (void*) 
PGSIZE
, 
PTE_W
) == 0);

1107 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 
PGSIZE
) == 
	`page2pa
(
pp2
));

1108 
	`assert
(
pp2
->
pp_ref
 == 1);

1112 
	`assert
(!
	`page_alloc
(0));

1115 
ptep
 = (
pte_t
 *) 
	`KADDR
(
	`PTE_ADDR
(
kern_pgdir
[
	`PDX
(
PGSIZE
)]));

1116 
	`assert
(
	`pgdir_walk
(
kern_pgdir
, (void*)
PGSIZE
, 0) == 
ptep
+
	`PTX
(PGSIZE));

1119 
	`assert
(
	`page_insert
(
kern_pgdir
, 
pp2
, (void*) 
PGSIZE
, 
PTE_W
|
PTE_U
) == 0);

1120 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 
PGSIZE
) == 
	`page2pa
(
pp2
));

1121 
	`assert
(
pp2
->
pp_ref
 == 1);

1122 
	`assert
(*
	`pgdir_walk
(
kern_pgdir
, (void*) 
PGSIZE
, 0) & 
PTE_U
);

1123 
	`assert
(
kern_pgdir
[0] & 
PTE_U
);

1126 
	`assert
(
	`page_insert
(
kern_pgdir
, 
pp0
, (void*) 
PTSIZE
, 
PTE_W
) < 0);

1129 
	`assert
(
	`page_insert
(
kern_pgdir
, 
pp1
, (void*) 
PGSIZE
, 
PTE_W
) == 0);

1130 
	`assert
(!(*
	`pgdir_walk
(
kern_pgdir
, (void*) 
PGSIZE
, 0) & 
PTE_U
));

1133 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 0) == 
	`page2pa
(
pp1
));

1134 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 
PGSIZE
) == 
	`page2pa
(
pp1
));

1136 
	`assert
(
pp1
->
pp_ref
 == 2);

1137 
	`assert
(
pp2
->
pp_ref
 == 0);

1140 
	`assert
((
pp
 = 
	`page_alloc
(0)) && pp == 
pp2
);

1143 
	`page_remove
(
kern_pgdir
, 0x0);

1144 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 0x0) == ~0);

1145 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 
PGSIZE
) == 
	`page2pa
(
pp1
));

1146 
	`assert
(
pp1
->
pp_ref
 == 1);

1147 
	`assert
(
pp2
->
pp_ref
 == 0);

1150 
	`page_remove
(
kern_pgdir
, (void*) 
PGSIZE
);

1151 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 0x0) == ~0);

1152 
	`assert
(
	`check_va2pa
(
kern_pgdir
, 
PGSIZE
) == ~0);

1153 
	`assert
(
pp1
->
pp_ref
 == 0);

1154 
	`assert
(
pp2
->
pp_ref
 == 0);

1157 
	`assert
((
pp
 = 
	`page_alloc
(0)) && pp == 
pp1
);

1160 
	`assert
(!
	`page_alloc
(0));

1163 
	`assert
(
	`PTE_ADDR
(
kern_pgdir
[0]) == 
	`page2pa
(
pp0
));

1164 
kern_pgdir
[0] = 0;

1165 
	`assert
(
pp0
->
pp_ref
 == 1);

1166 
pp0
->
pp_ref
 = 0;

1169 
	`page_free
(
pp0
);

1170 
va
 = (void*)(
PGSIZE
 * 
NPDENTRIES
 + PGSIZE);

1171 
ptep
 = 
	`pgdir_walk
(
kern_pgdir
, 
va
, 1);

1172 
ptep1
 = (
pte_t
 *) 
	`KADDR
(
	`PTE_ADDR
(
kern_pgdir
[
	`PDX
(
va
)]));

1173 
	`assert
(
ptep
 == 
ptep1
 + 
	`PTX
(
va
));

1174 
kern_pgdir
[
	`PDX
(
va
)] = 0;

1175 
pp0
->
pp_ref
 = 0;

1178 
	`memset
(
	`page2kva
(
pp0
), 0xFF, 
PGSIZE
);

1179 
	`page_free
(
pp0
);

1180 
	`pgdir_walk
(
kern_pgdir
, 0x0, 1);

1181 
ptep
 = (
pte_t
 *) 
	`page2kva
(
pp0
);

1182 for (
i
=0; i<
NPTENTRIES
; i++)

1183 
	`assert
((
ptep
[
i
] & 
PTE_P
) == 0);

1184 
kern_pgdir
[0] = 0;

1185 
pp0
->
pp_ref
 = 0;

1188 
page_free_list
 = 
fl
;

1191 
	`page_free
(
pp0
);

1192 
	`page_free
(
pp1
);

1193 
	`page_free
(
pp2
);

1195 
	`cprintf
("check_page() succeeded!\n");

1196 
	}
}

1200 
	$check_page_installed_pgdir
(void)

1202 struct 
Page
 *
pp
, *
pp0
, *
pp1
, *
pp2
;

1203 struct 
Page
 *
fl
;

1204 
pte_t
 *
ptep
, *
ptep1
;

1205 
uintptr_t
 
va
;

1206 int 
i
;

1209 
pp1
 = 
pp2
 = 0;

1210 
	`assert
((
pp0
 = 
	`page_alloc
(0)));

1211 
	`assert
((
pp1
 = 
	`page_alloc
(0)));

1212 
	`assert
((
pp2
 = 
	`page_alloc
(0)));

1213 
	`page_free
(
pp0
);

1214 
	`memset
(
	`page2kva
(
pp1
), 1, 
PGSIZE
);

1215 
	`memset
(
	`page2kva
(
pp2
), 2, 
PGSIZE
);

1216 
	`page_insert
(
kern_pgdir
, 
pp1
, (void*) 
PGSIZE
, 
PTE_W
);

1217 
	`assert
(
pp1
->
pp_ref
 == 1);

1218 
	`assert
(*(
uint32_t
 *)
PGSIZE
 == 0x01010101U);

1219 
	`page_insert
(
kern_pgdir
, 
pp2
, (void*) 
PGSIZE
, 
PTE_W
);

1220 
	`assert
(*(
uint32_t
 *)
PGSIZE
 == 0x02020202U);

1221 
	`assert
(
pp2
->
pp_ref
 == 1);

1222 
	`assert
(
pp1
->
pp_ref
 == 0);

1223 *(
uint32_t
 *)
PGSIZE
 = 0x03030303U;

1224 
	`assert
(*(
uint32_t
 *)
	`page2kva
(
pp2
) == 0x03030303U);

1225 
	`page_remove
(
kern_pgdir
, (void*) 
PGSIZE
);

1226 
	`assert
(
pp2
->
pp_ref
 == 0);

1229 
	`assert
(
	`PTE_ADDR
(
kern_pgdir
[0]) == 
	`page2pa
(
pp0
));

1230 
kern_pgdir
[0] = 0;

1231 
	`assert
(
pp0
->
pp_ref
 == 1);

1232 
pp0
->
pp_ref
 = 0;

1235 
	`page_free
(
pp0
);

1237 
	`cprintf
("check_page_installed_pgdir() succeeded!\n");

1238 
	}
}

	@/root/Robux/kern/pmap.h

3 #ifndef 
JOS_KERN_PMAP_H


4 #define 
	#JOS_KERN_PMAP_H


	)

5 #ifndef 
JOS_KERNEL


9 #include 
	~<inc/x86.h
>

10 #include 
	~<inc/memlayout.h
>

11 #include 
	~<inc/assert.h
>

12 struct 
	gEnv
;

14 extern char 
bootstacktop
[], 
bootstack
[];

16 extern struct 
Page
 *
pages
;

17 extern 
size_t
 
npages
;

19 extern 
pde_t
 *
kern_pgdir
;

27 #define 
	#PADDR
(
kva
) 
	`_paddr
(
__FILE__
, 
__LINE__
, kva)

	)

29 static 
inline
 
physaddr_t


30 
	$_paddr
(const char *
file
, int 
line
, void *
kva
)

32 if ((
uint32_t
)
kva
 < 
KERNBASE
)

33 
	`_panic
(
file
, 
line
, "PADDR called with invalid kva %08lx", 
kva
);

34 return (
physaddr_t
)
kva
 - 
KERNBASE
;

35 
	}
}

39 #define 
	#KADDR
(
pa
) 
	`_kaddr
(
__FILE__
, 
__LINE__
, pa)

	)

41 static 
inline
 void*

42 
	$_kaddr
(const char *
file
, int 
line
, 
physaddr_t
 
pa
)

44 if (
	`PGNUM
(
pa
) >= 
npages
)

45 
	`_panic
(
file
, 
line
, "KADDR called with invalid pa %08lx", 
pa
);

46 return (void *)(
pa
 + 
KERNBASE
);

47 
	}
}

52 
	mALLOC_ZERO
 = 1<<0,

55 void 
mem_init
(void);

58 void 
page_init
(void);

59 struct 
Page
 *
page_alloc
(int 
alloc_flags
);

60 void 
page_free
(struct 
Page
 *
pp
);

61 int 
page_insert
(
pde_t
 *
pgdir
, struct 
Page
 *
pp
, void *
va
, int 
perm
);

62 void 
page_remove
(
pde_t
 *
pgdir
, void *
va
);

63 struct 
Page
 *
page_lookup
(
pde_t
 *
pgdir
, void *
va
, 
pte_t
 **
pte_store
);

64 void 
page_decref
(struct 
Page
 *
pp
);

66 void 
tlb_invalidate
(
pde_t
 *
pgdir
, void *
va
);

68 int 
user_mem_check
(struct 
Env
 *
env
, const void *
va
, 
size_t
 
len
, int 
perm
);

69 void 
user_mem_assert
(struct 
Env
 *
env
, const void *
va
, 
size_t
 
len
, int 
perm
);

71 static 
inline
 
physaddr_t


72 
	$page2pa
(struct 
Page
 *
pp
)

74 return (
pp
 - 
pages
) << 
PGSHIFT
;

75 
	}
}

77 static 
inline
 struct 
Page
*

78 
	$pa2page
(
physaddr_t
 
pa
)

80 if (
	`PGNUM
(
pa
) >= 
npages
)

81 
	`panic
("pa2page called with invalid pa");

82 return &
pages
[
	`PGNUM
(
pa
)];

83 
	}
}

85 static 
inline
 void*

86 
	$page2kva
(struct 
Page
 *
pp
)

88 return 
	`KADDR
(
	`page2pa
(
pp
));

89 
	}
}

91 
pte_t
 *
pgdir_walk
(
pde_t
 *
pgdir
, const void *
va
, int 
create
);

94 void 
boot_map_region
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
, 
size_t
 
size
, 
physaddr_t
 
pa
, int 
perm
);

95 void 
boot_map_region_pse
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
, 
size_t
 
size
, 
physaddr_t
 
pa
, int 
perm
);

97 
boot_unmap_region
(
pde_t
 *
pgdir
, 
uintptr_t
 
va
, 
size_t
 
size
);

108 static 
inline
 int

109 
	$cpu_has_pse
(void)

111 
uint32_t
 
features
;

112 
	`asm
("movl $1, %%eax\n\t"

115 : "=r"(
features
)

119 return 
features
 & 
CPUID_FLAG_PSE
;

120 
	}
}

122 static 
inline
 void

123 
	$cpu_activate_pse
(void)

125 if (!
	`cpu_has_pse
())

126 
	`panic
("Trying to activate PSE, but CPU does not support it\n");

128 
	`lcr4
(
	`rcr4
() | 
CR4_PSE
);

129 
	}
}

	@/root/Robux/kern/printf.c

4 #include 
	~<inc/types.h
>

5 #include 
	~<inc/stdio.h
>

6 #include 
	~<inc/stdarg.h
>

10 
	$putch
(int 
ch
, int *
cnt
)

12 
	`cputchar
(
ch
);

13 *
cnt
++;

14 
	}
}

17 
	$vcprintf
(const char *
fmt
, 
va_list
 
ap
)

19 int 
cnt
 = 0;

21 
	`vprintfmt
((void*)
putch
, &
cnt
, 
fmt
, 
ap
);

22 return 
cnt
;

23 
	}
}

26 
	$cprintf
(const char *
fmt
, ...)

28 
va_list
 
ap
;

29 int 
cnt
;

31 
	`va_start
(
ap
, 
fmt
);

32 
cnt
 = 
	`vcprintf
(
fmt
, 
ap
);

33 
	`va_end
(
ap
);

35 return 
cnt
;

36 
	}
}

	@/root/Robux/kern/sched.c

1 #include 
	~<inc/assert.h
>

3 #include 
	~<kern/env.h
>

4 #include 
	~<kern/pmap.h
>

5 #include 
	~<kern/monitor.h
>

10 
	$sched_yield
(void)

12 struct 
Env
 *
idle
;

13 int 
i
 = 0;

34 if(
curenv
 != 
NULL
)

35 for (
i
 = 0; i < 
NENV
; i++)

37 if(&
envs
[
i
] == 
curenv
)

43 if(
i
 == 
NENV
 || 
curenv
 == 
NULL
)

45 if(
envs
[0].
env_type
 != 
ENV_TYPE_IDLE
 &&

46 
envs
[0].
env_status
 == 
ENV_RUNNABLE
)

48 
	`env_run
(&
envs
[0]);

51 
i
 = 0;

56 int 
j
;

57 for (
j
 = (
i
+1)%
NENV
; j != i; j = (j+1) % NENV)

59 if (
envs
[
j
].
env_type
 != 
ENV_TYPE_IDLE
 &&

60 
envs
[
j
].
env_status
 == 
ENV_RUNNABLE
)

62 
	`env_run
(&
envs
[
j
]);

67 if(
curenv
 &&

68 (
curenv
->
env_status
 == 
ENV_RUNNABLE
 ||

69 (
curenv
->
env_status
 == 
ENV_RUNNING
)))

71 
	`env_run
(
curenv
);

77 for (
i
 = 0; i < 
NENV
; i++) {

78 if (
envs
[
i
].
env_type
 != 
ENV_TYPE_IDLE
 &&

79 (
envs
[
i
].
env_status
 == 
ENV_RUNNABLE
 ||

80 
envs
[
i
].
env_status
 == 
ENV_RUNNING
))

83 if (
i
 == 
NENV
) {

84 
	`cprintf
("No more runnable environments!\n");

86 
	`monitor
(
NULL
);

90 
idle
 = &
envs
[
	`cpunum
()];

91 if (!(
idle
->
env_status
 == 
ENV_RUNNABLE
 || idle->env_status == 
ENV_RUNNING
))

92 
	`panic
("CPU %d: No idle environment!", 
	`cpunum
());

93 
	`env_run
(
idle
);

94 
	}
}

	@/root/Robux/kern/sched.h

3 #ifndef 
JOS_KERN_SCHED_H


4 #define 
	#JOS_KERN_SCHED_H


	)

5 #ifndef 
JOS_KERNEL


10 void 
	$sched_yield
(void) 
	`__attribute__
((
noreturn
));

	@/root/Robux/kern/spinlock.c

3 #include 
	~<inc/types.h
>

4 #include 
	~<inc/assert.h
>

5 #include 
	~<inc/x86.h
>

6 #include 
	~<inc/memlayout.h
>

7 #include 
	~<inc/string.h
>

8 #include 
	~<kern/cpu.h
>

9 #include 
	~<kern/spinlock.h
>

10 #include 
	~<kern/kdebug.h
>

13 struct 
spinlock
 
	gkernel_lock
 = {

14 #ifdef 
DEBUG_SPINLOCK


15 .
name
 = "kernel_lock"

19 #ifdef 
DEBUG_SPINLOCK


22 
	$get_caller_pcs
(
uint32_t
 
pcs
[])

24 
uint32_t
 *
ebp
;

25 int 
i
;

27 
ebp
 = (
uint32_t
 *)
	`read_ebp
();

28 for (
i
 = 0; i < 10; i++){

29 if (
ebp
 == 0 || ebp < (
uint32_t
 *)
ULIM


30 || 
ebp
 >= (
uint32_t
 *)
IOMEMBASE
)

32 
pcs
[
i
] = 
ebp
[1];

33 
ebp
 = (
uint32_t
 *)ebp[0];

35 for (; 
i
 < 10; i++)

36 
pcs
[
i
] = 0;

37 
	}
}

41 
	$holding
(struct 
spinlock
 *
lock
)

43 return 
lock
->
locked
 && lock->
cpu
 == 
thiscpu
;

44 
	}
}

48 
	$__spin_initlock
(struct 
spinlock
 *
lk
, char *
name
)

50 
lk
->
locked
 = 0;

51 #ifdef 
DEBUG_SPINLOCK


52 
lk
->
name
 = name;

53 
lk
->
cpu
 = 0;

55 
	}
}

62 
	$spin_lock
(struct 
spinlock
 *
lk
)

64 #ifdef 
DEBUG_SPINLOCK


65 if (
	`holding
(
lk
))

66 
	`panic
("CPU %d cannot acquire %s: already holding", 
	`cpunum
(), 
lk
->
name
);

72 while (
	`xchg
(&
lk
->
locked
, 1) != 0)

73 
asm
 volatile ("pause");

76 #ifdef 
DEBUG_SPINLOCK


77 
lk
->
cpu
 = 
thiscpu
;

78 
	`get_caller_pcs
(
lk
->
pcs
);

80 
	}
}

84 
	$spin_unlock
(struct 
spinlock
 *
lk
)

86 #ifdef 
DEBUG_SPINLOCK


87 if (!
	`holding
(
lk
)) {

88 int 
i
;

89 
uint32_t
 
pcs
[10];

91 
	`memmove
(
pcs
, 
lk
->pcs, sizeof pcs);

92 
	`cprintf
("CPU %d cannot release %s: held by CPU %d\nAcquired at:",

93 
	`cpunum
(), 
lk
->
name
, lk->
cpu
->
cpu_id
);

94 for (
i
 = 0; i < 10 && 
pcs
[i]; i++) {

95 struct 
Eipdebuginfo
 
info
;

96 if (
	`debuginfo_eip
(
pcs
[
i
], &
info
) >= 0)

97 
	`cprintf
(" %08x %s:%d: %.*s+%x\n", 
pcs
[
i
],

98 
info
.
eip_file
, info.
eip_line
,

99 
info
.
eip_fn_namelen
, info.
eip_fn_name
,

100 
pcs
[
i
] - 
info
.
eip_fn_addr
);

102 
	`cprintf
(" %08x\n", 
pcs
[
i
]);

104 
	`panic
("spin_unlock");

107 
lk
->
pcs
[0] = 0;

108 
lk
->
cpu
 = 0;

120 
	`xchg
(&
lk
->
locked
, 0);

121 
	}
}

	@/root/Robux/kern/spinlock.h

1 #ifndef 
JOS_INC_SPINLOCK_H


2 #define 
	#JOS_INC_SPINLOCK_H


	)

4 #include 
	~<inc/types.h
>

7 #define 
	#DEBUG_SPINLOCK


	)

10 struct 
	sspinlock
 {

11 unsigned 
	mlocked
;

13 #ifdef 
DEBUG_SPINLOCK


15 char *
	mname
;

16 struct 
Cpu
 *
	mcpu
;

17 
uintptr_t
 
	mpcs
[10];

22 void 
__spin_initlock
(struct 
spinlock
 *
lk
, char *
name
);

23 void 
spin_lock
(struct 
spinlock
 *
lk
);

24 void 
spin_unlock
(struct 
spinlock
 *
lk
);

26 #define 
	#spin_initlock
(
lock
) 
	`__spin_initlock
(lock, #lock)

	)

28 extern struct 
spinlock
 
kernel_lock
;

30 static 
inline
 void

31 
	$lock_kernel
(void)

33 
	`spin_lock
(&
kernel_lock
);

34 
	}
}

36 static 
inline
 void

37 
	$unlock_kernel
(void)

39 
	`spin_unlock
(&
kernel_lock
);

45 
asm
 volatile("pause");

46 
	}
}

	@/root/Robux/kern/syscall.c

3 #include 
	~<inc/x86.h
>

4 #include 
	~<inc/error.h
>

5 #include 
	~<inc/string.h
>

6 #include 
	~<inc/assert.h
>

8 #include 
	~<kern/env.h
>

9 #include 
	~<kern/pmap.h
>

10 #include 
	~<kern/trap.h
>

11 #include 
	~<kern/syscall.h
>

12 #include 
	~<kern/console.h
>

13 #include 
	~<kern/spinlock.h
>

14 #include 
	~<kern/sched.h
>

15 #include 
	~<kern/time.h
>

17 #include 
	~<kern/e1000.h
>

19 #define 
	#debug
 0

	)

20 #define 
	#no_sleep_send
 0

	)

27 
	$sys_cputs
(const char *
s
, 
size_t
 
len
)

33 
	`user_mem_assert
(
curenv
, 
s
, 
len
, 
PTE_U
);

37 
	`cprintf
("%.*s", 
len
, 
s
);

38 
	}
}

43 
	$sys_cgetc
(void)

45 return 
	`cons_getc
();

46 
	}
}

49 static 
envid_t


50 
	$sys_getenvid
(void)

52 return 
curenv
->
env_id
;

53 
	}
}

61 
	$sys_env_destroy
(
envid_t
 
envid
)

63 int 
r
;

64 struct 
Env
 *
e
;

66 if ((
r
 = 
	`envid2env
(
envid
, &
e
, 1)) < 0)

67 return 
r
;

68 
	`env_destroy
(
e
);

70 
	}
}

74 
	$sys_yield
(void)

76 
	`sched_yield
();

77 
	}
}

83 static 
envid_t


84 
	$sys_exofork
(void)

93 int 
ret
;

94 struct 
Env
 *
newEnv
;

95 struct 
Env
 *
thisEnv
 = 
curenv
;

96 if ((
ret
 = 
	`env_alloc
(&
newEnv
, 
curenv
->
env_id
)) < 0)

97 return 
ret
;

100 
newEnv
->
env_status
 = 
ENV_NOT_RUNNABLE
;

103 
newEnv
->
env_uid
 = 
curenv
->env_uid;

104 
newEnv
->
env_gid
 = 
curenv
->env_gid;

105 
newEnv
->
env_user_perm
 = 
curenv
->env_user_perm;

108 
	`memmove
(&
newEnv
->
env_tf
, &
curenv
->env_tf, sizeof(struct 
Trapframe
));

109 
newEnv
->
env_tf
.
tf_regs
.
reg_eax
 = 0;

111 return 
newEnv
->
env_id
;

112 
	}
}

122 
	$sys_env_set_status
(
envid_t
 
envid
, int 
status
)

129 struct 
Env
 *
env
;

131 int 
ret
 = 
	`envid2env
(
envid
, &
env
, 1);

132 if(
ret
 < 0)

133 return 
ret
;

135 if(
status
 != 
ENV_RUNNABLE
 && status != 
ENV_NOT_RUNNABLE
)

136 return -
E_INVAL
;

138 
env
->
env_status
 = 
status
;

142 
	}
}

152 
	$sys_env_set_trapframe
(
envid_t
 
envid
, struct 
Trapframe
 *
tf
)

157 int 
r
;

158 struct 
Env
 *
env
;

159 if ((
r
 = 
	`envid2env
(
envid
, &
env
, 1)) < 0)

161 return 
r
;

164 if ((
r
 = 
	`user_mem_check
(
env
,

165 
tf
,

166 sizeof(struct 
Trapframe
),

167 
PTE_W
 | 
PTE_U
)) < 0)

169 return 
r
;

172 
tf
->
tf_eflags
 |= 
FL_IF
;

173 
tf
->
tf_cs
 |= 3;

175 
	`memmove
(&
env
->
env_tf
, 
tf
, sizeof(struct 
Trapframe
));

178 
	}
}

189 
	$sys_env_set_pgfault_upcall
(
envid_t
 
envid
, void *
func
)

192 struct 
Env
 *
env
;

193 int 
ret
 = 
	`envid2env
(
envid
, &
env
, 1);

194 if(
ret
 < 0)

195 return 
ret
;

197 
env
->
env_pgfault_upcall
 = 
func
;

200 
	}
}

219 
	$sys_page_alloc
(
envid_t
 
envid
, void *
va
, int 
perm
)

229 if (!( (
perm
 & 
PTE_P
) &&

230 (
perm
 & 
PTE_U
) &&

231 !(
perm
 & ~(
PTE_P
 | 
PTE_U
 | 
PTE_AVAIL
 | 
PTE_W
))))

233 return -
E_INVAL
;

236 struct 
Env
 *
env
;

237 int 
ret
 = 
	`envid2env
(
envid
, &
env
, 1);

238 if(
ret
 < 0)

239 return 
ret
;

241 if((
uint32_t
)
va
 >= 
UTOP
 || ((uint32_t)va) % 
PGSIZE
 != 0)

242 return -
E_INVAL
;

244 struct 
Page
 *
page
 = 
	`page_alloc
(1);

245 if(!
page
)

246 return -
E_NO_MEM
;

248 
ret
 = 
	`page_insert
(
env
->
env_pgdir
, 
page
, 
va
, 
perm
);

249 if(
ret
 < 0)

250 return 
ret
;

253 
	}
}

272 
	$sys_page_map
(
envid_t
 
srcenvid
, void *
srcva
,

273 
envid_t
 
dstenvid
, void *
dstva
, int 
perm
)

283 struct 
Env
 *
srcenv
;

284 struct 
Env
 *
dstenv
;

285 int 
ret
;

286 
ret
 = 
	`envid2env
(
srcenvid
, &
srcenv
, 1);

287 if(
ret
 < 0)

288 return 
ret
;

289 
ret
 = 
	`envid2env
(
dstenvid
, &
dstenv
, 1);

290 if(
ret
 < 0)

291 return 
ret
;

293 if((
uint32_t
)
srcva
 > 
UTOP
 || (uint32_t)srcva % 
PGSIZE
 != 0)

294 return -
E_INVAL
;

295 if((
uint32_t
)
dstva
 > 
UTOP
 || (uint32_t)dstva % 
PGSIZE
 != 0)

296 return -
E_INVAL
;

298 
pte_t
 *
srcpte
;

299 struct 
Page
 *
srcpage
 = 
	`page_lookup
(
srcenv
->
env_pgdir
, 
srcva
, &
srcpte
);

300 if(!
srcpage
)

301 return -
E_INVAL
;

304 if(!( (
perm
 & 
PTE_P
) &&

305 (
perm
 & 
PTE_U
) &&

306 !(
perm
 & ~(
PTE_SYSCALL
))))

308 return -
E_INVAL
;

311 if((
perm
 & 
PTE_W
) && !(*
srcpte
 & PTE_W))

312 return -
E_INVAL
;

314 return 
	`page_insert
(
dstenv
->
env_pgdir
, 
srcpage
, 
dstva
, 
perm
);

315 
	}
}

325 
	$sys_page_unmap
(
envid_t
 
envid
, void *
va
)

330 struct 
Env
 *
env
;

331 int 
ret
 = 
	`envid2env
(
envid
, &
env
, 1);

332 if(
ret
 < 0)

333 return 
ret
;

335 if((
uint32_t
) 
va
 > 
UTOP
 || (uint32_t) va % 
PGSIZE
 != 0)

336 return -
E_INVAL
;

338 
	`page_remove
(
env
->
env_pgdir
, 
va
);

342 
	}
}

383 
	$sys_ipc_try_send
(
envid_t
 
envid
, 
uint32_t
 
value
, void *
srcva
, unsigned 
perm
)

386 struct 
Env
 *
env
;

387 int 
r
;

388 
uint32_t
 
srcint
 = (uint32_t)
srcva
;

389 struct 
Page
 *
srcpage
;

392 if ((
r
 = 
	`envid2env
(
envid
, &
env
, 0) < 0))

393 return 
r
;

395 int 
map_page
 = 0;

398 if (
srcint
 < 
UTOP
)

401 if(
srcint
 % 
PGSIZE
 != 0)

403 
	`cprintf
("A 0x%x\n", 
srcint
);

404 return -
E_INVAL
;

408 if (!( (
perm
 & 
PTE_P
) &&

409 (
perm
 & 
PTE_U
) &&

410 !(
perm
 & ~(
PTE_P
 | 
PTE_U
 | 
PTE_AVAIL
 | 
PTE_W
))))

412 
	`cprintf
("B\n");

413 return -
E_INVAL
;

417 
pte_t
 *
pte
;

418 if ((
srcpage
 = 
	`page_lookup
(
curenv
->
env_pgdir
, 
srcva
, &
pte
)) == 
NULL
)

420 
	`cprintf
("C\n");

421 return -
E_INVAL
;

425 if ((
perm
 & 
PTE_W
) != (*
pte
 & PTE_W))

427 
	`cprintf
("D\n");

428 return -
E_INVAL
;

433 
map_page
 = 1;

439 if (!
env
->
env_ipc_recving
)

442 #if 
no_sleep_send
 == 1

443 return -
E_IPC_NOT_RECV
;

452 
curenv
->
env_ipc_send_to
 = 
envid
;

453 
curenv
->
env_ipc_send_value
 = 
value
;

454 
curenv
->
env_ipc_send_srcva
 = 
srcva
;

455 
curenv
->
env_ipc_send_perm
 = 
perm
;

458 if(
debug
)

459 
	`cprintf
("[%x] Sleeping on IPC to %x\n", 
curenv
->
env_id
, 
envid
);

462 
curenv
->
env_status
 = 
ENV_NOT_RUNNABLE
;

463 
	`sched_yield
();

470 if(
map_page
 && (
uint32_t
) 
env
->
env_ipc_dstva
 < 
UTOP
)

473 
r
 = 
	`page_insert
(
env
->
env_pgdir
, 
srcpage
, env->
env_ipc_dstva
, 
perm
);

474 if(
r
 < 0)

475 return 
r
;

478 
env
->
env_ipc_perm
 = 
perm
;

482 if(
debug
)

483 
	`cprintf
("[%x] Waking on IPC from %x\n", 
envid
, 
curenv
->
env_id
);

486 
env
->
env_ipc_recving
 = 0;

487 
env
->
env_ipc_from
 = 
curenv
->
env_id
;

488 
env
->
env_ipc_value
 = 
value
;

489 
env
->
env_status
 = 
ENV_RUNNABLE
;

490 
env
->
env_tf
.
tf_regs
.
reg_eax
 = 0;

493 
	}
}

496 #define 
	#RECV_LIMIT
 16

	)

510 
	$sys_ipc_recv
(void *
dstva
)

514 if((
uint32_t
)
dstva
 < 
UTOP
)

516 if((
uint32_t
)
dstva
 % 
PGSIZE
 != 0)

518 
	`cprintf
("recv: bad va: 0x%08x\n", 
dstva
);

519 return -
E_INVAL
;

521 
curenv
->
env_ipc_dstva
 = 
dstva
;

525 
curenv
->
env_ipc_dstva
 = (void*)0xFFFFFFFF;

534 #if 
no_sleep_send
 == 0

537 static int 
i
 = 0;

538 static int 
recvs
 = 
RECV_LIMIT
;

540 int 
k
 = 
i
;

542 int 
j
;

552 int 
shift_j
 = 1;

553 for(
j
 = 
k
-1; k != j ; k = (k+1)%
NENV
)

557 if(
shift_j
)

559 
j
 = (j+1) % 
NENV
;

560 
shift_j
 = 0;

563 struct 
Env
 *
env
 = &
envs
[
k
];

564 if(
env
->
env_status
 == 
ENV_NOT_RUNNABLE
 &&

565 
env
->
env_ipc_send_to
 == 
curenv
->
env_id
)

568 
curenv
->
env_ipc_value
 = 
env
->
env_ipc_send_value
;

569 
curenv
->
env_ipc_from
 = 
env
->
env_id
;

572 if((
uint32_t
)
env
->
env_ipc_send_srcva
 < 
UTOP
 &&

573 (
uint32_t
)
curenv
->
env_ipc_dstva
 < 
UTOP
)

575 int 
r
;

576 struct 
Page
 *
page
 = 
	`page_lookup
(
env
->
env_pgdir
,

577 
env
->
env_ipc_send_srcva
, 
NULL
);

578 
r
 = 
	`page_insert
(
curenv
->
env_pgdir
, 
page
, curenv->
env_ipc_dstva
,

579 
env
->
env_ipc_send_perm
);

580 if(
r
 < 0)

584 
env
->
env_ipc_send_to
 = 0;

585 
env
->
env_tf
.
tf_regs
.
reg_eax
 = 
r
;

586 
env
->
env_status
 = 
ENV_RUNNABLE
;

590 
curenv
->
env_ipc_perm
 = 
env
->
env_ipc_send_perm
;

595 
curenv
->
env_ipc_perm
 = 0;

599 if(
k
 == 
i
)

601 if (--
recvs
 == 0)

606 
recvs
 = 
RECV_LIMIT
;

607 
k
++;

612 
recvs
 = 
RECV_LIMIT
;

615 
i
 = 
k
;

618 
env
->
env_ipc_send_to
 = 0;

619 
env
->
env_tf
.
tf_regs
.
reg_eax
 = 0;

620 
env
->
env_status
 = 
ENV_RUNNABLE
;

626 
curenv
->
env_ipc_recving
 = 1;

627 
curenv
->
env_status
 = 
ENV_NOT_RUNNABLE
;

629 if(
debug
)

630 
	`cprintf
("[%x] sleeping on IPC recv\n", 
curenv
->
env_id
);

631 
	`sched_yield
();

635 
	}
}

639 
	$sys_time_msec
(void)

642 return 
	`time_msec
();

643 
	}
}

646 static char 
	gtx_page
[
PGSIZE
] 
__attribute__
((
aligned
(PGSIZE)));

649 
	$sys_net_send_packet
(void *
addr
, 
uint16_t
 
len
)

652 if(
	`user_mem_check
(
curenv
, 
addr
, 
len
, 
PTE_U
) != 0)

653 return -
E_INVAL
;

657 if(
len
 > 4096)

658 
	`panic
("Packet is too big! %d bytes\n", 
len
);

660 
	`memmove
(
tx_page
, 
addr
, 
len
);

662 return 
	`e1000_send_packet
(
tx_page
, 
len
);

663 
	}
}

666 
	$sys_net_recv_packet
(void *
addr
)

669 if(
	`user_mem_check
(
curenv
, 
addr
, 
PGSIZE
, 
PTE_U
 | 
PTE_W
) != 0)

670 return -
E_INVAL
;

672 int 
r
;

673 
uint16_t
 
len
;

675 if((
r
 = 
	`e1000_recv_packet
(
addr
, &
len
)) < 0)

676 return 
r
;

679 return 
len
;

680 
	}
}

683 
	$sys_get_mac_addr
(
uint8_t
 *
addr
)

685 if(
	`user_mem_check
(
curenv
, 
addr
, 6, 
PTE_U
 | 
PTE_W
) != 0)

686 return -
E_INVAL
;

688 
	`e1000_read_mac
(
addr
);

691 
	}
}

698 void 
	$syscall_cond_lock
(
uint32_t
 
syscallno
, int 
lock
)

700 if (!(
	`cpu_get_features
() & 
CPUID_FLAG_SEP
))

708 switch(
syscallno
)

710 case 
SYS_cputs
:

711 case 
SYS_cgetc
:

712 case 
SYS_getenvid
:

713 if(
lock
)

714 
	`lock_kernel
();

716 
	`unlock_kernel
();

717 case 
SYS_env_destroy
:

718 case 
SYS_yield
:

723 
	}
}

727 
	$sys_get_env_user_id
()

729 return 
curenv
->
env_uid
;

730 
	}
}

734 
	$sys_get_env_group_id
()

736 return 
curenv
->
env_gid
;

737 
	}
}

742 
	$sys_set_user_id
(
envid_t
 
envid
, 
uid_t
 
uid
)

744 struct 
Env
 *
env
;

745 int 
r
 = 
	`envid2env
(
envid
, &
env
, 1);

746 if(
r
 < 0)

747 return 
r
;

749 if (
curenv
->
env_uid
 != 0)

750 return -
E_BAD_PERM
;

752 
env
->
env_uid
 = 
uid
;

754 
	}
}

759 
	$sys_set_group_id
(
envid_t
 
envid
, 
gid_t
 
gid
)

761 struct 
Env
 *
env
;

762 int 
r
 = 
	`envid2env
(
envid
, &
env
, 1);

763 if(
r
 < 0)

764 return 
r
;

766 if (
curenv
->
env_uid
 != 0)

767 return -
E_BAD_PERM
;

769 
env
->
env_gid
 = 
gid
;

771 
	}
}

775 
int32_t


776 
	$syscall
(
uint32_t
 
syscallno
, uint32_t 
a1
, uint32_t 
a2
, uint32_t 
a3
, uint32_t 
a4
, uint32_t 
a5
)

783 
	`syscall_cond_lock
(
syscallno
, 1);

785 
int32_t
 
ret
 = 0;

786 switch(
syscallno
)

788 case 
SYS_cputs
:

789 
	`sys_cputs
((char *)
a1
, 
a2
);

791 case 
SYS_cgetc
:

792 
ret
 = 
	`sys_cgetc
();

794 case 
SYS_env_destroy
:

795 
ret
 = 
	`sys_env_destroy
(
a1
);

797 case 
SYS_env_set_pgfault_upcall
:

798 
ret
 = 
	`sys_env_set_pgfault_upcall
((
envid_t
)
a1
, (void*)
a2
);

800 case 
SYS_getenvid
:

801 
ret
 = 
	`sys_getenvid
();

803 case 
SYS_yield
:

804 
	`sys_yield
();

806 case 
SYS_exofork
:

807 
ret
 = 
	`sys_exofork
();

809 case 
SYS_env_set_status
:

810 
ret
 = 
	`sys_env_set_status
((
envid_t
)
a1
, 
a2
);

812 case 
SYS_page_alloc
:

813 
ret
 = 
	`sys_page_alloc
((
envid_t
)
a1
, (void*)
a2
, 
a3
);

815 case 
SYS_page_map
:

816 
ret
 = 
	`sys_page_map
((
envid_t
)
a1
, (void*)
a2
, (envid_t)
a3
, (void*)
a4
, 
a5
);

818 case 
SYS_page_unmap
:

819 
ret
 = 
	`sys_page_unmap
((
envid_t
)
a1
, (void*)
a2
);

821 case 
SYS_ipc_try_send
:

822 
ret
 = 
	`sys_ipc_try_send
((
envid_t
)
a1
, (
uint32_t
)
a2
,

823 (void*)
a3
, (unsigned) 
a4
);

825 case 
SYS_set_user_id
:

826 
ret
 = 
	`sys_set_user_id
((
envid_t
)
a1
, (
uid_t
)
a2
);

828 case 
SYS_set_group_id
:

829 
ret
 = 
	`sys_set_group_id
((
envid_t
)
a1
, (
gid_t
)
a2
);

831 case 
SYS_get_env_user_id
:

832 
ret
 = 
	`sys_get_env_user_id
();

834 case 
SYS_get_env_group_id
:

835 
ret
 = 
	`sys_get_env_group_id
();

837 case 
SYS_ipc_recv
:

838 
ret
 = 
	`sys_ipc_recv
((void*)
a1
);

840 case 
SYS_env_set_trapframe
:

841 
ret
 = 
	`sys_env_set_trapframe
((
envid_t
)
a1
, (struct 
Trapframe
*)
a2
);

843 case 
SYS_time_msec
:

844 
ret
 = 
	`sys_time_msec
();

846 case 
SYS_net_send_packet
:

847 
ret
 = 
	`sys_net_send_packet
((void*)
a1
, (
uint16_t
)
a2
);

849 case 
SYS_net_recv_packet
:

850 
ret
 = 
	`sys_net_recv_packet
((void*)
a1
);

852 case 
SYS_get_mac_addr
:

853 
ret
 = 
	`sys_get_mac_addr
((
uint8_t
*)
a1
);

857 
ret
 = -
E_INVAL
;

861 
	`syscall_cond_lock
(
syscallno
, 0);

862 return 
ret
;

863 
	}
}

	@/root/Robux/kern/syscall.h

1 #ifndef 
JOS_KERN_SYSCALL_H


2 #define 
	#JOS_KERN_SYSCALL_H


	)

3 #ifndef 
JOS_KERNEL


7 #include 
	~<inc/syscall.h
>

9 
int32_t
 
syscall
(
uint32_t
 
num
, uint32_t 
a1
, uint32_t 
a2
, uint32_t 
a3
, uint32_t 
a4
, uint32_t 
a5
);

	@/root/Robux/kern/time.c

1 #include 
	~<kern/time.h
>

2 #include 
	~<inc/assert.h
>

4 static unsigned int 
	gticks
;

7 
	$time_init
(void)

9 
ticks
 = 0;

10 
	}
}

15 
	$time_tick
(void)

17 
ticks
++;

18 if (
ticks
 * 10 < ticks)

19 
	`panic
("time_tick: time overflowed");

20 
	}
}

23 
	$time_msec
(void)

25 return 
ticks
 * 10;

26 
	}
}

	@/root/Robux/kern/time.h

1 #ifndef 
JOS_KERN_TIME_H


2 #define 
	#JOS_KERN_TIME_H


	)

3 #ifndef 
JOS_KERNEL


7 void 
time_init
(void);

8 void 
time_tick
(void);

9 unsigned int 
time_msec
(void);

	@/root/Robux/kern/trap.c

1 #include 
	~<inc/mmu.h
>

2 #include 
	~<inc/x86.h
>

3 #include 
	~<inc/assert.h
>

4 #include 
	~<inc/trap.h
>

5 #include 
	~<inc/string.h
>

7 #include 
	~<kern/pmap.h
>

8 #include 
	~<kern/trap.h
>

9 #include 
	~<kern/console.h
>

10 #include 
	~<kern/monitor.h
>

11 #include 
	~<kern/env.h
>

12 #include 
	~<kern/syscall.h
>

13 #include 
	~<kern/sched.h
>

14 #include 
	~<kern/kclock.h
>

15 #include 
	~<kern/picirq.h
>

16 #include 
	~<kern/cpu.h
>

17 #include 
	~<kern/spinlock.h
>

18 #include 
	~<kern/time.h
>

20 static struct 
Taskstate
 
	gts
;

26 static struct 
Trapframe
 *
	glast_tf
;

31 struct 
Gatedesc
 
	gidt
[256] = { { 0 } };

32 struct 
Pseudodesc
 
	gidt_pd
 = {

33 sizeof(
idt
) - 1, (
uint32_t
) idt

37 static const char *
	$trapname
(int 
trapno
)

39 static const char * const 
excnames
[] = {

62 if (
trapno
 < sizeof(
excnames
)/sizeof(excnames[0]))

63 return 
excnames
[
trapno
];

64 if (
trapno
 == 
T_SYSCALL
)

66 if (
trapno
 >= 
IRQ_OFFSET
 && trapno < IRQ_OFFSET + 16)

69 
	}
}

73 
	$trap_init
(void)

75 extern struct 
Segdesc
 
gdt
[];

78 
	`SETGATE
(
idt
[0], 0, 
GD_KT
, 
trap0
, 0)

79 
	`SETGATE
(
idt
[1], 0, 
GD_KT
, 
trap1
, 0)

80 
	`SETGATE
(
idt
[2], 0, 
GD_KT
, 
trap2
, 0)

81 
	`SETGATE
(
idt
[3], 0, 
GD_KT
, 
trap3
, 3)

82 
	`SETGATE
(
idt
[4], 1, 
GD_KT
, 
trap4
, 0)

83 
	`SETGATE
(
idt
[5], 0, 
GD_KT
, 
trap5
, 0)

84 
	`SETGATE
(
idt
[6], 0, 
GD_KT
, 
trap6
, 0)

85 
	`SETGATE
(
idt
[7], 0, 
GD_KT
, 
trap7
, 0)

86 
	`SETGATE
(
idt
[8], 0, 
GD_KT
, 
trap8
, 0)

87 
	`SETGATE
(
idt
[9], 0, 
GD_KT
, 
trap9
, 0)

88 
	`SETGATE
(
idt
[10], 0, 
GD_KT
, 
trap10
, 0)

89 
	`SETGATE
(
idt
[11], 0, 
GD_KT
, 
trap11
, 0)

90 
	`SETGATE
(
idt
[12], 0, 
GD_KT
, 
trap12
, 0)

91 
	`SETGATE
(
idt
[13], 0, 
GD_KT
, 
trap13
, 0)

92 
	`SETGATE
(
idt
[14], 0, 
GD_KT
, 
trap14
, 0)

93 
	`SETGATE
(
idt
[15], 0, 
GD_KT
, 
trap15
, 0)

94 
	`SETGATE
(
idt
[16], 0, 
GD_KT
, 
trap16
, 0)

95 
	`SETGATE
(
idt
[17], 1, 
GD_KT
, 
trap17
, 0)

96 
	`SETGATE
(
idt
[18], 1, 
GD_KT
, 
trap18
, 0)

97 
	`SETGATE
(
idt
[19], 1, 
GD_KT
, 
trap19
, 0)

98 
	`SETGATE
(
idt
[20], 1, 
GD_KT
, 
trap20
, 0)

99 
	`SETGATE
(
idt
[21], 1, 
GD_KT
, 
trap21
, 0)

100 
	`SETGATE
(
idt
[22], 1, 
GD_KT
, 
trap22
, 0)

101 
	`SETGATE
(
idt
[23], 1, 
GD_KT
, 
trap23
, 0)

102 
	`SETGATE
(
idt
[24], 1, 
GD_KT
, 
trap24
, 0)

103 
	`SETGATE
(
idt
[25], 1, 
GD_KT
, 
trap25
, 0)

104 
	`SETGATE
(
idt
[26], 1, 
GD_KT
, 
trap26
, 0)

105 
	`SETGATE
(
idt
[27], 1, 
GD_KT
, 
trap27
, 0)

106 
	`SETGATE
(
idt
[28], 1, 
GD_KT
, 
trap28
, 0)

107 
	`SETGATE
(
idt
[29], 1, 
GD_KT
, 
trap29
, 0)

108 
	`SETGATE
(
idt
[30], 1, 
GD_KT
, 
trap30
, 0)

109 
	`SETGATE
(
idt
[31], 1, 
GD_KT
, 
trap31
, 0)

111 
	`SETGATE
(
idt
[32], 0, 
GD_KT
, 
trap32
, 0)

112 
	`SETGATE
(
idt
[33], 0, 
GD_KT
, 
trap33
, 0)

113 
	`SETGATE
(
idt
[34], 0, 
GD_KT
, 
trap34
, 0)

114 
	`SETGATE
(
idt
[35], 0, 
GD_KT
, 
trap35
, 0)

115 
	`SETGATE
(
idt
[36], 0, 
GD_KT
, 
trap36
, 0)

116 
	`SETGATE
(
idt
[37], 0, 
GD_KT
, 
trap37
, 0)

117 
	`SETGATE
(
idt
[38], 0, 
GD_KT
, 
trap38
, 0)

118 
	`SETGATE
(
idt
[39], 0, 
GD_KT
, 
trap39
, 0)

119 
	`SETGATE
(
idt
[40], 0, 
GD_KT
, 
trap40
, 0)

120 
	`SETGATE
(
idt
[41], 0, 
GD_KT
, 
trap41
, 0)

121 
	`SETGATE
(
idt
[42], 0, 
GD_KT
, 
trap42
, 0)

122 
	`SETGATE
(
idt
[43], 0, 
GD_KT
, 
trap43
, 0)

123 
	`SETGATE
(
idt
[44], 0, 
GD_KT
, 
trap44
, 0)

124 
	`SETGATE
(
idt
[45], 0, 
GD_KT
, 
trap45
, 0)

125 
	`SETGATE
(
idt
[46], 0, 
GD_KT
, 
trap46
, 0)

126 
	`SETGATE
(
idt
[47], 0, 
GD_KT
, 
trap47
, 0)

129 
	`SETGATE
(
idt
[
T_SYSCALL
], 0, 
GD_KT
, 
trap_sysc
, 3)

135 
	`trap_init_percpu
();

136 
	}
}

140 
	$trap_init_percpu
(void)

167 
thiscpu
->
cpu_ts
.
ts_esp0
 = 
KSTACKTOP
 - 
	`cpunum
() * (
KSTKSIZE
 + 
KSTKGAP
);

168 
thiscpu
->
cpu_ts
.
ts_ss0
 = 
GD_KD
;

171 
gdt
[(
GD_TSS0
 >> 3) + 
	`cpunum
()] = 
	`SEG16
(
STS_T32A
, (
uint32_t
) (&
thiscpu
->
cpu_ts
),

172 sizeof(struct 
Taskstate
), 0);

173 
gdt
[(
GD_TSS0
 >> 3) + 
	`cpunum
()].
sd_s
 = 0;

177 
	`ltr
(
GD_TSS0
 + (
	`cpunum
() << 3));

180 
	`lidt
(&
idt_pd
);

186 if (
	`cpu_get_features
() & 
CPUID_FLAG_SEP
)

188 
	`wrmsr
(
SYSENTER_CS
, 
GD_KT
, 0);

189 
	`wrmsr
(
SYSENTER_ESP
, 
KSTACKTOP
 - 
	`cpunum
() * (
KSTKSIZE
 + 
KSTKGAP
), 0);

190 
	`wrmsr
(
SYSENTER_EIP
, 
sysenter_handler
, 0);

193 
	}
}

196 
	$print_trapframe
(struct 
Trapframe
 *
tf
)

198 
	`cprintf
("TRAP frame at %p from CPU %d\n", 
tf
, 
	`cpunum
());

199 
	`print_regs
(&
tf
->
tf_regs
);

200 
	`cprintf
(" es 0x----%04x\n", 
tf
->
tf_es
);

201 
	`cprintf
(" ds 0x----%04x\n", 
tf
->
tf_ds
);

202 
	`cprintf
(" trap 0x%08x %s\n", 
tf
->
tf_trapno
, 
	`trapname
(tf->tf_trapno));

205 if (
tf
 == 
last_tf
 && tf->
tf_trapno
 == 
T_PGFLT
)

206 
	`cprintf
(" cr2 0x%08x\n", 
	`rcr2
());

207 
	`cprintf
(" err 0x%08x", 
tf
->
tf_err
);

212 if (
tf
->
tf_trapno
 == 
T_PGFLT
)

213 
	`cprintf
(" [%s, %s, %s]\n",

214 
tf
->
tf_err
 & 4 ? "user" : "kernel",

215 
tf
->
tf_err
 & 2 ? "write" : "read",

216 
tf
->
tf_err
 & 1 ? "protection" : "not-present");

218 
	`cprintf
("\n");

219 
	`cprintf
(" eip 0x%08x\n", 
tf
->
tf_eip
);

220 
	`cprintf
(" cs 0x----%04x\n", 
tf
->
tf_cs
);

221 
	`cprintf
(" flag 0x%08x\n", 
tf
->
tf_eflags
);

222 if ((
tf
->
tf_cs
 & 3) != 0) {

223 
	`cprintf
(" esp 0x%08x\n", 
tf
->
tf_esp
);

224 
	`cprintf
(" ss 0x----%04x\n", 
tf
->
tf_ss
);

226 
	}
}

229 
	$print_regs
(struct 
PushRegs
 *
regs
)

231 
	`cprintf
(" edi 0x%08x\n", 
regs
->
reg_edi
);

232 
	`cprintf
(" esi 0x%08x\n", 
regs
->
reg_esi
);

233 
	`cprintf
(" ebp 0x%08x\n", 
regs
->
reg_ebp
);

234 
	`cprintf
(" oesp 0x%08x\n", 
regs
->
reg_oesp
);

235 
	`cprintf
(" ebx 0x%08x\n", 
regs
->
reg_ebx
);

236 
	`cprintf
(" edx 0x%08x\n", 
regs
->
reg_edx
);

237 
	`cprintf
(" ecx 0x%08x\n", 
regs
->
reg_ecx
);

238 
	`cprintf
(" eax 0x%08x\n", 
regs
->
reg_eax
);

239 
	}
}

242 
	$trap_dispatch
(struct 
Trapframe
 *
tf
)

247 if (
tf
->
tf_trapno
 == 
T_PGFLT
)

249 
	`page_fault_handler
(
tf
);

252 else if (
tf
->
tf_trapno
 == 
T_BRKPT
)

254 
	`monitor
(
tf
);

257 else if (
tf
->
tf_trapno
 == 
T_SYSCALL
)

259 
tf
->
tf_regs
.
reg_eax
 = 
	`syscall
(tf->tf_regs.reg_eax,

260 
tf
->
tf_regs
.
reg_edx
,

261 
tf
->
tf_regs
.
reg_ecx
,

262 
tf
->
tf_regs
.
reg_ebx
,

263 
tf
->
tf_regs
.
reg_edi
,

264 
tf
->
tf_regs
.
reg_esi
);

271 if (
tf
->
tf_trapno
 == 
IRQ_OFFSET
 + 
IRQ_SPURIOUS
) {

272 
	`cprintf
("Spurious interrupt on irq 7\n");

273 
	`print_trapframe
(
tf
);

280 if (
tf
->
tf_trapno
 == 
IRQ_OFFSET
 + 
IRQ_TIMER
)

282 if(
	`cpunum
() == 0)

283 
	`time_tick
();

284 
	`lapic_eoi
();

285 
	`sched_yield
();

296 if (
tf
->
tf_trapno
 == 
IRQ_OFFSET
 + 
IRQ_KBD
)

298 
	`kbd_intr
();

302 if (
tf
->
tf_trapno
 == 
IRQ_OFFSET
 + 
IRQ_SERIAL
)

304 
	`serial_intr
();

309 
	`print_trapframe
(
tf
);

310 if (
tf
->
tf_cs
 == 
GD_KT
)

311 
	`panic
("unhandled trap in kernel");

313 
	`cprintf
("Killing env\n");

314 
	`env_destroy
(
curenv
);

317 
	}
}

320 
	$trap
(struct 
Trapframe
 *
tf
)

324 
asm
 volatile("cld" ::: "cc");

327 extern char *
panicstr
;

328 if (
panicstr
)

329 
asm
 volatile("hlt");

334 
	`assert
(!(
	`read_eflags
() & 
FL_IF
));

336 if ((
tf
->
tf_cs
 & 3) == 3) {

341 
	`lock_kernel
();

342 
	`assert
(
curenv
);

345 if (
curenv
->
env_status
 == 
ENV_DYING
) {

346 
	`env_free
(
curenv
);

347 
curenv
 = 
NULL
;

348 
	`sched_yield
();

354 
curenv
->
env_tf
 = *
tf
;

356 
tf
 = &
curenv
->
env_tf
;

361 
last_tf
 = 
tf
;

364 
	`trap_dispatch
(
tf
);

369 if (
curenv
 && curenv->
env_status
 == 
ENV_RUNNING
)

370 
	`env_run
(
curenv
);

372 
	`sched_yield
();

373 
	}
}

377 
	$page_fault_handler
(struct 
Trapframe
 *
tf
)

379 
uint32_t
 
fault_va
;

383 
fault_va
 = 
	`rcr2
();

389 if (!(
tf
->
tf_cs
 & 3))

391 
	`panic
("kernel fault va %08x ip %08x\n", 
fault_va
, 
tf
->
tf_eip
);

426 if(
curenv
->
env_pgfault_upcall
 != 
NULL
)

428 struct 
UTrapframe
 *
frame
;

430 if(
	`ROUNDUP
(
tf
->
tf_esp
, 
PGSIZE
) == 
UXSTACKTOP
)

432 
frame
 = (struct 
UTrapframe
*)(
tf
->
tf_esp
 - sizeof(
uint32_t
) - sizeof(struct UTrapframe));

436 
frame
 = (struct 
UTrapframe
*)(
UXSTACKTOP
 - sizeof(struct UTrapframe));

439 
	`user_mem_assert
(
curenv
,(void*)
frame
, 
UXSTACKTOP
 - (
uint32_t
)frame, 
PTE_W
);

441 
frame
->
utf_fault_va
 = 
fault_va
;

442 
frame
->
utf_err
 = 
tf
->
tf_err
;

443 
	`memmove
(&
frame
->
utf_regs
, &
tf
->
tf_regs
, sizeof(struct 
PushRegs
));

444 
frame
->
utf_eip
 = 
tf
->
tf_eip
;

445 
frame
->
utf_eflags
 = 
tf
->
tf_eflags
;

446 
frame
->
utf_esp
 = 
tf
->
tf_esp
;

448 
tf
->
tf_eip
 = (
uint32_t
)
curenv
->
env_pgfault_upcall
;

449 
tf
->
tf_esp
 = (
uint32_t
)
frame
;

450 
	`env_run
(
curenv
);

455 
	`cprintf
("[%08x] user fault va %08x ip %08x\n",

456 
curenv
->
env_id
, 
fault_va
, 
tf
->
tf_eip
);

457 
	`print_trapframe
(
tf
);

458 
	`env_destroy
(
curenv
);

459 
	}
}

	@/root/Robux/kern/trap.h

3 #ifndef 
JOS_KERN_TRAP_H


4 #define 
	#JOS_KERN_TRAP_H


	)

5 #ifndef 
JOS_KERNEL


9 #include 
	~<inc/trap.h
>

10 #include 
	~<inc/mmu.h
>

13 extern struct 
Gatedesc
 
idt
[];

14 extern struct 
Pseudodesc
 
idt_pd
;

16 void 
trap_init
(void);

17 void 
trap_init_percpu
(void);

18 void 
print_regs
(struct 
PushRegs
 *
regs
);

19 void 
print_trapframe
(struct 
Trapframe
 *
tf
);

20 void 
page_fault_handler
(struct 
Trapframe
 *);

21 void 
backtrace
(struct 
Trapframe
 *);

	@/root/Robux/lib/args.c

1 #include 
	~<inc/args.h
>

2 #include 
	~<inc/string.h
>

5 
	$argstart
(int *
argc
, char **
argv
, struct 
Argstate
 *
args
)

7 
args
->
argc
 = argc;

8 
args
->
argv
 = (const char **) argv;

9 
args
->
curarg
 = (*
argc
 > 1 && 
argv
 ? "" : 0);

10 
args
->
argvalue
 = 0;

11 
	}
}

14 
	$argnext
(struct 
Argstate
 *
args
)

16 int 
arg
;

18 
args
->
argvalue
 = 0;

21 if (
args
->
curarg
 == 0)

24 if (!*
args
->
curarg
) {

27 if (*
args
->
argc
 == 1

28 || 
args
->
argv
[1][0] != '-'

29 || 
args
->
argv
[1][1] == '\0')

30 goto 
endofargs
;

32 
args
->
curarg
 = args->
argv
[1] + 1;

33 
	`memmove
(
args
->
argv
 + 1, args->argv + 2, sizeof(const char *) * (*args->
argc
 - 1));

34 (*
args
->
argc
)--;

36 if (
args
->
curarg
[0] == '-' && args->curarg[1] == '\0')

37 goto 
endofargs
;

40 
arg
 = (unsigned char) *
args
->
curarg
;

41 
args
->
curarg
++;

42 return 
arg
;

44 
endofargs
:

45 
args
->
curarg
 = 0;

47 
	}
}

50 
	$argvalue
(struct 
Argstate
 *
args
)

52 return (char*) (
args
->
argvalue
 ? args->argvalue : 
	`argnextvalue
(args));

53 
	}
}

56 
	$argnextvalue
(struct 
Argstate
 *
args
)

58 if (!
args
->
curarg
)

60 if (*
args
->
curarg
) {

61 
args
->
argvalue
 = args->
curarg
;

62 
args
->
curarg
 = "";

63 } else if (*
args
->
argc
 > 1) {

64 
args
->
argvalue
 = args->
argv
[1];

65 
	`memmove
(
args
->
argv
 + 1, args->argv + 2, sizeof(const char *) * (*args->
argc
 - 1));

66 (*
args
->
argc
)--;

68 
args
->
argvalue
 = 0;

69 
args
->
curarg
 = 0;

71 return (char*) 
args
->
argvalue
;

72 
	}
}

	@/root/Robux/lib/b64.c

205 #include 
	~<inc/lib.h
>

210 static const char 
	gcb64
[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

215 static const char 
	gcd64
[]="|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq";

224 void 
	$encodeblock
( unsigned char 
in
[3], char *
out
, int 
len
 )

226 
out
[0] = 
cb64
[ 
in
[0] >> 2 ];

227 
out
[1] = 
cb64
[ ((
in
[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];

228 
out
[2] = (char) (
len
 > 1 ? 
cb64
[ ((
in
[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=');

229 
out
[3] = (char) (
len
 > 2 ? 
cb64
[ 
in
[2] & 0x3f ] : '=');

230 
	}
}

233 void 
	$base64
(char *
in
, char *
out
, int 
inlen
, int 
maxlen
)

235 unsigned int 
ini
, 
outi
;

237 unsigned char 
inbuf
[3];

238 int 
len
;

240 for(
ini
 = 0, 
outi
 = 0; ini < 
inlen
 && outi+4 < 
maxlen
; ini+=3)

242 int 
dying
 = 0;

243 
inbuf
[0] = (unsigned char)
in
[
ini
];

244 if(
ini
 == 
inlen
-1)

246 
inbuf
[1] = 0;

247 
inbuf
[2] = 0;

248 
len
 = 1;

249 
dying
 = 1;

251 else if(
ini
 == 
inlen
-2)

253 
inbuf
[1] = 
in
[
ini
+1];

254 
inbuf
[2] = 0;

255 
len
 = 2;

256 
dying
 = 1;

260 
inbuf
[1] = 
in
[
ini
+1];

261 
inbuf
[2] = 
in
[
ini
+2];

262 
len
 = 3;

265 
	`encodeblock
(
inbuf
, 
out
+
outi
, 
len
);

266 
outi
 += 4;

267 
out
[
outi
] = 0;

268 if(
dying
)

271 
	}
}

	@/root/Robux/lib/console.c

2 #include 
	~<inc/string.h
>

3 #include 
	~<inc/lib.h
>

6 
	$cputchar
(int 
ch
)

8 char 
c
 = 
ch
;

12 
	`sys_cputs
(&
c
, 1);

13 
	}
}

16 
	$getchar
(void)

18 unsigned char 
c
;

19 int 
r
;

24 
r
 = 
	`read
(0, &
c
, 1);

25 if (
r
 < 0)

26 return 
r
;

27 if (
r
 < 1)

28 return -
E_EOF
;

29 return 
c
;

30 
	}
}

37 static 
ssize_t
 
devcons_read
(struct 
Fd
*, void*, 
size_t
);

38 static 
ssize_t
 
devcons_write
(struct 
Fd
*, const void*, 
size_t
);

39 static int 
devcons_close
(struct 
Fd
*);

40 static int 
devcons_stat
(struct 
Fd
*, struct 
Stat
*);

42 struct 
Dev
 
	gdevcons
 =

44 .
dev_id
 = 'c',

45 .
	gdev_name
 = "cons",

46 .
	gdev_read
 = 
devcons_read
,

47 .
	gdev_write
 = 
devcons_write
,

48 .
	gdev_close
 = 
devcons_close
,

49 .
	gdev_stat
 = 
devcons_stat


53 
	$iscons
(int 
fdnum
)

55 int 
r
;

56 struct 
Fd
 *
fd
;

58 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0)

59 return 
r
;

60 return 
fd
->
fd_dev_id
 == 
devcons
.
dev_id
;

61 
	}
}

64 
	$opencons
(void)

66 int 
r
;

67 struct 
Fd
* 
fd
;

69 if ((
r
 = 
	`fd_alloc
(&
fd
)) < 0)

70 return 
r
;

71 if ((
r
 = 
	`sys_page_alloc
(0, 
fd
, 
PTE_P
|
PTE_U
|
PTE_W
|
PTE_SHARE
)) < 0)

72 return 
r
;

73 
fd
->
fd_dev_id
 = 
devcons
.
dev_id
;

74 
fd
->
fd_omode
 = 
O_RDWR
;

75 return 
	`fd2num
(
fd
);

76 
	}
}

78 static 
ssize_t


79 
	$devcons_read
(struct 
Fd
 *
fd
, void *
vbuf
, 
size_t
 
n
)

81 int 
c
;

83 if (
n
 == 0)

86 while ((
c
 = 
	`sys_cgetc
()) == 0)

87 
	`sys_yield
();

88 if (
c
 < 0)

89 return 
c
;

90 if (
c
 == 0x04)

92 *(char*)
vbuf
 = 
c
;

94 
	}
}

96 static 
ssize_t


97 
	$devcons_write
(struct 
Fd
 *
fd
, const void *
vbuf
, 
size_t
 
n
)

99 int 
tot
, 
m
;

100 char 
buf
[128];

104 for (
tot
 = 0; tot < 
n
; tot += 
m
) {

105 
m
 = 
n
 - 
tot
;

106 if (
m
 > sizeof(
buf
) - 1)

107 
m
 = sizeof(
buf
) - 1;

108 
	`memmove
(
buf
, (char*)
vbuf
 + 
tot
, 
m
);

109 
	`sys_cputs
(
buf
, 
m
);

111 return 
tot
;

112 
	}
}

115 
	$devcons_close
(struct 
Fd
 *
fd
)

117 
	`USED
(
fd
);

120 
	}
}

123 
	$devcons_stat
(struct 
Fd
 *
fd
, struct 
Stat
 *
stat
)

125 
	`strcpy
(
stat
->
st_name
, "<cons>");

127 
	}
}

	@/root/Robux/lib/exit.c

2 #include 
	~<inc/lib.h
>

5 
	$exit
(void)

7 
	`close_all
();

8 
	`sys_env_destroy
(0);

9 
	}
}

	@/root/Robux/lib/fd.c

1 #include 
	~<inc/lib.h
>

3 #define 
	#debug
 0

	)

6 #define 
	#MAXFD
 32

	)

8 #define 
	#FDTABLE
 0xD0000000

	)

11 #define 
	#FILEDATA
 (
FDTABLE
 + 
MAXFD
*
PGSIZE
)

	)

14 #define 
	#INDEX2FD
(
i
) ((struct 
Fd
*) (
FDTABLE
 + (i)*
PGSIZE
))

	)

16 #define 
	#INDEX2DATA
(
i
) ((char*) (
FILEDATA
 + (i)*
PGSIZE
))

	)

24 
	$fd2num
(struct 
Fd
 *
fd
)

26 return ((
uintptr_t
) 
fd
 - 
FDTABLE
) / 
PGSIZE
;

27 
	}
}

30 
	$fd2data
(struct 
Fd
 *
fd
)

32 return 
	`INDEX2DATA
(
	`fd2num
(
fd
));

33 
	}
}

51 
	$fd_alloc
(struct 
Fd
 **
fd_store
)

53 int 
i
;

54 struct 
Fd
 *
fd
;

56 for (
i
 = 0; i < 
MAXFD
; i++) {

57 
fd
 = 
	`INDEX2FD
(
i
);

58 if ((
vpd
[
	`PDX
(
fd
)] & 
PTE_P
) == 0 || (
vpt
[
	`PGNUM
(fd)] & PTE_P) == 0) {

59 *
fd_store
 = 
fd
;

63 *
fd_store
 = 0;

64 return -
E_MAX_OPEN
;

65 
	}
}

74 
	$fd_lookup
(int 
fdnum
, struct 
Fd
 **
fd_store
)

76 struct 
Fd
 *
fd
;

78 if (
fdnum
 < 0 || fdnum >= 
MAXFD
) {

79 if (
debug
)

80 
	`cprintf
("[%08x] bad fd %d\n", 
thisenv
->
env_id
, 
fd
);

81 return -
E_INVAL
;

83 
fd
 = 
	`INDEX2FD
(
fdnum
);

84 if (!(
vpd
[
	`PDX
(
fd
)] & 
PTE_P
) || !(
vpt
[
	`PGNUM
(fd)] & PTE_P)) {

85 if (
debug
)

86 
	`cprintf
("[%08x] closed fd %d\n", 
thisenv
->
env_id
, 
fd
);

87 return -
E_INVAL
;

89 *
fd_store
 = 
fd
;

91 
	}
}

101 
	$fd_close
(struct 
Fd
 *
fd
, 
bool
 
must_exist
)

103 struct 
Fd
 *
fd2
;

104 struct 
Dev
 *
dev
;

105 int 
r
;

106 if ((
r
 = 
	`fd_lookup
(
	`fd2num
(
fd
), &
fd2
)) < 0

107 || 
fd
 != 
fd2
)

108 return (
must_exist
 ? 
r
 : 0);

109 if ((
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) >= 0) {

110 if (
dev
->
dev_close
)

111 
r
 = (*
dev
->
dev_close
)(
fd
);

113 
r
 = 0;

117 (void) 
	`sys_page_unmap
(0, 
fd
);

118 return 
r
;

119 
	}
}

126 static struct 
Dev
 *
	gdevtab
[] =

128 &
devfile
,

129 &
devsock
,

130 &
devpipe
,

131 &
devcons
,

136 
	$dev_lookup
(int 
dev_id
, struct 
Dev
 **
dev
)

138 int 
i
;

139 for (
i
 = 0; 
devtab
[i]; i++)

140 if (
devtab
[
i
]->
dev_id
 == dev_id) {

141 *
dev
 = 
devtab
[
i
];

144 
	`cprintf
("[%08x] unknown device type %d\n", 
thisenv
->
env_id
, 
dev_id
);

145 *
dev
 = 0;

146 return -
E_INVAL
;

147 
	}
}

150 
	$close
(int 
fdnum
)

152 struct 
Fd
 *
fd
;

153 int 
r
;

155 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0)

156 return 
r
;

158 return 
	`fd_close
(
fd
, 1);

159 
	}
}

162 
	$close_all
(void)

164 int 
i
;

165 for (
i
 = 0; i < 
MAXFD
; i++)

166 
	`close
(
i
);

167 
	}
}

172 
	$isopen
(int 
fd
)

174 struct 
Fd
 *
fdsave
;

175 int 
r
 = 
	`fd_lookup
(
fd
, &
fdsave
);

176 if(
r
 < 0)

180 
	}
}

188 
	$dup
(int 
oldfdnum
, int 
newfdnum
)

190 int 
r
;

191 char *
ova
, *
nva
;

192 
pte_t
 
pte
;

193 struct 
Fd
 *
oldfd
, *
newfd
;

195 if ((
r
 = 
	`fd_lookup
(
oldfdnum
, &
oldfd
)) < 0)

196 return 
r
;

197 
	`close
(
newfdnum
);

199 
newfd
 = 
	`INDEX2FD
(
newfdnum
);

200 
ova
 = 
	`fd2data
(
oldfd
);

201 
nva
 = 
	`fd2data
(
newfd
);

203 if ((
vpd
[
	`PDX
(
ova
)] & 
PTE_P
) && (
vpt
[
	`PGNUM
(ova)] & PTE_P))

204 if ((
r
 = 
	`sys_page_map
(0, 
ova
, 0, 
nva
, 
vpt
[
	`PGNUM
(ova)] & 
PTE_SYSCALL
)) < 0)

205 goto 
err
;

206 if ((
r
 = 
	`sys_page_map
(0, 
oldfd
, 0, 
newfd
, 
vpt
[
	`PGNUM
(oldfd)] & 
PTE_SYSCALL
)) < 0)

207 goto 
err
;

209 return 
newfdnum
;

211 
err
:

212 
	`sys_page_unmap
(0, 
newfd
);

213 
	`sys_page_unmap
(0, 
nva
);

214 return 
r
;

215 
	}
}

217 
ssize_t


218 
	$read
(int 
fdnum
, void *
buf
, 
size_t
 
n
)

220 int 
r
;

221 struct 
Dev
 *
dev
;

222 struct 
Fd
 *
fd
;

224 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0

225 || (
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) < 0)

226 return 
r
;

227 if ((
fd
->
fd_omode
 & 
O_ACCMODE
) == 
O_WRONLY
) {

228 
	`cprintf
("[%08x] read %d -- bad mode\n", 
thisenv
->
env_id
, 
fdnum
);

229 return -
E_INVAL
;

231 if (!
dev
->
dev_read
)

232 return -
E_NOT_SUPP
;

233 return (*
dev
->
dev_read
)(
fd
, 
buf
, 
n
);

234 
	}
}

236 
ssize_t


237 
	$readn
(int 
fdnum
, void *
buf
, 
size_t
 
n
)

239 int 
m
, 
tot
;

241 for (
tot
 = 0; tot < 
n
; tot += 
m
) {

242 
m
 = 
	`read
(
fdnum
, (char*)
buf
 + 
tot
, 
n
 - tot);

243 if (
m
 < 0)

244 return 
m
;

245 if (
m
 == 0)

248 return 
tot
;

249 
	}
}

251 
ssize_t


252 
	$write
(int 
fdnum
, const void *
buf
, 
size_t
 
n
)

254 int 
r
;

255 struct 
Dev
 *
dev
;

256 struct 
Fd
 *
fd
;

259 int 
t
 = 
	`sys_time_msec
();

261 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0

262 || (
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) < 0)

263 return 
r
;

264 if ((
fd
->
fd_omode
 & 
O_ACCMODE
) == 
O_RDONLY
) {

265 
	`cprintf
("[%08x] write %d -- bad mode\n", 
thisenv
->
env_id
, 
fdnum
);

266 return -
E_INVAL
;

268 if (
debug
)

269 
	`cprintf
("write %d %p %d via dev %s\n",

270 
fdnum
, 
buf
, 
n
, 
dev
->
dev_name
);

271 if (!
dev
->
dev_write
)

272 return -
E_NOT_SUPP
;

274 return (*
dev
->
dev_write
)(
fd
, 
buf
, 
n
);

275 
	}
}

278 
	$seek
(int 
fdnum
, 
off_t
 
offset
)

280 int 
r
;

281 struct 
Fd
 *
fd
;

283 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0)

284 return 
r
;

285 
fd
->
fd_offset
 = 
offset
;

287 
	}
}

290 
	$ftruncate
(int 
fdnum
, 
off_t
 
newsize
)

292 int 
r
;

293 struct 
Dev
 *
dev
;

294 struct 
Fd
 *
fd
;

295 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0

296 || (
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) < 0)

297 return 
r
;

298 if ((
fd
->
fd_omode
 & 
O_ACCMODE
) == 
O_RDONLY
) {

299 
	`cprintf
("[%08x] ftruncate %d -- bad mode\n",

300 
thisenv
->
env_id
, 
fdnum
);

301 return -
E_INVAL
;

303 if (!
dev
->
dev_trunc
)

304 return -
E_NOT_SUPP
;

305 return (*
dev
->
dev_trunc
)(
fd
, 
newsize
);

306 
	}
}

310 
	$fchmod
(int 
fdnum
, 
fsperm_t
 
newperm
)

312 int 
r
;

313 struct 
Fd
 *
fd
;

314 struct 
Dev
 *
dev
;

316 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0

317 || (
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) < 0)

318 return 
r
;

319 if (!
dev
->
dev_chmod
)

320 return -
E_NOT_SUPP
;

321 return (*
dev
->
dev_chmod
)(
fd
, 
newperm
);

324 
	}
}

328 
	$fchown
(int 
fdnum
, 
uid_t
 
uid
)

330 int 
r
;

331 struct 
Fd
 *
fd
;

332 struct 
Dev
 *
dev
;

334 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0

335 || (
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) < 0)

336 return 
r
;

337 if (!
dev
->
dev_chown
)

338 return -
E_NOT_SUPP
;

339 return (*
dev
->
dev_chown
)(
fd
, 
uid
);

340 
	}
}

344 
	$fchgrp
(int 
fdnum
, 
gid_t
 
gid
)

346 int 
r
;

347 struct 
Fd
 *
fd
;

348 struct 
Dev
 *
dev
;

350 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0

351 || (
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) < 0)

352 return 
r
;

353 if (!
dev
->
dev_chgrp
)

354 return -
E_NOT_SUPP
;

355 return (*
dev
->
dev_chgrp
)(
fd
, 
gid
);

358 
	}
}

361 
	$fstat
(int 
fdnum
, struct 
Stat
 *
stat
)

363 int 
r
;

364 struct 
Dev
 *
dev
;

365 struct 
Fd
 *
fd
;

367 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0

368 || (
r
 = 
	`dev_lookup
(
fd
->
fd_dev_id
, &
dev
)) < 0)

369 return 
r
;

370 if (!
dev
->
dev_stat
)

371 return -
E_NOT_SUPP
;

372 
stat
->
st_name
[0] = 0;

373 
stat
->
st_size
 = 0;

374 
stat
->
st_isdir
 = 0;

375 
stat
->
st_dev
 = 
dev
;

376 
stat
->
st_uid
 = 0;

377 
stat
->
st_gid
 = 0;

378 
stat
->
st_perm
 = 0;

379 return (*
dev
->
dev_stat
)(
fd
, 
stat
);

380 
	}
}

383 
	$stat
(const char *
path
, struct 
Stat
 *
stat
)

385 int 
fd
, 
r
;

387 if ((
fd
 = 
	`open
(
path
, 
O_RDONLY
)) < 0)

388 return 
fd
;

389 
r
 = 
	`fstat
(
fd
, 
stat
);

390 
	`close
(
fd
);

391 return 
r
;

392 
	}
}

	@/root/Robux/lib/file.c

1 #include 
	~<inc/fs.h
>

2 #include 
	~<inc/string.h
>

3 #include 
	~<inc/lib.h
>

5 #define 
	#debug
 0

	)

7 union 
Fsipc
 
fsipcbuf
 
__attribute__
((
aligned
(
PGSIZE
)));

16 
	$fsipc
(unsigned 
type
, void *
dstva
)

18 static 
envid_t
 
fsenv
;

19 if (
fsenv
 == 0)

20 
fsenv
 = 
	`ipc_find_env
(
ENV_TYPE_FS
);

22 
	`static_assert
(sizeof(
fsipcbuf
) == 
PGSIZE
);

24 if (
debug
)

25 
	`cprintf
("[%08x] fsipc %d %08x\n", 
thisenv
->
env_id
, 
type
, *(
uint32_t
 *)&
fsipcbuf
);

27 
	`ipc_send
(
fsenv
, 
type
, &
fsipcbuf
, 
PTE_P
 | 
PTE_W
 | 
PTE_U
);

28 return 
	`ipc_recv
(
NULL
, 
dstva
, NULL);

29 
	}
}

31 static int 
devfile_flush
(struct 
Fd
 *
fd
);

32 static 
ssize_t
 
devfile_read
(struct 
Fd
 *
fd
, void *
buf
, 
size_t
 
n
);

33 static 
ssize_t
 
devfile_write
(struct 
Fd
 *
fd
, const void *
buf
, 
size_t
 
n
);

34 static int 
devfile_stat
(struct 
Fd
 *
fd
, struct 
Stat
 *
stat
);

35 static int 
devfile_trunc
(struct 
Fd
 *
fd
, 
off_t
 
newsize
);

36 static int 
devfile_chmod
(struct 
Fd
 *
fd
, 
fsperm_t
 
newperm
);

37 static int 
devfile_chown
(struct 
Fd
 *
fd
, 
uid_t
 
uid
);

38 static int 
devfile_chgrp
(struct 
Fd
 *
fd
, 
gid_t
 
gid
);

41 struct 
Dev
 
	gdevfile
 =

43 .
dev_id
 = 'f',

44 .
	gdev_name
 = "file",

45 .
	gdev_read
 = 
devfile_read
,

46 .
	gdev_write
 = 
devfile_write
,

47 .
	gdev_close
 = 
devfile_flush
,

48 .
	gdev_stat
 = 
devfile_stat
,

49 .
	gdev_trunc
 = 
devfile_trunc
,

50 .
	gdev_chmod
 = 
devfile_chmod
,

51 .
	gdev_chown
 = 
devfile_chown
,

52 .
	gdev_chgrp
 = 
devfile_chgrp


62 
	$open
(const char *
path
, int 
mode
)

79 struct 
Fd
 *
fd
;

80 int 
r
;

82 if (
	`strlen
(
path
) >= 
MAXPATHLEN
)

83 return -
E_BAD_PATH
;

85 if ((
r
 = 
	`fd_alloc
(&
fd
)) < 0)

86 return 
r
;

91 
	`memmove
(
fsipcbuf
.
open
.
req_path
, 
path
, 
	`strlen
(path)+1);

92 
fsipcbuf
.
open
.
req_omode
 = 
mode
;

93 if ((
r
 = 
	`fsipc
(
FSREQ_OPEN
, 
fd
)) < 0)

95 
	`fd_close
(
fd
, 0);

96 return 
r
;

100 return 
	`fd2num
(
fd
);

101 
	}
}

112 
	$devfile_flush
(struct 
Fd
 *
fd
)

114 
fsipcbuf
.
flush
.
req_fileid
 = 
fd
->
fd_file
.
id
;

115 return 
	`fsipc
(
FSREQ_FLUSH
, 
NULL
);

116 
	}
}

123 static 
ssize_t


124 
	$devfile_read
(struct 
Fd
 *
fd
, void *
buf
, 
size_t
 
n
)

131 
fsipcbuf
.
read
.
req_fileid
 = 
fd
->
fd_file
.
id
;

132 
fsipcbuf
.
read
.
req_n
 = 
n
;

133 int 
r
 = 
	`fsipc
(
FSREQ_READ
, 
NULL
);

134 if (
r
 < 0)

135 return 
r
;

137 
	`memmove
(
buf
, 
fsipcbuf
.
readRet
.
ret_buf
, 
r
);

138 return 
r
;

139 
	}
}

146 static 
ssize_t


147 
	$devfile_write
(struct 
Fd
 *
fd
, const void *
buf
, 
size_t
 
n
)

154 
fsipcbuf
.
write
.
req_fileid
 = 
fd
->
fd_file
.
id
;

155 
fsipcbuf
.
write
.
req_n
 = 
	`MIN
(
n
, sizeof(fsipcbuf.write.
req_buf
));

156 
	`memmove
(
fsipcbuf
.
write
.
req_buf
, 
buf
, fsipcbuf.write.
req_n
);

159 int 
r
 = 
	`fsipc
(
FSREQ_WRITE
, 
NULL
);

160 return 
r
;

161 
	}
}

164 
	$devfile_stat
(struct 
Fd
 *
fd
, struct 
Stat
 *
st
)

166 int 
r
;

168 
fsipcbuf
.
stat
.
req_fileid
 = 
fd
->
fd_file
.
id
;

169 if ((
r
 = 
	`fsipc
(
FSREQ_STAT
, 
NULL
)) < 0)

170 return 
r
;

171 
	`strcpy
(
st
->
st_name
, 
fsipcbuf
.
statRet
.
ret_name
);

172 
st
->
st_size
 = 
fsipcbuf
.
statRet
.
ret_size
;

173 
st
->
st_isdir
 = 
fsipcbuf
.
statRet
.
ret_isdir
;

174 
st
->
st_uid
 = 
fsipcbuf
.
statRet
.
ret_uid
;

175 
st
->
st_gid
 = 
fsipcbuf
.
statRet
.
ret_gid
;

176 
st
->
st_perm
 = 
fsipcbuf
.
statRet
.
ret_perm
;

178 
	}
}

182 
	$devfile_trunc
(struct 
Fd
 *
fd
, 
off_t
 
newsize
)

184 
fsipcbuf
.
set_size
.
req_fileid
 = 
fd
->
fd_file
.
id
;

185 
fsipcbuf
.
set_size
.
req_size
 = 
newsize
;

186 return 
	`fsipc
(
FSREQ_SET_SIZE
, 
NULL
);

187 
	}
}

191 
	$devfile_chmod
(struct 
Fd
 *
fd
, 
fsperm_t
 
newperm
)

193 
fsipcbuf
.
chmod
.
req_fileid
 = 
fd
->
fd_file
.
id
;

194 
fsipcbuf
.
chmod
.
f_perm
 = 
newperm
;

195 return 
	`fsipc
(
FSREQ_CHMOD
, 
NULL
);

196 
	}
}

200 
	$devfile_chown
(struct 
Fd
 *
fd
, 
uid_t
 
uid
)

202 
fsipcbuf
.
chown
.
req_fileid
 = 
fd
->
fd_file
.
id
;

203 
fsipcbuf
.
chown
.
uid
 = uid;

204 return 
	`fsipc
(
FSREQ_CHOWN
, 
NULL
);

205 
	}
}

209 
	$devfile_chgrp
(struct 
Fd
 *
fd
, 
gid_t
 
gid
)

211 
fsipcbuf
.
chgrp
.
req_fileid
 = 
fd
->
fd_file
.
id
;

212 
fsipcbuf
.
chgrp
.
gid
 = gid;

213 return 
	`fsipc
(
FSREQ_CHGRP
, 
NULL
);

214 
	}
}

221 
	$remove
(const char *
path
)

223 if (
	`strlen
(
path
) >= 
MAXPATHLEN
)

224 return -
E_BAD_PATH
;

225 
	`strcpy
(
fsipcbuf
.
remove
.
req_path
, 
path
);

226 return 
	`fsipc
(
FSREQ_REMOVE
, 
NULL
);

227 
	}
}

231 
	$sync
(void)

236 return 
	`fsipc
(
FSREQ_SYNC
, 
NULL
);

237 
	}
}

	@/root/Robux/lib/fork.c

3 #include 
	~<inc/string.h
>

4 #include 
	~<inc/lib.h
>

8 #define 
	#PTE_COW
 0x800

	)

15 
	$pgfault
(struct 
UTrapframe
 *
utf
)

17 void *
addr
 = (void *) 
utf
->
utf_fault_va
;

18 
uint32_t
 
err
 = 
utf
->
utf_err
;

19 int 
r
;

29 
pde_t
 
pde
 = 
vpt
[(
uint32_t
)
addr
>>12];

30 if(!((
pde
 & 
PTE_COW
) &&

31 (
err
 & 
FEC_WR
)))

33 
	`panic
("Unrecoverable page fault at 0x%08x\n", 
addr
);

45 
envid_t
 
myid
 = 
	`sys_getenvid
();

46 
	`sys_page_alloc
(
myid
, 
PFTEMP
, 
PTE_P
 | 
PTE_W
 | 
PTE_U
);

47 
	`memmove
((void*)
PFTEMP
, (void*)
	`ROUNDDOWN
(
addr
, 
PGSIZE
), PGSIZE);

48 
	`sys_page_map
(
myid
, (void*)
PFTEMP
, myid, (void*)
	`ROUNDDOWN
(
addr
, 
PGSIZE
), 
PTE_P
 | 
PTE_W
 | 
PTE_U
);

50 
	}
}

64 
	$duppage
(
envid_t
 
envid
, unsigned 
pn
)

66 int 
r
;

69 
envid_t
 
myid
 = 
	`sys_getenvid
();

70 int 
perm
 = 
vpt
[
pn
] & 
PTE_SYSCALL
;

71 if(
perm
 & 
PTE_COW
 || perm & 
PTE_W
)

73 
perm
 |= 
PTE_COW
;

74 
perm
 &= ~
PTE_W
;

77 int 
ret
 = 
	`sys_page_map
(
myid
, (void*)(
pn
*
PGSIZE
), 
envid
, (void*)(pn*PGSIZE), 
perm
);

78 if(
ret
 < 0)

79 return 
ret
;

80 
ret
 = 
	`sys_page_map
(
myid
, (void*)(
pn
*
PGSIZE
), myid, (void*)(pn*PGSIZE), 
perm
);

81 if(
ret
 < 0)

82 return 
ret
;

85 
	}
}

104 
envid_t


105 
	$fork
(void)

108 int 
ret
;

109 
envid_t
 
myid
 = 
	`sys_getenvid
();

110 
	`set_pgfault_handler
(
pgfault
);

112 
envid_t
 
newid
 = 
	`sys_exofork
();

113 if(
newid
 < 0)

114 
	`panic
("Failed to exofork in fork\n");

115 if(
newid
 != 0)

118 int 
i
;

119 for(
i
=0; i < 
UTOP
 >> 12; i++)

122 if(
i
 << 12 == 
UXSTACKTOP
 - 
PGSIZE
)

124 if(!
vpd
[
i
>>10] & 
PTE_P
)

129 
pte_t
 
pte
 = 
vpt
[
i
];

130 
pte
 &= 
PTE_SYSCALL
 & (
vpd
[
i
>>10] | 
PTE_COW
 | 
PTE_SHARE
);

131 if(
pte
 & 
PTE_P
 && pte & (
PTE_W
 | 
PTE_COW
) && ((pte & 
PTE_SHARE
) == 0))

133 
ret
 = 
	`duppage
(
newid
, 
i
);

134 if(
ret
 < 0)

135 
	`panic
("Failed to duppage in parent fork: %e at i = %d\n", 
ret
, 
i
);

137 else if(
pte
 & 
PTE_P
 && pte & 
PTE_SHARE
)

139 
ret
 = 
	`sys_page_map
(
myid
, (void*)(
i
*
PGSIZE
), 
newid
, (void*)(i*PGSIZE), 
pte
 & 
PTE_SYSCALL
);

140 if(
ret
 < 0)

141 
	`panic
("Failed to copy [W] page mapping to child: %e\n", 
ret
);

143 else if(
pte
 & 
PTE_P
)

145 
ret
 = 
	`sys_page_map
(
myid
, (void*)(
i
*
PGSIZE
), 
newid
, (void*)(i*PGSIZE), 
pte
 & 
PTE_SYSCALL
);

146 if(
ret
 < 0)

147 
	`panic
("Failed to copy page mapping to child: %e\n", 
ret
);

151 
ret
 = 
	`sys_env_set_pgfault_upcall
(
newid
, 
thisenv
->
env_pgfault_upcall
);

152 if(
ret
 < 0)

153 
	`panic
("Failed to set upcall in parent fork\n");

155 
	`sys_page_alloc
(
newid
, (void*)(
UXSTACKTOP
-
PGSIZE
), 
PTE_P
 | 
PTE_U
 | 
PTE_W
);

157 
	`sys_env_set_status
(
newid
, 
ENV_RUNNABLE
);

159 return 
newid
;

163 
thisenv
 = &
envs
[
	`ENVX
(
	`sys_getenvid
())];

167 
	}
}

171 
	$sfork
(void)

173 
	`panic
("sfork not implemented");

174 return -
E_INVAL
;

175 
	}
}

	@/root/Robux/lib/fprintf.c

1 #include 
	~<inc/lib.h
>

8 struct 
	sprintbuf
 {

9 int 
	mfd
;

10 int 
	midx
;

11 
ssize_t
 
	mresult
;

12 int 
	merror
;

13 char 
	mbuf
[256];

18 
	$writebuf
(struct 
printbuf
 *
b
)

20 if (
b
->
error
 > 0) {

21 
ssize_t
 
result
 = 
	`write
(
b
->
fd
, b->
buf
, b->
idx
);

22 if (
result
 > 0)

23 
b
->
result
 += result;

24 if (
result
 != 
b
->
idx
)

25 
b
->
error
 = (
result
 < 0 ? result : 0);

27 
	}
}

30 
	$putch
(int 
ch
, void *
thunk
)

32 struct 
printbuf
 *
b
 = (struct printbuf *) 
thunk
;

33 
b
->
buf
[b->
idx
++] = 
ch
;

34 if (
b
->
idx
 == 256) {

35 
	`writebuf
(
b
);

36 
b
->
idx
 = 0;

38 
	}
}

41 
	$vfprintf
(int 
fd
, const char *
fmt
, 
va_list
 
ap
)

43 struct 
printbuf
 
b
;

45 
b
.
fd
 = fd;

46 
b
.
idx
 = 0;

47 
b
.
result
 = 0;

48 
b
.
error
 = 1;

49 
	`vprintfmt
(
putch
, &
b
, 
fmt
, 
ap
);

50 if (
b
.
idx
 > 0)

51 
	`writebuf
(&
b
);

53 return (
b
.
result
 ? b.result : b.
error
);

54 
	}
}

57 
	$fprintf
(int 
fd
, const char *
fmt
, ...)

59 
va_list
 
ap
;

60 int 
cnt
;

62 
	`va_start
(
ap
, 
fmt
);

63 
cnt
 = 
	`vfprintf
(
fd
, 
fmt
, 
ap
);

64 
	`va_end
(
ap
);

66 return 
cnt
;

67 
	}
}

70 
	$printf
(const char *
fmt
, ...)

72 
va_list
 
ap
;

73 int 
cnt
;

75 
	`va_start
(
ap
, 
fmt
);

76 
cnt
 = 
	`vfprintf
(1, 
fmt
, 
ap
);

77 
	`va_end
(
ap
);

79 return 
cnt
;

80 
	}
}

	@/root/Robux/lib/getid.c

1 #include 
	~<inc/lib.h
>

4 
uid_t


5 
	$getuid
()

7 return 
	`sys_get_env_user_id
();

8 
	}
}

11 
gid_t


12 
	$getgid
()

14 return 
	`sys_get_env_group_id
();

15 
	}
}

	@/root/Robux/lib/ipc.c

3 #include 
	~<inc/lib.h
>

22 
int32_t


23 
	$ipc_recv
(
envid_t
 *
from_env_store
, void *
pg
, int *
perm_store
)

26 if(!
pg
)

27 
pg
 = (void*)0xFFFFFFFF;

29 int 
r
;

30 if ((
r
 = 
	`sys_ipc_recv
(
pg
)) < 0)

32 if (
from_env_store
)

33 *
from_env_store
 = 0;

34 if (
perm_store
)

35 *
perm_store
 = 0;

37 return 
r
;

41 if (
from_env_store
)

42 *
from_env_store
 = 
thisenv
->
env_ipc_from
;

43 if (
perm_store
)

44 *
perm_store
 = 
thisenv
->
env_ipc_perm
;

46 return 
thisenv
->
env_ipc_value
;

48 
	}
}

59 
	$ipc_send
(
envid_t
 
to_env
, 
uint32_t
 
val
, void *
pg
, int 
perm
)

63 if(!
pg
)

64 
pg
 = (void*)0xFFFFFFFF;

67 int 
ret
 = -
E_IPC_NOT_RECV
;

69 while(
ret
 == -
E_IPC_NOT_RECV
)

71 
ret
 = 
	`sys_ipc_try_send
(
to_env
, 
val
, 
pg
, 
perm
);

72 if(
ret
 != 0)

73 
	`sys_yield
();

76 if(
ret
 != 0)

77 
	`panic
("ipc_send got unknown error %d: %e\n", 
ret
, ret);

79 
	}
}

84 
envid_t


85 
	$ipc_find_env
(enum 
EnvType
 
type
)

87 int 
i
;

88 for (
i
 = 0; i < 
NENV
; i++)

89 if (
envs
[
i
].
env_type
 == 
type
)

90 return 
envs
[
i
].
env_id
;

92 
	}
}

	@/root/Robux/lib/libmain.c

4 #include 
	~<inc/lib.h
>

6 extern void 
umain
(int 
argc
, char **
argv
);

8 const volatile struct 
Env
 *
	gthisenv
;

9 const char *
	gbinaryname
 = "<unknown>";

12 
	$libmain
(int 
argc
, char **
argv
)

17 
thisenv
 = &
envs
[
	`ENVX
(
	`sys_getenvid
())];

20 if (
argc
 > 0)

21 
binaryname
 = 
argv
[0];

28 if(!
	`isopen
(0) && !isopen(1))

30 
	`opencons
();

31 
	`opencons
();

34 
	`umain
(
argc
, 
argv
);

37 
	`exit
();

38 
	}
}

	@/root/Robux/lib/malloc.c

2 #include 
	~<inc/lib.h
>

20 
	mMAXMALLOC
 = 1024*1024

23 #define 
	#PTE_CONTINUED
 0x400

	)

25 static 
uint8_t
 *
	gmbegin
 = (uint8_t*) 0x08000000;

26 static 
uint8_t
 *
	gmend
 = (uint8_t*) 0x10000000;

27 static 
uint8_t
 *
	gmptr
;

30 
	$isfree
(void *
v
, 
size_t
 
n
)

32 
uintptr_t
 
va
, 
end_va
 = (uintptr_t) 
v
 + 
n
;

34 for (
va
 = (
uintptr_t
) 
v
; va < 
end_va
; va += 
PGSIZE
)

35 if (
va
 >= (
uintptr_t
) 
mend


36 || ((
vpd
[
	`PDX
(
va
)] & 
PTE_P
) && (
vpt
[
	`PGNUM
(va)] & PTE_P)))

39 
	}
}

42 
	$malloc
(
size_t
 
n
)

44 int 
i
, 
cont
;

45 int 
nwrap
;

46 
uint32_t
 *
ref
;

47 void *
v
;

49 if (
mptr
 == 0)

50 
mptr
 = 
mbegin
;

52 
n
 = 
	`ROUNDUP
(n, 4);

54 if (
n
 >= 
MAXMALLOC
)

57 if ((
uintptr_t
) 
mptr
 % 
PGSIZE
){

63 
ref
 = (
uint32_t
*) (
	`ROUNDUP
(
mptr
, 
PGSIZE
) - 4);

64 if ((
uintptr_t
) 
mptr
 / 
PGSIZE
 == (uintptr_t) (mptr + 
n
 - 1 + 4) / PGSIZE) {

65 (*
ref
)++;

66 
v
 = 
mptr
;

67 
mptr
 += 
n
;

68 return 
v
;

73 
	`free
(
mptr
);

74 
mptr
 = 
	`ROUNDDOWN
(mptr + 
PGSIZE
, PGSIZE);

83 
nwrap
 = 0;

85 if (
	`isfree
(
mptr
, 
n
 + 4))

87 
mptr
 += 
PGSIZE
;

88 if (
mptr
 == 
mend
) {

89 
mptr
 = 
mbegin
;

90 if (++
nwrap
 == 2)

98 for (
i
 = 0; i < 
n
 + 4; i += 
PGSIZE
){

99 
cont
 = (
i
 + 
PGSIZE
 < 
n
 + 4) ? 
PTE_CONTINUED
 : 0;

100 if (
	`sys_page_alloc
(0, 
mptr
 + 
i
, 
PTE_P
|
PTE_U
|
PTE_W
|
cont
) < 0){

101 for (; 
i
 >= 0; i -= 
PGSIZE
)

102 
	`sys_page_unmap
(0, 
mptr
 + 
i
);

107 
ref
 = (
uint32_t
*) (
mptr
 + 
i
 - 4);

108 *
ref
 = 2;

109 
v
 = 
mptr
;

110 
mptr
 += 
n
;

111 return 
v
;

112 
	}
}

115 
	$free
(void *
v
)

117 
uint8_t
 *
c
;

118 
uint32_t
 *
ref
;

120 if (
v
 == 0)

122 
	`assert
(
mbegin
 <= (
uint8_t
*) 
v
 && (uint8_t*) v < 
mend
);

124 
c
 = 
	`ROUNDDOWN
(
v
, 
PGSIZE
);

126 while (
vpt
[
	`PGNUM
(
c
)] & 
PTE_CONTINUED
) {

127 
	`sys_page_unmap
(0, 
c
);

128 
c
 += 
PGSIZE
;

129 
	`assert
(
mbegin
 <= 
c
 && c < 
mend
);

136 
ref
 = (
uint32_t
*) (
c
 + 
PGSIZE
 - 4);

137 if (--(*
ref
) == 0)

138 
	`sys_page_unmap
(0, 
c
);

139 
	}
}

	@/root/Robux/lib/nsipc.c

1 #include 
	~<inc/ns.h
>

2 #include 
	~<inc/lib.h
>

3 #include 
	~<lwip/sockets.h
>

5 #define 
	#debug
 0

	)

8 #define 
	#REQVA
 0x0ffff000

	)

9 union 
Nsipc
 
nsipcbuf
 
__attribute__
((
aligned
(
PGSIZE
)));

17 
	$nsipc
(unsigned 
type
)

19 static 
envid_t
 
nsenv
;

20 if (
nsenv
 == 0)

21 
nsenv
 = 
	`ipc_find_env
(
ENV_TYPE_NS
);

23 
	`static_assert
(sizeof(
nsipcbuf
) == 
PGSIZE
);

25 if (
debug
)

26 
	`cprintf
("[%08x] nsipc %d\n", 
thisenv
->
env_id
, 
type
);

28 
	`ipc_send
(
nsenv
, 
type
, &
nsipcbuf
, 
PTE_P
|
PTE_W
|
PTE_U
);

29 return 
	`ipc_recv
(
NULL
, NULL, NULL);

30 
	}
}

33 
	$nsipc_accept
(int 
s
, struct 
sockaddr
 *
addr
, 
socklen_t
 *
addrlen
)

35 int 
r
;

37 
nsipcbuf
.
accept
.
req_s
 = 
s
;

38 if ((
r
 = 
	`nsipc
(
NSREQ_ACCEPT
)) >= 0) {

39 struct 
Nsret_accept
 *
ret
 = &
nsipcbuf
.
acceptRet
;

40 
	`memmove
(
addr
, &
ret
->
ret_addr
, ret->
ret_addrlen
);

41 *
addrlen
 = 
ret
->
ret_addrlen
;

43 return 
r
;

44 
	}
}

47 
	$nsipc_bind
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
)

49 
nsipcbuf
.
bind
.
req_s
 = 
s
;

50 
	`memmove
(&
nsipcbuf
.
bind
.
req_name
, 
name
, 
namelen
);

51 
nsipcbuf
.
bind
.
req_namelen
 = 
namelen
;

52 return 
	`nsipc
(
NSREQ_BIND
);

53 
	}
}

56 
	$nsipc_shutdown
(int 
s
, int 
how
)

58 
nsipcbuf
.
shutdown
.
req_s
 = 
s
;

59 
nsipcbuf
.
shutdown
.
req_how
 = 
how
;

60 return 
	`nsipc
(
NSREQ_SHUTDOWN
);

61 
	}
}

64 
	$nsipc_close
(int 
s
)

66 
nsipcbuf
.
close
.
req_s
 = 
s
;

67 return 
	`nsipc
(
NSREQ_CLOSE
);

68 
	}
}

71 
	$nsipc_connect
(int 
s
, const struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
)

73 
nsipcbuf
.
connect
.
req_s
 = 
s
;

74 
	`memmove
(&
nsipcbuf
.
connect
.
req_name
, 
name
, 
namelen
);

75 
nsipcbuf
.
connect
.
req_namelen
 = 
namelen
;

76 return 
	`nsipc
(
NSREQ_CONNECT
);

77 
	}
}

80 
	$nsipc_listen
(int 
s
, int 
backlog
)

82 
nsipcbuf
.
listen
.
req_s
 = 
s
;

83 
nsipcbuf
.
listen
.
req_backlog
 = 
backlog
;

84 return 
	`nsipc
(
NSREQ_LISTEN
);

85 
	}
}

88 
	$nsipc_recv
(int 
s
, void *
mem
, int 
len
, unsigned int 
flags
)

90 int 
r
;

92 
nsipcbuf
.
recv
.
req_s
 = 
s
;

93 
nsipcbuf
.
recv
.
req_len
 = 
len
;

94 
nsipcbuf
.
recv
.
req_flags
 = 
flags
;

96 if ((
r
 = 
	`nsipc
(
NSREQ_RECV
)) >= 0) {

97 
	`assert
(
r
 < 1600 && r <= 
len
);

98 
	`memmove
(
mem
, 
nsipcbuf
.
recvRet
.
ret_buf
, 
r
);

101 return 
r
;

102 
	}
}

105 
	$nsipc_send
(int 
s
, const void *
buf
, int 
size
, unsigned int 
flags
)

107 
nsipcbuf
.
send
.
req_s
 = 
s
;

109 if(
size
 > 1599)

111 
	`printf
("network: packet too big\n");

112 return -
E_INVAL
;

115 
	`memmove
(&
nsipcbuf
.
send
.
req_buf
, 
buf
, 
size
);

116 
nsipcbuf
.
send
.
req_size
 = 
size
;

117 
nsipcbuf
.
send
.
req_flags
 = 
flags
;

118 return 
	`nsipc
(
NSREQ_SEND
);

119 
	}
}

122 
	$nsipc_socket
(int 
domain
, int 
type
, int 
protocol
)

124 
nsipcbuf
.
socket
.
req_domain
 = 
domain
;

125 
nsipcbuf
.
socket
.
req_type
 = 
type
;

126 
nsipcbuf
.
socket
.
req_protocol
 = 
protocol
;

127 return 
	`nsipc
(
NSREQ_SOCKET
);

128 
	}
}

	@/root/Robux/lib/pageref.c

1 #include 
	~<inc/lib.h
>

4 
	$pageref
(void *
v
)

6 
pte_t
 
pte
;

8 if (!(
vpd
[
	`PDX
(
v
)] & 
PTE_P
))

10 
pte
 = 
vpt
[
	`PGNUM
(
v
)];

11 if (!(
pte
 & 
PTE_P
))

13 return 
pages
[
	`PGNUM
(
pte
)].
pp_ref
;

14 
	}
}

	@/root/Robux/lib/panic.c

2 #include 
	~<inc/lib.h
>

10 
	$_panic
(const char *
file
, int 
line
, const char *
fmt
, ...)

12 
va_list
 
ap
;

14 
	`va_start
(
ap
, 
fmt
);

17 
	`cprintf
("[%08x] user panic in %s at %s:%d: ",

18 
	`sys_getenvid
(), 
binaryname
, 
file
, 
line
);

19 
	`vcprintf
(
fmt
, 
ap
);

20 
	`cprintf
("\n");

24 
asm
 volatile("int3");

25 
	}
}

	@/root/Robux/lib/pgfault.c

7 #include 
	~<inc/lib.h
>

11 extern void 
_pgfault_upcall
(void);

14 void (*
_pgfault_handler
)(struct 
UTrapframe
 *
utf
);

25 
	`set_pgfault_handler
(void (*
handler
)(struct 
UTrapframe
 *
utf
))

27 int 
r
;

29 if (
_pgfault_handler
 == 0) {

32 int 
ret
 = 
	`sys_page_alloc
(
	`sys_getenvid
(), (void*)
UXSTACKTOP
-
PGSIZE
, 
PTE_W
 | 
PTE_P
 | 
PTE_U
);

33 if(
ret
 < 0)

35 
	`panic
("Page alloc failed %e\n", 
ret
);

37 
ret
 = 
	`sys_env_set_pgfault_upcall
(
	`sys_getenvid
(), (void*)
_pgfault_upcall
);

38 if(
ret
 < 0)

40 
	`panic
("Set upcall failed %e\n", 
ret
);

45 
_pgfault_handler
 = 
handler
;

46 
	}
}

	@/root/Robux/lib/pipe.c

1 #include 
	~<inc/lib.h
>

3 #define 
	#debug
 0

	)

5 static 
ssize_t
 
devpipe_read
(struct 
Fd
 *
fd
, void *
buf
, 
size_t
 
n
);

6 static 
ssize_t
 
devpipe_write
(struct 
Fd
 *
fd
, const void *
buf
, 
size_t
 
n
);

7 static int 
devpipe_stat
(struct 
Fd
 *
fd
, struct 
Stat
 *
stat
);

8 static int 
devpipe_close
(struct 
Fd
 *
fd
);

10 struct 
Dev
 
	gdevpipe
 =

12 .
dev_id
 = 'p',

13 .
	gdev_name
 = "pipe",

14 .
	gdev_read
 = 
devpipe_read
,

15 .
	gdev_write
 = 
devpipe_write
,

16 .
	gdev_close
 = 
devpipe_close
,

17 .
	gdev_stat
 = 
devpipe_stat
,

20 #define 
	#PIPEBUFSIZ
 32

21 

	)

22 struct 
	sPipe
 {

23 
off_t
 
	mp_rpos
;

24 
off_t
 
	mp_wpos
;

25 
uint8_t
 
	mp_buf
[
PIPEBUFSIZ
];

29 
	$pipe
(int 
pfd
[2])

31 int 
r
;

32 struct 
Fd
 *
fd0
, *
fd1
;

33 void *
va
;

36 if ((
r
 = 
	`fd_alloc
(&
fd0
)) < 0

37 || (
r
 = 
	`sys_page_alloc
(0, 
fd0
, 
PTE_P
|
PTE_W
|
PTE_U
|
PTE_SHARE
)) < 0)

38 goto 
err
;

40 if ((
r
 = 
	`fd_alloc
(&
fd1
)) < 0

41 || (
r
 = 
	`sys_page_alloc
(0, 
fd1
, 
PTE_P
|
PTE_W
|
PTE_U
|
PTE_SHARE
)) < 0)

42 goto 
err1
;

45 
va
 = 
	`fd2data
(
fd0
);

46 if ((
r
 = 
	`sys_page_alloc
(0, 
va
, 
PTE_P
|
PTE_W
|
PTE_U
|
PTE_SHARE
)) < 0)

47 goto 
err2
;

48 if ((
r
 = 
	`sys_page_map
(0, 
va
, 0, 
	`fd2data
(
fd1
), 
PTE_P
|
PTE_W
|
PTE_U
|
PTE_SHARE
)) < 0)

49 goto 
err3
;

52 
fd0
->
fd_dev_id
 = 
devpipe
.
dev_id
;

53 
fd0
->
fd_omode
 = 
O_RDONLY
;

55 
fd1
->
fd_dev_id
 = 
devpipe
.
dev_id
;

56 
fd1
->
fd_omode
 = 
O_WRONLY
;

58 if (
debug
)

59 
	`cprintf
("[%08x] pipecreate %08x\n", 
thisenv
->
env_id
, 
vpt
[
	`PGNUM
(
va
)]);

61 
pfd
[0] = 
	`fd2num
(
fd0
);

62 
pfd
[1] = 
	`fd2num
(
fd1
);

65 
err3
:

66 
	`sys_page_unmap
(0, 
va
);

67 
err2
:

68 
	`sys_page_unmap
(0, 
fd1
);

69 
err1
:

70 
	`sys_page_unmap
(0, 
fd0
);

71 
err
:

72 return 
r
;

73 
	}
}

76 
	$_pipeisclosed
(struct 
Fd
 *
fd
, struct 
Pipe
 *
p
)

78 int 
n
, 
nn
, 
ret
;

81 
n
 = 
thisenv
->
env_runs
;

82 
ret
 = 
	`pageref
(
fd
) == pageref(
p
);

83 
nn
 = 
thisenv
->
env_runs
;

84 if (
n
 == 
nn
)

85 return 
ret
;

86 if (
n
 != 
nn
 && 
ret
 == 1)

87 
	`cprintf
("pipe race avoided\n", 
n
, 
thisenv
->
env_runs
, 
ret
);

89 
	}
}

92 
	$pipeisclosed
(int 
fdnum
)

94 struct 
Fd
 *
fd
;

95 struct 
Pipe
 *
p
;

96 int 
r
;

98 if ((
r
 = 
	`fd_lookup
(
fdnum
, &
fd
)) < 0)

99 return 
r
;

100 
p
 = (struct 
Pipe
*) 
	`fd2data
(
fd
);

101 return 
	`_pipeisclosed
(
fd
, 
p
);

102 
	}
}

104 static 
ssize_t


105 
	$devpipe_read
(struct 
Fd
 *
fd
, void *
vbuf
, 
size_t
 
n
)

107 
uint8_t
 *
buf
;

108 
size_t
 
i
;

109 struct 
Pipe
 *
p
;

111 
p
 = (struct 
Pipe
*)
	`fd2data
(
fd
);

112 if (
debug
)

113 
	`cprintf
("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",

114 
thisenv
->
env_id
, 
vpt
[
	`PGNUM
(
p
)], 
n
, p->
p_rpos
, p->
p_wpos
);

116 
buf
 = 
vbuf
;

117 for (
i
 = 0; i < 
n
; i++) {

118 while (
p
->
p_rpos
 == p->
p_wpos
) {

121 if (
i
 > 0)

122 return 
i
;

124 if (
	`_pipeisclosed
(
fd
, 
p
))

127 if (
debug
)

128 
	`cprintf
("devpipe_read yield\n");

129 
	`sys_yield
();

133 
buf
[
i
] = 
p
->
p_buf
[p->
p_rpos
 % 
PIPEBUFSIZ
];

134 
p
->
p_rpos
++;

136 return 
i
;

137 
	}
}

139 static 
ssize_t


140 
	$devpipe_write
(struct 
Fd
 *
fd
, const void *
vbuf
, 
size_t
 
n
)

142 const 
uint8_t
 *
buf
;

143 
size_t
 
i
;

144 struct 
Pipe
 *
p
;

146 
p
 = (struct 
Pipe
*) 
	`fd2data
(
fd
);

147 if (
debug
)

148 
	`cprintf
("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",

149 
thisenv
->
env_id
, 
vpt
[
	`PGNUM
(
p
)], 
n
, p->
p_rpos
, p->
p_wpos
);

151 
buf
 = 
vbuf
;

152 for (
i
 = 0; i < 
n
; i++) {

153 while (
p
->
p_wpos
 >= p->
p_rpos
 + sizeof(p->
p_buf
)) {

158 if (
	`_pipeisclosed
(
fd
, 
p
))

161 if (
debug
)

162 
	`cprintf
("devpipe_write yield\n");

163 
	`sys_yield
();

167 
p
->
p_buf
[p->
p_wpos
 % 
PIPEBUFSIZ
] = 
buf
[
i
];

168 
p
->
p_wpos
++;

171 return 
i
;

172 
	}
}

175 
	$devpipe_stat
(struct 
Fd
 *
fd
, struct 
Stat
 *
stat
)

177 struct 
Pipe
 *
p
 = (struct Pipe*) 
	`fd2data
(
fd
);

178 
	`strcpy
(
stat
->
st_name
, "<pipe>");

179 
stat
->
st_size
 = 
p
->
p_wpos
 - p->
p_rpos
;

180 
stat
->
st_isdir
 = 0;

181 
stat
->
st_dev
 = &
devpipe
;

183 
	}
}

186 
	$devpipe_close
(struct 
Fd
 *
fd
)

188 (void) 
	`sys_page_unmap
(0, 
fd
);

189 return 
	`sys_page_unmap
(0, 
	`fd2data
(
fd
));

190 
	}
}

	@/root/Robux/lib/printf.c

8 #include 
	~<inc/types.h
>

9 #include 
	~<inc/stdio.h
>

10 #include 
	~<inc/stdarg.h
>

11 #include 
	~<inc/lib.h
>

19 struct 
	sprintbuf
 {

20 int 
	midx
;

21 int 
	mcnt
;

22 char 
	mbuf
[256];

27 
	$putch
(int 
ch
, struct 
printbuf
 *
b
)

29 
b
->
buf
[b->
idx
++] = 
ch
;

30 if (
b
->
idx
 == 256-1) {

31 
	`sys_cputs
(
b
->
buf
, b->
idx
);

32 
b
->
idx
 = 0;

34 
b
->
cnt
++;

35 
	}
}

38 
	$vcprintf
(const char *
fmt
, 
va_list
 
ap
)

40 struct 
printbuf
 
b
;

42 
b
.
idx
 = 0;

43 
b
.
cnt
 = 0;

44 
	`vprintfmt
((void*)
putch
, &
b
, 
fmt
, 
ap
);

45 
	`sys_cputs
(
b
.
buf
, b.
idx
);

47 return 
b
.
cnt
;

48 
	}
}

51 
	$cprintf
(const char *
fmt
, ...)

53 
va_list
 
ap
;

54 int 
cnt
;

56 
	`va_start
(
ap
, 
fmt
);

57 
cnt
 = 
	`vcprintf
(
fmt
, 
ap
);

58 
	`va_end
(
ap
);

60 return 
cnt
;

61 
	}
}

	@/root/Robux/lib/printfmt.c

5 #include 
	~<inc/types.h
>

6 #include 
	~<inc/stdio.h
>

7 #include 
	~<inc/string.h
>

8 #include 
	~<inc/stdarg.h
>

9 #include 
	~<inc/error.h
>

21 static const char * const 
	gerror_string
[
MAXERROR
] =

23 [
E_UNSPECIFIED
] = "unspecified error",

24 [
E_BAD_ENV
] = "bad environment",

25 [
E_INVAL
] = "invalid parameter",

26 [
E_NO_MEM
] = "out of memory",

27 [
E_NO_FREE_ENV
] = "out of environments",

28 [
E_FAULT
] = "segmentation fault",

29 [
E_IPC_NOT_RECV
]= "env is not recving",

30 [
E_EOF
] = "unexpected end of file",

31 [
E_NO_DISK
] = "no free space on disk",

32 [
E_MAX_OPEN
] = "too many files are open",

33 [
E_NOT_FOUND
] = "file or block not found",

34 [
E_BAD_PATH
] = "invalid path",

35 [
E_FILE_EXISTS
] = "file already exists",

36 [
E_NOT_EXEC
] = "file is not a valid executable",

37 [
E_NOT_SUPP
] = "operation not supported",

38 [
E_NET_NOT_RECV
] = "network recv buffer empty",

39 [
E_USER_NOT_FOUND
] = "user not found",

40 [
E_BAD_PERM
] = "permission denied",

51 
printnum
(void (*
putch
)(int, void*), void *
putdat
,

52 unsigned long long 
num
, unsigned 
base
, int 
width
, int 
padc
, int 
neg
)

55 if (
num
 >= 
base
) {

56 
	`printnum
(
putch
, 
putdat
, 
num
 / 
base
, base, 
width
 - 1, 
padc
, 
neg
);

57 
neg
 = 0;

60 while (--
width
 > 
neg
)

61 
	`putch
(
padc
, 
putdat
);

64 if(
neg
)

65 
	`putch
('-', 
putdat
);

67 
	`putch
("0123456789abcdef"[
num
 % 
base
], 
putdat
);

68 
	}
}

73 
	$getuint
(
va_list
 *
ap
, int 
lflag
)

75 if (
lflag
 >= 2)

76 return 
	`va_arg
(*
ap
, unsigned long long);

77 else if (
lflag
)

78 return 
	`va_arg
(*
ap
, unsigned long);

80 return 
	`va_arg
(*
ap
, unsigned int);

81 
	}
}

86 
	$getint
(
va_list
 *
ap
, int 
lflag
)

88 if (
lflag
 >= 2)

89 return 
	`va_arg
(*
ap
, long long);

90 else if (
lflag
)

91 return 
	`va_arg
(*
ap
, long);

93 return 
	`va_arg
(*
ap
, int);

94 
	}
}

98 void 
printfmt
(void (*
putch
)(int, void*), void *
putdat
, const char *
fmt
, ...);

101 
	`vprintfmt
(void (*
putch
)(int, void*), void *
putdat
, const char *
fmt
, 
va_list
 
ap
)

103 register const char *
p
;

104 register int 
ch
, 
err
;

105 unsigned long long 
num
;

106 int 
base
, 
lflag
, 
width
, 
precision
, 
altflag
;

107 char 
padc
;

108 int 
neg
 = 0;

111 while ((
ch
 = *(unsigned char *) 
fmt
++) != '%') {

112 if (
ch
 == '\0')

114 
	`putch
(
ch
, 
putdat
);

118 
padc
 = ' ';

119 
width
 = -1;

120 
precision
 = -1;

121 
lflag
 = 0;

122 
altflag
 = 0;

123 
reswitch
:

124 switch (
ch
 = *(unsigned char *) 
fmt
++) {

128 
padc
 = '-';

129 goto 
reswitch
;

133 
padc
 = '0';

134 goto 
reswitch
;

146 for (
precision
 = 0; ; ++
fmt
) {

147 
precision
 = precision * 10 + 
ch
 - '0';

148 
ch
 = *
fmt
;

149 if (
ch
 < '0' || ch > '9')

152 goto 
process_precision
;

155 
precision
 = 
	`va_arg
(
ap
, int);

156 goto 
process_precision
;

159 if (
width
 < 0)

160 
width
 = 0;

161 goto 
reswitch
;

164 
altflag
 = 1;

165 goto 
reswitch
;

167 
process_precision
:

168 if (
width
 < 0)

169 
width
 = 
precision
, precision = -1;

170 goto 
reswitch
;

174 
lflag
++;

175 goto 
reswitch
;

179 
	`putch
(
	`va_arg
(
ap
, int), 
putdat
);

184 
err
 = 
	`va_arg
(
ap
, int);

185 if (
err
 < 0)

186 
err
 = -err;

187 if (
err
 >= 
MAXERROR
 || (
p
 = 
error_string
[err]) == 
NULL
)

188 
	`printfmt
(
putch
, 
putdat
, "error %d", 
err
);

190 
	`printfmt
(
putch
, 
putdat
, "%s", 
p
);

195 if ((
p
 = 
	`va_arg
(
ap
, char *)) == 
NULL
)

196 
p
 = "(null)";

197 if (
width
 > 0 && 
padc
 != '-')

198 for (
width
 -= 
	`strnlen
(
p
, 
precision
); width > 0; width--)

199 
	`putch
(
padc
, 
putdat
);

200 for (; (
ch
 = *
p
++) != '\0' && (
precision
 < 0 || --precision >= 0); 
width
--)

201 if (
altflag
 && (
ch
 < ' ' || ch > '~'))

202 
	`putch
('?', 
putdat
);

204 
	`putch
(
ch
, 
putdat
);

205 for (; 
width
 > 0; width--)

206 
	`putch
(' ', 
putdat
);

211 
num
 = 
	`getint
(&
ap
, 
lflag
);

212 if ((long long) 
num
 < 0) {

213 
neg
 = 1;

214 
num
 = -(long long) num;

216 
base
 = 10;

217 goto 
number
;

221 
num
 = 
	`getuint
(&
ap
, 
lflag
);

222 
base
 = 10;

223 goto 
number
;

228 
num
 = 
	`getuint
(&
ap
, 
lflag
);

229 
base
 = 8;

230 goto 
number
;

239 
	`putch
('0', 
putdat
);

240 
	`putch
('x', 
putdat
);

241 
num
 = (unsigned long long)

242 (
uintptr_t
) 
	`va_arg
(
ap
, void *);

243 
base
 = 16;

244 goto 
number
;

248 
num
 = 
	`getuint
(&
ap
, 
lflag
);

249 
base
 = 16;

250 
number
:

251 
	`printnum
(
putch
, 
putdat
, 
num
, 
base
, 
width
, 
padc
, 
neg
);

256 
	`putch
(
ch
, 
putdat
);

261 
	`putch
('%', 
putdat
);

262 for (
fmt
--; fmt[-1] != '%'; fmt--)

267 
	}
}

270 
printfmt
(void (*
putch
)(int, void*), void *
putdat
, const char *
fmt
, ...)

272 
va_list
 
ap
;

274 
	`va_start
(
ap
, 
fmt
);

275 
	`vprintfmt
(
putch
, 
putdat
, 
fmt
, 
ap
);

276 
	`va_end
(
ap
);

277 
	}
}

279 struct 
	ssprintbuf
 {

280 char *
	mbuf
;

281 char *
	mebuf
;

282 int 
	mcnt
;

286 
	$sprintputch
(int 
ch
, struct 
sprintbuf
 *
b
)

288 
b
->
cnt
++;

289 if (
b
->
buf
 < b->
ebuf
)

290 *
b
->
buf
++ = 
ch
;

291 
	}
}

294 
	$vsnprintf
(char *
buf
, int 
n
, const char *
fmt
, 
va_list
 
ap
)

296 struct 
sprintbuf
 
b
 = {
buf
, buf+
n
-1, 0};

298 if (
buf
 == 
NULL
 || 
n
 < 1)

299 return -
E_INVAL
;

302 
	`vprintfmt
((void*)
sprintputch
, &
b
, 
fmt
, 
ap
);

305 *
b
.
buf
 = '\0';

307 return 
b
.
cnt
;

308 
	}
}

311 
	$snprintf
(char *
buf
, int 
n
, const char *
fmt
, ...)

313 
va_list
 
ap
;

314 int 
rc
;

316 
	`va_start
(
ap
, 
fmt
);

317 
rc
 = 
	`vsnprintf
(
buf
, 
n
, 
fmt
, 
ap
);

318 
	`va_end
(
ap
);

320 return 
rc
;

321 
	}
}

	@/root/Robux/lib/readline.c

1 #include 
	~<inc/stdio.h
>

2 #include 
	~<inc/error.h
>

4 #define 
	#BUFLEN
 1024

	)

5 static char 
	gbuf
[
BUFLEN
];

11 
	$readline_full
(const char *
prompt
, int 
no_echo
)

13 int 
i
, 
c
, 
echoing
;

15 #if 
JOS_KERNEL


16 if (
prompt
 != 
NULL
)

17 
	`cprintf
("%s", 
prompt
);

19 if (
prompt
 != 
NULL
)

20 
	`fprintf
(1, "%s", 
prompt
);

23 
i
 = 0;

24 
echoing
 = 
	`iscons
(1);

25 if (
no_echo
)

26 
echoing
 = 0;

29 
c
 = 
	`getchar
();

30 if (
c
 < 0) {

31 if (
c
 != -
E_EOF
)

32 
	`cprintf
("read error: %e\n", 
c
);

33 return 
NULL
;

34 } else if ((
c
 == '\b' || c == '\x7f') && 
i
 > 0) {

35 if (
echoing
)

36 
	`cputchar
('\b');

37 
i
--;

38 } else if (
c
 >= ' ' && 
i
 < 
BUFLEN
-1) {

39 if (
echoing
)

40 
	`cputchar
(
c
);

41 
buf
[
i
++] = 
c
;

43 } else if(
c
 == '\r') {

45 } else if (
c
 == '\n') {

46 if (
echoing
)

47 
	`cputchar
('\n');

48 
buf
[
i
] = 0;

49 return 
buf
;

52 
	}
}

56 
	$readline
(const char *
prompt
)

58 return 
	`readline_full
(
prompt
,0);

59 
	}
}

	@/root/Robux/lib/security.c

6 #include 
	~<inc/env.h
>

7 #include 
	~<security/secipc.h
>

8 #include 
	~<inc/lib.h
>

9 #include 
	~<inc/mmu.h
>

12 static 
envid_t
 
	gsecenv
 = 0;

15 static union 
secipc_buffer
 *
	gsec_send
 = (union secipc_buffer *)0x10000000;

16 static struct 
user_info
 *
	gsec_resp
 = (struct user_info *)0x10001000;

21 
	$alloc_send
()

23 
	`sys_page_alloc
(0, 
sec_send
, 
PTE_W
 | 
PTE_U
 | 
PTE_P
);

24 
	}
}

28 
	$send_req
(
uint32_t
 
num
)

30 
	`ipc_send
(
secenv
, 
num
, 
sec_send
, 
PTE_P
 | 
PTE_U
 | 
PTE_W
);

31 
	}
}

36 
	$wait_resp
(int 
page_map
)

38 
envid_t
 
from
 = 0;

39 int 
r
 = 0;

40 while(
from
 != 
secenv
)

42 if(
page_map
)

43 
r
 = 
	`ipc_recv
(&
from
, 
sec_resp
, 
NULL
);

45 
r
 = 
	`ipc_recv
(&
from
, 
NULL
, NULL);

46 if(
r
 < 0)

50 return 
r
;

51 
	}
}

55 
	$format_text
(char *
to
, char *
from
, int 
len
)

57 
	`memmove
(
to
, 
from
, 
	`MIN
(
	`strlen
(from)+1, 
len
-1));

58 
to
[
len
-1] = '\0';

59 
	}
}

63 int 
	$get_user_by_id
(
uid_t
 
uid
, struct 
user_info
 *user_info)

65 if(
secenv
 == 0)

66 
secenv
 = 
	`ipc_find_env
(
ENV_TYPE_SECURITY
);

68 
	`alloc_send
();

69 
sec_send
->
uid_req
.
uid
 = uid;

70 
	`send_req
(
UID2INFO
);

72 int 
r
 = 
	`wait_resp
(1);

73 if(
r
 < 0)

74 return 
r
;

76 
	`memmove
(
user_info
, 
sec_resp
, sizeof(struct user_info));

77 
	`sys_page_unmap
(0, 
sec_resp
);

80 
	}
}

83 int 
	$get_user_by_name
(char *
name
, struct 
user_info
 *user_info)

85 if(
secenv
 == 0)

86 
secenv
 = 
	`ipc_find_env
(
ENV_TYPE_SECURITY
);

88 
	`alloc_send
();

89 
	`format_text
(
sec_send
->
name_req
.
name
, name, 
NAME_LEN
);

90 
	`send_req
(
NAME2INFO
);

92 int 
r
 = 
	`wait_resp
(1);

93 if(
r
 < 0)

94 return 
r
;

96 
	`memmove
(
user_info
, 
sec_resp
, sizeof(struct user_info));

97 
	`sys_page_unmap
(0, 
sec_resp
);

100 
	}
}

104 int 
	$verify_password
(
uid_t
 
uid
, char *
pass
)

106 if(
secenv
 == 0)

107 
secenv
 = 
	`ipc_find_env
(
ENV_TYPE_SECURITY
);

109 
	`alloc_send
();

110 
sec_send
->
verify_req
.
uid
 = uid;

111 
	`format_text
(
sec_send
->
verify_req
.
pass
, pass, 
PASS_LEN
);

112 
	`send_req
(
VERIFYPASS
);

114 int 
r
 = 
	`wait_resp
(0);

115 return 
r
;

116 
	}
}

	@/root/Robux/lib/sha2.c

34 #include 
	~<inc/string.h
>

35 #include 
	~<inc/assert.h
>

36 #include 
	~<contrib/sha2/sha2.h
>

87 #if !
defined
(
BYTE_ORDER
) || (BYTE_ORDER != 
LITTLE_ENDIAN
 && BYTE_ORDER != 
BIG_ENDIAN
)

88 #error 
Define
 
BYTE_ORDER
 
to
 
be
 
equal
 to 
either
 
LITTLE_ENDIAN
 
or
 
BIG_ENDIAN


105 #ifdef 
SHA2_USE_INTTYPES_H


107 typedef 
uint8_t
 
	tsha2_byte
;

108 typedef 
uint32_t
 
	tsha2_word32
;

109 typedef 
uint64_t
 
	tsha2_word64
;

113 typedef 
u_int8_t
 
	tsha2_byte
;

114 typedef 
u_int32_t
 
	tsha2_word32
;

115 typedef 
u_int64_t
 
	tsha2_word64
;

122 #define 
	#SHA256_SHORT_BLOCK_LENGTH
 (
SHA256_BLOCK_LENGTH
 - 8)

	)

123 #define 
	#SHA384_SHORT_BLOCK_LENGTH
 (
SHA384_BLOCK_LENGTH
 - 16)

	)

124 #define 
	#SHA512_SHORT_BLOCK_LENGTH
 (
SHA512_BLOCK_LENGTH
 - 16)

	)

128 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


129 #define 
	#REVERSE32
(
w
,
x
) { \

130 
sha2_word32
 
tmp
 = (
w
); \

131 
tmp
 = (tmp >> 16) | (tmp << 16); \

132 (
x
) = ((
tmp
 & 0xff00ff00UL) >> 8) | ((tmp & 0x00ff00ffUL) << 8); \

133 }

	)

134 #define 
	#REVERSE64
(
w
,
x
) { \

135 
sha2_word64
 
tmp
 = (
w
); \

136 
tmp
 = (tmp >> 32) | (tmp << 32); \

137 
tmp
 = ((tmp & 0xff00ff00ff00ff00ULL) >> 8) | \

138 ((
tmp
 & 0x00ff00ff00ff00ffULL) << 8); \

139 (
x
) = ((
tmp
 & 0xffff0000ffff0000ULL) >> 16) | \

140 ((
tmp
 & 0x0000ffff0000ffffULL) << 16); \

141 }

	)

149 #define 
	#ADDINC128
(
w
,
n
) { \

150 (
w
)[0] += (
sha2_word64
)(
n
); \

151 if ((
w
)[0] < (
n
)) { \

152 (
w
)[1]++; \

154 }

	)

165 #if !
defined
(
SHA2_USE_MEMSET_MEMCPY
) && !defined(
SHA2_USE_BZERO_BCOPY
)

167 #define 
	#SHA2_USE_MEMSET_MEMCPY
 1

	)

169 #if 
defined
(
SHA2_USE_MEMSET_MEMCPY
) && defined(
SHA2_USE_BZERO_BCOPY
)

171 #error 
Define
 
either
 
SHA2_USE_MEMSET_MEMCPY
 
or
 
SHA2_USE_BZERO_BCOPY
, 
not
 
both
!

174 #ifdef 
SHA2_USE_MEMSET_MEMCPY


175 #define 
	#MEMSET_BZERO
(
p
,
l
) 
	`memset
((p), 0, (l))

	)

176 #define 
	#MEMCPY_BCOPY
(
d
,
s
,
l
) 
	`memcpy
((d), (s), (l))

	)

178 #ifdef 
SHA2_USE_BZERO_BCOPY


179 #define 
	#MEMSET_BZERO
(
p
,
l
) 
	`bzero
((p), (l))

	)

180 #define 
	#MEMCPY_BCOPY
(
d
,
s
,
l
) 
	`bcopy
((s), (d), (l))

	)

194 #define 
	#R
(
b
,
x
) ((x) >> (b))

	)

196 #define 
	#S32
(
b
,
x
) (((x) >> (b)) | ((x) << (32 - (b))))

	)

198 #define 
	#S64
(
b
,
x
) (((x) >> (b)) | ((x) << (64 - (b))))

	)

201 #define 
	#Ch
(
x
,
y
,
z
) (((x) & (y)) ^ ((~(x)) & (z)))

	)

202 #define 
	#Maj
(
x
,
y
,
z
) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

	)

205 #define 
	#Sigma0_256
(
x
) (
	`S32
(2, (x)) ^ S32(13, (x)) ^ S32(22, (x)))

	)

206 #define 
	#Sigma1_256
(
x
) (
	`S32
(6, (x)) ^ S32(11, (x)) ^ S32(25, (x)))

	)

207 #define 
	#sigma0_256
(
x
) (
	`S32
(7, (x)) ^ S32(18, (x)) ^ 
	`R
(3 , (x)))

	)

208 #define 
	#sigma1_256
(
x
) (
	`S32
(17, (x)) ^ S32(19, (x)) ^ 
	`R
(10, (x)))

	)

211 #define 
	#Sigma0_512
(
x
) (
	`S64
(28, (x)) ^ S64(34, (x)) ^ S64(39, (x)))

	)

212 #define 
	#Sigma1_512
(
x
) (
	`S64
(14, (x)) ^ S64(18, (x)) ^ S64(41, (x)))

	)

213 #define 
	#sigma0_512
(
x
) (
	`S64
( 1, (x)) ^ S64( 8, (x)) ^ 
	`R
( 7, (x)))

	)

214 #define 
	#sigma1_512
(
x
) (
	`S64
(19, (x)) ^ S64(61, (x)) ^ 
	`R
( 6, (x)))

	)

221 void 
SHA512_Last
(
SHA512_CTX
*);

222 void 
SHA256_Transform
(
SHA256_CTX
*, const 
sha2_word32
*);

223 void 
SHA512_Transform
(
SHA512_CTX
*, const 
sha2_word64
*);

228 const static 
sha2_word32
 
	gK256
[64] = {

248 const static 
sha2_word32
 
	gsha256_initial_hash_value
[8] = {

260 const static 
sha2_word64
 
	gK512
[80] = {

304 const static 
sha2_word64
 
	gsha384_initial_hash_value
[8] = {

316 const static 
sha2_word64
 
	gsha512_initial_hash_value
[8] = {

331 static const char *
	gsha2_hex_digits
 = "0123456789abcdef";

335 void 
	$SHA256_Init
(
SHA256_CTX
* 
context
) {

336 if (
context
 == (
SHA256_CTX
*)0) {

339 
	`MEMCPY_BCOPY
(
context
->
state
, 
sha256_initial_hash_value
, 
SHA256_DIGEST_LENGTH
);

340 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA256_BLOCK_LENGTH
);

341 
context
->
bitcount
 = 0;

342 
	}
}

344 #ifdef 
SHA2_UNROLL_TRANSFORM


348 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


350 #define 
	#ROUND256_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

351 
	`REVERSE32
(*
data
++, 
W256
[
j
]); \

352 
T1
 = (
h
) + 
	`Sigma1_256
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

353 
K256
[
j
] + 
W256
[j]; \

354 (
d
) += 
T1
; \

355 (
h
) = 
T1
 + 
	`Sigma0_256
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

356 
j
++

	)

361 #define 
	#ROUND256_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

362 
T1
 = (
h
) + 
	`Sigma1_256
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

363 
K256
[
j
] + (
W256
[j] = *
data
++); \

364 (
d
) += 
T1
; \

365 (
h
) = 
T1
 + 
	`Sigma0_256
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

366 
j
++

	)

370 #define 
	#ROUND256
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

371 
s0
 = 
W256
[(
j
+1)&0x0f]; \

372 
s0
 = 
	`sigma0_256
(s0); \

373 
s1
 = 
W256
[(
j
+14)&0x0f]; \

374 
s1
 = 
	`sigma1_256
(s1); \

375 
T1
 = (
h
) + 
	`Sigma1_256
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + 
K256
[
j
] + \

376 (
W256
[
j
&0x0f] += 
s1
 + W256[(j+9)&0x0f] + 
s0
); \

377 (
d
) += 
T1
; \

378 (
h
) = 
T1
 + 
	`Sigma0_256
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

379 
j
++

	)

381 void 
	$SHA256_Transform
(
SHA256_CTX
* 
context
, const 
sha2_word32
* 
data
) {

382 
sha2_word32
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

383 
sha2_word32
 
T1
, *
W256
;

384 int 
j
;

386 
W256
 = (
sha2_word32
*)
context
->
buffer
;

389 
a
 = 
context
->
state
[0];

390 
b
 = 
context
->
state
[1];

391 
c
 = 
context
->
state
[2];

392 
d
 = 
context
->
state
[3];

393 
e
 = 
context
->
state
[4];

394 
f
 = 
context
->
state
[5];

395 
g
 = 
context
->
state
[6];

396 
h
 = 
context
->
state
[7];

398 
j
 = 0;

401 
	`ROUND256_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

402 
	`ROUND256_0_TO_15
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

403 
	`ROUND256_0_TO_15
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

404 
	`ROUND256_0_TO_15
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

405 
	`ROUND256_0_TO_15
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

406 
	`ROUND256_0_TO_15
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

407 
	`ROUND256_0_TO_15
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

408 
	`ROUND256_0_TO_15
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

409 } while (
j
 < 16);

413 
	`ROUND256
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

414 
	`ROUND256
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

415 
	`ROUND256
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

416 
	`ROUND256
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

417 
	`ROUND256
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

418 
	`ROUND256
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

419 
	`ROUND256
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

420 
	`ROUND256
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

421 } while (
j
 < 64);

424 
context
->
state
[0] += 
a
;

425 
context
->
state
[1] += 
b
;

426 
context
->
state
[2] += 
c
;

427 
context
->
state
[3] += 
d
;

428 
context
->
state
[4] += 
e
;

429 
context
->
state
[5] += 
f
;

430 
context
->
state
[6] += 
g
;

431 
context
->
state
[7] += 
h
;

434 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 0;

435 
	}
}

439 void 
	$SHA256_Transform
(
SHA256_CTX
* 
context
, const 
sha2_word32
* 
data
) {

440 
sha2_word32
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

441 
sha2_word32
 
T1
, 
T2
, *
W256
;

442 int 
j
;

444 
W256
 = (
sha2_word32
*)
context
->
buffer
;

447 
a
 = 
context
->
state
[0];

448 
b
 = 
context
->
state
[1];

449 
c
 = 
context
->
state
[2];

450 
d
 = 
context
->
state
[3];

451 
e
 = 
context
->
state
[4];

452 
f
 = 
context
->
state
[5];

453 
g
 = 
context
->
state
[6];

454 
h
 = 
context
->
state
[7];

456 
j
 = 0;

458 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


460 
	`REVERSE32
(*
data
++,
W256
[
j
]);

462 
T1
 = 
h
 + 
	`Sigma1_256
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K256
[
j
] + 
W256
[j];

465 
T1
 = 
h
 + 
	`Sigma1_256
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K256
[
j
] + (
W256
[j] = *
data
++);

467 
T2
 = 
	`Sigma0_256
(
a
) + 
	`Maj
(a, 
b
, 
c
);

468 
h
 = 
g
;

469 
g
 = 
f
;

470 
f
 = 
e
;

471 
e
 = 
d
 + 
T1
;

472 
d
 = 
c
;

473 
c
 = 
b
;

474 
b
 = 
a
;

475 
a
 = 
T1
 + 
T2
;

477 
j
++;

478 } while (
j
 < 16);

482 
s0
 = 
W256
[(
j
+1)&0x0f];

483 
s0
 = 
	`sigma0_256
(s0);

484 
s1
 = 
W256
[(
j
+14)&0x0f];

485 
s1
 = 
	`sigma1_256
(s1);

488 
T1
 = 
h
 + 
	`Sigma1_256
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K256
[
j
] +

489 (
W256
[
j
&0x0f] += 
s1
 + W256[(j+9)&0x0f] + 
s0
);

490 
T2
 = 
	`Sigma0_256
(
a
) + 
	`Maj
(a, 
b
, 
c
);

491 
h
 = 
g
;

492 
g
 = 
f
;

493 
f
 = 
e
;

494 
e
 = 
d
 + 
T1
;

495 
d
 = 
c
;

496 
c
 = 
b
;

497 
b
 = 
a
;

498 
a
 = 
T1
 + 
T2
;

500 
j
++;

501 } while (
j
 < 64);

504 
context
->
state
[0] += 
a
;

505 
context
->
state
[1] += 
b
;

506 
context
->
state
[2] += 
c
;

507 
context
->
state
[3] += 
d
;

508 
context
->
state
[4] += 
e
;

509 
context
->
state
[5] += 
f
;

510 
context
->
state
[6] += 
g
;

511 
context
->
state
[7] += 
h
;

514 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 
T2
 = 0;

515 
	}
}

519 void 
	$SHA256_Update
(
SHA256_CTX
* 
context
, const 
sha2_byte
 *
data
, 
size_t
 
len
) {

520 unsigned int 
freespace
, 
usedspace
;

522 if (
len
 == 0) {

528 
	`assert
(
context
 != (
SHA256_CTX
*)0 && 
data
 != (
sha2_byte
*)0);

530 
usedspace
 = (
context
->
bitcount
 >> 3) % 
SHA256_BLOCK_LENGTH
;

531 if (
usedspace
 > 0) {

533 
freespace
 = 
SHA256_BLOCK_LENGTH
 - 
usedspace
;

535 if (
len
 >= 
freespace
) {

537 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
freespace
);

538 
context
->
bitcount
 += 
freespace
 << 3;

539 
len
 -= 
freespace
;

540 
data
 += 
freespace
;

541 
	`SHA256_Transform
(
context
, (
sha2_word32
*)context->
buffer
);

544 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
len
);

545 
context
->
bitcount
 += 
len
 << 3;

547 
usedspace
 = 
freespace
 = 0;

551 while (
len
 >= 
SHA256_BLOCK_LENGTH
) {

553 
	`SHA256_Transform
(
context
, (
sha2_word32
*)
data
);

554 
context
->
bitcount
 += 
SHA256_BLOCK_LENGTH
 << 3;

555 
len
 -= 
SHA256_BLOCK_LENGTH
;

556 
data
 += 
SHA256_BLOCK_LENGTH
;

558 if (
len
 > 0) {

560 
	`MEMCPY_BCOPY
(
context
->
buffer
, 
data
, 
len
);

561 
context
->
bitcount
 += 
len
 << 3;

564 
usedspace
 = 
freespace
 = 0;

565 
	}
}

567 void 
	$SHA256_Final
(
sha2_byte
 
digest
[], 
SHA256_CTX
* 
context
) {

568 
sha2_word32
 *
d
 = (sha2_word32*)
digest
;

569 unsigned int 
usedspace
;

572 
	`assert
(
context
 != (
SHA256_CTX
*)0);

575 if (
digest
 != (
sha2_byte
*)0) {

576 
usedspace
 = (
context
->
bitcount
 >> 3) % 
SHA256_BLOCK_LENGTH
;

577 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


579 
	`REVERSE64
(
context
->
bitcount
,context->bitcount);

581 if (
usedspace
 > 0) {

583 
context
->
buffer
[
usedspace
++] = 0x80;

585 if (
usedspace
 <= 
SHA256_SHORT_BLOCK_LENGTH
) {

587 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA256_SHORT_BLOCK_LENGTH
 - usedspace);

589 if (
usedspace
 < 
SHA256_BLOCK_LENGTH
) {

590 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA256_BLOCK_LENGTH
 - usedspace);

593 
	`SHA256_Transform
(
context
, (
sha2_word32
*)context->
buffer
);

596 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA256_SHORT_BLOCK_LENGTH
);

600 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA256_SHORT_BLOCK_LENGTH
);

603 *
context
->
buffer
 = 0x80;

606 *(
sha2_word64
*)&
context
->
buffer
[
SHA256_SHORT_BLOCK_LENGTH
] = context->
bitcount
;

609 
	`SHA256_Transform
(
context
, (
sha2_word32
*)context->
buffer
);

611 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


614 int 
j
;

615 for (
j
 = 0; j < 8; j++) {

616 
	`REVERSE32
(
context
->
state
[
j
],context->state[j]);

617 *
d
++ = 
context
->
state
[
j
];

621 
	`MEMCPY_BCOPY
(
d
, 
context
->
state
, 
SHA256_DIGEST_LENGTH
);

626 
	`MEMSET_BZERO
(
context
, sizeof(
SHA256_CTX
));

627 
usedspace
 = 0;

628 
	}
}

630 char *
	$SHA256_End
(
SHA256_CTX
* 
context
, char 
buffer
[]) {

631 
sha2_byte
 
digest
[
SHA256_DIGEST_LENGTH
], *
d
 = digest;

632 int 
i
;

635 
	`assert
(
context
 != (
SHA256_CTX
*)0);

637 if (
buffer
 != (char*)0) {

638 
	`SHA256_Final
(
digest
, 
context
);

640 for (
i
 = 0; i < 
SHA256_DIGEST_LENGTH
; i++) {

641 *
buffer
++ = 
sha2_hex_digits
[(*
d
 & 0xf0) >> 4];

642 *
buffer
++ = 
sha2_hex_digits
[*
d
 & 0x0f];

643 
d
++;

645 *
buffer
 = (char)0;

647 
	`MEMSET_BZERO
(
context
, sizeof(
SHA256_CTX
));

649 
	`MEMSET_BZERO
(
digest
, 
SHA256_DIGEST_LENGTH
);

650 return 
buffer
;

651 
	}
}

653 char* 
	$SHA256_Data
(const 
sha2_byte
* 
data
, 
size_t
 
len
, char 
digest
[
SHA256_DIGEST_STRING_LENGTH
]) {

654 
SHA256_CTX
 
context
;

656 
	`SHA256_Init
(&
context
);

657 
	`SHA256_Update
(&
context
, 
data
, 
len
);

658 return 
	`SHA256_End
(&
context
, 
digest
);

659 
	}
}

663 void 
	$SHA512_Init
(
SHA512_CTX
* 
context
) {

664 if (
context
 == (
SHA512_CTX
*)0) {

667 
	`MEMCPY_BCOPY
(
context
->
state
, 
sha512_initial_hash_value
, 
SHA512_DIGEST_LENGTH
);

668 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA512_BLOCK_LENGTH
);

669 
context
->
bitcount
[0] = context->bitcount[1] = 0;

670 
	}
}

672 #ifdef 
SHA2_UNROLL_TRANSFORM


675 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


677 #define 
	#ROUND512_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

678 
	`REVERSE64
(*
data
++, 
W512
[
j
]); \

679 
T1
 = (
h
) + 
	`Sigma1_512
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

680 
K512
[
j
] + 
W512
[j]; \

681 (
d
) += 
T1
, \

682 (
h
) = 
T1
 + 
	`Sigma0_512
(
a
) + 
	`Maj
((a), (
b
), (
c
)), \

683 
j
++

	)

688 #define 
	#ROUND512_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

689 
T1
 = (
h
) + 
	`Sigma1_512
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + \

690 
K512
[
j
] + (
W512
[j] = *
data
++); \

691 (
d
) += 
T1
; \

692 (
h
) = 
T1
 + 
	`Sigma0_512
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

693 
j
++

	)

697 #define 
	#ROUND512
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) \

698 
s0
 = 
W512
[(
j
+1)&0x0f]; \

699 
s0
 = 
	`sigma0_512
(s0); \

700 
s1
 = 
W512
[(
j
+14)&0x0f]; \

701 
s1
 = 
	`sigma1_512
(s1); \

702 
T1
 = (
h
) + 
	`Sigma1_512
(
e
) + 
	`Ch
((e), (
f
), (
g
)) + 
K512
[
j
] + \

703 (
W512
[
j
&0x0f] += 
s1
 + W512[(j+9)&0x0f] + 
s0
); \

704 (
d
) += 
T1
; \

705 (
h
) = 
T1
 + 
	`Sigma0_512
(
a
) + 
	`Maj
((a), (
b
), (
c
)); \

706 
j
++

	)

708 void 
	$SHA512_Transform
(
SHA512_CTX
* 
context
, const 
sha2_word64
* 
data
) {

709 
sha2_word64
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

710 
sha2_word64
 
T1
, *
W512
 = (sha2_word64*)
context
->
buffer
;

711 int 
j
;

714 
a
 = 
context
->
state
[0];

715 
b
 = 
context
->
state
[1];

716 
c
 = 
context
->
state
[2];

717 
d
 = 
context
->
state
[3];

718 
e
 = 
context
->
state
[4];

719 
f
 = 
context
->
state
[5];

720 
g
 = 
context
->
state
[6];

721 
h
 = 
context
->
state
[7];

723 
j
 = 0;

725 
	`ROUND512_0_TO_15
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

726 
	`ROUND512_0_TO_15
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

727 
	`ROUND512_0_TO_15
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

728 
	`ROUND512_0_TO_15
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

729 
	`ROUND512_0_TO_15
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

730 
	`ROUND512_0_TO_15
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

731 
	`ROUND512_0_TO_15
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

732 
	`ROUND512_0_TO_15
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

733 } while (
j
 < 16);

737 
	`ROUND512
(
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
);

738 
	`ROUND512
(
h
,
a
,
b
,
c
,
d
,
e
,
f
,
g
);

739 
	`ROUND512
(
g
,
h
,
a
,
b
,
c
,
d
,
e
,
f
);

740 
	`ROUND512
(
f
,
g
,
h
,
a
,
b
,
c
,
d
,
e
);

741 
	`ROUND512
(
e
,
f
,
g
,
h
,
a
,
b
,
c
,
d
);

742 
	`ROUND512
(
d
,
e
,
f
,
g
,
h
,
a
,
b
,
c
);

743 
	`ROUND512
(
c
,
d
,
e
,
f
,
g
,
h
,
a
,
b
);

744 
	`ROUND512
(
b
,
c
,
d
,
e
,
f
,
g
,
h
,
a
);

745 } while (
j
 < 80);

748 
context
->
state
[0] += 
a
;

749 
context
->
state
[1] += 
b
;

750 
context
->
state
[2] += 
c
;

751 
context
->
state
[3] += 
d
;

752 
context
->
state
[4] += 
e
;

753 
context
->
state
[5] += 
f
;

754 
context
->
state
[6] += 
g
;

755 
context
->
state
[7] += 
h
;

758 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 0;

759 
	}
}

763 void 
	$SHA512_Transform
(
SHA512_CTX
* 
context
, const 
sha2_word64
* 
data
) {

764 
sha2_word64
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
, 
g
, 
h
, 
s0
, 
s1
;

765 
sha2_word64
 
T1
, 
T2
, *
W512
 = (sha2_word64*)
context
->
buffer
;

766 int 
j
;

769 
a
 = 
context
->
state
[0];

770 
b
 = 
context
->
state
[1];

771 
c
 = 
context
->
state
[2];

772 
d
 = 
context
->
state
[3];

773 
e
 = 
context
->
state
[4];

774 
f
 = 
context
->
state
[5];

775 
g
 = 
context
->
state
[6];

776 
h
 = 
context
->
state
[7];

778 
j
 = 0;

780 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


782 
	`REVERSE64
(*
data
++, 
W512
[
j
]);

784 
T1
 = 
h
 + 
	`Sigma1_512
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K512
[
j
] + 
W512
[j];

787 
T1
 = 
h
 + 
	`Sigma1_512
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K512
[
j
] + (
W512
[j] = *
data
++);

789 
T2
 = 
	`Sigma0_512
(
a
) + 
	`Maj
(a, 
b
, 
c
);

790 
h
 = 
g
;

791 
g
 = 
f
;

792 
f
 = 
e
;

793 
e
 = 
d
 + 
T1
;

794 
d
 = 
c
;

795 
c
 = 
b
;

796 
b
 = 
a
;

797 
a
 = 
T1
 + 
T2
;

799 
j
++;

800 } while (
j
 < 16);

804 
s0
 = 
W512
[(
j
+1)&0x0f];

805 
s0
 = 
	`sigma0_512
(s0);

806 
s1
 = 
W512
[(
j
+14)&0x0f];

807 
s1
 = 
	`sigma1_512
(s1);

810 
T1
 = 
h
 + 
	`Sigma1_512
(
e
) + 
	`Ch
(e, 
f
, 
g
) + 
K512
[
j
] +

811 (
W512
[
j
&0x0f] += 
s1
 + W512[(j+9)&0x0f] + 
s0
);

812 
T2
 = 
	`Sigma0_512
(
a
) + 
	`Maj
(a, 
b
, 
c
);

813 
h
 = 
g
;

814 
g
 = 
f
;

815 
f
 = 
e
;

816 
e
 = 
d
 + 
T1
;

817 
d
 = 
c
;

818 
c
 = 
b
;

819 
b
 = 
a
;

820 
a
 = 
T1
 + 
T2
;

822 
j
++;

823 } while (
j
 < 80);

826 
context
->
state
[0] += 
a
;

827 
context
->
state
[1] += 
b
;

828 
context
->
state
[2] += 
c
;

829 
context
->
state
[3] += 
d
;

830 
context
->
state
[4] += 
e
;

831 
context
->
state
[5] += 
f
;

832 
context
->
state
[6] += 
g
;

833 
context
->
state
[7] += 
h
;

836 
a
 = 
b
 = 
c
 = 
d
 = 
e
 = 
f
 = 
g
 = 
h
 = 
T1
 = 
T2
 = 0;

837 
	}
}

841 void 
	$SHA512_Update
(
SHA512_CTX
* 
context
, const 
sha2_byte
 *
data
, 
size_t
 
len
) {

842 unsigned int 
freespace
, 
usedspace
;

844 if (
len
 == 0) {

850 
	`assert
(
context
 != (
SHA512_CTX
*)0 && 
data
 != (
sha2_byte
*)0);

852 
usedspace
 = (
context
->
bitcount
[0] >> 3) % 
SHA512_BLOCK_LENGTH
;

853 if (
usedspace
 > 0) {

855 
freespace
 = 
SHA512_BLOCK_LENGTH
 - 
usedspace
;

857 if (
len
 >= 
freespace
) {

859 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
freespace
);

860 
	`ADDINC128
(
context
->
bitcount
, 
freespace
 << 3);

861 
len
 -= 
freespace
;

862 
data
 += 
freespace
;

863 
	`SHA512_Transform
(
context
, (
sha2_word64
*)context->
buffer
);

866 
	`MEMCPY_BCOPY
(&
context
->
buffer
[
usedspace
], 
data
, 
len
);

867 
	`ADDINC128
(
context
->
bitcount
, 
len
 << 3);

869 
usedspace
 = 
freespace
 = 0;

873 while (
len
 >= 
SHA512_BLOCK_LENGTH
) {

875 
	`SHA512_Transform
(
context
, (
sha2_word64
*)
data
);

876 
	`ADDINC128
(
context
->
bitcount
, 
SHA512_BLOCK_LENGTH
 << 3);

877 
len
 -= 
SHA512_BLOCK_LENGTH
;

878 
data
 += 
SHA512_BLOCK_LENGTH
;

880 if (
len
 > 0) {

882 
	`MEMCPY_BCOPY
(
context
->
buffer
, 
data
, 
len
);

883 
	`ADDINC128
(
context
->
bitcount
, 
len
 << 3);

886 
usedspace
 = 
freespace
 = 0;

887 
	}
}

889 void 
	$SHA512_Last
(
SHA512_CTX
* 
context
) {

890 unsigned int 
usedspace
;

892 
usedspace
 = (
context
->
bitcount
[0] >> 3) % 
SHA512_BLOCK_LENGTH
;

893 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


895 
	`REVERSE64
(
context
->
bitcount
[0],context->bitcount[0]);

896 
	`REVERSE64
(
context
->
bitcount
[1],context->bitcount[1]);

898 if (
usedspace
 > 0) {

900 
context
->
buffer
[
usedspace
++] = 0x80;

902 if (
usedspace
 <= 
SHA512_SHORT_BLOCK_LENGTH
) {

904 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA512_SHORT_BLOCK_LENGTH
 - usedspace);

906 if (
usedspace
 < 
SHA512_BLOCK_LENGTH
) {

907 
	`MEMSET_BZERO
(&
context
->
buffer
[
usedspace
], 
SHA512_BLOCK_LENGTH
 - usedspace);

910 
	`SHA512_Transform
(
context
, (
sha2_word64
*)context->
buffer
);

913 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA512_BLOCK_LENGTH
 - 2);

917 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA512_SHORT_BLOCK_LENGTH
);

920 *
context
->
buffer
 = 0x80;

923 *(
sha2_word64
*)&
context
->
buffer
[
SHA512_SHORT_BLOCK_LENGTH
] = context->
bitcount
[1];

924 *(
sha2_word64
*)&
context
->
buffer
[
SHA512_SHORT_BLOCK_LENGTH
+8] = context->
bitcount
[0];

927 
	`SHA512_Transform
(
context
, (
sha2_word64
*)context->
buffer
);

928 
	}
}

930 void 
	$SHA512_Final
(
sha2_byte
 
digest
[], 
SHA512_CTX
* 
context
) {

931 
sha2_word64
 *
d
 = (sha2_word64*)
digest
;

934 
	`assert
(
context
 != (
SHA512_CTX
*)0);

937 if (
digest
 != (
sha2_byte
*)0) {

938 
	`SHA512_Last
(
context
);

941 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


944 int 
j
;

945 for (
j
 = 0; j < 8; j++) {

946 
	`REVERSE64
(
context
->
state
[
j
],context->state[j]);

947 *
d
++ = 
context
->
state
[
j
];

951 
	`MEMCPY_BCOPY
(
d
, 
context
->
state
, 
SHA512_DIGEST_LENGTH
);

956 
	`MEMSET_BZERO
(
context
, sizeof(
SHA512_CTX
));

957 
	}
}

959 char *
	$SHA512_End
(
SHA512_CTX
* 
context
, char 
buffer
[]) {

960 
sha2_byte
 
digest
[
SHA512_DIGEST_LENGTH
], *
d
 = digest;

961 int 
i
;

964 
	`assert
(
context
 != (
SHA512_CTX
*)0);

966 if (
buffer
 != (char*)0) {

967 
	`SHA512_Final
(
digest
, 
context
);

969 for (
i
 = 0; i < 
SHA512_DIGEST_LENGTH
; i++) {

970 *
buffer
++ = 
sha2_hex_digits
[(*
d
 & 0xf0) >> 4];

971 *
buffer
++ = 
sha2_hex_digits
[*
d
 & 0x0f];

972 
d
++;

974 *
buffer
 = (char)0;

976 
	`MEMSET_BZERO
(
context
, sizeof(
SHA512_CTX
));

978 
	`MEMSET_BZERO
(
digest
, 
SHA512_DIGEST_LENGTH
);

979 return 
buffer
;

980 
	}
}

982 char* 
	$SHA512_Data
(const 
sha2_byte
* 
data
, 
size_t
 
len
, char 
digest
[
SHA512_DIGEST_STRING_LENGTH
]) {

983 
SHA512_CTX
 
context
;

985 
	`SHA512_Init
(&
context
);

986 
	`SHA512_Update
(&
context
, 
data
, 
len
);

987 return 
	`SHA512_End
(&
context
, 
digest
);

988 
	}
}

992 void 
	$SHA384_Init
(
SHA384_CTX
* 
context
) {

993 if (
context
 == (
SHA384_CTX
*)0) {

996 
	`MEMCPY_BCOPY
(
context
->
state
, 
sha384_initial_hash_value
, 
SHA512_DIGEST_LENGTH
);

997 
	`MEMSET_BZERO
(
context
->
buffer
, 
SHA384_BLOCK_LENGTH
);

998 
context
->
bitcount
[0] = context->bitcount[1] = 0;

999 
	}
}

1001 void 
	$SHA384_Update
(
SHA384_CTX
* 
context
, const 
sha2_byte
* 
data
, 
size_t
 
len
) {

1002 
	`SHA512_Update
((
SHA512_CTX
*)
context
, 
data
, 
len
);

1003 
	}
}

1005 void 
	$SHA384_Final
(
sha2_byte
 
digest
[], 
SHA384_CTX
* 
context
) {

1006 
sha2_word64
 *
d
 = (sha2_word64*)
digest
;

1009 
	`assert
(
context
 != (
SHA384_CTX
*)0);

1012 if (
digest
 != (
sha2_byte
*)0) {

1013 
	`SHA512_Last
((
SHA512_CTX
*)
context
);

1016 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


1019 int 
j
;

1020 for (
j
 = 0; j < 6; j++) {

1021 
	`REVERSE64
(
context
->
state
[
j
],context->state[j]);

1022 *
d
++ = 
context
->
state
[
j
];

1026 
	`MEMCPY_BCOPY
(
d
, 
context
->
state
, 
SHA384_DIGEST_LENGTH
);

1031 
	`MEMSET_BZERO
(
context
, sizeof(
SHA384_CTX
));

1032 
	}
}

1034 char *
	$SHA384_End
(
SHA384_CTX
* 
context
, char 
buffer
[]) {

1035 
sha2_byte
 
digest
[
SHA384_DIGEST_LENGTH
], *
d
 = digest;

1036 int 
i
;

1039 
	`assert
(
context
 != (
SHA384_CTX
*)0);

1041 if (
buffer
 != (char*)0) {

1042 
	`SHA384_Final
(
digest
, 
context
);

1044 for (
i
 = 0; i < 
SHA384_DIGEST_LENGTH
; i++) {

1045 *
buffer
++ = 
sha2_hex_digits
[(*
d
 & 0xf0) >> 4];

1046 *
buffer
++ = 
sha2_hex_digits
[*
d
 & 0x0f];

1047 
d
++;

1049 *
buffer
 = (char)0;

1051 
	`MEMSET_BZERO
(
context
, sizeof(
SHA384_CTX
));

1053 
	`MEMSET_BZERO
(
digest
, 
SHA384_DIGEST_LENGTH
);

1054 return 
buffer
;

1055 
	}
}

1057 char* 
	$SHA384_Data
(const 
sha2_byte
* 
data
, 
size_t
 
len
, char 
digest
[
SHA384_DIGEST_STRING_LENGTH
]) {

1058 
SHA384_CTX
 
context
;

1060 
	`SHA384_Init
(&
context
);

1061 
	`SHA384_Update
(&
context
, 
data
, 
len
);

1062 return 
	`SHA384_End
(&
context
, 
digest
);

1063 
	}
}

	@/root/Robux/lib/sockets.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<lwip/sockets.h
>

4 static 
ssize_t
 
devsock_read
(struct 
Fd
 *
fd
, void *
buf
, 
size_t
 
n
);

5 static 
ssize_t
 
devsock_write
(struct 
Fd
 *
fd
, const void *
buf
, 
size_t
 
n
);

6 static int 
devsock_close
(struct 
Fd
 *
fd
);

7 static int 
devsock_stat
(struct 
Fd
 *
fd
, struct 
Stat
 *
stat
);

9 struct 
Dev
 
	gdevsock
 =

11 .
dev_id
 = 's',

12 .
	gdev_name
 = "sock",

13 .
	gdev_read
 = 
devsock_read
,

14 .
	gdev_write
 = 
devsock_write
,

15 .
	gdev_close
 = 
devsock_close
,

16 .
	gdev_stat
 = 
devsock_stat
,

20 
	$fd2sockid
(int 
fd
)

22 struct 
Fd
 *
sfd
;

23 int 
r
;

25 if ((
r
 = 
	`fd_lookup
(
fd
, &
sfd
)) < 0)

26 return 
r
;

27 if (
sfd
->
fd_dev_id
 != 
devsock
.
dev_id
)

28 return -
E_NOT_SUPP
;

29 return 
sfd
->
fd_sock
.
sockid
;

30 
	}
}

33 
	$alloc_sockfd
(int 
sockid
)

35 struct 
Fd
 *
sfd
;

36 int 
r
;

38 if ((
r
 = 
	`fd_alloc
(&
sfd
)) < 0

39 || (
r
 = 
	`sys_page_alloc
(0, 
sfd
, 
PTE_P
|
PTE_W
|
PTE_U
|
PTE_SHARE
)) < 0) {

40 
	`nsipc_close
(
sockid
);

41 return 
r
;

44 
sfd
->
fd_dev_id
 = 
devsock
.
dev_id
;

45 
sfd
->
fd_omode
 = 
O_RDWR
;

46 
sfd
->
fd_sock
.
sockid
 = sockid;

47 return 
	`fd2num
(
sfd
);

48 
	}
}

51 
	$accept
(int 
s
, struct 
sockaddr
 *
addr
, 
socklen_t
 *
addrlen
)

53 int 
r
;

54 if ((
r
 = 
	`fd2sockid
(
s
)) < 0)

55 return 
r
;

56 if ((
r
 = 
	`nsipc_accept
(r, 
addr
, 
addrlen
)) < 0)

57 return 
r
;

58 return 
	`alloc_sockfd
(
r
);

59 
	}
}

62 
	$bind
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
)

64 int 
r
;

65 if ((
r
 = 
	`fd2sockid
(
s
)) < 0)

66 return 
r
;

67 return 
	`nsipc_bind
(
r
, 
name
, 
namelen
);

68 
	}
}

71 
	$shutdown
(int 
s
, int 
how
)

73 int 
r
;

74 if ((
r
 = 
	`fd2sockid
(
s
)) < 0)

75 return 
r
;

76 return 
	`nsipc_shutdown
(
r
, 
how
);

77 
	}
}

80 
	$devsock_close
(struct 
Fd
 *
fd
)

82 if (
	`pageref
(
fd
) == 1)

83 return 
	`nsipc_close
(
fd
->
fd_sock
.
sockid
);

86 
	}
}

89 
	$connect
(int 
s
, const struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
)

91 int 
r
;

92 if ((
r
 = 
	`fd2sockid
(
s
)) < 0)

93 return 
r
;

94 return 
	`nsipc_connect
(
r
, 
name
, 
namelen
);

95 
	}
}

98 
	$listen
(int 
s
, int 
backlog
)

100 int 
r
;

101 if ((
r
 = 
	`fd2sockid
(
s
)) < 0)

102 return 
r
;

103 return 
	`nsipc_listen
(
r
, 
backlog
);

104 
	}
}

106 static 
ssize_t


107 
	$devsock_read
(struct 
Fd
 *
fd
, void *
buf
, 
size_t
 
n
)

109 return 
	`nsipc_recv
(
fd
->
fd_sock
.
sockid
, 
buf
, 
n
, 0);

110 
	}
}

112 static 
ssize_t


113 
	$devsock_write
(struct 
Fd
 *
fd
, const void *
buf
, 
size_t
 
n
)

115 return 
	`nsipc_send
(
fd
->
fd_sock
.
sockid
, 
buf
, 
n
, 0);

116 
	}
}

119 
	$devsock_stat
(struct 
Fd
 *
fd
, struct 
Stat
 *
stat
)

121 
	`strcpy
(
stat
->
st_name
, "<sock>");

123 
	}
}

126 
	$socket
(int 
domain
, int 
type
, int 
protocol
)

128 int 
r
;

129 if ((
r
 = 
	`nsipc_socket
(
domain
, 
type
, 
protocol
)) < 0)

130 return 
r
;

131 return 
	`alloc_sockfd
(
r
);

132 
	}
}

	@/root/Robux/lib/spawn.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<inc/elf.h
>

3 #include 
	~<inc/mmu.h
>

5 #define 
	#UTEMP2USTACK
(
addr
) ((void*) (addr) + (
USTACKTOP
 - 
PGSIZE
) - 
UTEMP
)

	)

6 #define 
	#UTEMP2
 (
UTEMP
 + 
PGSIZE
)

	)

7 #define 
	#UTEMP3
 (
UTEMP2
 + 
PGSIZE
)

	)

10 static int 
init_stack
(
envid_t
 
child
, const char **
argv
, 
uintptr_t
 *
init_esp
);

11 static int 
map_segment
(
envid_t
 
child
, 
uintptr_t
 
va
, 
size_t
 
memsz
,

12 int 
fd
, 
size_t
 
filesz
, 
off_t
 
fileoffset
, int 
perm
);

13 static int 
copy_shared_pages
(
envid_t
 
child
);

19 
	$spawn
(const char *
prog
, const char **
argv
)

21 return 
	`spawn_full
(
prog
, 
argv
, 0, 0);

22 
	}
}

32 
	$spawn_full
(const char *
prog
, const char **
argv
, 
uid_t
 
uid
, 
gid_t
 
gid
)

34 unsigned char 
elf_buf
[512];

35 struct 
Trapframe
 
child_tf
;

36 
envid_t
 
child
;

38 int 
fd
, 
i
, 
r
;

39 struct 
Elf
 *
elf
;

40 struct 
Proghdr
 *
ph
;

41 int 
perm
;

100 if ((
r
 = 
	`open
(
prog
, 
O_RDONLY
)) < 0)

101 return 
r
;

102 
fd
 = 
r
;

105 
elf
 = (struct 
Elf
*) 
elf_buf
;

106 if (
	`readn
(
fd
, 
elf_buf
, sizeof(elf_buf)) != sizeof(elf_buf)

107 || 
elf
->
e_magic
 != 
ELF_MAGIC
) {

108 
	`close
(
fd
);

109 
	`cprintf
("elf magic %08x want %08x\n", 
elf
->
e_magic
, 
ELF_MAGIC
);

110 return -
E_NOT_EXEC
;

114 if ((
r
 = 
	`sys_exofork
()) < 0)

115 return 
r
;

116 
child
 = 
r
;

118 if(
uid
)

120 if((
r
 = 
	`sys_set_user_id
(
child
, 
uid
)) < 0)

121 goto 
error
;

123 if(
gid
)

125 if((
r
 = 
	`sys_set_group_id
(
child
, 
gid
)) < 0)

126 goto 
error
;

130 
child_tf
 = 
envs
[
	`ENVX
(
child
)].
env_tf
;

131 
child_tf
.
tf_eip
 = 
elf
->
e_entry
;

133 if ((
r
 = 
	`init_stack
(
child
, 
argv
, &
child_tf
.
tf_esp
)) < 0)

134 return 
r
;

137 
ph
 = (struct 
Proghdr
*) (
elf_buf
 + 
elf
->
e_phoff
);

138 for (
i
 = 0; i < 
elf
->
e_phnum
; i++, 
ph
++) {

139 if (
ph
->
p_type
 != 
ELF_PROG_LOAD
)

141 
perm
 = 
PTE_P
 | 
PTE_U
;

142 if (
ph
->
p_flags
 & 
ELF_PROG_FLAG_WRITE
)

143 
perm
 |= 
PTE_W
;

144 if ((
r
 = 
	`map_segment
(
child
, 
ph
->
p_va
, ph->
p_memsz
,

145 
fd
, 
ph
->
p_filesz
, ph->
p_offset
, 
perm
)) < 0)

146 goto 
error
;

148 
	`close
(
fd
);

149 
fd
 = -1;

152 if ((
r
 = 
	`copy_shared_pages
(
child
)) < 0)

153 
	`panic
("copy_shared_pages: %e", 
r
);

155 if ((
r
 = 
	`sys_env_set_trapframe
(
child
, &
child_tf
)) < 0)

156 
	`panic
("sys_env_set_trapframe: %e", 
r
);

158 if ((
r
 = 
	`sys_env_set_status
(
child
, 
ENV_RUNNABLE
)) < 0)

159 
	`panic
("sys_env_set_status: %e", 
r
);

161 return 
child
;

163 
error
:

164 
	`sys_env_destroy
(
child
);

165 
	`close
(
fd
);

166 return 
r
;

167 
	}
}

173 
	$spawnl
(const char *
prog
, const char *
arg0
, ...)

179 int 
argc
=0;

180 
va_list
 
vl
;

181 
	`va_start
(
vl
, 
arg0
);

182 while(
	`va_arg
(
vl
, void *) != 
NULL
)

183 
argc
++;

184 
	`va_end
(
vl
);

188 const char *
argv
[
argc
+2];

189 
argv
[0] = 
arg0
;

190 
argv
[
argc
+1] = 
NULL
;

192 
	`va_start
(
vl
, 
arg0
);

193 unsigned 
i
;

194 for(
i
=0;i<
argc
;i++)

195 
argv
[
i
+1] = 
	`va_arg
(
vl
, const char *);

196 
	`va_end
(
vl
);

197 return 
	`spawn
(
prog
, 
argv
);

198 
	}
}

209 
	$init_stack
(
envid_t
 
child
, const char **
argv
, 
uintptr_t
 *
init_esp
)

211 
size_t
 
string_size
;

212 int 
argc
, 
i
, 
r
;

213 char *
string_store
;

214 
uintptr_t
 *
argv_store
;

218 
string_size
 = 0;

219 for (
argc
 = 0; 
argv
[argc] != 0; argc++)

220 
string_size
 += 
	`strlen
(
argv
[
argc
]) + 1;

227 
string_store
 = (char*) 
UTEMP
 + 
PGSIZE
 - 
string_size
;

230 
argv_store
 = (
uintptr_t
*) (
	`ROUNDDOWN
(
string_store
, 4) - 4 * (
argc
 + 1));

234 if ((void*) (
argv_store
 - 2) < (void*) 
UTEMP
)

235 return -
E_NO_MEM
;

238 if ((
r
 = 
	`sys_page_alloc
(0, (void*) 
UTEMP
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

239 return 
r
;

258 for (
i
 = 0; i < 
argc
; i++) {

259 
argv_store
[
i
] = 
	`UTEMP2USTACK
(
string_store
);

260 
	`strcpy
(
string_store
, 
argv
[
i
]);

261 
string_store
 += 
	`strlen
(
argv
[
i
]) + 1;

263 
argv_store
[
argc
] = 0;

264 
	`assert
(
string_store
 == (char*)
UTEMP
 + 
PGSIZE
);

266 
argv_store
[-1] = 
	`UTEMP2USTACK
(argv_store);

267 
argv_store
[-2] = 
argc
;

269 *
init_esp
 = 
	`UTEMP2USTACK
(&
argv_store
[-2]);

273 if ((
r
 = 
	`sys_page_map
(0, 
UTEMP
, 
child
, (void*) (
USTACKTOP
 - 
PGSIZE
), 
PTE_P
 | 
PTE_U
 | 
PTE_W
)) < 0)

274 goto 
error
;

275 if ((
r
 = 
	`sys_page_unmap
(0, 
UTEMP
)) < 0)

276 goto 
error
;

280 
error
:

281 
	`sys_page_unmap
(0, 
UTEMP
);

282 return 
r
;

283 
	}
}

286 
	$map_segment
(
envid_t
 
child
, 
uintptr_t
 
va
, 
size_t
 
memsz
,

287 int 
fd
, 
size_t
 
filesz
, 
off_t
 
fileoffset
, int 
perm
)

289 int 
i
, 
r
;

290 void *
blk
;

294 if ((
i
 = 
	`PGOFF
(
va
))) {

295 
va
 -= 
i
;

296 
memsz
 += 
i
;

297 
filesz
 += 
i
;

298 
fileoffset
 -= 
i
;

301 for (
i
 = 0; i < 
memsz
; i += 
PGSIZE
) {

302 if (
i
 >= 
filesz
) {

304 if ((
r
 = 
	`sys_page_alloc
(
child
, (void*) (
va
 + 
i
), 
perm
)) < 0)

305 return 
r
;

308 if ((
r
 = 
	`sys_page_alloc
(0, 
UTEMP
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

309 return 
r
;

310 if ((
r
 = 
	`seek
(
fd
, 
fileoffset
 + 
i
)) < 0)

311 return 
r
;

312 if ((
r
 = 
	`readn
(
fd
, 
UTEMP
, 
	`MIN
(
PGSIZE
, 
filesz
-
i
))) < 0)

313 return 
r
;

314 if ((
r
 = 
	`sys_page_map
(0, 
UTEMP
, 
child
, (void*) (
va
 + 
i
), 
perm
)) < 0)

315 
	`panic
("spawn: sys_page_map data: %e", 
r
);

316 
	`sys_page_unmap
(0, 
UTEMP
);

320 
	}
}

324 
	$copy_shared_pages
(
envid_t
 
child
)

326 int 
i
;

327 int 
ret
;

329 
envid_t
 
myid
;

330 
myid
 = 
	`sys_getenvid
();

331 for(
i
=0; i < 
UTOP
 >> 12; i++)

334 if(
i
 << 12 == 
UXSTACKTOP
 - 
PGSIZE
)

336 if(!
vpd
[
i
>>10] & 
PTE_P
)

341 
pte_t
 
pte
 = 
vpt
[
i
];

342 if(
pte
 & 
PTE_P
 && pte & 
PTE_SHARE
)

344 
ret
 = 
	`sys_page_map
(
myid
, (void*)(
i
*
PGSIZE
), 
child
, (void*)(i*PGSIZE), 
pte
 & 
PTE_SYSCALL
);

345 if(
ret
 < 0)

346 
	`panic
("Failed to copy [W] page mapping to child in spawn: %e\n", 
ret
);

351 
	}
}

	@/root/Robux/lib/string.c

3 #include 
	~<inc/string.h
>

9 #define 
	#ASM
 1

	)

12 
	$strlen
(const char *
s
)

14 int 
n
;

16 for (
n
 = 0; *
s
 != '\0'; s++)

17 
n
++;

18 return 
n
;

19 
	}
}

22 
	$strnlen
(const char *
s
, 
size_t
 
size
)

24 int 
n
;

26 for (
n
 = 0; 
size
 > 0 && *
s
 != '\0'; s++, size--)

27 
n
++;

28 return 
n
;

29 
	}
}

32 
	$strcpy
(char *
dst
, const char *
src
)

34 char *
ret
;

36 
ret
 = 
dst
;

37 while ((*
dst
++ = *
src
++) != '\0')

39 return 
ret
;

40 
	}
}

43 
	$strcat
(char *
dst
, const char *
src
)

45 int 
len
 = 
	`strlen
(
dst
);

46 
	`strcpy
(
dst
 + 
len
, 
src
);

47 return 
dst
;

48 
	}
}

51 
	$strncpy
(char *
dst
, const char *
src
, 
size_t
 
size
) {

52 
size_t
 
i
;

53 char *
ret
;

55 
ret
 = 
dst
;

56 for (
i
 = 0; i < 
size
; i++) {

57 *
dst
++ = *
src
;

59 if (*
src
 != '\0')

60 
src
++;

62 return 
ret
;

63 
	}
}

65 
size_t


66 
	$strlcpy
(char *
dst
, const char *
src
, 
size_t
 
size
)

68 char *
dst_in
;

70 
dst_in
 = 
dst
;

71 if (
size
 > 0) {

72 while (--
size
 > 0 && *
src
 != '\0')

73 *
dst
++ = *
src
++;

74 *
dst
 = '\0';

76 return 
dst
 - 
dst_in
;

77 
	}
}

80 
	$strcmp
(const char *
p
, const char *
q
)

82 while (*
p
 && *p == *
q
)

83 
p
++, 
q
++;

84 return (int) ((unsigned char) *
p
 - (unsigned char) *
q
);

85 
	}
}

88 
	$strncmp
(const char *
p
, const char *
q
, 
size_t
 
n
)

90 while (
n
 > 0 && *
p
 && *p == *
q
)

91 
n
--, 
p
++, 
q
++;

92 if (
n
 == 0)

95 return (int) ((unsigned char) *
p
 - (unsigned char) *
q
);

96 
	}
}

101 
	$strchr
(const char *
s
, char 
c
)

103 for (; *
s
; s++)

104 if (*
s
 == 
c
)

105 return (char *) 
s
;

107 
	}
}

112 
	$strfind
(const char *
s
, char 
c
)

114 for (; *
s
; s++)

115 if (*
s
 == 
c
)

117 return (char *) 
s
;

118 
	}
}

120 #if 
ASM


122 
	$memset
(void *
v
, int 
c
, 
size_t
 
n
)

124 char *
p
;

126 if (
n
 == 0)

127 return 
v
;

128 if ((int)
v
%4 == 0 && 
n
%4 == 0) {

129 
c
 &= 0xFF;

130 
c
 = (c<<24)|(c<<16)|(c<<8)|c;

131 
asm
 volatile("cld; rep stosl\n"

132 :: "D" (
v
), "a" (
c
), "c" (
n
/4)

135 
asm
 volatile("cld; rep stosb\n"

136 :: "D" (
v
), "a" (
c
), "c" (
n
)

138 return 
v
;

139 
	}
}

142 
	$memmove
(void *
dst
, const void *
src
, 
size_t
 
n
)

144 const char *
s
;

145 char *
d
;

147 
s
 = 
src
;

148 
d
 = 
dst
;

149 if (
s
 < 
d
 && s + 
n
 > d) {

150 
s
 += 
n
;

151 
d
 += 
n
;

152 if ((int)
s
%4 == 0 && (int)
d
%4 == 0 && 
n
%4 == 0)

153 
asm
 volatile("std; rep movsl\n"

154 :: "D" (
d
-4), "S" (
s
-4), "c" (
n
/4) : "cc", "memory");

156 
asm
 volatile("std; rep movsb\n"

157 :: "D" (
d
-1), "S" (
s
-1), "c" (
n
) : "cc", "memory");

159 
asm
 volatile("cld" ::: "cc");

161 if ((int)
s
%4 == 0 && (int)
d
%4 == 0 && 
n
%4 == 0)

162 
asm
 volatile("cld; rep movsl\n"

163 :: "D" (
d
), "S" (
s
), "c" (
n
/4) : "cc", "memory");

165 
asm
 volatile("cld; rep movsb\n"

166 :: "D" (
d
), "S" (
s
), "c" (
n
) : "cc", "memory");

168 return 
dst
;

169 
	}
}

174 
	$memset
(void *
v
, int 
c
, 
size_t
 
n
)

176 char *
p
;

177 int 
m
;

179 
p
 = 
v
;

180 
m
 = 
n
;

181 while (--
m
 >= 0)

182 *
p
++ = 
c
;

184 return 
v
;

185 
	}
}

190 
	$memmove
(void *
dst
, const void *
src
, 
size_t
 
n
)

192 const char *
s
;

193 char *
d
;

195 
s
 = 
src
;

196 
d
 = 
dst
;

197 if (
s
 < 
d
 && s + 
n
 > d) {

198 
s
 += 
n
;

199 
d
 += 
n
;

200 while (
n
-- > 0)

201 *--
d
 = *--
s
;

203 while (
n
-- > 0)

204 *
d
++ = *
s
++;

206 return 
dst
;

207 
	}
}

213 
	$memcpy
(void *
dst
, void *
src
, 
size_t
 
n
)

215 return 
	`memmove
(
dst
, 
src
, 
n
);

216 
	}
}

219 
	$memcmp
(const void *
v1
, const void *
v2
, 
size_t
 
n
)

221 const 
uint8_t
 *
s1
 = (const uint8_t *) 
v1
;

222 const 
uint8_t
 *
s2
 = (const uint8_t *) 
v2
;

224 while (
n
-- > 0) {

225 if (*
s1
 != *
s2
)

226 return (int) *
s1
 - (int) *
s2
;

227 
s1
++, 
s2
++;

231 
	}
}

234 
	$memfind
(const void *
s
, int 
c
, 
size_t
 
n
)

236 const void *
ends
 = (const char *) 
s
 + 
n
;

237 for (; 
s
 < 
ends
; s++)

238 if (*(const unsigned char *) 
s
 == (unsigned char) 
c
)

240 return (void *) 
s
;

241 
	}
}

244 
	$strtol
(const char *
s
, char **
endptr
, int 
base
)

246 int 
neg
 = 0;

247 long 
val
 = 0;

250 while (*
s
 == ' ' || *s == '\t')

251 
s
++;

254 if (*
s
 == '+')

255 
s
++;

256 else if (*
s
 == '-')

257 
s
++, 
neg
 = 1;

260 if ((
base
 == 0 || base == 16) && (
s
[0] == '0' && s[1] == 'x'))

261 
s
 += 2, 
base
 = 16;

262 else if (
base
 == 0 && 
s
[0] == '0')

263 
s
++, 
base
 = 8;

264 else if (
base
 == 0)

265 
base
 = 10;

269 int 
dig
;

271 if (*
s
 >= '0' && *s <= '9')

272 
dig
 = *
s
 - '0';

273 else if (*
s
 >= 'a' && *s <= 'z')

274 
dig
 = *
s
 - 'a' + 10;

275 else if (*
s
 >= 'A' && *s <= 'Z')

276 
dig
 = *
s
 - 'A' + 10;

279 if (
dig
 >= 
base
)

281 
s
++, 
val
 = (val * 
base
) + 
dig
;

285 if (
endptr
)

286 *
endptr
 = (char *) 
s
;

287 return (
neg
 ? -
val
 : val);

288 
	}
}

294 
	$atoi
(const char *
str
)

296 int 
len
 = 
	`strlen
(
str
);

297 int 
ret
 = 0;

300 int 
end
;

301 for(
end
 = 0; end < 
len
; end++)

303 char 
c
 = 
str
[
end
];

304 switch(
c
)

318 
end
++;

324 int 
i
;

325 for(
i
=1; i <= 
end
; i++)

327 int 
c
 = 
str
[
end
-
i
] - '0';

329 int 
mult
;

330 for(
mult
 = 0; mult < (
i
-1); mult++)

331 
c
 *= 10;

333 
ret
 += 
c
;

336 return 
ret
;

337 
	}
}

	@/root/Robux/lib/syscall.c

3 #include 
	~<inc/syscall.h
>

4 #include 
	~<inc/lib.h
>

5 #include 
	~<inc/x86.h
>

9 static 
int32_t
 
	$do_fast_call
(int 
num
, 
uint32_t
 
a1
, uint32_t 
a2
, uint32_t 
a3
, uint32_t 
a4
)

11 
int32_t
 
ret
;

21 
asm
 volatile ("pushl %%ebp;"

35 : "=m"(
ret
)

36 : "m"(
num
), "m"(
a1
), "m"(
a2
), "m"(
a3
), "m"(
a4
));

37 return 
ret
;

38 
	}
}

40 static 
inline
 
int32_t


41 
	$syscall
(int 
num
, int 
check
, 
uint32_t
 
a1
, uint32_t 
a2
, uint32_t 
a3
, uint32_t 
a4
, uint32_t 
a5
)

43 
int32_t
 
ret
;

46 if (
	`cpu_get_features
() & 
CPUID_FLAG_SEP
)

57 switch(
num
)

60 case 
SYS_cgetc
:

61 case 
SYS_cputs
:

62 case 
SYS_getenvid
:

63 case 
SYS_yield
:

64 case 
SYS_env_destroy
:

82 
asm
 volatile("int %1\n"

83 : "=a" (
ret
)

84 : "i" (
T_SYSCALL
),

85 "a" (
num
),

86 "d" (
a1
),

87 "c" (
a2
),

88 "b" (
a3
),

89 "D" (
a4
),

90 "S" (
a5
)

93 if (
check
 && 
ret
 > 0)

94 
	`panic
("syscall %d returned %d (> 0)", 
num
, 
ret
);

96 return 
ret
;

97 
	}
}

100 
	$sys_cputs
(const char *
s
, 
size_t
 
len
)

102 
	`syscall
(
SYS_cputs
, 0, (
uint32_t
)
s
, 
len
, 0, 0, 0);

103 
	}
}

106 
	$sys_cgetc
(void)

108 return 
	`syscall
(
SYS_cgetc
, 0, 0, 0, 0, 0, 0);

109 
	}
}

112 
	$sys_env_destroy
(
envid_t
 
envid
)

114 return 
	`syscall
(
SYS_env_destroy
, 1, 
envid
, 0, 0, 0, 0);

115 
	}
}

117 
envid_t


118 
	$sys_getenvid
(void)

120 return 
	`syscall
(
SYS_getenvid
, 0, 0, 0, 0, 0, 0);

121 
	}
}

124 
	$sys_yield
(void)

126 
	`syscall
(
SYS_yield
, 0, 0, 0, 0, 0, 0);

127 
	}
}

130 
	$sys_page_alloc
(
envid_t
 
envid
, void *
va
, int 
perm
)

132 return 
	`syscall
(
SYS_page_alloc
, 1, 
envid
, (
uint32_t
) 
va
, 
perm
, 0, 0);

133 
	}
}

136 
	$sys_page_map
(
envid_t
 
srcenv
, void *
srcva
, envid_t 
dstenv
, void *
dstva
, int 
perm
)

138 return 
	`syscall
(
SYS_page_map
, 1, 
srcenv
, (
uint32_t
) 
srcva
, 
dstenv
, (uint32_t) 
dstva
, 
perm
);

139 
	}
}

142 
	$sys_page_unmap
(
envid_t
 
envid
, void *
va
)

144 return 
	`syscall
(
SYS_page_unmap
, 1, 
envid
, (
uint32_t
) 
va
, 0, 0, 0);

145 
	}
}

150 
	$sys_env_set_status
(
envid_t
 
envid
, int 
status
)

152 return 
	`syscall
(
SYS_env_set_status
, 1, 
envid
, 
status
, 0, 0, 0);

153 
	}
}

156 
	$sys_env_set_trapframe
(
envid_t
 
envid
, struct 
Trapframe
 *
tf
)

158 return 
	`syscall
(
SYS_env_set_trapframe
, 1, 
envid
, (
uint32_t
) 
tf
, 0, 0, 0);

159 
	}
}

162 
	$sys_env_set_pgfault_upcall
(
envid_t
 
envid
, void *
upcall
)

164 return 
	`syscall
(
SYS_env_set_pgfault_upcall
, 1, 
envid
, (
uint32_t
) 
upcall
, 0, 0, 0);

165 
	}
}

168 
	$sys_ipc_try_send
(
envid_t
 
envid
, 
uint32_t
 
value
, void *
srcva
, int 
perm
)

170 return 
	`syscall
(
SYS_ipc_try_send
, 0, 
envid
, 
value
, (
uint32_t
) 
srcva
, 
perm
, 0);

171 
	}
}

174 
	$sys_ipc_recv
(void *
dstva
)

176 return 
	`syscall
(
SYS_ipc_recv
, 1, (
uint32_t
)
dstva
, 0, 0, 0, 0);

177 
	}
}

180 
	$sys_time_msec
(void)

182 return (unsigned int) 
	`syscall
(
SYS_time_msec
, 0, 0, 0, 0, 0, 0);

183 
	}
}

186 
	$sys_net_send_packet
(void *
buf
, 
uint16_t
 
len
)

188 return 
	`syscall
(
SYS_net_send_packet
, 0, (
uint32_t
)
buf
, 
len
, 0, 0, 0);

189 
	}
}

192 
	$sys_net_recv_packet
(void *
buf
)

194 return 
	`syscall
(
SYS_net_recv_packet
, 0, (
uint32_t
)
buf
, 0, 0, 0, 0);

195 
	}
}

198 
	$sys_get_mac_addr
(
uint8_t
 
buf
[6])

200 return 
	`syscall
(
SYS_get_mac_addr
, 0, (
uint32_t
) 
buf
, 0, 0, 0, 0);

201 
	}
}

204 
	$sys_get_env_user_id
()

206 return 
	`syscall
(
SYS_get_env_user_id
,0,0,0,0,0,0);

207 
	}
}

210 
	$sys_get_env_group_id
()

212 return 
	`syscall
(
SYS_get_env_group_id
,0,0,0,0,0,0);

213 
	}
}

216 
	$sys_set_user_id
(
envid_t
 
envid
, 
uid_t
 
uid
)

218 return 
	`syscall
(
SYS_set_user_id
,0,(
uint32_t
)
envid
, (uint32_t)
uid
,0,0,0);

219 
	}
}

222 
	$sys_set_group_id
(
envid_t
 
envid
, 
gid_t
 
gid
)

224 return 
	`syscall
(
SYS_set_group_id
,0,(
uint32_t
)
envid
, (uint32_t)
gid
,0,0,0);

225 
	}
}

	@/root/Robux/lib/wait.c

1 #include 
	~<inc/lib.h
>

5 
	$wait
(
envid_t
 
envid
)

7 const volatile struct 
Env
 *
e
;

9 
	`assert
(
envid
 != 0);

10 
e
 = &
envs
[
	`ENVX
(
envid
)];

11 while (
e
->
env_id
 == 
envid
 && e->
env_status
 != 
ENV_FREE
)

12 
	`sys_yield
();

13 
	}
}

	@/root/Robux/net/input.c

1 #include 
	~"ns.h
"

3 extern union 
Nsipc
 
nsipcbuf
;

5 #define 
	#NBUFS
 16

	)

6 char 
	gdata
[
NBUFS
*
PGSIZE
] 
__attribute__
((
aligned
(PGSIZE)));

9 
	$input
(
envid_t
 
ns_envid
)

11 
binaryname
 = "ns_input";

25 int 
r
;

26 int 
buf
 = 0;

28 
	`memset
(
data
, 0, 
NBUFS
*
PGSIZE
);

30 struct 
jif_pkt
 *
packet
 = (struct jif_pkt*) 
data
;

31 
retry
:

32 while((
r
 = 
	`sys_net_recv_packet
(&
packet
->
jp_data
)) >= 0)

34 
packet
->
jp_len
 = 
r
;

35 
	`ipc_send
(
ns_envid
, 
NSREQ_INPUT
, 
packet
, 
PTE_P
 | 
PTE_U
 | 
PTE_W
);

38 
buf
 = (buf + 1) % 
NBUFS
;

39 
packet
 = (struct 
jif_pkt
*) &
data
[
PGSIZE
*
buf
];

41 if(
r
 == -
E_NET_NOT_RECV
)

43 
	`sys_yield
();

44 goto 
retry
;

47 
	`cprintf
("0x%08x %d %x\n", 
packet
, 
buf
, 
PGSIZE
*buf);

48 
	`cprintf
("net input: sys_net_recv_packet failed: %e\n", 
r
);

49 
	}
}

	@/root/Robux/net/lwip/api/api_lib.c

42 #include 
	~"lwip/opt.h
"

44 #if 
LWIP_NETCONN


46 #include 
	~"lwip/api.h
"

47 #include 
	~"lwip/tcpip.h
"

48 #include 
	~"lwip/memp.h
"

50 #include 
	~"lwip/ip.h
"

51 #include 
	~"lwip/raw.h
"

52 #include 
	~"lwip/udp.h
"

53 #include 
	~"lwip/tcp.h
"

55 #include 
	~<string.h
>

67 struct 
netconn
*

68 
	$netconn_new_with_proto_and_callback
(enum 
netconn_type
 
t
, 
u8_t
 
proto
, 
netconn_callback
 
callback
)

70 struct 
netconn
 *
conn
;

71 struct 
api_msg
 
msg
;

73 
conn
 = 
	`netconn_alloc
(
t
, 
callback
);

75 if (
conn
 != 
NULL
 ) {

76 
msg
.
function
 = 
do_newconn
;

77 
msg
.msg.msg.
n
.
proto
 = proto;

78 
msg
.msg.
conn
 = conn;

79 
	`TCPIP_APIMSG
(&
msg
);

81 if (
conn
->
err
 != 
ERR_OK
) {

82 
	`LWIP_ASSERT
("freeing conn without freeing pcb", 
conn
->
pcb
.
tcp
 == 
NULL
);

83 
	`LWIP_ASSERT
("conn has no op_completed", 
conn
->
op_completed
 != 
SYS_SEM_NULL
);

84 
	`LWIP_ASSERT
("conn has no recvmbox", 
conn
->
recvmbox
 != 
SYS_MBOX_NULL
);

85 
	`LWIP_ASSERT
("conn->acceptmbox shouldn't exist", 
conn
->
acceptmbox
 == 
SYS_MBOX_NULL
);

86 
	`sys_sem_free
(
conn
->
op_completed
);

87 
	`sys_mbox_free
(
conn
->
recvmbox
);

88 
	`memp_free
(
MEMP_NETCONN
, 
conn
);

89 return 
NULL
;

92 return 
conn
;

93 
	}
}

103 
err_t


104 
	$netconn_delete
(struct 
netconn
 *
conn
)

106 struct 
api_msg
 
msg
;

109 if (
conn
 == 
NULL
) {

110 return 
ERR_OK
;

113 
msg
.
function
 = 
do_delconn
;

114 
msg
.msg.
conn
 = conn;

115 
	`tcpip_apimsg
(&
msg
);

117 
conn
->
pcb
.
tcp
 = 
NULL
;

118 
	`netconn_free
(
conn
);

120 return 
ERR_OK
;

121 
	}
}

129 enum 
netconn_type


130 
	$netconn_type
(struct 
netconn
 *
conn
)

132 
	`LWIP_ERROR
("netconn_type: invalid conn", (
conn
 != 
NULL
), return 
NETCONN_INVALID
;);

133 return 
conn
->
type
;

134 
	}
}

147 
err_t


148 
	$netconn_getaddr
(struct 
netconn
 *
conn
, struct 
ip_addr
 *
addr
, 
u16_t
 *
port
, 
u8_t
 
local
)

150 struct 
api_msg
 
msg
;

152 
	`LWIP_ERROR
("netconn_getaddr: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

153 
	`LWIP_ERROR
("netconn_getaddr: invalid addr", (
addr
 != 
NULL
), return 
ERR_ARG
;);

154 
	`LWIP_ERROR
("netconn_getaddr: invalid port", (
port
 != 
NULL
), return 
ERR_ARG
;);

156 
msg
.
function
 = 
do_getaddr
;

157 
msg
.msg.
conn
 = conn;

158 
msg
.msg.msg.
ad
.
ipaddr
 = 
addr
;

159 
msg
.msg.msg.
ad
.
port
 = port;

160 
msg
.msg.msg.
ad
.
local
 = local;

161 
	`TCPIP_APIMSG
(&
msg
);

163 return 
conn
->
err
;

164 
	}
}

176 
err_t


177 
	$netconn_bind
(struct 
netconn
 *
conn
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
)

179 struct 
api_msg
 
msg
;

181 
	`LWIP_ERROR
("netconn_bind: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

183 
msg
.
function
 = 
do_bind
;

184 
msg
.msg.
conn
 = conn;

185 
msg
.msg.msg.
bc
.
ipaddr
 = 
addr
;

186 
msg
.msg.msg.
bc
.
port
 = port;

187 
	`TCPIP_APIMSG
(&
msg
);

188 return 
conn
->
err
;

189 
	}
}

199 
err_t


200 
	$netconn_connect
(struct 
netconn
 *
conn
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
)

202 struct 
api_msg
 
msg
;

204 
	`LWIP_ERROR
("netconn_connect: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

206 
msg
.
function
 = 
do_connect
;

207 
msg
.msg.
conn
 = conn;

208 
msg
.msg.msg.
bc
.
ipaddr
 = 
addr
;

209 
msg
.msg.msg.
bc
.
port
 = port;

211 
	`tcpip_apimsg
(&
msg
);

212 return 
conn
->
err
;

213 
	}
}

221 
err_t


222 
	$netconn_disconnect
(struct 
netconn
 *
conn
)

224 struct 
api_msg
 
msg
;

226 
	`LWIP_ERROR
("netconn_disconnect: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

228 
msg
.
function
 = 
do_disconnect
;

229 
msg
.msg.
conn
 = conn;

230 
	`TCPIP_APIMSG
(&
msg
);

231 return 
conn
->
err
;

232 
	}
}

242 
err_t


243 
	$netconn_listen_with_backlog
(struct 
netconn
 *
conn
, 
u8_t
 
backlog
)

245 struct 
api_msg
 
msg
;

248 
	`LWIP_UNUSED_ARG
(
backlog
);

250 
	`LWIP_ERROR
("netconn_listen: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

252 
msg
.
function
 = 
do_listen
;

253 
msg
.msg.
conn
 = conn;

254 #if 
TCP_LISTEN_BACKLOG


255 
msg
.msg.msg.
lb
.
backlog
 = backlog;

257 
	`TCPIP_APIMSG
(&
msg
);

258 return 
conn
->
err
;

259 
	}
}

267 struct 
netconn
 *

268 
	$netconn_accept
(struct 
netconn
 *
conn
)

270 struct 
netconn
 *
newconn
;

272 
	`LWIP_ERROR
("netconn_accept: invalid conn", (
conn
 != 
NULL
), return NULL;);

273 
	`LWIP_ERROR
("netconn_accept: invalid acceptmbox", (
conn
->
acceptmbox
 != 
SYS_MBOX_NULL
), return 
NULL
;);

275 #if 
LWIP_SO_RCVTIMEO


276 if (
	`sys_arch_mbox_fetch
(
conn
->
acceptmbox
, (void *)&
newconn
, conn->
recv_timeout
) == 
SYS_ARCH_TIMEOUT
) {

277 
newconn
 = 
NULL
;

280 
	`sys_arch_mbox_fetch
(
conn
->
acceptmbox
, (void *)&
newconn
, 0);

284 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVMINUS
, 0);

286 #if 
TCP_LISTEN_BACKLOG


287 if (
newconn
 != 
NULL
) {

289 struct 
api_msg
 
msg
;

290 
msg
.
function
 = 
do_recv
;

291 
msg
.msg.
conn
 = conn;

292 
	`TCPIP_APIMSG
(&
msg
);

297 return 
newconn
;

298 
	}
}

306 struct 
netbuf
 *

307 
	$netconn_recv
(struct 
netconn
 *
conn
)

309 struct 
api_msg
 
msg
;

310 struct 
netbuf
 *
buf
 = 
NULL
;

311 struct 
pbuf
 *
p
;

312 
u16_t
 
len
;

314 
	`LWIP_ERROR
("netconn_recv: invalid conn", (
conn
 != 
NULL
), return NULL;);

316 if (
conn
->
recvmbox
 == 
SYS_MBOX_NULL
) {

319 
conn
->
err
 = 
ERR_CONN
;

320 return 
NULL
;

323 if (
	`ERR_IS_FATAL
(
conn
->
err
)) {

324 return 
NULL
;

327 if (
conn
->
type
 == 
NETCONN_TCP
) {

328 #if 
LWIP_TCP


329 if (
conn
->
state
 == 
NETCONN_LISTEN
) {

331 
conn
->
err
 = 
ERR_CONN
;

332 return 
NULL
;

335 
buf
 = 
	`memp_malloc
(
MEMP_NETBUF
);

337 if (
buf
 == 
NULL
) {

338 
conn
->
err
 = 
ERR_MEM
;

339 return 
NULL
;

342 #if 
LWIP_SO_RCVTIMEO


343 if (
	`sys_arch_mbox_fetch
(
conn
->
recvmbox
, (void *)&
p
, conn->
recv_timeout
)==
SYS_ARCH_TIMEOUT
) {

344 
conn
->
err
 = 
ERR_TIMEOUT
;

345 
p
 = 
NULL
;

348 
	`sys_arch_mbox_fetch
(
conn
->
recvmbox
, (void *)&
p
, 0);

351 if (
p
 != 
NULL
) {

352 
len
 = 
p
->
tot_len
;

353 
	`SYS_ARCH_DEC
(
conn
->
recv_avail
, 
len
);

355 
len
 = 0;

359 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVMINUS
, 
len
);

362 if (
p
 == 
NULL
) {

363 
	`memp_free
(
MEMP_NETBUF
, 
buf
);

365 if (
conn
->
err
 == 
ERR_OK
) {

366 
conn
->
err
 = 
ERR_CLSD
;

368 return 
NULL
;

371 
buf
->
p
 = p;

372 
buf
->
ptr
 = 
p
;

373 
buf
->
port
 = 0;

374 
buf
->
addr
 = 
NULL
;

377 
msg
.
function
 = 
do_recv
;

378 
msg
.msg.
conn
 = conn;

379 if (
buf
 != 
NULL
) {

380 
msg
.msg.msg.
r
.
len
 = 
buf
->
p
->
tot_len
;

382 
msg
.msg.msg.
r
.
len
 = 1;

384 
	`TCPIP_APIMSG
(&
msg
);

387 #if (
LWIP_UDP
 || 
LWIP_RAW
)

388 #if 
LWIP_SO_RCVTIMEO


389 if (
	`sys_arch_mbox_fetch
(
conn
->
recvmbox
, (void *)&
buf
, conn->
recv_timeout
)==
SYS_ARCH_TIMEOUT
) {

390 
buf
 = 
NULL
;

393 
	`sys_arch_mbox_fetch
(
conn
->
recvmbox
, (void *)&
buf
, 0);

395 if (
buf
!=
NULL
) {

396 
	`SYS_ARCH_DEC
(
conn
->
recv_avail
, 
buf
->
p
->
tot_len
);

398 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVMINUS
, 
buf
->
p
->
tot_len
);

403 
	`LWIP_DEBUGF
(
API_LIB_DEBUG
, ("netconn_recv: received %p (err %d)\n", (void *)
buf
, 
conn
->
err
));

405 return 
buf
;

406 
	}
}

418 
err_t


419 
	$netconn_sendto
(struct 
netconn
 *
conn
, struct 
netbuf
 *
buf
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
)

421 if (
buf
 != 
NULL
) {

422 
buf
->
addr
 = addr;

423 
buf
->
port
 = port;

424 return 
	`netconn_send
(
conn
, 
buf
);

426 return 
ERR_VAL
;

427 
	}
}

436 
err_t


437 
	$netconn_send
(struct 
netconn
 *
conn
, struct 
netbuf
 *
buf
)

439 struct 
api_msg
 
msg
;

441 
	`LWIP_ERROR
("netconn_send: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

443 
	`LWIP_DEBUGF
(
API_LIB_DEBUG
, ("netconn_send: sending %d bytes\n", 
buf
->
p
->
tot_len
));

444 
msg
.
function
 = 
do_send
;

445 
msg
.msg.
conn
 = conn;

446 
msg
.msg.msg.
b
 = 
buf
;

447 
	`TCPIP_APIMSG
(&
msg
);

448 return 
conn
->
err
;

449 
	}
}

462 
err_t


463 
	$netconn_write
(struct 
netconn
 *
conn
, const void *
dataptr
, int 
size
, 
u8_t
 
apiflags
)

465 struct 
api_msg
 
msg
;

467 
	`LWIP_ERROR
("netconn_write: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

468 
	`LWIP_ERROR
("netconn_write: invalid conn->type", (
conn
->
type
 == 
NETCONN_TCP
), return 
ERR_VAL
;);

470 
msg
.
function
 = 
do_write
;

471 
msg
.msg.
conn
 = conn;

472 
msg
.msg.msg.
w
.
dataptr
 = dataptr;

473 
msg
.msg.msg.
w
.
apiflags
 = apiflags;

474 
msg
.msg.msg.
w
.
len
 = 
size
;

478 
	`TCPIP_APIMSG
(&
msg
);

479 return 
conn
->
err
;

480 
	}
}

488 
err_t


489 
	$netconn_close
(struct 
netconn
 *
conn
)

491 struct 
api_msg
 
msg
;

493 
	`LWIP_ERROR
("netconn_close: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

495 
msg
.
function
 = 
do_close
;

496 
msg
.msg.
conn
 = conn;

497 
	`tcpip_apimsg
(&
msg
);

498 return 
conn
->
err
;

499 
	}
}

501 #if 
LWIP_IGMP


512 
err_t


513 
	$netconn_join_leave_group
(struct 
netconn
 *
conn
,

514 struct 
ip_addr
 *
multiaddr
,

515 struct 
ip_addr
 *
interface
,

516 enum 
netconn_igmp
 
join_or_leave
)

518 struct 
api_msg
 
msg
;

520 
	`LWIP_ERROR
("netconn_join_leave_group: invalid conn", (
conn
 != 
NULL
), return 
ERR_ARG
;);

522 
msg
.
function
 = 
do_join_leave_group
;

523 
msg
.msg.
conn
 = conn;

524 
msg
.msg.msg.
jl
.
multiaddr
 = multiaddr;

525 
msg
.msg.msg.
jl
.
interface
 = interface;

526 
msg
.msg.msg.
jl
.
join_or_leave
 = join_or_leave;

527 
	`TCPIP_APIMSG
(&
msg
);

528 return 
conn
->
err
;

529 
	}
}

532 #if 
LWIP_DNS


543 
err_t


544 
	$netconn_gethostbyname
(const char *
name
, struct 
ip_addr
 *
addr
)

546 struct 
dns_api_msg
 
msg
;

547 
err_t
 
err
;

548 
sys_sem_t
 
sem
;

550 
	`LWIP_ERROR
("netconn_gethostbyname: invalid name", (
name
 != 
NULL
), return 
ERR_ARG
;);

551 
	`LWIP_ERROR
("netconn_gethostbyname: invalid addr", (
addr
 != 
NULL
), return 
ERR_ARG
;);

553 
sem
 = 
	`sys_sem_new
(0);

554 if (
sem
 == 
SYS_SEM_NULL
) {

555 return 
ERR_MEM
;

558 
msg
.
name
 = name;

559 
msg
.
addr
 = addr;

560 
msg
.
err
 = &err;

561 
msg
.
sem
 = sem;

563 
	`tcpip_callback
(
do_gethostbyname
, &
msg
);

564 
	`sys_sem_wait
(
sem
);

565 
	`sys_sem_free
(
sem
);

567 return 
err
;

568 
	}
}

	@/root/Robux/net/lwip/api/api_msg.c

39 #include 
	~"lwip/opt.h
"

41 #if 
LWIP_NETCONN


43 #include 
	~"lwip/api_msg.h
"

45 #include 
	~"lwip/ip.h
"

46 #include 
	~"lwip/udp.h
"

47 #include 
	~"lwip/tcp.h
"

48 #include 
	~"lwip/raw.h
"

50 #include 
	~"lwip/memp.h
"

51 #include 
	~"lwip/tcpip.h
"

52 #include 
	~"lwip/igmp.h
"

53 #include 
	~"lwip/dns.h
"

56 #if 
LWIP_TCP


57 static 
err_t
 
do_writemore
(struct 
netconn
 *
conn
);

58 static void 
do_close_internal
(struct 
netconn
 *
conn
);

61 #if 
LWIP_RAW


69 static 
u8_t


70 
	$recv_raw
(void *
arg
, struct 
raw_pcb
 *
pcb
, struct 
pbuf
 *
p
,

71 struct 
ip_addr
 *
addr
)

73 struct 
pbuf
 *
q
;

74 struct 
netbuf
 *
buf
;

75 struct 
netconn
 *
conn
;

76 #if 
LWIP_SO_RCVBUF


77 int 
recv_avail
;

80 
	`LWIP_UNUSED_ARG
(
addr
);

81 
conn
 = 
arg
;

83 #if 
LWIP_SO_RCVBUF


84 
	`SYS_ARCH_GET
(
conn
->
recv_avail
, recv_avail);

85 if ((
conn
 != 
NULL
) && (conn->
recvmbox
 != 
SYS_MBOX_NULL
) &&

86 ((
recv_avail
 + (int)(
p
->
tot_len
)) <= 
conn
->
recv_bufsize
)) {

88 if ((
conn
 != 
NULL
) && (conn->
recvmbox
 != 
SYS_MBOX_NULL
)) {

91 
q
 = 
	`pbuf_alloc
(
PBUF_RAW
, 
p
->
tot_len
, 
PBUF_RAM
);

92 if(
q
 != 
NULL
) {

93 if (
	`pbuf_copy
(
q
, 
p
) != 
ERR_OK
) {

94 
	`pbuf_free
(
q
);

95 
q
 = 
NULL
;

99 if(
q
 != 
NULL
) {

100 
buf
 = 
	`memp_malloc
(
MEMP_NETBUF
);

101 if (
buf
 == 
NULL
) {

102 
	`pbuf_free
(
q
);

106 
buf
->
p
 = 
q
;

107 
buf
->
ptr
 = 
q
;

108 
buf
->
addr
 = &(((struct 
ip_hdr
*)(
q
->
payload
))->
src
);

109 
buf
->
port
 = 
pcb
->
protocol
;

111 
	`SYS_ARCH_INC
(
conn
->
recv_avail
, 
q
->
tot_len
);

113 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVPLUS
, 
q
->
tot_len
);

114 if (
	`sys_mbox_trypost
(
conn
->
recvmbox
, 
buf
) != 
ERR_OK
) {

115 
	`netbuf_delete
(
buf
);

121 
	}
}

124 #if 
LWIP_UDP


132 
	$recv_udp
(void *
arg
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
,

133 struct 
ip_addr
 *
addr
, 
u16_t
 
port
)

135 struct 
netbuf
 *
buf
;

136 struct 
netconn
 *
conn
;

137 #if 
LWIP_SO_RCVBUF


138 int 
recv_avail
;

141 
	`LWIP_UNUSED_ARG
(
pcb
);

142 
	`LWIP_ASSERT
("recv_udp must have a pcb argument", 
pcb
 != 
NULL
);

143 
	`LWIP_ASSERT
("recv_udp must have an argument", 
arg
 != 
NULL
);

144 
conn
 = 
arg
;

145 
	`LWIP_ASSERT
("recv_udp: recv for wrong pcb!", 
conn
->
pcb
.
udp
 == pcb);

147 #if 
LWIP_SO_RCVBUF


148 
	`SYS_ARCH_GET
(
conn
->
recv_avail
, recv_avail);

149 if ((
conn
 == 
NULL
) || (conn->
recvmbox
 == 
SYS_MBOX_NULL
) ||

150 ((
recv_avail
 + (int)(
p
->
tot_len
)) > 
conn
->
recv_bufsize
)) {

152 if ((
conn
 == 
NULL
) || (conn->
recvmbox
 == 
SYS_MBOX_NULL
)) {

154 
	`pbuf_free
(
p
);

158 
buf
 = 
	`memp_malloc
(
MEMP_NETBUF
);

159 if (
buf
 == 
NULL
) {

160 
	`pbuf_free
(
p
);

163 
buf
->
p
 = p;

164 
buf
->
ptr
 = 
p
;

165 
buf
->
addr
 = addr;

166 
buf
->
port
 = port;

169 
	`SYS_ARCH_INC
(
conn
->
recv_avail
, 
p
->
tot_len
);

171 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVPLUS
, 
p
->
tot_len
);

172 if (
	`sys_mbox_trypost
(
conn
->
recvmbox
, 
buf
) != 
ERR_OK
) {

173 
	`netbuf_delete
(
buf
);

176 
	}
}

179 #if 
LWIP_TCP


186 static 
err_t


187 
	$recv_tcp
(void *
arg
, struct 
tcp_pcb
 *
pcb
, struct 
pbuf
 *
p
, 
err_t
 
err
)

189 struct 
netconn
 *
conn
;

190 
u16_t
 
len
;

192 
	`LWIP_UNUSED_ARG
(
pcb
);

193 
	`LWIP_ASSERT
("recv_tcp must have a pcb argument", 
pcb
 != 
NULL
);

194 
	`LWIP_ASSERT
("recv_tcp must have an argument", 
arg
 != 
NULL
);

195 
conn
 = 
arg
;

196 
	`LWIP_ASSERT
("recv_tcp: recv for wrong pcb!", 
conn
->
pcb
.
tcp
 == pcb);

198 if ((
conn
 == 
NULL
) || (conn->
recvmbox
 == 
SYS_MBOX_NULL
)) {

199 return 
ERR_VAL
;

202 
conn
->
err
 = err;

203 if (
p
 != 
NULL
) {

204 
len
 = 
p
->
tot_len
;

205 
	`SYS_ARCH_INC
(
conn
->
recv_avail
, 
len
);

207 
len
 = 0;

210 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVPLUS
, 
len
);

211 if (
	`sys_mbox_trypost
(
conn
->
recvmbox
, 
p
) != 
ERR_OK
) {

212 return 
ERR_MEM
;

215 return 
ERR_OK
;

216 
	}
}

229 static 
err_t


230 
	$poll_tcp
(void *
arg
, struct 
tcp_pcb
 *
pcb
)

232 struct 
netconn
 *
conn
 = 
arg
;

234 
	`LWIP_UNUSED_ARG
(
pcb
);

235 
	`LWIP_ASSERT
("conn != NULL", (
conn
 != 
NULL
));

237 if (
conn
->
state
 == 
NETCONN_WRITE
) {

238 
	`do_writemore
(
conn
);

239 } else if (
conn
->
state
 == 
NETCONN_CLOSE
) {

240 
	`do_close_internal
(
conn
);

243 return 
ERR_OK
;

244 
	}
}

253 static 
err_t


254 
	$sent_tcp
(void *
arg
, struct 
tcp_pcb
 *
pcb
, 
u16_t
 
len
)

256 struct 
netconn
 *
conn
 = 
arg
;

258 
	`LWIP_UNUSED_ARG
(
pcb
);

259 
	`LWIP_ASSERT
("conn != NULL", (
conn
 != 
NULL
));

261 if (
conn
->
state
 == 
NETCONN_WRITE
) {

262 
	`LWIP_ASSERT
("conn->pcb.tcp != NULL", 
conn
->
pcb
.
tcp
 != 
NULL
);

263 
	`do_writemore
(
conn
);

264 } else if (
conn
->
state
 == 
NETCONN_CLOSE
) {

265 
	`do_close_internal
(
conn
);

268 if (
conn
) {

269 if ((
conn
->
pcb
.
tcp
 != 
NULL
) && (
	`tcp_sndbuf
(conn->pcb.tcp) > 
TCP_SNDLOWAT
)) {

270 
	`API_EVENT
(
conn
, 
NETCONN_EVT_SENDPLUS
, 
len
);

274 return 
ERR_OK
;

275 
	}
}

285 
	$err_tcp
(void *
arg
, 
err_t
 
err
)

287 struct 
netconn
 *
conn
;

289 
conn
 = 
arg
;

290 
	`LWIP_ASSERT
("conn != NULL", (
conn
 != 
NULL
));

292 
conn
->
pcb
.
tcp
 = 
NULL
;

294 
conn
->
err
 = err;

295 if (
conn
->
recvmbox
 != 
SYS_MBOX_NULL
) {

297 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVPLUS
, 0);

298 
	`sys_mbox_post
(
conn
->
recvmbox
, 
NULL
);

300 if (
conn
->
op_completed
 != 
SYS_SEM_NULL
 && conn->
state
 == 
NETCONN_CONNECT
) {

301 
conn
->
state
 = 
NETCONN_NONE
;

302 
	`sys_sem_signal
(
conn
->
op_completed
);

304 if (
conn
->
acceptmbox
 != 
SYS_MBOX_NULL
) {

306 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVPLUS
, 0);

307 
	`sys_mbox_post
(
conn
->
acceptmbox
, 
NULL
);

309 if ((
conn
->
state
 == 
NETCONN_WRITE
) || (conn->state == 
NETCONN_CLOSE
)) {

312 
conn
->
state
 = 
NETCONN_NONE
;

314 
	`sys_sem_signal
(
conn
->
op_completed
);

316 
	}
}

325 
	$setup_tcp
(struct 
netconn
 *
conn
)

327 struct 
tcp_pcb
 *
pcb
;

329 
pcb
 = 
conn
->pcb.
tcp
;

330 
	`tcp_arg
(
pcb
, 
conn
);

331 
	`tcp_recv
(
pcb
, 
recv_tcp
);

332 
	`tcp_sent
(
pcb
, 
sent_tcp
);

333 
	`tcp_poll
(
pcb
, 
poll_tcp
, 4);

334 
	`tcp_err
(
pcb
, 
err_tcp
);

335 
	}
}

343 static 
err_t


344 
	$accept_function
(void *
arg
, struct 
tcp_pcb
 *
newpcb
, 
err_t
 
err
)

346 struct 
netconn
 *
newconn
;

347 struct 
netconn
 *
conn
;

349 #if 
API_MSG_DEBUG


350 #if 
TCP_DEBUG


351 
	`tcp_debug_print_state
(
newpcb
->
state
);

354 
conn
 = (struct 
netconn
 *)
arg
;

356 
	`LWIP_ERROR
("accept_function: invalid conn->acceptmbox",

357 
conn
->
acceptmbox
 != 
SYS_MBOX_NULL
, return 
ERR_VAL
;);

361 
newconn
 = 
	`netconn_alloc
(
conn
->
type
, conn->
callback
);

362 if (
newconn
 == 
NULL
) {

363 return 
ERR_MEM
;

365 
newconn
->
pcb
.
tcp
 = 
newpcb
;

366 
	`setup_tcp
(
newconn
);

367 
newconn
->
err
 = err;

369 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVPLUS
, 0);

371 if (
	`sys_mbox_trypost
(
conn
->
acceptmbox
, 
newconn
) != 
ERR_OK
) {

374 
newconn
->
pcb
.
tcp
 = 
NULL
;

375 
	`netconn_free
(
newconn
);

376 return 
ERR_MEM
;

378 return 
ERR_OK
;

379 
	}
}

389 static 
err_t


390 
	$pcb_new
(struct 
api_msg_msg
 *
msg
)

392 
msg
->
conn
->
err
 = 
ERR_OK
;

394 
	`LWIP_ASSERT
("pcb_new: pcb already allocated", 
msg
->
conn
->
pcb
.
tcp
 == 
NULL
);

397 switch(
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
)) {

398 #if 
LWIP_RAW


399 case 
NETCONN_RAW
:

400 
msg
->
conn
->
pcb
.
raw
 = 
	`raw_new
(msg->msg.
n
.
proto
);

401 if(
msg
->
conn
->
pcb
.
raw
 == 
NULL
) {

402 
msg
->
conn
->
err
 = 
ERR_MEM
;

405 
	`raw_recv
(
msg
->
conn
->
pcb
.
raw
, 
recv_raw
, msg->conn);

408 #if 
LWIP_UDP


409 case 
NETCONN_UDP
:

410 
msg
->
conn
->
pcb
.
udp
 = 
	`udp_new
();

411 if(
msg
->
conn
->
pcb
.
udp
 == 
NULL
) {

412 
msg
->
conn
->
err
 = 
ERR_MEM
;

415 #if 
LWIP_UDPLITE


416 if (
msg
->
conn
->
type
==
NETCONN_UDPLITE
) {

417 
	`udp_setflags
(
msg
->
conn
->
pcb
.
udp
, 
UDP_FLAGS_UDPLITE
);

420 if (
msg
->
conn
->
type
==
NETCONN_UDPNOCHKSUM
) {

421 
	`udp_setflags
(
msg
->
conn
->
pcb
.
udp
, 
UDP_FLAGS_NOCHKSUM
);

423 
	`udp_recv
(
msg
->
conn
->
pcb
.
udp
, 
recv_udp
, msg->conn);

426 #if 
LWIP_TCP


427 case 
NETCONN_TCP
:

428 
msg
->
conn
->
pcb
.
tcp
 = 
	`tcp_new
();

429 if(
msg
->
conn
->
pcb
.
tcp
 == 
NULL
) {

430 
msg
->
conn
->
err
 = 
ERR_MEM
;

433 
	`setup_tcp
(
msg
->
conn
);

438 
msg
->
conn
->
err
 = 
ERR_VAL
;

442 return 
msg
->
conn
->
err
;

443 
	}
}

452 
	$do_newconn
(struct 
api_msg_msg
 *
msg
)

454 if(
msg
->
conn
->
pcb
.
tcp
 == 
NULL
) {

455 
	`pcb_new
(
msg
);

461 
	`TCPIP_APIMSG_ACK
(
msg
);

462 
	}
}

474 struct 
netconn
*

475 
	$netconn_alloc
(enum 
netconn_type
 
t
, 
netconn_callback
 
callback
)

477 struct 
netconn
 *
conn
;

478 int 
size
;

480 
conn
 = 
	`memp_malloc
(
MEMP_NETCONN
);

481 if (
conn
 == 
NULL
) {

482 return 
NULL
;

485 
conn
->
err
 = 
ERR_OK
;

486 
conn
->
type
 = 
t
;

487 
conn
->
pcb
.
tcp
 = 
NULL
;

489 #if (
DEFAULT_RAW_RECVMBOX_SIZE
 == 
DEFAULT_UDP_RECVMBOX_SIZE
) && \

490 (
DEFAULT_RAW_RECVMBOX_SIZE
 == 
DEFAULT_TCP_RECVMBOX_SIZE
)

491 
size
 = 
DEFAULT_RAW_RECVMBOX_SIZE
;

493 switch(
	`NETCONNTYPE_GROUP
(
t
)) {

494 #if 
LWIP_RAW


495 case 
NETCONN_RAW
:

496 
size
 = 
DEFAULT_RAW_RECVMBOX_SIZE
;

499 #if 
LWIP_UDP


500 case 
NETCONN_UDP
:

501 
size
 = 
DEFAULT_UDP_RECVMBOX_SIZE
;

504 #if 
LWIP_TCP


505 case 
NETCONN_TCP
:

506 
size
 = 
DEFAULT_TCP_RECVMBOX_SIZE
;

510 
	`LWIP_ASSERT
("netconn_alloc: undefined netconn_type", 0);

515 if ((
conn
->
op_completed
 = 
	`sys_sem_new
(0)) == 
SYS_SEM_NULL
) {

516 
	`memp_free
(
MEMP_NETCONN
, 
conn
);

517 return 
NULL
;

519 if ((
conn
->
recvmbox
 = 
	`sys_mbox_new
(
size
)) == 
SYS_MBOX_NULL
) {

520 
	`sys_sem_free
(
conn
->
op_completed
);

521 
	`memp_free
(
MEMP_NETCONN
, 
conn
);

522 return 
NULL
;

525 
conn
->
acceptmbox
 = 
SYS_MBOX_NULL
;

526 
conn
->
state
 = 
NETCONN_NONE
;

528 
conn
->
socket
 = -1;

529 
conn
->
callback
 = callback;

530 
conn
->
recv_avail
 = 0;

531 #if 
LWIP_SO_RCVTIMEO


532 
conn
->
recv_timeout
 = 0;

534 #if 
LWIP_SO_RCVBUF


535 
conn
->
recv_bufsize
 = 
INT_MAX
;

537 return 
conn
;

538 
	}
}

547 
	$netconn_free
(struct 
netconn
 *
conn
)

549 void *
mem
;

550 
	`LWIP_ASSERT
("PCB must be deallocated outside this function", 
conn
->
pcb
.
tcp
 == 
NULL
);

553 if (
conn
->
recvmbox
 != 
SYS_MBOX_NULL
) {

554 while (
	`sys_mbox_tryfetch
(
conn
->
recvmbox
, &
mem
) != 
SYS_MBOX_EMPTY
) {

555 if (
conn
->
type
 == 
NETCONN_TCP
) {

556 if(
mem
 != 
NULL
) {

557 
	`pbuf_free
((struct 
pbuf
 *)
mem
);

560 
	`netbuf_delete
((struct 
netbuf
 *)
mem
);

563 
	`sys_mbox_free
(
conn
->
recvmbox
);

564 
conn
->
recvmbox
 = 
SYS_MBOX_NULL
;

568 if (
conn
->
acceptmbox
 != 
SYS_MBOX_NULL
) {

569 while (
	`sys_mbox_tryfetch
(
conn
->
acceptmbox
, &
mem
) != 
SYS_MBOX_EMPTY
) {

570 
	`netconn_delete
((struct 
netconn
 *)
mem
);

572 
	`sys_mbox_free
(
conn
->
acceptmbox
);

573 
conn
->
acceptmbox
 = 
SYS_MBOX_NULL
;

576 
	`sys_sem_free
(
conn
->
op_completed
);

577 
conn
->
op_completed
 = 
SYS_SEM_NULL
;

579 
	`memp_free
(
MEMP_NETCONN
, 
conn
);

580 
	}
}

582 #if 
LWIP_TCP


591 
	$do_close_internal
(struct 
netconn
 *
conn
)

593 
err_t
 
err
;

595 
	`LWIP_ASSERT
("invalid conn", (
conn
 != 
NULL
));

596 
	`LWIP_ASSERT
("this is for tcp netconns only", (
conn
->
type
 == 
NETCONN_TCP
));

597 
	`LWIP_ASSERT
("conn must be in state NETCONN_CLOSE", (
conn
->
state
 == 
NETCONN_CLOSE
));

598 
	`LWIP_ASSERT
("pcb already closed", (
conn
->
pcb
.
tcp
 != 
NULL
));

601 
	`tcp_arg
(
conn
->
pcb
.
tcp
, 
NULL
);

602 if (
conn
->
pcb
.
tcp
->
state
 == 
LISTEN
) {

603 
	`tcp_accept
(
conn
->
pcb
.
tcp
, 
NULL
);

605 
	`tcp_recv
(
conn
->
pcb
.
tcp
, 
NULL
);

606 
	`tcp_accept
(
conn
->
pcb
.
tcp
, 
NULL
);

608 
	`tcp_sent
(
conn
->
pcb
.
tcp
, 
NULL
);

609 
	`tcp_poll
(
conn
->
pcb
.
tcp
, 
NULL
, 4);

610 
	`tcp_err
(
conn
->
pcb
.
tcp
, 
NULL
);

613 
err
 = 
	`tcp_close
(
conn
->
pcb
.
tcp
);

614 if (
err
 == 
ERR_OK
) {

616 
conn
->
state
 = 
NETCONN_NONE
;

618 
conn
->
pcb
.
tcp
 = 
NULL
;

619 
conn
->
err
 = 
ERR_OK
;

622 
	`API_EVENT
(
conn
, 
NETCONN_EVT_RCVPLUS
, 0);

623 
	`API_EVENT
(
conn
, 
NETCONN_EVT_SENDPLUS
, 0);

625 
	`sys_sem_signal
(
conn
->
op_completed
);

629 
	`LWIP_ASSERT
("Closing a listen pcb may not fail!", (
conn
->
pcb
.
tcp
->
state
 != 
LISTEN
));

630 
	`tcp_sent
(
conn
->
pcb
.
tcp
, 
sent_tcp
);

631 
	`tcp_poll
(
conn
->
pcb
.
tcp
, 
poll_tcp
, 4);

632 
	`tcp_err
(
conn
->
pcb
.
tcp
, 
err_tcp
);

633 
	`tcp_arg
(
conn
->
pcb
.
tcp
, conn);

637 
	}
}

647 
	$do_delconn
(struct 
api_msg_msg
 *
msg
)

649 if (
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) {

650 switch (
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
)) {

651 #if 
LWIP_RAW


652 case 
NETCONN_RAW
:

653 
	`raw_remove
(
msg
->
conn
->
pcb
.
raw
);

656 #if 
LWIP_UDP


657 case 
NETCONN_UDP
:

658 
msg
->
conn
->
pcb
.
udp
->
recv_arg
 = 
NULL
;

659 
	`udp_remove
(
msg
->
conn
->
pcb
.
udp
);

662 #if 
LWIP_TCP


663 case 
NETCONN_TCP
:

664 
msg
->
conn
->
state
 = 
NETCONN_CLOSE
;

665 
	`do_close_internal
(
msg
->
conn
);

678 
	`API_EVENT
(
msg
->
conn
, 
NETCONN_EVT_RCVPLUS
, 0);

679 
	`API_EVENT
(
msg
->
conn
, 
NETCONN_EVT_SENDPLUS
, 0);

681 if (
msg
->
conn
->
op_completed
 != 
SYS_SEM_NULL
) {

682 
	`sys_sem_signal
(
msg
->
conn
->
op_completed
);

684 
	}
}

694 
	$do_bind
(struct 
api_msg_msg
 *
msg
)

696 if (!
	`ERR_IS_FATAL
(
msg
->
conn
->
err
)) {

697 if (
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) {

698 switch (
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
)) {

699 #if 
LWIP_RAW


700 case 
NETCONN_RAW
:

701 
msg
->
conn
->
err
 = 
	`raw_bind
(msg->conn->
pcb
.
raw
, msg->msg.
bc
.
ipaddr
);

704 #if 
LWIP_UDP


705 case 
NETCONN_UDP
:

706 
msg
->
conn
->
err
 = 
	`udp_bind
(msg->conn->
pcb
.
udp
, msg->msg.
bc
.
ipaddr
, msg->msg.bc.
port
);

709 #if 
LWIP_TCP


710 case 
NETCONN_TCP
:

711 
msg
->
conn
->
err
 = 
	`tcp_bind
(msg->conn->
pcb
.
tcp
, msg->msg.
bc
.
ipaddr
, msg->msg.bc.
port
);

719 
msg
->
conn
->
err
 = 
ERR_VAL
;

722 
	`TCPIP_APIMSG_ACK
(
msg
);

723 
	}
}

725 #if 
LWIP_TCP


732 static 
err_t


733 
	$do_connected
(void *
arg
, struct 
tcp_pcb
 *
pcb
, 
err_t
 
err
)

735 struct 
netconn
 *
conn
;

737 
	`LWIP_UNUSED_ARG
(
pcb
);

739 
conn
 = 
arg
;

741 if (
conn
 == 
NULL
) {

742 return 
ERR_VAL
;

745 
conn
->
err
 = err;

746 if ((
conn
->
type
 == 
NETCONN_TCP
) && (
err
 == 
ERR_OK
)) {

747 
	`setup_tcp
(
conn
);

749 
conn
->
state
 = 
NETCONN_NONE
;

750 
	`sys_sem_signal
(
conn
->
op_completed
);

751 return 
ERR_OK
;

752 
	}
}

763 
	$do_connect
(struct 
api_msg_msg
 *
msg
)

765 if (
msg
->
conn
->
pcb
.
tcp
 == 
NULL
) {

766 
	`sys_sem_signal
(
msg
->
conn
->
op_completed
);

770 switch (
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
)) {

771 #if 
LWIP_RAW


772 case 
NETCONN_RAW
:

773 
msg
->
conn
->
err
 = 
	`raw_connect
(msg->conn->
pcb
.
raw
, msg->msg.
bc
.
ipaddr
);

774 
	`sys_sem_signal
(
msg
->
conn
->
op_completed
);

777 #if 
LWIP_UDP


778 case 
NETCONN_UDP
:

779 
msg
->
conn
->
err
 = 
	`udp_connect
(msg->conn->
pcb
.
udp
, msg->msg.
bc
.
ipaddr
, msg->msg.bc.
port
);

780 
	`sys_sem_signal
(
msg
->
conn
->
op_completed
);

783 #if 
LWIP_TCP


784 case 
NETCONN_TCP
:

785 
msg
->
conn
->
state
 = 
NETCONN_CONNECT
;

786 
	`setup_tcp
(
msg
->
conn
);

787 
msg
->
conn
->
err
 = 
	`tcp_connect
(msg->conn->
pcb
.
tcp
, msg->msg.
bc
.
ipaddr
, msg->msg.bc.
port
,

788 
do_connected
);

796 
	}
}

806 
	$do_disconnect
(struct 
api_msg_msg
 *
msg
)

808 #if 
LWIP_UDP


809 if (
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
) == 
NETCONN_UDP
) {

810 
	`udp_disconnect
(
msg
->
conn
->
pcb
.
udp
);

813 
	`TCPIP_APIMSG_ACK
(
msg
);

814 
	}
}

823 
	$do_listen
(struct 
api_msg_msg
 *
msg
)

825 #if 
LWIP_TCP


826 if (!
	`ERR_IS_FATAL
(
msg
->
conn
->
err
)) {

827 if (
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) {

828 if (
msg
->
conn
->
type
 == 
NETCONN_TCP
) {

829 if (
msg
->
conn
->
pcb
.
tcp
->
state
 == 
CLOSED
) {

830 #if 
TCP_LISTEN_BACKLOG


831 struct 
tcp_pcb
* 
lpcb
 = 
	`tcp_listen_with_backlog
(
msg
->
conn
->
pcb
.
tcp
, msg->msg.
lb
.
backlog
);

833 struct 
tcp_pcb
* 
lpcb
 = 
	`tcp_listen
(
msg
->
conn
->
pcb
.
tcp
);

835 if (
lpcb
 == 
NULL
) {

836 
msg
->
conn
->
err
 = 
ERR_MEM
;

839 if (
msg
->
conn
->
recvmbox
 != 
SYS_MBOX_NULL
) {

841 
	`sys_mbox_free
(
msg
->
conn
->
recvmbox
);

842 
msg
->
conn
->
recvmbox
 = 
SYS_MBOX_NULL
;

844 if (
msg
->
conn
->
acceptmbox
 == 
SYS_MBOX_NULL
) {

845 if ((
msg
->
conn
->
acceptmbox
 = 
	`sys_mbox_new
(
DEFAULT_ACCEPTMBOX_SIZE
)) == 
SYS_MBOX_NULL
) {

846 
msg
->
conn
->
err
 = 
ERR_MEM
;

849 if (
msg
->
conn
->
err
 == 
ERR_OK
) {

850 
msg
->
conn
->
state
 = 
NETCONN_LISTEN
;

851 
msg
->
conn
->
pcb
.
tcp
 = 
lpcb
;

852 
	`tcp_arg
(
msg
->
conn
->
pcb
.
tcp
, msg->conn);

853 
	`tcp_accept
(
msg
->
conn
->
pcb
.
tcp
, 
accept_function
);

857 
msg
->
conn
->
err
 = 
ERR_CONN
;

863 
	`TCPIP_APIMSG_ACK
(
msg
);

864 
	}
}

873 
	$do_send
(struct 
api_msg_msg
 *
msg
)

875 if (!
	`ERR_IS_FATAL
(
msg
->
conn
->
err
)) {

876 if (
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) {

877 switch (
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
)) {

878 #if 
LWIP_RAW


879 case 
NETCONN_RAW
:

880 if (
msg
->msg.
b
->
addr
 == 
NULL
) {

881 
msg
->
conn
->
err
 = 
	`raw_send
(msg->conn->
pcb
.
raw
, msg->msg.
b
->
p
);

883 
msg
->
conn
->
err
 = 
	`raw_sendto
(msg->conn->
pcb
.
raw
, msg->msg.
b
->
p
, msg->msg.b->
addr
);

887 #if 
LWIP_UDP


888 case 
NETCONN_UDP
:

889 if (
msg
->msg.
b
->
addr
 == 
NULL
) {

890 
msg
->
conn
->
err
 = 
	`udp_send
(msg->conn->
pcb
.
udp
, msg->msg.
b
->
p
);

892 
msg
->
conn
->
err
 = 
	`udp_sendto
(msg->conn->
pcb
.
udp
, msg->msg.
b
->
p
, msg->msg.b->
addr
, msg->msg.b->
port
);

901 
	`TCPIP_APIMSG_ACK
(
msg
);

902 
	}
}

911 
	$do_recv
(struct 
api_msg_msg
 *
msg
)

913 #if 
LWIP_TCP


914 if (!
	`ERR_IS_FATAL
(
msg
->
conn
->
err
)) {

915 if (
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) {

916 if (
msg
->
conn
->
type
 == 
NETCONN_TCP
) {

917 #if 
TCP_LISTEN_BACKLOG


918 if (
msg
->
conn
->
pcb
.
tcp
->
state
 == 
LISTEN
) {

919 
	`tcp_accepted
(
msg
->
conn
->
pcb
.
tcp
);

923 
	`tcp_recved
(
msg
->
conn
->
pcb
.
tcp
, msg->msg.
r
.
len
);

929 
	`TCPIP_APIMSG_ACK
(
msg
);

930 
	}
}

932 #if 
LWIP_TCP


944 static 
err_t


945 
	$do_writemore
(struct 
netconn
 *
conn
)

947 
err_t
 
err
;

948 void *
dataptr
;

949 
u16_t
 
len
, 
available
;

950 
u8_t
 
write_finished
 = 0;

952 
	`LWIP_ASSERT
("conn->state == NETCONN_WRITE", (
conn
->
state
 == 
NETCONN_WRITE
));

954 
dataptr
 = (
u8_t
*)
conn
->
write_msg
->
msg
.
w
.dataptr + conn->
write_offset
;

955 if ((
conn
->
write_msg
->
msg
.
w
.
len
 - conn->
write_offset
 > 0xffff)) {

956 
len
 = 0xffff;

957 #if 
LWIP_TCPIP_CORE_LOCKING


958 
conn
->
write_delayed
 = 1;

961 
len
 = 
conn
->
write_msg
->
msg
.
w
.len - conn->
write_offset
;

963 
available
 = 
	`tcp_sndbuf
(
conn
->
pcb
.
tcp
);

964 if (
available
 < 
len
) {

966 
len
 = 
available
;

967 #if 
LWIP_TCPIP_CORE_LOCKING


968 
conn
->
write_delayed
 = 1;

972 
err
 = 
	`tcp_write
(
conn
->
pcb
.
tcp
, 
dataptr
, 
len
, conn->
write_msg
->
msg
.
w
.
apiflags
);

973 
	`LWIP_ASSERT
("do_writemore: invalid length!", ((
conn
->
write_offset
 + 
len
) <= conn->
write_msg
->
msg
.
w
.len));

974 if (
err
 == 
ERR_OK
) {

975 
conn
->
write_offset
 += 
len
;

976 if (
conn
->
write_offset
 == conn->
write_msg
->
msg
.
w
.
len
) {

978 
write_finished
 = 1;

979 
conn
->
write_msg
 = 
NULL
;

980 
conn
->
write_offset
 = 0;

982 
err
 = 
	`tcp_output_nagle
(
conn
->
pcb
.
tcp
);

983 
conn
->
err
 = err;

984 if ((
err
 == 
ERR_OK
) && (
	`tcp_sndbuf
(
conn
->
pcb
.
tcp
) <= 
TCP_SNDLOWAT
)) {

985 
	`API_EVENT
(
conn
, 
NETCONN_EVT_SENDMINUS
, 
len
);

987 } else if (
err
 == 
ERR_MEM
) {

993 
err
 = 
	`tcp_output
(
conn
->
pcb
.
tcp
);

995 #if 
LWIP_TCPIP_CORE_LOCKING


996 
conn
->
write_delayed
 = 1;

1001 
conn
->
err
 = err;

1002 
write_finished
 = 1;

1005 if (
write_finished
) {

1008 
conn
->
state
 = 
NETCONN_NONE
;

1009 #if 
LWIP_TCPIP_CORE_LOCKING


1010 if (
conn
->
write_delayed
 != 0)

1013 
	`sys_sem_signal
(
conn
->
op_completed
);

1016 #if 
LWIP_TCPIP_CORE_LOCKING


1018 return 
ERR_MEM
;

1020 return 
ERR_OK
;

1021 
	}
}

1031 
	$do_write
(struct 
api_msg_msg
 *
msg
)

1033 if (!
	`ERR_IS_FATAL
(
msg
->
conn
->
err
)) {

1034 if ((
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) && (msg->conn->
type
 == 
NETCONN_TCP
)) {

1035 #if 
LWIP_TCP


1036 
msg
->
conn
->
state
 = 
NETCONN_WRITE
;

1038 
msg
->
conn
->
write_msg
 = msg;

1039 
msg
->
conn
->
write_offset
 = 0;

1040 #if 
LWIP_TCPIP_CORE_LOCKING


1041 
msg
->
conn
->
write_delayed
 = 0;

1042 if (
	`do_writemore
(
msg
->
conn
) != 
ERR_OK
) {

1043 
	`LWIP_ASSERT
("state!", 
msg
->
conn
->
state
 == 
NETCONN_WRITE
);

1044 
	`UNLOCK_TCPIP_CORE
();

1045 
	`sys_arch_sem_wait
(
msg
->
conn
->
op_completed
, 0);

1046 
	`LOCK_TCPIP_CORE
();

1047 
	`LWIP_ASSERT
("state!", 
msg
->
conn
->
state
 == 
NETCONN_NONE
);

1050 
	`do_writemore
(
msg
->
conn
);

1055 #if (
LWIP_UDP
 || 
LWIP_RAW
)

1057 
msg
->
conn
->
err
 = 
ERR_VAL
;

1061 
	`TCPIP_APIMSG_ACK
(
msg
);

1062 
	}
}

1071 
	$do_getaddr
(struct 
api_msg_msg
 *
msg
)

1073 if (
msg
->
conn
->
pcb
.
ip
 != 
NULL
) {

1074 *(
msg
->msg.
ad
.
ipaddr
) = (msg->msg.ad.
local
?msg->
conn
->
pcb
.
ip
->
local_ip
:msg->conn->pcb.ip->
remote_ip
);

1076 switch (
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
)) {

1077 #if 
LWIP_RAW


1078 case 
NETCONN_RAW
:

1079 if (
msg
->msg.
ad
.
local
) {

1080 *(
msg
->msg.
ad
.
port
) = msg->
conn
->
pcb
.
raw
->
protocol
;

1083 
msg
->
conn
->
err
 = 
ERR_CONN
;

1087 #if 
LWIP_UDP


1088 case 
NETCONN_UDP
:

1089 if (
msg
->msg.
ad
.
local
) {

1090 *(
msg
->msg.
ad
.
port
) = msg->
conn
->
pcb
.
udp
->
local_port
;

1092 if ((
msg
->
conn
->
pcb
.
udp
->
flags
 & 
UDP_FLAGS_CONNECTED
) == 0) {

1093 
msg
->
conn
->
err
 = 
ERR_CONN
;

1095 *(
msg
->msg.
ad
.
port
) = msg->
conn
->
pcb
.
udp
->
remote_port
;

1100 #if 
LWIP_TCP


1101 case 
NETCONN_TCP
:

1102 *(
msg
->msg.
ad
.
port
) = (msg->msg.ad.
local
?msg->
conn
->
pcb
.
tcp
->
local_port
:msg->conn->pcb.tcp->
remote_port
);

1107 
msg
->
conn
->
err
 = 
ERR_CONN
;

1109 
	`TCPIP_APIMSG_ACK
(
msg
);

1110 
	}
}

1119 
	$do_close
(struct 
api_msg_msg
 *
msg
)

1121 #if 
LWIP_TCP


1122 if ((
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) && (msg->conn->
type
 == 
NETCONN_TCP
)) {

1123 
msg
->
conn
->
state
 = 
NETCONN_CLOSE
;

1124 
	`do_close_internal
(
msg
->
conn
);

1129 
msg
->
conn
->
err
 = 
ERR_VAL
;

1130 
	`TCPIP_APIMSG_ACK
(
msg
);

1132 
	}
}

1134 #if 
LWIP_IGMP


1142 
	$do_join_leave_group
(struct 
api_msg_msg
 *
msg
)

1144 if (!
	`ERR_IS_FATAL
(
msg
->
conn
->
err
)) {

1145 if (
msg
->
conn
->
pcb
.
tcp
 != 
NULL
) {

1146 if (
	`NETCONNTYPE_GROUP
(
msg
->
conn
->
type
) == 
NETCONN_UDP
) {

1147 #if 
LWIP_UDP


1148 if (
msg
->msg.
jl
.
join_or_leave
 == 
NETCONN_JOIN
) {

1149 
msg
->
conn
->
err
 = 
	`igmp_joingroup
(msg->msg.
jl
.
interface
, msg->msg.jl.
multiaddr
);

1151 
msg
->
conn
->
err
 = 
	`igmp_leavegroup
(msg->msg.
jl
.
interface
, msg->msg.jl.
multiaddr
);

1154 #if (
LWIP_TCP
 || 
LWIP_RAW
)

1156 
msg
->
conn
->
err
 = 
ERR_VAL
;

1161 
	`TCPIP_APIMSG_ACK
(
msg
);

1162 
	}
}

1165 #if 
LWIP_DNS


1172 
	$do_dns_found
(const char *
name
, struct 
ip_addr
 *
ipaddr
, void *
arg
)

1174 struct 
dns_api_msg
 *
msg
 = (struct dns_api_msg*)
arg
;

1176 
	`LWIP_ASSERT
("DNS response for wrong host name", 
	`strcmp
(
msg
->
name
, name) == 0);

1178 if (
ipaddr
 == 
NULL
) {

1180 *
msg
->
err
 = 
ERR_VAL
;

1183 *
msg
->
err
 = 
ERR_OK
;

1184 *
msg
->
addr
 = *
ipaddr
;

1187 
	`sys_sem_signal
(
msg
->
sem
);

1188 
	}
}

1197 
	$do_gethostbyname
(void *
arg
)

1199 struct 
dns_api_msg
 *
msg
 = (struct dns_api_msg*)
arg
;

1201 *
msg
->
err
 = 
	`dns_gethostbyname
(msg->
name
, msg->
addr
, 
do_dns_found
, msg);

1202 if (*
msg
->
err
 != 
ERR_INPROGRESS
) {

1205 
	`sys_sem_signal
(
msg
->
sem
);

1207 
	}
}

	@/root/Robux/net/lwip/api/err.c

39 #include 
	~"lwip/err.h
"

41 #ifdef 
LWIP_DEBUG


43 static const char *
	gerr_strerr
[] = {

68 
	$lwip_strerr
(
err_t
 
err
)

70 return 
err_strerr
[-
err
];

72 
	}
}

	@/root/Robux/net/lwip/api/netbuf.c

39 #include 
	~"lwip/opt.h
"

41 #if 
LWIP_NETCONN


43 #include 
	~"lwip/netbuf.h
"

44 #include 
	~"lwip/memp.h
"

46 #include 
	~<string.h
>

56 
netbuf
 *
	$netbuf_new
(void)

58 struct 
netbuf
 *
buf
;

60 
buf
 = 
	`memp_malloc
(
MEMP_NETBUF
);

61 if (
buf
 != 
NULL
) {

62 
buf
->
p
 = 
NULL
;

63 
buf
->
ptr
 = 
NULL
;

64 
buf
->
addr
 = 
NULL
;

65 return 
buf
;

67 return 
NULL
;

69 
	}
}

77 
	$netbuf_delete
(struct 
netbuf
 *
buf
)

79 if (
buf
 != 
NULL
) {

80 if (
buf
->
p
 != 
NULL
) {

81 
	`pbuf_free
(
buf
->
p
);

82 
buf
->
p
 = buf->
ptr
 = 
NULL
;

84 
	`memp_free
(
MEMP_NETBUF
, 
buf
);

86 
	}
}

97 
	$netbuf_alloc
(struct 
netbuf
 *
buf
, 
u16_t
 
size
)

99 
	`LWIP_ERROR
("netbuf_alloc: invalid buf", (
buf
 != 
NULL
), return NULL;);

102 if (
buf
->
p
 != 
NULL
) {

103 
	`pbuf_free
(
buf
->
p
);

105 
buf
->
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
size
, 
PBUF_RAM
);

106 if (
buf
->
p
 == 
NULL
) {

107 return 
NULL
;

109 
	`LWIP_ASSERT
("check that first pbuf can hold size",

110 (
buf
->
p
->
len
 >= 
size
));

111 
buf
->
ptr
 = buf->
p
;

112 return 
buf
->
p
->
payload
;

113 
	}
}

121 
	$netbuf_free
(struct 
netbuf
 *
buf
)

123 
	`LWIP_ERROR
("netbuf_free: invalid buf", (
buf
 != 
NULL
), return;);

124 if (
buf
->
p
 != 
NULL
) {

125 
	`pbuf_free
(
buf
->
p
);

127 
buf
->
p
 = buf->
ptr
 = 
NULL
;

128 
	}
}

139 
err_t


140 
	$netbuf_ref
(struct 
netbuf
 *
buf
, const void *
dataptr
, 
u16_t
 
size
)

142 
	`LWIP_ERROR
("netbuf_ref: invalid buf", (
buf
 != 
NULL
), return 
ERR_ARG
;);

143 if (
buf
->
p
 != 
NULL
) {

144 
	`pbuf_free
(
buf
->
p
);

146 
buf
->
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 0, 
PBUF_REF
);

147 if (
buf
->
p
 == 
NULL
) {

148 
buf
->
ptr
 = 
NULL
;

149 return 
ERR_MEM
;

151 
buf
->
p
->
payload
 = (void*)
dataptr
;

152 
buf
->
p
->
len
 = buf->p->
tot_len
 = 
size
;

153 
buf
->
ptr
 = buf->
p
;

154 return 
ERR_OK
;

155 
	}
}

164 
	$netbuf_chain
(struct 
netbuf
 *
head
, struct netbuf *
tail
)

166 
	`LWIP_ERROR
("netbuf_ref: invalid head", (
head
 != 
NULL
), return;);

167 
	`LWIP_ERROR
("netbuf_chain: invalid tail", (
tail
 != 
NULL
), return;);

168 
	`pbuf_chain
(
head
->
p
, 
tail
->p);

169 
head
->
ptr
 = head->
p
;

170 
	`memp_free
(
MEMP_NETBUF
, 
tail
);

171 
	}
}

182 
err_t


183 
	$netbuf_data
(struct 
netbuf
 *
buf
, void **
dataptr
, 
u16_t
 *
len
)

185 
	`LWIP_ERROR
("netbuf_data: invalid buf", (
buf
 != 
NULL
), return 
ERR_ARG
;);

186 
	`LWIP_ERROR
("netbuf_data: invalid dataptr", (
dataptr
 != 
NULL
), return 
ERR_ARG
;);

187 
	`LWIP_ERROR
("netbuf_data: invalid len", (
len
 != 
NULL
), return 
ERR_ARG
;);

189 if (
buf
->
ptr
 == 
NULL
) {

190 return 
ERR_BUF
;

192 *
dataptr
 = 
buf
->
ptr
->
payload
;

193 *
len
 = 
buf
->
ptr
->len;

194 return 
ERR_OK
;

195 
	}
}

207 
s8_t


208 
	$netbuf_next
(struct 
netbuf
 *
buf
)

210 
	`LWIP_ERROR
("netbuf_free: invalid buf", (
buf
 != 
NULL
), return -1;);

211 if (
buf
->
ptr
->
next
 == 
NULL
) {

214 
buf
->
ptr
 = buf->ptr->
next
;

215 if (
buf
->
ptr
->
next
 == 
NULL
) {

219 
	}
}

229 
	$netbuf_first
(struct 
netbuf
 *
buf
)

231 
	`LWIP_ERROR
("netbuf_free: invalid buf", (
buf
 != 
NULL
), return;);

232 
buf
->
ptr
 = buf->
p
;

233 
	}
}

	@/root/Robux/net/lwip/api/netdb.c

36 #include 
	~"lwip/netdb.h
"

38 #if 
LWIP_DNS
 && 
LWIP_SOCKET


40 #include 
	~"lwip/err.h
"

41 #include 
	~"lwip/mem.h
"

42 #include 
	~"lwip/ip_addr.h
"

43 #include 
	~"lwip/api.h
"

46 struct 
	sgethostbyname_r_helper
 {

47 struct 
ip_addr
 *
	maddrs
;

48 struct 
ip_addr
 
	maddr
;

49 char *
	maliases
;

53 #if 
LWIP_DNS_API_DECLARE_H_ERRNO


54 int 
	gh_errno
;

59 #ifndef 
LWIP_DNS_API_HOSTENT_STORAGE


60 #define 
	#LWIP_DNS_API_HOSTENT_STORAGE
 0

	)

64 #if 
LWIP_DNS_API_HOSTENT_STORAGE


65 #define 
	#HOSTENT_STORAGE


	)

67 #define 
	#HOSTENT_STORAGE
 static

	)

79 struct 
hostent
*

80 
	$lwip_gethostbyname
(const char *
name
)

82 
err_t
 
err
;

83 struct 
ip_addr
 
addr
;

86 
HOSTENT_STORAGE
 struct 
hostent
 
s_hostent
;

87 
HOSTENT_STORAGE
 char *
s_aliases
;

88 
HOSTENT_STORAGE
 struct 
ip_addr
 
s_hostent_addr
;

89 
HOSTENT_STORAGE
 struct 
ip_addr
 *
s_phostent_addr
;

92 
err
 = 
	`netconn_gethostbyname
(
name
, &
addr
);

93 if (
err
 != 
ERR_OK
) {

94 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("lwip_gethostbyname(%s) failed, err=%d\n", 
name
, 
err
));

95 
h_errno
 = 
HOST_NOT_FOUND
;

96 return 
NULL
;

100 
s_hostent_addr
 = 
addr
;

101 
s_phostent_addr
 = &
s_hostent_addr
;

102 
s_hostent
.
h_name
 = (char*)
name
;

103 
s_hostent
.
h_aliases
 = &
s_aliases
;

104 
s_hostent
.
h_addrtype
 = 
AF_INET
;

105 
s_hostent
.
h_length
 = sizeof(struct 
ip_addr
);

106 
s_hostent
.
h_addr_list
 = (char**)&
s_phostent_addr
;

108 #if 
DNS_DEBUG


110 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_name == %s\n", 
s_hostent
.
h_name
));

111 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_aliases == 0x%08lX\n",(
u32_t
)(
s_hostent
.
h_aliases
)));

112 if (
s_hostent
.
h_aliases
 != 
NULL
) {

113 
u8_t
 
idx
;

114 for ( 
idx
=0; 
s_hostent
.
h_aliases
[idx]; idx++) {

115 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_aliases[%i]-> == 0x%08lX\n", 
idx
, 
s_hostent
.
h_aliases
[idx]));

116 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_aliases[%i]-> == %s\n", 
idx
, 
s_hostent
.
h_aliases
[idx]));

119 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_addrtype == %lu\n", (
u32_t
)(
s_hostent
.
h_addrtype
)));

120 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_length == %lu\n", (
u32_t
)(
s_hostent
.
h_length
)));

121 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_addr_list == 0x%08lX\n", 
s_hostent
.
h_addr_list
));

122 if (
s_hostent
.
h_addr_list
 != 
NULL
) {

123 
u8_t
 
idx
;

124 for ( 
idx
=0; 
s_hostent
.
h_addr_list
[idx]; idx++) {

125 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_addr_list[%i] == 0x%08lX\n", 
idx
, 
s_hostent
.
h_addr_list
[idx]));

126 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("hostent.h_addr_list[%i]-> == %s\n", 
idx
, 
	`inet_ntoa
(*((struct 
in_addr
*)(
s_hostent
.
h_addr_list
[idx])))));

131 #if 
LWIP_DNS_API_HOSTENT_STORAGE


133 return 
	`sys_thread_hostent
(&
s_hostent
);

135 return &
s_hostent
;

137 
	}
}

156 
	$lwip_gethostbyname_r
(const char *
name
, struct 
hostent
 *
ret
, char *
buf
,

157 
size_t
 
buflen
, struct 
hostent
 **
result
, int *
h_errnop
)

159 
err_t
 
err
;

160 struct 
gethostbyname_r_helper
 *
h
;

161 char *
hostname
;

162 
size_t
 
namelen
;

163 int 
lh_errno
;

165 if (
h_errnop
 == 
NULL
) {

167 
h_errnop
 = &
lh_errno
;

170 if (
result
 == 
NULL
) {

172 *
h_errnop
 = 
EINVAL
;

176 *
result
 = 
NULL
;

177 if ((
name
 == 
NULL
) || (
ret
 == NULL) || (
buf
 == 0)) {

179 *
h_errnop
 = 
EINVAL
;

183 
namelen
 = 
	`strlen
(
name
);

184 if (
buflen
 < (sizeof(struct 
gethostbyname_r_helper
) + 
namelen
 + 1 + (
MEM_ALIGNMENT
 - 1))) {

186 *
h_errnop
 = 
ERANGE
;

190 
h
 = (struct 
gethostbyname_r_helper
*)
	`LWIP_MEM_ALIGN
(
buf
);

191 
hostname
 = ((char*)
h
) + sizeof(struct 
gethostbyname_r_helper
);

194 
err
 = 
	`netconn_gethostbyname
(
name
, &(
h
->
addr
));

195 if (
err
 != 
ERR_OK
) {

196 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("lwip_gethostbyname(%s) failed, err=%d\n", 
name
, 
err
));

197 *
h_errnop
 = 
ENSRNOTFOUND
;

202 
	`MEMCPY
(
hostname
, 
name
, 
namelen
);

203 
hostname
[
namelen
] = 0;

206 
h
->
addrs
 = &(h->
addr
);

207 
h
->
aliases
 = 
NULL
;

208 
ret
->
h_name
 = (char*)
hostname
;

209 
ret
->
h_aliases
 = &(
h
->
aliases
);

210 
ret
->
h_addrtype
 = 
AF_INET
;

211 
ret
->
h_length
 = sizeof(struct 
ip_addr
);

212 
ret
->
h_addr_list
 = (char**)&(
h
->
addrs
);

215 *
result
 = 
ret
;

219 
	}
}

229 
	$lwip_freeaddrinfo
(struct 
addrinfo
 *
ai
)

231 struct 
addrinfo
 *
next
;

233 while (
ai
 != 
NULL
) {

234 if (
ai
->
ai_addr
 != 
NULL
) {

235 
	`mem_free
(
ai
->
ai_addr
);

237 if (
ai
->
ai_canonname
 != 
NULL
) {

238 
	`mem_free
(
ai
->
ai_canonname
);

240 
next
 = 
ai
->
ai_next
;

241 
	`mem_free
(
ai
);

242 
ai
 = 
next
;

244 
	}
}

266 
	$lwip_getaddrinfo
(const char *
nodename
, const char *
servname
,

267 const struct 
addrinfo
 *
hints
, struct addrinfo **
res
)

269 
err_t
 
err
;

270 struct 
ip_addr
 
addr
;

271 struct 
addrinfo
 *
ai
;

272 struct 
sockaddr_in
 *
sa
 = 
NULL
;

273 int 
port_nr
 = 0;

275 if (
res
 == 
NULL
) {

276 return 
EAI_FAIL
;

278 *
res
 = 
NULL
;

279 if ((
nodename
 == 
NULL
) && (
servname
 == NULL)) {

280 return 
EAI_NONAME
;

283 if (
servname
 != 
NULL
) {

286 
port_nr
 = 
	`atoi
(
servname
);

287 if ((
port_nr
 <= 0) || (port_nr > 0xffff)) {

288 return 
EAI_SERVICE
;

292 if (
nodename
 != 
NULL
) {

294 
err
 = 
	`netconn_gethostbyname
(
nodename
, &
addr
);

295 if (
err
 != 
ERR_OK
) {

296 return 
EAI_FAIL
;

300 
addr
.addr = 
INADDR_LOOPBACK
;

303 
ai
 = 
	`mem_malloc
(sizeof(struct 
addrinfo
));

304 if (
ai
 == 
NULL
) {

305 goto 
memerr
;

307 
	`memset
(
ai
, 0, sizeof(struct 
addrinfo
));

308 
sa
 = 
	`mem_malloc
(sizeof(struct 
sockaddr_in
));

309 if (
sa
 == 
NULL
) {

310 goto 
memerr
;

312 
	`memset
(
sa
, 0, sizeof(struct 
sockaddr_in
));

314 
sa
->
sin_addr
.
s_addr
 = 
addr
.addr;

315 
sa
->
sin_family
 = 
AF_INET
;

316 
sa
->
sin_len
 = sizeof(struct 
sockaddr_in
);

317 
sa
->
sin_port
 = 
	`htons
(
port_nr
);

320 
ai
->
ai_family
 = 
AF_INET
;

321 if (
hints
 != 
NULL
) {

323 
ai
->
ai_socktype
 = 
hints
->ai_socktype;

324 
ai
->
ai_protocol
 = 
hints
->ai_protocol;

326 if (
nodename
 != 
NULL
) {

328 
size_t
 
namelen
 = 
	`strlen
(
nodename
);

329 
	`LWIP_ASSERT
("namelen is too long", (
namelen
 + 1) <= (
mem_size_t
)-1);

330 
ai
->
ai_canonname
 = 
	`mem_malloc
((
mem_size_t
)(
namelen
 + 1));

331 if (
ai
->
ai_canonname
 == 
NULL
) {

332 goto 
memerr
;

334 
	`MEMCPY
(
ai
->
ai_canonname
, 
nodename
, 
namelen
);

335 
ai
->
ai_canonname
[
namelen
] = 0;

337 
ai
->
ai_addrlen
 = sizeof(struct 
sockaddr_in
);

338 
ai
->
ai_addr
 = (struct 
sockaddr
*)
sa
;

340 *
res
 = 
ai
;

343 
memerr
:

344 if (
ai
 != 
NULL
) {

345 
	`mem_free
(
ai
);

347 if (
sa
 != 
NULL
) {

348 
	`mem_free
(
sa
);

350 return 
EAI_MEMORY
;

351 
	}
}

	@/root/Robux/net/lwip/api/netifapi.c

34 #include 
	~"lwip/opt.h
"

36 #if 
LWIP_NETIF_API


38 #include 
	~"lwip/netifapi.h
"

39 #include 
	~"lwip/tcpip.h
"

45 
	$do_netifapi_netif_add
( struct 
netifapi_msg_msg
 *
msg
)

47 if (!
	`netif_add
( 
msg
->
netif
,

48 
msg
->msg.
add
.
ipaddr
,

49 
msg
->msg.
add
.
netmask
,

50 
msg
->msg.
add
.
gw
,

51 
msg
->msg.
add
.
state
,

52 
msg
->msg.
add
.
init
,

53 
msg
->msg.
add
.
input
)) {

54 
msg
->
err
 = 
ERR_IF
;

56 
msg
->
err
 = 
ERR_OK
;

58 
	`TCPIP_NETIFAPI_ACK
(
msg
);

59 
	}
}

66 
	$do_netifapi_netif_common
( struct 
netifapi_msg_msg
 *
msg
)

68 if (
msg
->msg.
common
.
errtfunc
!=
NULL
) {

69 
msg
->
err
 =

70 
msg
->msg.
common
.
	`errtfunc
(msg->
netif
);

72 
msg
->
err
 = 
ERR_OK
;

73 
msg
->msg.
common
.
	`voidfunc
(msg->
netif
);

75 
	`TCPIP_NETIFAPI_ACK
(
msg
);

76 
	}
}

84 
err_t


85 
netifapi_netif_add
(struct 
netif
 *netif,

86 struct 
ip_addr
 *
ipaddr
,

87 struct 
ip_addr
 *
netmask
,

88 struct 
ip_addr
 *
gw
,

89 void *
state
,

90 
	$err_t
 (* 
init
)(struct 
netif
 *netif),

91 
	$err_t
 (* 
input
)(struct 
pbuf
 *
p
, struct 
netif
 *netif))

93 struct 
netifapi_msg
 
msg
;

94 
msg
.
function
 = 
do_netifapi_netif_add
;

95 
msg
.msg.
netif
 = netif;

96 
msg
.msg.msg.
add
.
ipaddr
 = ipaddr;

97 
msg
.msg.msg.
add
.
netmask
 = netmask;

98 
msg
.msg.msg.
add
.
gw
 = gw;

99 
msg
.msg.msg.
add
.
state
 = state;

100 
msg
.msg.msg.
add
.
init
 = init;

101 
msg
.msg.msg.
add
.
input
 = input;

102 
	`TCPIP_NETIFAPI
(&
msg
);

103 return 
msg
.msg.
err
;

104 
	}
}

112 
err_t


113 
netifapi_netif_common
( struct 
netif
 *netif,

114 void (* 
voidfunc
)(struct 
netif
 *netif),

115 
	$err_t
 (* 
errtfunc
)(struct 
netif
 *netif) )

117 struct 
netifapi_msg
 
msg
;

118 
msg
.
function
 = 
do_netifapi_netif_common
;

119 
msg
.msg.
netif
 = netif;

120 
msg
.msg.msg.
common
.
voidfunc
 = voidfunc;

121 
msg
.msg.msg.
common
.
errtfunc
 = errtfunc;

122 
	`TCPIP_NETIFAPI
(&
msg
);

123 return 
msg
.msg.
err
;

124 
	}
}

	@/root/Robux/net/lwip/api/sockets.c

41 #include 
	~"lwip/opt.h
"

43 #if 
LWIP_SOCKET


45 #include 
	~"lwip/sockets.h
"

46 #include 
	~"lwip/api.h
"

47 #include 
	~"lwip/sys.h
"

48 #include 
	~"lwip/igmp.h
"

49 #include 
	~"lwip/inet.h
"

50 #include 
	~"lwip/tcp.h
"

51 #include 
	~"lwip/raw.h
"

52 #include 
	~"lwip/udp.h
"

53 #include 
	~"lwip/tcpip.h
"

55 #include 
	~<string.h
>

57 #define 
	#NUM_SOCKETS
 
MEMP_NUM_NETCONN


	)

60 struct 
	slwip_socket
 {

62 struct 
netconn
 *
	mconn
;

64 struct 
netbuf
 *
	mlastdata
;

66 
u16_t
 
	mlastoffset
;

69 
u16_t
 
	mrcvevent
;

72 
u16_t
 
	msendevent
;

74 
u16_t
 
	mflags
;

76 int 
	merr
;

80 struct 
	slwip_select_cb
 {

82 struct 
lwip_select_cb
 *
	mnext
;

84 
fd_set
 *
	mreadset
;

86 
fd_set
 *
	mwriteset
;

88 
fd_set
 *
	mexceptset
;

90 int 
	msem_signalled
;

92 
sys_sem_t
 
	msem
;

97 struct 
	slwip_setgetsockopt_data
 {

99 struct 
lwip_socket
 *
	msock
;

101 int 
	ms
;

103 int 
	mlevel
;

105 int 
	moptname
;

108 void *
	moptval
;

110 
socklen_t
 *
	moptlen
;

112 
err_t
 
	merr
;

116 static struct 
lwip_socket
 
	gsockets
[
NUM_SOCKETS
];

118 static struct 
lwip_select_cb
 *
	gselect_cb_list
;

121 static 
sys_sem_t
 
	gsocksem
;

123 static 
sys_sem_t
 
	gselectsem
;

127 static const int 
	gerr_to_errno_table
[] = {

129 
ENOMEM
,

130 
ENOBUFS
,

131 
ETIMEDOUT
,

132 
EHOSTUNREACH
,

133 
ECONNABORTED
,

134 
ECONNRESET
,

135 
ESHUTDOWN
,

136 
ENOTCONN
,

137 
EINVAL
,

138 
EIO
,

139 
EADDRINUSE
,

142 
EINPROGRESS


145 #define 
	#ERR_TO_ERRNO_TABLE_SIZE
 \

146 (sizeof(
err_to_errno_table
)/sizeof(err_to_errno_table[0]))

	)

148 #define 
	#err_to_errno
(
err
) \

149 ((unsigned)(-(
err
)) < 
ERR_TO_ERRNO_TABLE_SIZE
 ? \

150 
err_to_errno_table
[-(
err
)] : 
EIO
)

	)

152 #ifdef 
ERRNO


153 #define 
	#set_errno
(
err
) 
errno
 = (err)

	)

155 #define 
	#set_errno
(
err
)

	)

158 #define 
	#sock_set_errno
(
sk
, 
e
) do { \

159 
sk
->
err
 = (
e
); \

160 
	`set_errno
(
sk
->
err
); \

161 } while (0)

	)

164 static void 
event_callback
(struct 
netconn
 *
conn
, enum 
netconn_evt
 
evt
, 
u16_t
 
len
);

165 static void 
lwip_getsockopt_internal
(void *
arg
);

166 static void 
lwip_setsockopt_internal
(void *
arg
);

173 
	$lwip_socket_init
(void)

175 
socksem
 = 
	`sys_sem_new
(1);

176 
selectsem
 = 
	`sys_sem_new
(1);

177 
	}
}

185 static struct 
lwip_socket
 *

186 
	$get_socket
(int 
s
)

188 struct 
lwip_socket
 *
sock
;

190 if ((
s
 < 0) || (s >= 
NUM_SOCKETS
)) {

191 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("get_socket(%d): invalid\n", 
s
));

192 
	`set_errno
(
EBADF
);

193 return 
NULL
;

196 
sock
 = &
sockets
[
s
];

198 if (!
sock
->
conn
) {

199 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("get_socket(%d): not active\n", 
s
));

200 
	`set_errno
(
EBADF
);

201 return 
NULL
;

204 return 
sock
;

205 
	}
}

214 
	$alloc_socket
(struct 
netconn
 *
newconn
)

216 int 
i
;

219 
	`sys_sem_wait
(
socksem
);

222 for (
i
 = 0; i < 
NUM_SOCKETS
; ++i) {

223 if (!
sockets
[
i
].
conn
) {

224 
sockets
[
i
].
conn
 = 
newconn
;

225 
sockets
[
i
].
lastdata
 = 
NULL
;

226 
sockets
[
i
].
lastoffset
 = 0;

227 
sockets
[
i
].
rcvevent
 = 0;

228 
sockets
[
i
].
sendevent
 = 1;

229 
sockets
[
i
].
flags
 = 0;

230 
sockets
[
i
].
err
 = 0;

231 
	`sys_sem_signal
(
socksem
);

232 return 
i
;

235 
	`sys_sem_signal
(
socksem
);

237 
	}
}

246 
	$lwip_accept
(int 
s
, struct 
sockaddr
 *
addr
, 
socklen_t
 *
addrlen
)

248 struct 
lwip_socket
 *
sock
, *
nsock
;

249 struct 
netconn
 *
newconn
;

250 struct 
ip_addr
 
naddr
;

251 
u16_t
 
port
;

252 int 
newsock
;

253 struct 
sockaddr_in
 
sin
;

254 
err_t
 
err
;

256 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_accept(%d)...\n", 
s
));

257 
sock
 = 
	`get_socket
(
s
);

258 if (!
sock
)

261 
newconn
 = 
	`netconn_accept
(
sock
->
conn
);

262 if (!
newconn
) {

263 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_accept(%d) failed, err=%d\n", 
s
, 
sock
->
conn
->
err
));

264 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(sock->
conn
->
err
));

269 
err
 = 
	`netconn_peer
(
newconn
, &
naddr
, &
port
);

270 if (
err
 != 
ERR_OK
) {

271 
	`netconn_delete
(
newconn
);

272 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
err
));

276 
	`memset
(&
sin
, 0, sizeof(sin));

277 
sin
.
sin_len
 = sizeof(sin);

278 
sin
.
sin_family
 = 
AF_INET
;

279 
sin
.
sin_port
 = 
	`htons
(
port
);

280 
sin
.
sin_addr
.
s_addr
 = 
naddr
.
addr
;

282 if (*
addrlen
 > sizeof(
sin
))

283 *
addrlen
 = sizeof(
sin
);

285 
	`SMEMCPY
(
addr
, &
sin
, *
addrlen
);

287 
newsock
 = 
	`alloc_socket
(
newconn
);

288 if (
newsock
 == -1) {

289 
	`netconn_delete
(
newconn
);

290 
	`sock_set_errno
(
sock
, 
ENFILE
);

293 
	`LWIP_ASSERT
("invalid socket index", (
newsock
 >= 0) && (newsock < 
NUM_SOCKETS
));

294 
newconn
->
callback
 = 
event_callback
;

295 
nsock
 = &
sockets
[
newsock
];

296 
	`LWIP_ASSERT
("invalid socket pointer", 
nsock
 != 
NULL
);

298 
	`sys_sem_wait
(
socksem
);

304 
nsock
->
rcvevent
 += -1 - 
newconn
->
socket
;

305 
newconn
->
socket
 = 
newsock
;

306 
	`sys_sem_signal
(
socksem
);

308 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_accept(%d) returning new sock=%d addr=", 
s
, 
newsock
));

310 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, (" port=%u\n", 
port
));

312 
	`sock_set_errno
(
sock
, 0);

313 return 
newsock
;

314 
	}
}

317 
	$lwip_bind
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
)

319 struct 
lwip_socket
 *
sock
;

320 struct 
ip_addr
 
local_addr
;

321 
u16_t
 
local_port
;

322 
err_t
 
err
;

324 
sock
 = 
	`get_socket
(
s
);

325 if (!
sock
)

328 
	`LWIP_ERROR
("lwip_bind: invalid address", ((
namelen
 == sizeof(struct 
sockaddr_in
)) &&

329 ((((struct 
sockaddr_in
 *)
name
)->
sin_family
) == 
AF_INET
)),

330 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
ERR_ARG
)); return -1;);

332 
local_addr
.
addr
 = ((struct 
sockaddr_in
 *)
name
)->
sin_addr
.
s_addr
;

333 
local_port
 = ((struct 
sockaddr_in
 *)
name
)->
sin_port
;

335 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_bind(%d, addr=", 
s
));

337 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, (" port=%u)\n", 
	`ntohs
(
local_port
)));

339 
err
 = 
	`netconn_bind
(
sock
->
conn
, &
local_addr
, 
	`ntohs
(
local_port
));

341 if (
err
 != 
ERR_OK
) {

342 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_bind(%d) failed, err=%d\n", 
s
, 
err
));

343 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
err
));

347 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_bind(%d) succeeded\n", 
s
));

348 
	`sock_set_errno
(
sock
, 0);

350 
	}
}

353 
	$lwip_close
(int 
s
)

355 struct 
lwip_socket
 *
sock
;

357 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_close(%d)\n", 
s
));

359 
sock
 = 
	`get_socket
(
s
);

360 if (!
sock
) {

364 
	`netconn_delete
(
sock
->
conn
);

366 
	`sys_sem_wait
(
socksem
);

367 if (
sock
->
lastdata
) {

368 
	`netbuf_delete
(
sock
->
lastdata
);

370 
sock
->
lastdata
 = 
NULL
;

371 
sock
->
lastoffset
 = 0;

372 
sock
->
conn
 = 
NULL
;

373 
	`sock_set_errno
(
sock
, 0);

374 
	`sys_sem_signal
(
socksem
);

376 
	}
}

379 
	$lwip_connect
(int 
s
, const struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
)

381 struct 
lwip_socket
 *
sock
;

382 
err_t
 
err
;

384 
sock
 = 
	`get_socket
(
s
);

385 if (!
sock
)

388 
	`LWIP_ERROR
("lwip_connect: invalid address", ((
namelen
 == sizeof(struct 
sockaddr_in
)) &&

389 ((((struct 
sockaddr_in
 *)
name
)->
sin_family
) == 
AF_INET
)),

390 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
ERR_ARG
)); return -1;);

392 if (((struct 
sockaddr_in
 *)
name
)->
sin_family
 == 
AF_UNSPEC
) {

393 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_connect(%d, AF_UNSPEC)\n", 
s
));

394 
err
 = 
	`netconn_disconnect
(
sock
->
conn
);

396 struct 
ip_addr
 
remote_addr
;

397 
u16_t
 
remote_port
;

399 
remote_addr
.
addr
 = ((struct 
sockaddr_in
 *)
name
)->
sin_addr
.
s_addr
;

400 
remote_port
 = ((struct 
sockaddr_in
 *)
name
)->
sin_port
;

402 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_connect(%d, addr=", 
s
));

404 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, (" port=%u)\n", 
	`ntohs
(
remote_port
)));

406 
err
 = 
	`netconn_connect
(
sock
->
conn
, &
remote_addr
, 
	`ntohs
(
remote_port
));

409 if (
err
 != 
ERR_OK
) {

410 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_connect(%d) failed, err=%d\n", 
s
, 
err
));

411 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
err
));

415 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_connect(%d) succeeded\n", 
s
));

416 
	`sock_set_errno
(
sock
, 0);

418 
	}
}

429 
	$lwip_listen
(int 
s
, int 
backlog
)

431 struct 
lwip_socket
 *
sock
;

432 
err_t
 
err
;

434 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_listen(%d, backlog=%d)\n", 
s
, 
backlog
));

436 
sock
 = 
	`get_socket
(
s
);

437 if (!
sock
)

441 if (
backlog
 < 0) {

442 
backlog
 = 0;

444 if (
backlog
 > 0xff) {

445 
backlog
 = 0xff;

448 
err
 = 
	`netconn_listen_with_backlog
(
sock
->
conn
, 
backlog
);

450 if (
err
 != 
ERR_OK
) {

451 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_listen(%d) failed, err=%d\n", 
s
, 
err
));

452 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
err
));

456 
	`sock_set_errno
(
sock
, 0);

458 
	}
}

461 
	$lwip_recvfrom
(int 
s
, void *
mem
, int 
len
, unsigned int 
flags
,

462 struct 
sockaddr
 *
from
, 
socklen_t
 *
fromlen
)

464 struct 
lwip_socket
 *
sock
;

465 struct 
netbuf
 *
buf
;

466 
u16_t
 
buflen
, 
copylen
, 
off
 = 0;

467 struct 
ip_addr
 *
addr
;

468 
u16_t
 
port
;

469 
u8_t
 
done
 = 0;

471 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", 
s
, 
mem
, 
len
, 
flags
));

472 
sock
 = 
	`get_socket
(
s
);

473 if (!
sock
)

477 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)
sock
->
lastdata
));

479 if (
sock
->
lastdata
) {

480 
buf
 = 
sock
->
lastdata
;

483 if (((
flags
 & 
MSG_DONTWAIT
) || (
sock
->flags & 
O_NONBLOCK
)) && !sock->
rcvevent
) {

484 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", 
s
));

485 
	`sock_set_errno
(
sock
, 
EWOULDBLOCK
);

491 
sock
->
lastdata
 = 
buf
 = 
	`netconn_recv
(sock->
conn
);

492 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)
buf
));

494 if (!
buf
) {

496 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom(%d): buf == NULL!\n", 
s
));

497 
	`sock_set_errno
(
sock
, (((sock->
conn
->
pcb
.
ip
!=
NULL
) && (sock->conn->
err
==
ERR_OK
))?
ETIMEDOUT
:
	`err_to_errno
(sock->conn->err)));

502 
buflen
 = 
	`netbuf_len
(
buf
);

503 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", 
buflen
, 
len
, 
off
, 
sock
->
lastoffset
));

505 
buflen
 -= 
sock
->
lastoffset
;

507 if (
len
 > 
buflen
) {

508 
copylen
 = 
buflen
;

510 
copylen
 = 
len
;

515 
	`netbuf_copy_partial
(
buf
, (
u8_t
*)
mem
 + 
off
, 
copylen
, 
sock
->
lastoffset
);

517 
off
 += 
copylen
;

519 if (
	`netconn_type
(
sock
->
conn
) == 
NETCONN_TCP
) {

520 
len
 -= 
copylen
;

521 if ( (
len
 <= 0) || (
buf
->
p
->
flags
 & 
PBUF_FLAG_PUSH
) || !
sock
->
rcvevent
) {

522 
done
 = 1;

525 
done
 = 1;

529 if ((
flags
 & 
MSG_PEEK
)==0) {

533 if ((
sock
->
conn
->
type
 == 
NETCONN_TCP
) && (
buflen
 - 
copylen
 > 0)) {

534 
sock
->
lastdata
 = 
buf
;

535 
sock
->
lastoffset
 += 
copylen
;

536 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)
buf
));

538 
sock
->
lastdata
 = 
NULL
;

539 
sock
->
lastoffset
 = 0;

540 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)
buf
));

541 
	`netbuf_delete
(
buf
);

544 
done
 = 1;

546 } while (!
done
);

549 if (
from
 && 
fromlen
) {

550 struct 
sockaddr_in
 
sin
;

552 if (
	`netconn_type
(
sock
->
conn
) == 
NETCONN_TCP
) {

553 
addr
 = (struct 
ip_addr
*)&(
sin
.
sin_addr
.
s_addr
);

554 
	`netconn_getaddr
(
sock
->
conn
, 
addr
, &
port
, 0);

556 
addr
 = 
	`netbuf_fromaddr
(
buf
);

557 
port
 = 
	`netbuf_fromport
(
buf
);

560 
	`memset
(&
sin
, 0, sizeof(sin));

561 
sin
.
sin_len
 = sizeof(sin);

562 
sin
.
sin_family
 = 
AF_INET
;

563 
sin
.
sin_port
 = 
	`htons
(
port
);

564 
sin
.
sin_addr
.
s_addr
 = 
addr
->addr;

566 if (*
fromlen
 > sizeof(
sin
))

567 *
fromlen
 = sizeof(
sin
);

569 
	`SMEMCPY
(
from
, &
sin
, *
fromlen
);

571 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom(%d): addr=", 
s
));

573 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, (" port=%u len=%u\n", 
port
, 
off
));

575 #if 
SOCKETS_DEBUG


576 struct 
sockaddr_in
 
sin
;

578 if (
	`netconn_type
(
sock
->
conn
) == 
NETCONN_TCP
) {

579 
addr
 = (struct 
ip_addr
*)&(
sin
.
sin_addr
.
s_addr
);

580 
	`netconn_getaddr
(
sock
->
conn
, 
addr
, &
port
, 0);

582 
addr
 = 
	`netbuf_fromaddr
(
buf
);

583 
port
 = 
	`netbuf_fromport
(
buf
);

586 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_recvfrom(%d): addr=", 
s
));

588 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, (" port=%u len=%u\n", 
port
, 
off
));

592 
	`sock_set_errno
(
sock
, 0);

593 return 
off
;

594 
	}
}

597 
	$lwip_read
(int 
s
, void *
mem
, int 
len
)

599 return 
	`lwip_recvfrom
(
s
, 
mem
, 
len
, 0, 
NULL
, NULL);

600 
	}
}

603 
	$lwip_recv
(int 
s
, void *
mem
, int 
len
, unsigned int 
flags
)

605 return 
	`lwip_recvfrom
(
s
, 
mem
, 
len
, 
flags
, 
NULL
, NULL);

606 
	}
}

609 
	$lwip_send
(int 
s
, const void *
data
, int 
size
, unsigned int 
flags
)

611 struct 
lwip_socket
 *
sock
;

612 
err_t
 
err
;

614 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",

615 
s
, 
data
, 
size
, 
flags
));

617 
sock
 = 
	`get_socket
(
s
);

618 if (!
sock
)

621 if (
sock
->
conn
->
type
!=
NETCONN_TCP
) {

622 #if (
LWIP_UDP
 || 
LWIP_RAW
)

623 return 
	`lwip_sendto
(
s
, 
data
, 
size
, 
flags
, 
NULL
, 0);

625 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
ERR_ARG
));

630 
err
 = 
	`netconn_write
(
sock
->
conn
, 
data
, 
size
, 
NETCONN_COPY
 | ((
flags
 & 
MSG_MORE
)?
NETCONN_MORE
:0));

632 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_send(%d) err=%d size=%d\n", 
s
, 
err
, 
size
));

633 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
err
));

634 return (
err
==
ERR_OK
?
size
:-1);

635 
	}
}

638 
	$lwip_sendto
(int 
s
, const void *
data
, int 
size
, unsigned int 
flags
,

639 struct 
sockaddr
 *
to
, 
socklen_t
 
tolen
)

641 struct 
lwip_socket
 *
sock
;

642 struct 
ip_addr
 
remote_addr
;

643 int 
err
;

644 #if !
LWIP_TCPIP_CORE_LOCKING


645 struct 
netbuf
 
buf
;

646 
u16_t
 
remote_port
;

649 
sock
 = 
	`get_socket
(
s
);

650 if (!
sock
)

653 if (
sock
->
conn
->
type
==
NETCONN_TCP
) {

654 #if 
LWIP_TCP


655 return 
	`lwip_send
(
s
, 
data
, 
size
, 
flags
);

657 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
ERR_ARG
));

662 
	`LWIP_ASSERT
("lwip_sendto: size must fit in u16_t",

663 ((
size
 >= 0) && (size <= 0xffff)));

664 
	`LWIP_ERROR
("lwip_sendto: invalid address", (((
to
 == 
NULL
) && (
tolen
 == 0)) ||

665 ((
tolen
 == sizeof(struct 
sockaddr_in
)) &&

666 ((((struct 
sockaddr_in
 *)
to
)->
sin_family
) == 
AF_INET
))),

667 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
ERR_ARG
)); return -1;);

669 #if 
LWIP_TCPIP_CORE_LOCKING


671 { struct 
pbuf
* 
p
;

673 
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 0, 
PBUF_REF
);

674 if (
p
 == 
NULL
) {

675 
err
 = 
ERR_MEM
;

677 
p
->
payload
 = (void*)
data
;

678 
p
->
len
 = p->
tot_len
 = 
size
;

680 
remote_addr
.
addr
 = ((struct 
sockaddr_in
 *)
to
)->
sin_addr
.
s_addr
;

682 
	`LOCK_TCPIP_CORE
();

683 if (
sock
->
conn
->
type
==
NETCONN_RAW
) {

684 
err
 = 
sock
->
conn
->err = 
	`raw_sendto
(sock->conn->
pcb
.
raw
, 
p
, &
remote_addr
);

686 
err
 = 
sock
->
conn
->err = 
	`udp_sendto
(sock->conn->
pcb
.
udp
, 
p
, &
remote_addr
, 
	`ntohs
(((struct 
sockaddr_in
 *)
to
)->
sin_port
));

688 
	`UNLOCK_TCPIP_CORE
();

690 
	`pbuf_free
(
p
);

695 
buf
.
p
 = buf.
ptr
 = 
NULL
;

696 if (
to
) {

697 
remote_addr
.
addr
 = ((struct 
sockaddr_in
 *)
to
)->
sin_addr
.
s_addr
;

698 
remote_port
 = 
	`ntohs
(((struct 
sockaddr_in
 *)
to
)->
sin_port
);

699 
buf
.
addr
 = &
remote_addr
;

700 
buf
.
port
 = 
remote_port
;

702 
remote_addr
.
addr
 = 0;

703 
remote_port
 = 0;

704 
buf
.
addr
 = 
NULL
;

705 
buf
.
port
 = 0;

708 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_sendto(%d, data=%p, size=%d, flags=0x%x to=",

709 
s
, 
data
, 
size
, 
flags
));

711 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, (" port=%u\n", 
remote_port
));

714 if ((
err
 = 
	`netbuf_ref
(&
buf
, 
data
, 
size
)) == 
ERR_OK
) {

716 
err
 = 
	`netconn_send
(
sock
->
conn
, &
buf
);

720 if (
buf
.
p
 != 
NULL
) {

721 
	`pbuf_free
(
buf
.
p
);

724 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(
err
));

725 return (
err
==
ERR_OK
?
size
:-1);

726 
	}
}

729 
	$lwip_socket
(int 
domain
, int 
type
, int 
protocol
)

731 struct 
netconn
 *
conn
;

732 int 
i
;

734 
	`LWIP_UNUSED_ARG
(
domain
);

737 switch (
type
) {

738 case 
SOCK_RAW
:

739 
conn
 = 
	`netconn_new_with_proto_and_callback
(
NETCONN_RAW
, (
u8_t
)
protocol
, 
event_callback
);

740 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_socket(%s, SOCK_RAW, %d) = ",

741 
domain
 == 
PF_INET
 ? "PF_INET" : "UNKNOWN", 
protocol
));

743 case 
SOCK_DGRAM
:

744 
conn
 = 
	`netconn_new_with_callback
( (
protocol
 == 
IPPROTO_UDPLITE
) ?

745 
NETCONN_UDPLITE
 : 
NETCONN_UDP
, 
event_callback
);

746 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",

747 
domain
 == 
PF_INET
 ? "PF_INET" : "UNKNOWN", 
protocol
));

749 case 
SOCK_STREAM
:

750 
conn
 = 
	`netconn_new_with_callback
(
NETCONN_TCP
, 
event_callback
);

751 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_socket(%s, SOCK_STREAM, %d) = ",

752 
domain
 == 
PF_INET
 ? "PF_INET" : "UNKNOWN", 
protocol
));

755 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",

756 
domain
, 
type
, 
protocol
));

757 
	`set_errno
(
EINVAL
);

761 if (!
conn
) {

762 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("-1 / ENOBUFS (could not create netconn)\n"));

763 
	`set_errno
(
ENOBUFS
);

767 
i
 = 
	`alloc_socket
(
conn
);

769 if (
i
 == -1) {

770 
	`netconn_delete
(
conn
);

771 
	`set_errno
(
ENFILE
);

774 
conn
->
socket
 = 
i
;

775 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("%d\n", 
i
));

776 
	`set_errno
(0);

777 return 
i
;

778 
	}
}

781 
	$lwip_write
(int 
s
, const void *
data
, int 
size
)

783 return 
	`lwip_send
(
s
, 
data
, 
size
, 0);

784 
	}
}

802 
	$lwip_selscan
(int 
maxfdp1
, 
fd_set
 *
readset
, fd_set *
writeset
, fd_set *
exceptset
)

804 int 
i
, 
nready
 = 0;

805 
fd_set
 
lreadset
, 
lwriteset
, 
lexceptset
;

806 struct 
lwip_socket
 *
p_sock
;

808 
	`FD_ZERO
(&
lreadset
);

809 
	`FD_ZERO
(&
lwriteset
);

810 
	`FD_ZERO
(&
lexceptset
);

814 for(
i
 = 0; i < 
maxfdp1
; i++) {

815 if (
	`FD_ISSET
(
i
, 
readset
)) {

817 
p_sock
 = 
	`get_socket
(
i
);

818 if (
p_sock
 && (p_sock->
lastdata
 || p_sock->
rcvevent
)) {

819 
	`FD_SET
(
i
, &
lreadset
);

820 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_selscan: fd=%d ready for reading\n", 
i
));

821 
nready
++;

824 if (
	`FD_ISSET
(
i
, 
writeset
)) {

826 
p_sock
 = 
	`get_socket
(
i
);

827 if (
p_sock
 && p_sock->
sendevent
) {

828 
	`FD_SET
(
i
, &
lwriteset
);

829 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_selscan: fd=%d ready for writing\n", 
i
));

830 
nready
++;

834 *
readset
 = 
lreadset
;

835 *
writeset
 = 
lwriteset
;

836 
	`FD_ZERO
(
exceptset
);

838 return 
nready
;

839 
	}
}

846 
	$lwip_select
(int 
maxfdp1
, 
fd_set
 *
readset
, fd_set *
writeset
, fd_set *
exceptset
,

847 struct 
timeval
 *
timeout
)

849 int 
i
;

850 int 
nready
;

851 
fd_set
 
lreadset
, 
lwriteset
, 
lexceptset
;

852 
u32_t
 
msectimeout
;

853 struct 
lwip_select_cb
 
select_cb
;

854 struct 
lwip_select_cb
 *
p_selcb
;

856 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",

857 
maxfdp1
, (void *)
readset
, (void *) 
writeset
, (void *) 
exceptset
,

858 
timeout
 ? timeout->
tv_sec
 : -1L, timeout ? timeout->
tv_usec
 : -1L));

860 
select_cb
.
next
 = 0;

861 
select_cb
.
readset
 = readset;

862 
select_cb
.
writeset
 = writeset;

863 
select_cb
.
exceptset
 = exceptset;

864 
select_cb
.
sem_signalled
 = 0;

867 
	`sys_sem_wait
(
selectsem
);

869 if (
readset
)

870 
lreadset
 = *
readset
;

872 
	`FD_ZERO
(&
lreadset
);

873 if (
writeset
)

874 
lwriteset
 = *
writeset
;

876 
	`FD_ZERO
(&
lwriteset
);

877 if (
exceptset
)

878 
lexceptset
 = *
exceptset
;

880 
	`FD_ZERO
(&
lexceptset
);

884 
nready
 = 
	`lwip_selscan
(
maxfdp1
, &
lreadset
, &
lwriteset
, &
lexceptset
);

887 if (!
nready
) {

888 if (
timeout
 && timeout->
tv_sec
 == 0 && timeout->
tv_usec
 == 0) {

889 
	`sys_sem_signal
(
selectsem
);

890 if (
readset
)

891 
	`FD_ZERO
(
readset
);

892 if (
writeset
)

893 
	`FD_ZERO
(
writeset
);

894 if (
exceptset
)

895 
	`FD_ZERO
(
exceptset
);

897 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_select: no timeout, returning 0\n"));

898 
	`set_errno
(0);

908 
select_cb
.
sem
 = 
	`sys_sem_new
(0);

911 
select_cb
.
next
 = 
select_cb_list
;

912 
select_cb_list
 = &
select_cb
;

915 
	`sys_sem_signal
(
selectsem
);

918 if (
timeout
 == 0)

920 
msectimeout
 = 0;

922 
msectimeout
 = ((
timeout
->
tv_sec
 * 1000) + ((timeout->
tv_usec
 + 500)/1000));

923 if(
msectimeout
 == 0)

924 
msectimeout
 = 1;

927 
i
 = 
	`sys_sem_wait_timeout
(
select_cb
.
sem
, 
msectimeout
);

930 
	`sys_sem_wait
(
selectsem
);

931 if (
select_cb_list
 == &
select_cb
)

932 
select_cb_list
 = 
select_cb
.
next
;

934 for (
p_selcb
 = 
select_cb_list
; p_selcb; p_selcb = p_selcb->
next
) {

935 if (
p_selcb
->
next
 == &
select_cb
) {

936 
p_selcb
->
next
 = 
select_cb
.next;

941 
	`sys_sem_signal
(
selectsem
);

943 
	`sys_sem_free
(
select_cb
.
sem
);

944 if (
i
 == 0) {

946 if (
readset
)

947 
	`FD_ZERO
(
readset
);

948 if (
writeset
)

949 
	`FD_ZERO
(
writeset
);

950 if (
exceptset
)

951 
	`FD_ZERO
(
exceptset
);

953 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_select: timeout expired\n"));

954 
	`set_errno
(0);

959 if (
readset
)

960 
lreadset
 = *
readset
;

962 
	`FD_ZERO
(&
lreadset
);

963 if (
writeset
)

964 
lwriteset
 = *
writeset
;

966 
	`FD_ZERO
(&
lwriteset
);

967 if (
exceptset
)

968 
lexceptset
 = *
exceptset
;

970 
	`FD_ZERO
(&
lexceptset
);

973 
nready
 = 
	`lwip_selscan
(
maxfdp1
, &
lreadset
, &
lwriteset
, &
lexceptset
);

975 
	`sys_sem_signal
(
selectsem
);

977 if (
readset
)

978 *
readset
 = 
lreadset
;

979 if (
writeset
)

980 *
writeset
 = 
lwriteset
;

981 if (
exceptset
)

982 *
exceptset
 = 
lexceptset
;

984 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_select: nready=%d\n", 
nready
));

985 
	`set_errno
(0);

987 return 
nready
;

988 
	}
}

995 
	$event_callback
(struct 
netconn
 *
conn
, enum 
netconn_evt
 
evt
, 
u16_t
 
len
)

997 int 
s
;

998 struct 
lwip_socket
 *
sock
;

999 struct 
lwip_select_cb
 *
scb
;

1001 
	`LWIP_UNUSED_ARG
(
len
);

1004 if (
conn
) {

1005 
s
 = 
conn
->
socket
;

1006 if (
s
 < 0) {

1012 
	`sys_sem_wait
(
socksem
);

1013 if (
conn
->
socket
 < 0) {

1014 if (
evt
 == 
NETCONN_EVT_RCVPLUS
) {

1015 
conn
->
socket
--;

1017 
	`sys_sem_signal
(
socksem
);

1020 
	`sys_sem_signal
(
socksem
);

1023 
sock
 = 
	`get_socket
(
s
);

1024 if (!
sock
) {

1031 
	`sys_sem_wait
(
selectsem
);

1033 switch (
evt
) {

1034 case 
NETCONN_EVT_RCVPLUS
:

1035 
sock
->
rcvevent
++;

1037 case 
NETCONN_EVT_RCVMINUS
:

1038 
sock
->
rcvevent
--;

1040 case 
NETCONN_EVT_SENDPLUS
:

1041 
sock
->
sendevent
 = 1;

1043 case 
NETCONN_EVT_SENDMINUS
:

1044 
sock
->
sendevent
 = 0;

1047 
	`LWIP_ASSERT
("unknown event", 0);

1050 
	`sys_sem_signal
(
selectsem
);

1060 
	`sys_sem_wait
(
selectsem
);

1061 for (
scb
 = 
select_cb_list
; scb; scb = scb->
next
) {

1062 if (
scb
->
sem_signalled
 == 0) {

1064 if (
scb
->
readset
 && 
	`FD_ISSET
(
s
, scb->readset))

1065 if (
sock
->
rcvevent
)

1067 if (
scb
->
writeset
 && 
	`FD_ISSET
(
s
, scb->writeset))

1068 if (
sock
->
sendevent
)

1072 if (
scb
) {

1073 
scb
->
sem_signalled
 = 1;

1074 
	`sys_sem_signal
(
selectsem
);

1075 
	`sys_sem_signal
(
scb
->
sem
);

1077 
	`sys_sem_signal
(
selectsem
);

1081 
	}
}

1088 
	$lwip_shutdown
(int 
s
, int 
how
)

1090 
	`LWIP_UNUSED_ARG
(
how
);

1091 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_shutdown(%d, how=%d)\n", 
s
, 
how
));

1092 return 
	`lwip_close
(
s
);

1093 
	}
}

1096 
	$lwip_getaddrname
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 *
namelen
, 
u8_t
 
local
)

1098 struct 
lwip_socket
 *
sock
;

1099 struct 
sockaddr_in
 
sin
;

1100 struct 
ip_addr
 
naddr
;

1102 
sock
 = 
	`get_socket
(
s
);

1103 if (!
sock
)

1106 
	`memset
(&
sin
, 0, sizeof(sin));

1107 
sin
.
sin_len
 = sizeof(sin);

1108 
sin
.
sin_family
 = 
AF_INET
;

1111 
	`netconn_getaddr
(
sock
->
conn
, &
naddr
, &
sin
.
sin_port
, 
local
);

1113 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getaddrname(%d, addr=", 
s
));

1115 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, (" port=%d)\n", 
sin
.
sin_port
));

1117 
sin
.
sin_port
 = 
	`htons
(sin.sin_port);

1118 
sin
.
sin_addr
.
s_addr
 = 
naddr
.
addr
;

1120 if (*
namelen
 > sizeof(
sin
))

1121 *
namelen
 = sizeof(
sin
);

1123 
	`SMEMCPY
(
name
, &
sin
, *
namelen
);

1124 
	`sock_set_errno
(
sock
, 0);

1126 
	}
}

1129 
	$lwip_getpeername
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 *
namelen
)

1131 return 
	`lwip_getaddrname
(
s
, 
name
, 
namelen
, 0);

1132 
	}
}

1135 
	$lwip_getsockname
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 *
namelen
)

1137 return 
	`lwip_getaddrname
(
s
, 
name
, 
namelen
, 1);

1138 
	}
}

1141 
	$lwip_getsockopt
(int 
s
, int 
level
, int 
optname
, void *
optval
, 
socklen_t
 *
optlen
)

1143 
err_t
 
err
 = 
ERR_OK
;

1144 struct 
lwip_socket
 *
sock
 = 
	`get_socket
(
s
);

1145 struct 
lwip_setgetsockopt_data
 
data
;

1147 if (!
sock
)

1150 if ((
NULL
 == 
optval
) || (NULL == 
optlen
)) {

1151 
	`sock_set_errno
(
sock
, 
EFAULT
);

1156 switch (
level
) {

1159 case 
SOL_SOCKET
:

1160 switch (
optname
) {

1162 case 
SO_ACCEPTCONN
:

1163 case 
SO_BROADCAST
:

1166 case 
SO_ERROR
:

1167 case 
SO_KEEPALIVE
:

1170 #if 
LWIP_SO_RCVTIMEO


1171 case 
SO_RCVTIMEO
:

1173 #if 
LWIP_SO_RCVBUF


1174 case 
SO_RCVBUF
:

1180 #if 
SO_REUSE


1181 case 
SO_REUSEADDR
:

1182 case 
SO_REUSEPORT
:

1184 case 
SO_TYPE
:

1186 if (*
optlen
 < sizeof(int)) {

1187 
err
 = 
EINVAL
;

1191 case 
SO_NO_CHECK
:

1192 if (*
optlen
 < sizeof(int)) {

1193 
err
 = 
EINVAL
;

1195 #if 
LWIP_UDP


1196 if ((
sock
->
conn
->
type
 != 
NETCONN_UDP
) ||

1197 ((
	`udp_flags
(
sock
->
conn
->
pcb
.
udp
) & 
UDP_FLAGS_UDPLITE
) != 0)) {

1199 
err
 = 
EAFNOSUPPORT
;

1205 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",

1206 
s
, 
optname
));

1207 
err
 = 
ENOPROTOOPT
;

1212 case 
IPPROTO_IP
:

1213 switch (
optname
) {

1217 case 
IP_TTL
:

1218 case 
IP_TOS
:

1219 if (*
optlen
 < sizeof(int)) {

1220 
err
 = 
EINVAL
;

1223 #if 
LWIP_IGMP


1224 case 
IP_MULTICAST_TTL
:

1225 if (*
optlen
 < sizeof(
u8_t
)) {

1226 
err
 = 
EINVAL
;

1229 case 
IP_MULTICAST_IF
:

1230 if (*
optlen
 < sizeof(struct 
in_addr
)) {

1231 
err
 = 
EINVAL
;

1237 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",

1238 
s
, 
optname
));

1239 
err
 = 
ENOPROTOOPT
;

1243 #if 
LWIP_TCP


1245 case 
IPPROTO_TCP
:

1246 if (*
optlen
 < sizeof(int)) {

1247 
err
 = 
EINVAL
;

1252 if (
sock
->
conn
->
type
 != 
NETCONN_TCP
)

1255 switch (
optname
) {

1256 case 
TCP_NODELAY
:

1257 case 
TCP_KEEPALIVE
:

1258 #if 
LWIP_TCP_KEEPALIVE


1259 case 
TCP_KEEPIDLE
:

1260 case 
TCP_KEEPINTVL
:

1261 case 
TCP_KEEPCNT
:

1266 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",

1267 
s
, 
optname
));

1268 
err
 = 
ENOPROTOOPT
;

1272 #if 
LWIP_UDP
 && 
LWIP_UDPLITE


1274 case 
IPPROTO_UDPLITE
:

1275 if (*
optlen
 < sizeof(int)) {

1276 
err
 = 
EINVAL
;

1281 if (
sock
->
conn
->
type
 != 
NETCONN_UDPLITE
)

1284 switch (
optname
) {

1285 case 
UDPLITE_SEND_CSCOV
:

1286 case 
UDPLITE_RECV_CSCOV
:

1290 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",

1291 
s
, 
optname
));

1292 
err
 = 
ENOPROTOOPT
;

1298 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",

1299 
s
, 
level
, 
optname
));

1300 
err
 = 
ENOPROTOOPT
;

1304 if (
err
 != 
ERR_OK
) {

1305 
	`sock_set_errno
(
sock
, 
err
);

1310 
data
.
sock
 = sock;

1311 
data
.
level
 = level;

1312 
data
.
optname
 = optname;

1313 
data
.
optval
 = optval;

1314 
data
.
optlen
 = optlen;

1315 
data
.
err
 = err;

1316 
	`tcpip_callback
(
lwip_getsockopt_internal
, &
data
);

1317 
	`sys_arch_sem_wait
(
sock
->
conn
->
op_completed
, 0);

1319 
err
 = 
data
.err;

1321 
	`sock_set_errno
(
sock
, 
err
);

1322 return 
err
 ? -1 : 0;

1323 
	}
}

1326 
	$lwip_getsockopt_internal
(void *
arg
)

1328 struct 
lwip_socket
 *
sock
;

1329 #ifdef 
LWIP_DEBUG


1330 int 
s
;

1332 int 
level
, 
optname
;

1333 void *
optval
;

1334 struct 
lwip_setgetsockopt_data
 *
data
;

1336 
	`LWIP_ASSERT
("arg != NULL", 
arg
 != 
NULL
);

1338 
data
 = (struct 
lwip_setgetsockopt_data
*)
arg
;

1339 
sock
 = 
data
->sock;

1340 #ifdef 
LWIP_DEBUG


1341 
s
 = 
data
->s;

1343 
level
 = 
data
->level;

1344 
optname
 = 
data
->optname;

1345 
optval
 = 
data
->optval;

1347 switch (
level
) {

1350 case 
SOL_SOCKET
:

1351 switch (
optname
) {

1354 case 
SO_ACCEPTCONN
:

1355 case 
SO_BROADCAST
:

1358 case 
SO_KEEPALIVE
:

1360 #if 
SO_REUSE


1361 case 
SO_REUSEADDR
:

1362 case 
SO_REUSEPORT
:

1365 *(int*)
optval
 = 
sock
->
conn
->
pcb
.
ip
->
so_options
 & 
optname
;

1366 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",

1367 
s
, 
optname
, (*(int*)
optval
?"on":"off")));

1370 case 
SO_TYPE
:

1371 switch (
	`NETCONNTYPE_GROUP
(
sock
->
conn
->
type
)) {

1372 case 
NETCONN_RAW
:

1373 *(int*)
optval
 = 
SOCK_RAW
;

1375 case 
NETCONN_TCP
:

1376 *(int*)
optval
 = 
SOCK_STREAM
;

1378 case 
NETCONN_UDP
:

1379 *(int*)
optval
 = 
SOCK_DGRAM
;

1382 *(int*)
optval
 = 
sock
->
conn
->
type
;

1383 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
,

1385 
s
, *(int *)
optval
));

1387 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",

1388 
s
, *(int *)
optval
));

1391 case 
SO_ERROR
:

1392 if (
sock
->
err
 == 0) {

1393 
	`sock_set_errno
(
sock
, 
	`err_to_errno
(sock->
conn
->
err
));

1395 *(int *)
optval
 = 
sock
->
err
;

1396 
sock
->
err
 = 0;

1397 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",

1398 
s
, *(int *)
optval
));

1401 #if 
LWIP_SO_RCVTIMEO


1402 case 
SO_RCVTIMEO
:

1403 *(int *)
optval
 = 
sock
->
conn
->
recv_timeout
;

1406 #if 
LWIP_SO_RCVBUF


1407 case 
SO_RCVBUF
:

1408 *(int *)
optval
 = 
sock
->
conn
->
recv_bufsize
;

1411 #if 
LWIP_UDP


1412 case 
SO_NO_CHECK
:

1413 *(int*)
optval
 = (
	`udp_flags
(
sock
->
conn
->
pcb
.
udp
) & 
UDP_FLAGS_NOCHKSUM
) ? 1 : 0;

1420 case 
IPPROTO_IP
:

1421 switch (
optname
) {

1422 case 
IP_TTL
:

1423 *(int*)
optval
 = 
sock
->
conn
->
pcb
.
ip
->
ttl
;

1424 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",

1425 
s
, *(int *)
optval
));

1427 case 
IP_TOS
:

1428 *(int*)
optval
 = 
sock
->
conn
->
pcb
.
ip
->
tos
;

1429 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",

1430 
s
, *(int *)
optval
));

1432 #if 
LWIP_IGMP


1433 case 
IP_MULTICAST_TTL
:

1434 *(
u8_t
*)
optval
 = 
sock
->
conn
->
pcb
.
ip
->
ttl
;

1435 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",

1436 
s
, *(int *)
optval
));

1438 case 
IP_MULTICAST_IF
:

1439 ((struct 
in_addr
*) 
optval
)->
s_addr
 = 
sock
->
conn
->
pcb
.
udp
->
multicast_ip
.
addr
;

1440 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",

1441 
s
, *(
u32_t
 *)
optval
));

1447 #if 
LWIP_TCP


1449 case 
IPPROTO_TCP
:

1450 switch (
optname
) {

1451 case 
TCP_NODELAY
:

1452 *(int*)
optval
 = (
sock
->
conn
->
pcb
.
tcp
->
flags
 & 
TF_NODELAY
);

1453 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",

1454 
s
, (*(int*)
optval
)?"on":"off") );

1456 case 
TCP_KEEPALIVE
:

1457 *(int*)
optval
 = (int)
sock
->
conn
->
pcb
.
tcp
->
keep_idle
;

1458 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",

1459 
s
, *(int *)
optval
));

1462 #if 
LWIP_TCP_KEEPALIVE


1463 case 
TCP_KEEPIDLE
:

1464 *(int*)
optval
 = (int)(
sock
->
conn
->
pcb
.
tcp
->
keep_idle
/1000);

1465 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",

1466 
s
, *(int *)
optval
));

1468 case 
TCP_KEEPINTVL
:

1469 *(int*)
optval
 = (int)(
sock
->
conn
->
pcb
.
tcp
->
keep_intvl
/1000);

1470 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",

1471 
s
, *(int *)
optval
));

1473 case 
TCP_KEEPCNT
:

1474 *(int*)
optval
 = (int)
sock
->
conn
->
pcb
.
tcp
->
keep_cnt
;

1475 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",

1476 
s
, *(int *)
optval
));

1483 #if 
LWIP_UDP
 && 
LWIP_UDPLITE


1485 case 
IPPROTO_UDPLITE
:

1486 switch (
optname
) {

1487 case 
UDPLITE_SEND_CSCOV
:

1488 *(int*)
optval
 = 
sock
->
conn
->
pcb
.
udp
->
chksum_len_tx
;

1489 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) = %d\n",

1490 
s
, (*(int*)
optval
)) );

1492 case 
UDPLITE_RECV_CSCOV
:

1493 *(int*)
optval
 = 
sock
->
conn
->
pcb
.
udp
->
chksum_len_rx
;

1494 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) = %d\n",

1495 
s
, (*(int*)
optval
)) );

1501 
	`sys_sem_signal
(
sock
->
conn
->
op_completed
);

1502 
	}
}

1505 
	$lwip_setsockopt
(int 
s
, int 
level
, int 
optname
, const void *
optval
, 
socklen_t
 
optlen
)

1507 struct 
lwip_socket
 *
sock
 = 
	`get_socket
(
s
);

1508 int 
err
 = 
ERR_OK
;

1509 struct 
lwip_setgetsockopt_data
 
data
;

1511 if (!
sock
)

1514 if (
NULL
 == 
optval
) {

1515 
	`sock_set_errno
(
sock
, 
EFAULT
);

1520 switch (
level
) {

1523 case 
SOL_SOCKET
:

1524 switch (
optname
) {

1526 case 
SO_BROADCAST
:

1529 case 
SO_KEEPALIVE
:

1532 #if 
LWIP_SO_RCVTIMEO


1533 case 
SO_RCVTIMEO
:

1535 #if 
LWIP_SO_RCVBUF


1536 case 
SO_RCVBUF
:

1542 #if 
SO_REUSE


1543 case 
SO_REUSEADDR
:

1544 case 
SO_REUSEPORT
:

1547 if (
optlen
 < sizeof(int)) {

1548 
err
 = 
EINVAL
;

1551 case 
SO_NO_CHECK
:

1552 if (
optlen
 < sizeof(int)) {

1553 
err
 = 
EINVAL
;

1555 #if 
LWIP_UDP


1556 if ((
sock
->
conn
->
type
 != 
NETCONN_UDP
) ||

1557 ((
	`udp_flags
(
sock
->
conn
->
pcb
.
udp
) & 
UDP_FLAGS_UDPLITE
) != 0)) {

1559 
err
 = 
EAFNOSUPPORT
;

1564 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",

1565 
s
, 
optname
));

1566 
err
 = 
ENOPROTOOPT
;

1571 case 
IPPROTO_IP
:

1572 switch (
optname
) {

1576 case 
IP_TTL
:

1577 case 
IP_TOS
:

1578 if (
optlen
 < sizeof(int)) {

1579 
err
 = 
EINVAL
;

1582 #if 
LWIP_IGMP


1583 case 
IP_MULTICAST_TTL
:

1584 if (
optlen
 < sizeof(
u8_t
)) {

1585 
err
 = 
EINVAL
;

1587 if (
	`NETCONNTYPE_GROUP
(
sock
->
conn
->
type
) != 
NETCONN_UDP
) {

1588 
err
 = 
EAFNOSUPPORT
;

1591 case 
IP_MULTICAST_IF
:

1592 if (
optlen
 < sizeof(struct 
in_addr
)) {

1593 
err
 = 
EINVAL
;

1595 if (
	`NETCONNTYPE_GROUP
(
sock
->
conn
->
type
) != 
NETCONN_UDP
) {

1596 
err
 = 
EAFNOSUPPORT
;

1599 case 
IP_ADD_MEMBERSHIP
:

1600 case 
IP_DROP_MEMBERSHIP
:

1601 if (
optlen
 < sizeof(struct 
ip_mreq
)) {

1602 
err
 = 
EINVAL
;

1604 if (
	`NETCONNTYPE_GROUP
(
sock
->
conn
->
type
) != 
NETCONN_UDP
) {

1605 
err
 = 
EAFNOSUPPORT
;

1610 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",

1611 
s
, 
optname
));

1612 
err
 = 
ENOPROTOOPT
;

1616 #if 
LWIP_TCP


1618 case 
IPPROTO_TCP
:

1619 if (
optlen
 < sizeof(int)) {

1620 
err
 = 
EINVAL
;

1625 if (
sock
->
conn
->
type
 != 
NETCONN_TCP
)

1628 switch (
optname
) {

1629 case 
TCP_NODELAY
:

1630 case 
TCP_KEEPALIVE
:

1631 #if 
LWIP_TCP_KEEPALIVE


1632 case 
TCP_KEEPIDLE
:

1633 case 
TCP_KEEPINTVL
:

1634 case 
TCP_KEEPCNT
:

1639 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",

1640 
s
, 
optname
));

1641 
err
 = 
ENOPROTOOPT
;

1645 #if 
LWIP_UDP
 && 
LWIP_UDPLITE


1647 case 
IPPROTO_UDPLITE
:

1648 if (
optlen
 < sizeof(int)) {

1649 
err
 = 
EINVAL
;

1654 if (
sock
->
conn
->
type
 != 
NETCONN_UDPLITE
)

1657 switch (
optname
) {

1658 case 
UDPLITE_SEND_CSCOV
:

1659 case 
UDPLITE_RECV_CSCOV
:

1663 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",

1664 
s
, 
optname
));

1665 
err
 = 
ENOPROTOOPT
;

1671 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",

1672 
s
, 
level
, 
optname
));

1673 
err
 = 
ENOPROTOOPT
;

1677 if (
err
 != 
ERR_OK
) {

1678 
	`sock_set_errno
(
sock
, 
err
);

1684 
data
.
sock
 = sock;

1685 
data
.
level
 = level;

1686 
data
.
optname
 = optname;

1687 
data
.
optval
 = (void*)optval;

1688 
data
.
optlen
 = &optlen;

1689 
data
.
err
 = err;

1690 
	`tcpip_callback
(
lwip_setsockopt_internal
, &
data
);

1691 
	`sys_arch_sem_wait
(
sock
->
conn
->
op_completed
, 0);

1693 
err
 = 
data
.err;

1695 
	`sock_set_errno
(
sock
, 
err
);

1696 return 
err
 ? -1 : 0;

1697 
	}
}

1700 
	$lwip_setsockopt_internal
(void *
arg
)

1702 struct 
lwip_socket
 *
sock
;

1703 #ifdef 
LWIP_DEBUG


1704 int 
s
;

1706 int 
level
, 
optname
;

1707 const void *
optval
;

1708 struct 
lwip_setgetsockopt_data
 *
data
;

1710 
	`LWIP_ASSERT
("arg != NULL", 
arg
 != 
NULL
);

1712 
data
 = (struct 
lwip_setgetsockopt_data
*)
arg
;

1713 
sock
 = 
data
->sock;

1714 #ifdef 
LWIP_DEBUG


1715 
s
 = 
data
->s;

1717 
level
 = 
data
->level;

1718 
optname
 = 
data
->optname;

1719 
optval
 = 
data
->optval;

1721 switch (
level
) {

1724 case 
SOL_SOCKET
:

1725 switch (
optname
) {

1728 case 
SO_BROADCAST
:

1731 case 
SO_KEEPALIVE
:

1733 #if 
SO_REUSE


1734 case 
SO_REUSEADDR
:

1735 case 
SO_REUSEPORT
:

1738 if (*(int*)
optval
) {

1739 
sock
->
conn
->
pcb
.
ip
->
so_options
 |= 
optname
;

1741 
sock
->
conn
->
pcb
.
ip
->
so_options
 &= ~
optname
;

1743 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",

1744 
s
, 
optname
, (*(int*)
optval
?"on":"off")));

1746 #if 
LWIP_SO_RCVTIMEO


1747 case 
SO_RCVTIMEO
:

1748 
sock
->
conn
->
recv_timeout
 = ( *(int*)
optval
 );

1751 #if 
LWIP_SO_RCVBUF


1752 case 
SO_RCVBUF
:

1753 
sock
->
conn
->
recv_bufsize
 = ( *(int*)
optval
 );

1756 #if 
LWIP_UDP


1757 case 
SO_NO_CHECK
:

1758 if (*(int*)
optval
) {

1759 
	`udp_setflags
(
sock
->
conn
->
pcb
.
udp
, 
	`udp_flags
(sock->conn->pcb.udp) | 
UDP_FLAGS_NOCHKSUM
);

1761 
	`udp_setflags
(
sock
->
conn
->
pcb
.
udp
, 
	`udp_flags
(sock->conn->pcb.udp) & ~
UDP_FLAGS_NOCHKSUM
);

1769 case 
IPPROTO_IP
:

1770 switch (
optname
) {

1771 case 
IP_TTL
:

1772 
sock
->
conn
->
pcb
.
ip
->
ttl
 = (
u8_t
)(*(int*)
optval
);

1773 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",

1774 
s
, 
sock
->
conn
->
pcb
.
ip
->
ttl
));

1776 case 
IP_TOS
:

1777 
sock
->
conn
->
pcb
.
ip
->
tos
 = (
u8_t
)(*(int*)
optval
);

1778 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",

1779 
s
, 
sock
->
conn
->
pcb
.
ip
->
tos
));

1781 #if 
LWIP_IGMP


1782 case 
IP_MULTICAST_TTL
:

1783 
sock
->
conn
->
pcb
.
udp
->
ttl
 = (
u8_t
)(*(u8_t*)
optval
);

1785 case 
IP_MULTICAST_IF
:

1786 
sock
->
conn
->
pcb
.
udp
->
multicast_ip
.
addr
 = ((struct 
in_addr
*) 
optval
)->
s_addr
;

1788 case 
IP_ADD_MEMBERSHIP
:

1789 case 
IP_DROP_MEMBERSHIP
:

1792 struct 
ip_mreq
 *
imr
 = (struct ip_mreq *)
optval
;

1793 if(
optname
 == 
IP_ADD_MEMBERSHIP
){

1794 
data
->
err
 = 
	`igmp_joingroup
((struct 
ip_addr
*)&(
imr
->
imr_interface
.
s_addr
), (struct ip_addr*)&(imr->
imr_multiaddr
.s_addr));

1796 
data
->
err
 = 
	`igmp_leavegroup
((struct 
ip_addr
*)&(
imr
->
imr_interface
.
s_addr
), (struct ip_addr*)&(imr->
imr_multiaddr
.s_addr));

1798 if(
data
->
err
 != 
ERR_OK
) {

1799 
data
->
err
 = 
EADDRNOTAVAIL
;

1807 #if 
LWIP_TCP


1809 case 
IPPROTO_TCP
:

1810 switch (
optname
) {

1811 case 
TCP_NODELAY
:

1812 if (*(int*)
optval
) {

1813 
sock
->
conn
->
pcb
.
tcp
->
flags
 |= 
TF_NODELAY
;

1815 
sock
->
conn
->
pcb
.
tcp
->
flags
 &= ~
TF_NODELAY
;

1817 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",

1818 
s
, (*(int *)
optval
)?"on":"off") );

1820 case 
TCP_KEEPALIVE
:

1821 
sock
->
conn
->
pcb
.
tcp
->
keep_idle
 = (
u32_t
)(*(int*)
optval
);

1822 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",

1823 
s
, 
sock
->
conn
->
pcb
.
tcp
->
keep_idle
));

1826 #if 
LWIP_TCP_KEEPALIVE


1827 case 
TCP_KEEPIDLE
:

1828 
sock
->
conn
->
pcb
.
tcp
->
keep_idle
 = 1000*(
u32_t
)(*(int*)
optval
);

1829 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %lu\n",

1830 
s
, 
sock
->
conn
->
pcb
.
tcp
->
keep_idle
));

1832 case 
TCP_KEEPINTVL
:

1833 
sock
->
conn
->
pcb
.
tcp
->
keep_intvl
 = 1000*(
u32_t
)(*(int*)
optval
);

1834 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %lu\n",

1835 
s
, 
sock
->
conn
->
pcb
.
tcp
->
keep_intvl
));

1837 case 
TCP_KEEPCNT
:

1838 
sock
->
conn
->
pcb
.
tcp
->
keep_cnt
 = (
u32_t
)(*(int*)
optval
);

1839 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %lu\n",

1840 
s
, 
sock
->
conn
->
pcb
.
tcp
->
keep_cnt
));

1847 #if 
LWIP_UDP
 && 
LWIP_UDPLITE


1849 case 
IPPROTO_UDPLITE
:

1850 switch (
optname
) {

1851 case 
UDPLITE_SEND_CSCOV
:

1852 if ((*(int*)
optval
 != 0) && (*(int*)optval < 8)) {

1854 
sock
->
conn
->
pcb
.
udp
->
chksum_len_tx
 = 8;

1856 
sock
->
conn
->
pcb
.
udp
->
chksum_len_tx
 = *(int*)
optval
;

1858 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) -> %d\n",

1859 
s
, (*(int*)
optval
)) );

1861 case 
UDPLITE_RECV_CSCOV
:

1862 if ((*(int*)
optval
 != 0) && (*(int*)optval < 8)) {

1864 
sock
->
conn
->
pcb
.
udp
->
chksum_len_rx
 = 8;

1866 
sock
->
conn
->
pcb
.
udp
->
chksum_len_rx
 = *(int*)
optval
;

1868 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) -> %d\n",

1869 
s
, (*(int*)
optval
)) );

1875 
	`sys_sem_signal
(
sock
->
conn
->
op_completed
);

1876 
	}
}

1879 
	$lwip_ioctl
(int 
s
, long 
cmd
, void *
argp
)

1881 struct 
lwip_socket
 *
sock
 = 
	`get_socket
(
s
);

1882 
u16_t
 
buflen
 = 0;

1884 if (!
sock
)

1887 switch (
cmd
) {

1888 case 
FIONREAD
:

1889 if (!
argp
) {

1890 
	`sock_set_errno
(
sock
, 
EINVAL
);

1894 
	`SYS_ARCH_GET
(
sock
->
conn
->
recv_avail
, *((
u16_t
*)
argp
));

1897 if (
sock
->
lastdata
) {

1898 
buflen
 = 
	`netbuf_len
(
sock
->
lastdata
);

1899 
buflen
 -= 
sock
->
lastoffset
;

1901 *((
u16_t
*)
argp
) += 
buflen
;

1904 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", 
s
, 
argp
, *((
u16_t
*)argp)));

1905 
	`sock_set_errno
(
sock
, 0);

1908 case 
FIONBIO
:

1909 if (
argp
 && *(
u32_t
*)argp)

1910 
sock
->
flags
 |= 
O_NONBLOCK
;

1912 
sock
->
flags
 &= ~
O_NONBLOCK
;

1913 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_ioctl(%d, FIONBIO, %d)\n", 
s
, !!(
sock
->
flags
 & 
O_NONBLOCK
)));

1914 
	`sock_set_errno
(
sock
, 0);

1918 
	`LWIP_DEBUGF
(
SOCKETS_DEBUG
, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", 
s
, 
cmd
, 
argp
));

1919 
	`sock_set_errno
(
sock
, 
ENOSYS
);

1922 
	}
}

	@/root/Robux/net/lwip/api/tcpip.c

39 #include 
	~"lwip/opt.h
"

41 #if !
NO_SYS


43 #include 
	~"lwip/sys.h
"

44 #include 
	~"lwip/memp.h
"

45 #include 
	~"lwip/pbuf.h
"

46 #include 
	~"lwip/ip_frag.h
"

47 #include 
	~"lwip/tcp.h
"

48 #include 
	~"lwip/autoip.h
"

49 #include 
	~"lwip/dhcp.h
"

50 #include 
	~"lwip/igmp.h
"

51 #include 
	~"lwip/dns.h
"

52 #include 
	~"lwip/tcpip.h
"

53 #include 
	~"lwip/init.h
"

54 #include 
	~"netif/etharp.h
"

55 #include 
	~"netif/ppp_oe.h
"

58 static void (* 
tcpip_init_done
)(void *
arg
);

59 static void *
tcpip_init_done_arg
;

60 static 
sys_mbox_t
 
mbox
 = 
SYS_MBOX_NULL
;

62 #if 
LWIP_TCPIP_CORE_LOCKING


64 
sys_sem_t
 
lock_tcpip_core
;

67 #if 
LWIP_TCP


69 static int 
tcpip_tcp_timer_active
;

77 
	$tcpip_tcp_timer
(void *
arg
)

79 
	`LWIP_UNUSED_ARG
(
arg
);

82 
	`tcp_tmr
();

84 if (
tcp_active_pcbs
 || 
tcp_tw_pcbs
) {

86 
	`sys_timeout
(
TCP_TMR_INTERVAL
, 
tcpip_tcp_timer
, 
NULL
);

89 
tcpip_tcp_timer_active
 = 0;

91 
	}
}

93 #if !
NO_SYS


100 
	$tcp_timer_needed
(void)

103 if (!
tcpip_tcp_timer_active
 && (
tcp_active_pcbs
 || 
tcp_tw_pcbs
)) {

105 
tcpip_tcp_timer_active
 = 1;

106 
	`sys_timeout
(
TCP_TMR_INTERVAL
, 
tcpip_tcp_timer
, 
NULL
);

108 
	}
}

112 #if 
IP_REASSEMBLY


119 
	$ip_reass_timer
(void *
arg
)

121 
	`LWIP_UNUSED_ARG
(
arg
);

122 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip: ip_reass_tmr()\n"));

123 
	`ip_reass_tmr
();

124 
	`sys_timeout
(
IP_TMR_INTERVAL
, 
ip_reass_timer
, 
NULL
);

125 
	}
}

128 #if 
LWIP_ARP


135 
	$arp_timer
(void *
arg
)

137 
	`LWIP_UNUSED_ARG
(
arg
);

138 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip: etharp_tmr()\n"));

139 
	`etharp_tmr
();

140 
	`sys_timeout
(
ARP_TMR_INTERVAL
, 
arp_timer
, 
NULL
);

141 
	}
}

144 #if 
LWIP_DHCP


151 
	$dhcp_timer_coarse
(void *
arg
)

153 
	`LWIP_UNUSED_ARG
(
arg
);

154 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip: dhcp_coarse_tmr()\n"));

155 
	`dhcp_coarse_tmr
();

156 
	`sys_timeout
(
DHCP_COARSE_TIMER_MSECS
, 
dhcp_timer_coarse
, 
NULL
);

157 
	}
}

165 
	$dhcp_timer_fine
(void *
arg
)

167 
	`LWIP_UNUSED_ARG
(
arg
);

168 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip: dhcp_fine_tmr()\n"));

169 
	`dhcp_fine_tmr
();

170 
	`sys_timeout
(
DHCP_FINE_TIMER_MSECS
, 
dhcp_timer_fine
, 
NULL
);

171 
	}
}

174 #if 
LWIP_AUTOIP


181 
	$autoip_timer
(void *
arg
)

183 
	`LWIP_UNUSED_ARG
(
arg
);

184 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip: autoip_tmr()\n"));

185 
	`autoip_tmr
();

186 
	`sys_timeout
(
AUTOIP_TMR_INTERVAL
, 
autoip_timer
, 
NULL
);

187 
	}
}

190 #if 
LWIP_IGMP


197 
	$igmp_timer
(void *
arg
)

199 
	`LWIP_UNUSED_ARG
(
arg
);

200 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip: igmp_tmr()\n"));

201 
	`igmp_tmr
();

202 
	`sys_timeout
(
IGMP_TMR_INTERVAL
, 
igmp_timer
, 
NULL
);

203 
	}
}

206 #if 
LWIP_DNS


213 
	$dns_timer
(void *
arg
)

215 
	`LWIP_UNUSED_ARG
(
arg
);

216 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip: dns_tmr()\n"));

217 
	`dns_tmr
();

218 
	`sys_timeout
(
DNS_TMR_INTERVAL
, 
dns_timer
, 
NULL
);

219 
	}
}

233 
	$tcpip_thread
(void *
arg
)

235 struct 
tcpip_msg
 *
msg
;

236 
	`LWIP_UNUSED_ARG
(
arg
);

238 #if 
IP_REASSEMBLY


239 
	`sys_timeout
(
IP_TMR_INTERVAL
, 
ip_reass_timer
, 
NULL
);

241 #if 
LWIP_ARP


242 
	`sys_timeout
(
ARP_TMR_INTERVAL
, 
arp_timer
, 
NULL
);

244 #if 
LWIP_DHCP


245 
	`sys_timeout
(
DHCP_COARSE_TIMER_MSECS
, 
dhcp_timer_coarse
, 
NULL
);

246 
	`sys_timeout
(
DHCP_FINE_TIMER_MSECS
, 
dhcp_timer_fine
, 
NULL
);

248 #if 
LWIP_AUTOIP


249 
	`sys_timeout
(
AUTOIP_TMR_INTERVAL
, 
autoip_timer
, 
NULL
);

251 #if 
LWIP_IGMP


252 
	`sys_timeout
(
IGMP_TMR_INTERVAL
, 
igmp_timer
, 
NULL
);

254 #if 
LWIP_DNS


255 
	`sys_timeout
(
DNS_TMR_INTERVAL
, 
dns_timer
, 
NULL
);

258 if (
tcpip_init_done
 != 
NULL
) {

259 
	`tcpip_init_done
(
tcpip_init_done_arg
);

262 
	`LOCK_TCPIP_CORE
();

264 
	`sys_mbox_fetch
(
mbox
, (void *)&
msg
);

265 switch (
msg
->
type
) {

266 #if 
LWIP_NETCONN


267 case 
TCPIP_MSG_API
:

268 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip_thread: API message %p\n", (void *)
msg
));

269 
msg
->msg.
apimsg
->
	`function
(&(msg->msg.apimsg->msg));

273 case 
TCPIP_MSG_INPKT
:

274 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip_thread: PACKET %p\n", (void *)
msg
));

275 #if 
LWIP_ARP


276 if (
msg
->msg.
inp
.
netif
->
flags
 & 
NETIF_FLAG_ETHARP
) {

277 
	`ethernet_input
(
msg
->msg.
inp
.
p
, msg->msg.inp.
netif
);

280 { 
	`ip_input
(
msg
->msg.
inp
.
p
, msg->msg.inp.
netif
);

282 
	`memp_free
(
MEMP_TCPIP_MSG_INPKT
, 
msg
);

285 #if 
LWIP_NETIF_API


286 case 
TCPIP_MSG_NETIFAPI
:

287 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip_thread: Netif API message %p\n", (void *)
msg
));

288 
msg
->msg.
netifapimsg
->
	`function
(&(msg->msg.netifapimsg->msg));

292 case 
TCPIP_MSG_CALLBACK
:

293 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip_thread: CALLBACK %p\n", (void *)
msg
));

294 
msg
->msg.
cb
.
	`f
(msg->msg.cb.
ctx
);

295 
	`memp_free
(
MEMP_TCPIP_MSG_API
, 
msg
);

298 case 
TCPIP_MSG_TIMEOUT
:

299 
	`LWIP_DEBUGF
(
TCPIP_DEBUG
, ("tcpip_thread: TIMEOUT %p\n", (void *)
msg
));

301 if(
msg
->msg.
tmo
.
msecs
 != 0xffffffff)

302 
	`sys_timeout
 (
msg
->msg.
tmo
.
msecs
, msg->msg.tmo.
h
, msg->msg.tmo.
arg
);

304 
	`sys_untimeout
 (
msg
->msg.
tmo
.
h
, msg->msg.tmo.
arg
);

305 
	`memp_free
(
MEMP_TCPIP_MSG_API
, 
msg
);

312 
	}
}

321 
err_t


322 
	$tcpip_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
)

324 struct 
tcpip_msg
 *
msg
;

326 if (
mbox
 != 
SYS_MBOX_NULL
) {

327 
msg
 = 
	`memp_malloc
(
MEMP_TCPIP_MSG_INPKT
);

328 if (
msg
 == 
NULL
) {

329 return 
ERR_MEM
;

332 
msg
->
type
 = 
TCPIP_MSG_INPKT
;

333 
msg
->msg.
inp
.
p
 = p;

334 
msg
->msg.
inp
.
netif
 = inp;

335 if (
	`sys_mbox_trypost
(
mbox
, 
msg
) != 
ERR_OK
) {

336 
	`memp_free
(
MEMP_TCPIP_MSG_INPKT
, 
msg
);

337 return 
ERR_MEM
;

339 return 
ERR_OK
;

341 return 
ERR_VAL
;

342 
	}
}

355 
err_t


356 
tcpip_callback_with_block
(void (*
f
)(void *
ctx
), void *ctx, 
u8_t
 
block
)

358 struct 
tcpip_msg
 *
msg
;

360 if (
mbox
 != 
SYS_MBOX_NULL
) {

361 
msg
 = 
	`memp_malloc
(
MEMP_TCPIP_MSG_API
);

362 if (
msg
 == 
NULL
) {

363 return 
ERR_MEM
;

366 
msg
->
type
 = 
TCPIP_MSG_CALLBACK
;

367 
msg
->msg.
cb
.
f
 = f;

368 
msg
->msg.
cb
.
ctx
 = ctx;

369 if (
block
) {

370 
	`sys_mbox_post
(
mbox
, 
msg
);

372 if (
	`sys_mbox_trypost
(
mbox
, 
msg
) != 
ERR_OK
) {

373 
	`memp_free
(
MEMP_TCPIP_MSG_API
, 
msg
);

374 return 
ERR_MEM
;

377 return 
ERR_OK
;

379 return 
ERR_VAL
;

380 
	}
}

382 
err_t


383 
	$tcpip_timeout
(
u32_t
 
msecs
, 
sys_timeout_handler
 
h
, void *
arg
)

385 struct 
tcpip_msg
 *
msg
;

387 if (
mbox
 != 
SYS_MBOX_NULL
) {

388 
msg
 = 
	`memp_malloc
(
MEMP_TCPIP_MSG_API
);

389 if (
msg
 == 
NULL
) {

390 return 
ERR_MEM
;

393 
msg
->
type
 = 
TCPIP_MSG_TIMEOUT
;

394 
msg
->msg.
tmo
.
msecs
 = msecs;

395 
msg
->msg.
tmo
.
h
 = h;

396 
msg
->msg.
tmo
.
arg
 = arg;

397 
	`sys_mbox_post
(
mbox
, 
msg
);

398 return 
ERR_OK
;

400 return 
ERR_VAL
;

401 
	}
}

403 #if 
LWIP_NETCONN


412 
err_t


413 
	$tcpip_apimsg
(struct 
api_msg
 *
apimsg
)

415 struct 
tcpip_msg
 
msg
;

417 if (
mbox
 != 
SYS_MBOX_NULL
) {

418 
msg
.
type
 = 
TCPIP_MSG_API
;

419 
msg
.msg.
apimsg
 = apimsg;

420 
	`sys_mbox_post
(
mbox
, &
msg
);

421 
	`sys_arch_sem_wait
(
apimsg
->
msg
.
conn
->
op_completed
, 0);

422 return 
ERR_OK
;

424 return 
ERR_VAL
;

425 
	}
}

427 #if 
LWIP_TCPIP_CORE_LOCKING


436 
err_t


437 
	$tcpip_apimsg_lock
(struct 
api_msg
 *
apimsg
)

439 
	`LOCK_TCPIP_CORE
();

440 
apimsg
->
	`function
(&(apimsg->
msg
));

441 
	`UNLOCK_TCPIP_CORE
();

442 return 
ERR_OK
;

444 
	}
}

448 #if 
LWIP_NETIF_API


449 #if !
LWIP_TCPIP_CORE_LOCKING


457 
err_t


458 
	$tcpip_netifapi
(struct 
netifapi_msg
* 
netifapimsg
)

460 struct 
tcpip_msg
 
msg
;

462 if (
mbox
 != 
SYS_MBOX_NULL
) {

463 
netifapimsg
->
msg
.
sem
 = 
	`sys_sem_new
(0);

464 if (
netifapimsg
->
msg
.
sem
 == 
SYS_SEM_NULL
) {

465 
netifapimsg
->
msg
.
err
 = 
ERR_MEM
;

466 return 
netifapimsg
->
msg
.
err
;

469 
msg
.
type
 = 
TCPIP_MSG_NETIFAPI
;

470 
msg
.msg.
netifapimsg
 = netifapimsg;

471 
	`sys_mbox_post
(
mbox
, &
msg
);

472 
	`sys_sem_wait
(
netifapimsg
->
msg
.
sem
);

473 
	`sys_sem_free
(
netifapimsg
->
msg
.
sem
);

474 return 
netifapimsg
->
msg
.
err
;

476 return 
ERR_VAL
;

477 
	}
}

487 
err_t


488 
	$tcpip_netifapi_lock
(struct 
netifapi_msg
* 
netifapimsg
)

490 
	`LOCK_TCPIP_CORE
();

491 
netifapimsg
->
	`function
(&(netifapimsg->
msg
));

492 
	`UNLOCK_TCPIP_CORE
();

493 return 
netifapimsg
->
msg
.
err
;

494 
	}
}

507 
tcpip_init
(void (* 
initfunc
)(void *), void *
arg
)

509 
	`lwip_init
();

511 
tcpip_init_done
 = 
initfunc
;

512 
tcpip_init_done_arg
 = 
arg
;

513 
mbox
 = 
	`sys_mbox_new
(
TCPIP_MBOX_SIZE
);

514 #if 
LWIP_TCPIP_CORE_LOCKING


515 
lock_tcpip_core
 = 
	`sys_sem_new
(1);

518 
	`sys_thread_new
(
TCPIP_THREAD_NAME
, 
tcpip_thread
, 
NULL
, 
TCPIP_THREAD_STACKSIZE
, 
TCPIP_THREAD_PRIO
);

519 
	}
}

528 
	$pbuf_free_int
(void *
p
)

530 struct 
pbuf
 *
q
 = 
p
;

531 
	`pbuf_free
(
q
);

532 
	}
}

540 
err_t


541 
	$pbuf_free_callback
(struct 
pbuf
 *
p
)

543 return 
	`tcpip_callback_with_block
(
pbuf_free_int
, 
p
, 0);

544 
	}
}

553 
err_t


554 
	$mem_free_callback
(void *
m
)

556 return 
	`tcpip_callback_with_block
(
mem_free
, 
m
, 0);

557 
	}
}

	@/root/Robux/net/lwip/core/dhcp.c

71 #include 
	~"lwip/opt.h
"

73 #if 
LWIP_DHCP


75 #include 
	~"lwip/stats.h
"

76 #include 
	~"lwip/mem.h
"

77 #include 
	~"lwip/udp.h
"

78 #include 
	~"lwip/ip_addr.h
"

79 #include 
	~"lwip/netif.h
"

80 #include 
	~"lwip/inet.h
"

81 #include 
	~"lwip/sys.h
"

82 #include 
	~"lwip/dhcp.h
"

83 #include 
	~"lwip/autoip.h
"

84 #include 
	~"lwip/dns.h
"

85 #include 
	~"netif/etharp.h
"

87 #include 
	~<string.h
>

92 static 
u32_t
 
	gxid
 = 0xABCD0000;

95 static void 
dhcp_handle_ack
(struct 
netif
 *netif);

96 static void 
dhcp_handle_nak
(struct 
netif
 *netif);

97 static void 
dhcp_handle_offer
(struct 
netif
 *netif);

99 static 
err_t
 
dhcp_discover
(struct 
netif
 *netif);

100 static 
err_t
 
dhcp_select
(struct 
netif
 *netif);

101 static void 
dhcp_check
(struct 
netif
 *netif);

102 static void 
dhcp_bind
(struct 
netif
 *netif);

103 #if 
DHCP_DOES_ARP_CHECK


104 static 
err_t
 
dhcp_decline
(struct 
netif
 *netif);

106 static 
err_t
 
dhcp_rebind
(struct 
netif
 *netif);

107 static void 
dhcp_set_state
(struct 
dhcp
 *dhcp, 
u8_t
 
new_state
);

110 static void 
dhcp_recv
(void *
arg
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
);

111 static 
err_t
 
dhcp_unfold_reply
(struct 
dhcp
 *dhcp);

112 static 
u8_t
 *
dhcp_get_option_ptr
(struct 
dhcp
 *dhcp, u8_t 
option_type
);

113 static 
u8_t
 
dhcp_get_option_byte
(u8_t *
ptr
);

115 static 
u16_t
 
dhcp_get_option_short
(
u8_t
 *
ptr
);

117 static 
u32_t
 
dhcp_get_option_long
(
u8_t
 *
ptr
);

118 static void 
dhcp_free_reply
(struct 
dhcp
 *dhcp);

121 static void 
dhcp_timeout
(struct 
netif
 *netif);

122 static void 
dhcp_t1_timeout
(struct 
netif
 *netif);

123 static void 
dhcp_t2_timeout
(struct 
netif
 *netif);

127 static 
err_t
 
dhcp_create_request
(struct 
netif
 *netif);

129 static void 
dhcp_delete_request
(struct 
netif
 *netif);

131 static void 
dhcp_option
(struct 
dhcp
 *dhcp, 
u8_t
 
option_type
, u8_t 
option_len
);

133 static void 
dhcp_option_byte
(struct 
dhcp
 *dhcp, 
u8_t
 
value
);

134 static void 
dhcp_option_short
(struct 
dhcp
 *dhcp, 
u16_t
 
value
);

135 static void 
dhcp_option_long
(struct 
dhcp
 *dhcp, 
u32_t
 
value
);

137 static void 
dhcp_option_trailer
(struct 
dhcp
 *dhcp);

152 
	$dhcp_handle_nak
(struct 
netif
 *netif)

154 struct 
dhcp
 *dhcp = 
netif
->dhcp;

155 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_handle_nak(netif=%p) %c%c%"
U16_F
"\n",

156 (void*)
netif
, netif->
name
[0], netif->name[1], (
u16_t
)netif->
num
));

158 
	`netif_set_down
(
netif
);

160 
	`netif_set_ipaddr
(
netif
, 
IP_ADDR_ANY
);

161 
	`netif_set_gw
(
netif
, 
IP_ADDR_ANY
);

162 
	`netif_set_netmask
(
netif
, 
IP_ADDR_ANY
);

164 
	`dhcp_set_state
(
dhcp
, 
DHCP_BACKING_OFF
);

166 
	`dhcp_discover
(
netif
);

167 
	}
}

179 
	$dhcp_check
(struct 
netif
 *netif)

181 struct 
dhcp
 *dhcp = 
netif
->dhcp;

182 
err_t
 
result
;

183 
u16_t
 
msecs
;

184 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)
netif
, (
s16_t
)netif->
name
[0],

185 (
s16_t
)
netif
->
name
[1]));

188 
result
 = 
	`etharp_query
(
netif
, &
dhcp
->
offered_ip_addr
, 
NULL
);

189 if (
result
 != 
ERR_OK
) {

190 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_check: could not perform ARP query\n"));

192 
dhcp
->
tries
++;

193 
msecs
 = 500;

194 
dhcp
->
request_timeout
 = (
msecs
 + 
DHCP_FINE_TIMER_MSECS
 - 1) / DHCP_FINE_TIMER_MSECS;

195 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_check(): set request timeout %"
U16_F
" msecs\n", 
msecs
));

196 
	`dhcp_set_state
(
dhcp
, 
DHCP_CHECKING
);

197 
	}
}

205 
	$dhcp_handle_offer
(struct 
netif
 *netif)

207 struct 
dhcp
 *dhcp = 
netif
->dhcp;

209 
u8_t
 *
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_SERVER_ID
);

210 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_handle_offer(netif=%p) %c%c%"
U16_F
"\n",

211 (void*)
netif
, netif->
name
[0], netif->name[1], (
u16_t
)netif->
num
));

212 if (
option_ptr
 != 
NULL
) {

213 
dhcp
->
server_ip_addr
.
addr
 = 
	`htonl
(
	`dhcp_get_option_long
(&
option_ptr
[2]));

214 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_STATE
, ("dhcp_handle_offer(): server 0x%08"
X32_F
"\n", 
dhcp
->
server_ip_addr
.
addr
));

216 
	`ip_addr_set
(&
dhcp
->
offered_ip_addr
, (struct 
ip_addr
 *)&dhcp->
msg_in
->
yiaddr
);

217 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_STATE
, ("dhcp_handle_offer(): offer for 0x%08"
X32_F
"\n", 
dhcp
->
offered_ip_addr
.
addr
));

219 
	`dhcp_select
(
netif
);

221 
	}
}

231 static 
err_t


232 
	$dhcp_select
(struct 
netif
 *netif)

234 struct 
dhcp
 *dhcp = 
netif
->dhcp;

235 
err_t
 
result
;

236 
u16_t
 
msecs
;

237 #if 
LWIP_NETIF_HOSTNAME


238 const char *
p
;

241 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_select(netif=%p) %c%c%"
U16_F
"\n", (void*)
netif
, netif->
name
[0], netif->name[1], (
u16_t
)netif->
num
));

244 
result
 = 
	`dhcp_create_request
(
netif
);

245 if (
result
 == 
ERR_OK
) {

246 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
, 
DHCP_OPTION_MESSAGE_TYPE_LEN
);

247 
	`dhcp_option_byte
(
dhcp
, 
DHCP_REQUEST
);

249 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MAX_MSG_SIZE
, 
DHCP_OPTION_MAX_MSG_SIZE_LEN
);

250 
	`dhcp_option_short
(
dhcp
, 576);

253 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_REQUESTED_IP
, 4);

254 
	`dhcp_option_long
(
dhcp
, 
	`ntohl
(dhcp->
offered_ip_addr
.
addr
));

256 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_SERVER_ID
, 4);

257 
	`dhcp_option_long
(
dhcp
, 
	`ntohl
(dhcp->
server_ip_addr
.
addr
));

259 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_PARAMETER_REQUEST_LIST
, 4 );

260 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_SUBNET_MASK
);

261 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_ROUTER
);

262 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_BROADCAST
);

263 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_DNS_SERVER
);

265 #if 
LWIP_NETIF_HOSTNAME


266 
p
 = (const char*)
netif
->
hostname
;

267 if (
p
!=
NULL
) {

268 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_HOSTNAME
, 
	`strlen
(
p
));

269 while (*
p
) {

270 
	`dhcp_option_byte
(
dhcp
, *
p
++);

275 
	`dhcp_option_trailer
(
dhcp
);

277 
	`pbuf_realloc
(
dhcp
->
p_out
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
 + dhcp->
options_out_len
);

282 
	`udp_sendto_if
(
dhcp
->
pcb
, dhcp->
p_out
, 
IP_ADDR_BROADCAST
, 
DHCP_SERVER_PORT
, 
netif
);

284 
	`udp_connect
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_SERVER_PORT
);

285 
	`dhcp_delete_request
(
netif
);

286 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_select: REQUESTING\n"));

287 
	`dhcp_set_state
(
dhcp
, 
DHCP_REQUESTING
);

289 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_select: could not allocate DHCP request\n"));

291 
dhcp
->
tries
++;

292 
msecs
 = 
dhcp
->
tries
 < 4 ? dhcp->tries * 1000 : 4 * 1000;

293 
dhcp
->
request_timeout
 = (
msecs
 + 
DHCP_FINE_TIMER_MSECS
 - 1) / DHCP_FINE_TIMER_MSECS;

294 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_STATE
, ("dhcp_select(): set request timeout %"
U16_F
" msecs\n", 
msecs
));

295 return 
result
;

296 
	}
}

303 
	$dhcp_coarse_tmr
()

305 struct 
netif
 *netif = 
netif_list
;

306 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_coarse_tmr()\n"));

308 while (
netif
 != 
NULL
) {

310 if (
netif
->
dhcp
 != 
NULL
) {

312 if (
netif
->
dhcp
->
t2_timeout
-- == 1) {

313 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_coarse_tmr(): t2 timeout\n"));

315 
	`dhcp_t2_timeout
(
netif
);

317 } else if (
netif
->
dhcp
->
t1_timeout
-- == 1) {

318 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_coarse_tmr(): t1 timeout\n"));

320 
	`dhcp_t1_timeout
(
netif
);

324 
netif
 = netif->
next
;

326 
	}
}

336 
	$dhcp_fine_tmr
()

338 struct 
netif
 *netif = 
netif_list
;

340 while (
netif
 != 
NULL
) {

342 if (
netif
->
dhcp
 != 
NULL
) {

344 if (
netif
->
dhcp
->
request_timeout
 > 1) {

345 
netif
->
dhcp
->
request_timeout
--;

347 else if (
netif
->
dhcp
->
request_timeout
 == 1) {

348 
netif
->
dhcp
->
request_timeout
--;

350 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_fine_tmr(): request timeout\n"));

352 
	`dhcp_timeout
(
netif
);

356 
netif
 = netif->
next
;

358 
	}
}

369 
	$dhcp_timeout
(struct 
netif
 *netif)

371 struct 
dhcp
 *dhcp = 
netif
->dhcp;

372 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_timeout()\n"));

374 if ((
dhcp
->
state
 == 
DHCP_BACKING_OFF
) || (dhcp->state == 
DHCP_SELECTING
)) {

375 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_timeout(): restarting discovery\n"));

376 
	`dhcp_discover
(
netif
);

378 } else if (
dhcp
->
state
 == 
DHCP_REQUESTING
) {

379 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));

380 if (
dhcp
->
tries
 <= 5) {

381 
	`dhcp_select
(
netif
);

383 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));

384 
	`dhcp_release
(
netif
);

385 
	`dhcp_discover
(
netif
);

388 } else if (
dhcp
->
state
 == 
DHCP_CHECKING
) {

389 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));

390 if (
dhcp
->
tries
 <= 1) {

391 
	`dhcp_check
(
netif
);

396 
	`dhcp_bind
(
netif
);

400 else if (
dhcp
->
state
 == 
DHCP_RENEWING
) {

401 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));

404 
	`dhcp_renew
(
netif
);

406 } else if (
dhcp
->
state
 == 
DHCP_REBINDING
) {

407 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));

408 if (
dhcp
->
tries
 <= 8) {

409 
	`dhcp_rebind
(
netif
);

411 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));

412 
	`dhcp_release
(
netif
);

413 
	`dhcp_discover
(
netif
);

416 
	}
}

424 
	$dhcp_t1_timeout
(struct 
netif
 *netif)

426 struct 
dhcp
 *dhcp = 
netif
->dhcp;

427 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_STATE
, ("dhcp_t1_timeout()\n"));

428 if ((
dhcp
->
state
 == 
DHCP_REQUESTING
) || (dhcp->state == 
DHCP_BOUND
) || (dhcp->state == 
DHCP_RENEWING
)) {

431 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_t1_timeout(): must renew\n"));

432 
	`dhcp_renew
(
netif
);

434 
	}
}

442 
	$dhcp_t2_timeout
(struct 
netif
 *netif)

444 struct 
dhcp
 *dhcp = 
netif
->dhcp;

445 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_t2_timeout()\n"));

446 if ((
dhcp
->
state
 == 
DHCP_REQUESTING
) || (dhcp->state == 
DHCP_BOUND
) || (dhcp->state == 
DHCP_RENEWING
)) {

448 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_t2_timeout(): must rebind\n"));

449 
	`dhcp_rebind
(
netif
);

451 
	}
}

459 
	$dhcp_handle_ack
(struct 
netif
 *netif)

461 struct 
dhcp
 *dhcp = 
netif
->dhcp;

462 
u8_t
 *
option_ptr
;

464 
dhcp
->
offered_sn_mask
.
addr
 = 0;

465 
dhcp
->
offered_gw_addr
.
addr
 = 0;

466 
dhcp
->
offered_bc_addr
.
addr
 = 0;

469 
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_LEASE_TIME
);

470 if (
option_ptr
 != 
NULL
) {

472 
dhcp
->
offered_t0_lease
 = 
	`dhcp_get_option_long
(
option_ptr
 + 2);

475 
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_T1
);

476 if (
option_ptr
 != 
NULL
) {

478 
dhcp
->
offered_t1_renew
 = 
	`dhcp_get_option_long
(
option_ptr
 + 2);

481 
dhcp
->
offered_t1_renew
 = dhcp->
offered_t0_lease
 / 2;

485 
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_T2
);

486 if (
option_ptr
 != 
NULL
) {

488 
dhcp
->
offered_t2_rebind
 = 
	`dhcp_get_option_long
(
option_ptr
 + 2);

491 
dhcp
->
offered_t2_rebind
 = dhcp->
offered_t0_lease
;

495 
	`ip_addr_set
(&
dhcp
->
offered_ip_addr
, &dhcp->
msg_in
->
yiaddr
);

503 
	`ip_addr_set
(&
dhcp
->
offered_si_addr
, &dhcp->
msg_in
->
siaddr
);

505 if (
dhcp
->
msg_in
->
file
[0]) {

506 
dhcp
->
boot_file_name
 = 
	`mem_malloc
(
	`strlen
(dhcp->
msg_in
->
file
) + 1);

507 
	`strcpy
(
dhcp
->
boot_file_name
, dhcp->
msg_in
->
file
);

512 
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_SUBNET_MASK
);

514 if (
option_ptr
 != 
NULL
) {

515 
dhcp
->
offered_sn_mask
.
addr
 = 
	`htonl
(
	`dhcp_get_option_long
(&
option_ptr
[2]));

519 
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_ROUTER
);

520 if (
option_ptr
 != 
NULL
) {

521 
dhcp
->
offered_gw_addr
.
addr
 = 
	`htonl
(
	`dhcp_get_option_long
(&
option_ptr
[2]));

525 
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_BROADCAST
);

526 if (
option_ptr
 != 
NULL
) {

527 
dhcp
->
offered_bc_addr
.
addr
 = 
	`htonl
(
	`dhcp_get_option_long
(&
option_ptr
[2]));

531 
option_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_DNS_SERVER
);

532 if (
option_ptr
 != 
NULL
) {

533 
u8_t
 
n
;

534 
dhcp
->
dns_count
 = 
	`dhcp_get_option_byte
(&
option_ptr
[1]) / (
u32_t
)sizeof(struct 
ip_addr
);

536 if (
dhcp
->
dns_count
 > 
DHCP_MAX_DNS
)

537 
dhcp
->
dns_count
 = 
DHCP_MAX_DNS
;

538 for (
n
 = 0; n < 
dhcp
->
dns_count
; n++) {

539 
dhcp
->
offered_dns_addr
[
n
].
addr
 = 
	`htonl
(
	`dhcp_get_option_long
(&
option_ptr
[2 + n * 4]));

540 #if 
LWIP_DNS


541 
	`dns_setserver
( 
n
, (struct 
ip_addr
 *)(&(
dhcp
->
offered_dns_addr
[n].
addr
)));

544 #if 
LWIP_DNS


545 
	`dns_setserver
( 
n
, (struct 
ip_addr
 *)(&
ip_addr_any
));

548 
	}
}

562 
err_t


563 
	$dhcp_start
(struct 
netif
 *netif)

565 struct 
dhcp
 *dhcp;

566 
err_t
 
result
 = 
ERR_OK
;

568 
	`LWIP_ERROR
("netif != NULL", (
netif
 != 
NULL
), return 
ERR_ARG
;);

569 
dhcp
 = 
netif
->dhcp;

570 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_start(netif=%p) %c%c%"
U16_F
"\n", (void*)
netif
, netif->
name
[0], netif->name[1], (
u16_t
)netif->
num
));

573 
netif
->
flags
 &= ~
NETIF_FLAG_DHCP
;

576 if (
dhcp
 == 
NULL
) {

577 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_start(): starting new DHCP client\n"));

578 
dhcp
 = 
	`mem_malloc
(sizeof(struct dhcp));

579 if (
dhcp
 == 
NULL
) {

580 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_start(): could not allocate dhcp\n"));

581 return 
ERR_MEM
;

584 
netif
->
dhcp
 = dhcp;

585 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_start(): allocated dhcp"));

588 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 3, ("dhcp_start(): restarting DHCP configuration\n"));

592 
	`memset
(
dhcp
, 0, sizeof(struct dhcp));

594 
dhcp
->
pcb
 = 
	`udp_new
();

595 if (
dhcp
->
pcb
 == 
NULL
) {

596 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_start(): could not obtain pcb\n"));

597 
	`mem_free
((void *)
dhcp
);

598 
netif
->
dhcp
 = dhcp = 
NULL
;

599 return 
ERR_MEM
;

602 
	`udp_bind
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_CLIENT_PORT
);

603 
	`udp_connect
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_SERVER_PORT
);

605 
	`udp_recv
(
dhcp
->
pcb
, 
dhcp_recv
, 
netif
);

606 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_start(): starting DHCP configuration\n"));

608 
result
 = 
	`dhcp_discover
(
netif
);

609 if (
result
 != 
ERR_OK
) {

611 
	`dhcp_stop
(
netif
);

612 return 
ERR_MEM
;

615 
netif
->
flags
 |= 
NETIF_FLAG_DHCP
;

616 return 
result
;

617 
	}
}

629 
	$dhcp_inform
(struct 
netif
 *netif)

631 struct 
dhcp
 *dhcp, *
old_dhcp
 = 
netif
->dhcp;

632 
err_t
 
result
 = 
ERR_OK
;

633 
dhcp
 = 
	`mem_malloc
(sizeof(struct dhcp));

634 if (
dhcp
 == 
NULL
) {

635 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_inform(): could not allocate dhcp\n"));

638 
netif
->
dhcp
 = dhcp;

639 
	`memset
(
dhcp
, 0, sizeof(struct dhcp));

641 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_inform(): allocated dhcp\n"));

642 
dhcp
->
pcb
 = 
	`udp_new
();

643 if (
dhcp
->
pcb
 == 
NULL
) {

644 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_inform(): could not obtain pcb"));

645 
	`mem_free
((void *)
dhcp
);

648 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_inform(): created new udp pcb\n"));

650 
result
 = 
	`dhcp_create_request
(
netif
);

651 if (
result
 == 
ERR_OK
) {

653 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
, 
DHCP_OPTION_MESSAGE_TYPE_LEN
);

654 
	`dhcp_option_byte
(
dhcp
, 
DHCP_INFORM
);

656 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MAX_MSG_SIZE
, 
DHCP_OPTION_MAX_MSG_SIZE_LEN
);

658 
	`dhcp_option_short
(
dhcp
, 576);

660 
	`dhcp_option_trailer
(
dhcp
);

662 
	`pbuf_realloc
(
dhcp
->
p_out
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
 + dhcp->
options_out_len
);

664 
	`udp_bind
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_CLIENT_PORT
);

665 
	`udp_connect
(
dhcp
->
pcb
, 
IP_ADDR_BROADCAST
, 
DHCP_SERVER_PORT
);

666 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_inform: INFORMING\n"));

667 
	`udp_sendto_if
(
dhcp
->
pcb
, dhcp->
p_out
, 
IP_ADDR_BROADCAST
, 
DHCP_SERVER_PORT
, 
netif
);

668 
	`udp_connect
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_SERVER_PORT
);

669 
	`dhcp_delete_request
(
netif
);

671 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_inform: could not allocate DHCP request\n"));

674 if (
dhcp
 != 
NULL
) {

675 if (
dhcp
->
pcb
 != 
NULL
) {

676 
	`udp_remove
(
dhcp
->
pcb
);

678 
dhcp
->
pcb
 = 
NULL
;

679 
	`mem_free
((void *)
dhcp
);

680 
netif
->
dhcp
 = 
old_dhcp
;

682 
	}
}

684 #if 
DHCP_DOES_ARP_CHECK


691 void 
	$dhcp_arp_reply
(struct 
netif
 *netif, struct 
ip_addr
 *
addr
)

693 
	`LWIP_ERROR
("netif != NULL", (
netif
 != 
NULL
), return;);

694 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_arp_reply()\n"));

696 if ((
netif
->
dhcp
 != 
NULL
) && (netif->dhcp->
state
 == 
DHCP_CHECKING
)) {

697 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"
X32_F
"\n", 
addr
->addr));

700 if (
	`ip_addr_cmp
(
addr
, &
netif
->
dhcp
->
offered_ip_addr
)) {

702 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));

703 
	`dhcp_decline
(
netif
);

706 
	}
}

717 static 
err_t


718 
	$dhcp_decline
(struct 
netif
 *netif)

720 struct 
dhcp
 *dhcp = 
netif
->dhcp;

721 
err_t
 
result
 = 
ERR_OK
;

722 
u16_t
 
msecs
;

723 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_decline()\n"));

724 
	`dhcp_set_state
(
dhcp
, 
DHCP_BACKING_OFF
);

726 
result
 = 
	`dhcp_create_request
(
netif
);

727 if (
result
 == 
ERR_OK
) {

728 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
, 
DHCP_OPTION_MESSAGE_TYPE_LEN
);

729 
	`dhcp_option_byte
(
dhcp
, 
DHCP_DECLINE
);

731 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MAX_MSG_SIZE
, 
DHCP_OPTION_MAX_MSG_SIZE_LEN
);

732 
	`dhcp_option_short
(
dhcp
, 576);

734 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_REQUESTED_IP
, 4);

735 
	`dhcp_option_long
(
dhcp
, 
	`ntohl
(dhcp->
offered_ip_addr
.
addr
));

737 
	`dhcp_option_trailer
(
dhcp
);

739 
	`pbuf_realloc
(
dhcp
->
p_out
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
 + dhcp->
options_out_len
);

742 
	`udp_connect
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_SERVER_PORT
);

744 
	`udp_sendto_if
(
dhcp
->
pcb
, dhcp->
p_out
, 
IP_ADDR_BROADCAST
, 
DHCP_SERVER_PORT
, 
netif
);

745 
	`dhcp_delete_request
(
netif
);

746 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_decline: BACKING OFF\n"));

748 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_decline: could not allocate DHCP request\n"));

750 
dhcp
->
tries
++;

751 
msecs
 = 10*1000;

752 
dhcp
->
request_timeout
 = (
msecs
 + 
DHCP_FINE_TIMER_MSECS
 - 1) / DHCP_FINE_TIMER_MSECS;

753 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_decline(): set request timeout %"
U16_F
" msecs\n", 
msecs
));

754 return 
result
;

755 
	}
}

764 static 
err_t


765 
	$dhcp_discover
(struct 
netif
 *netif)

767 struct 
dhcp
 *dhcp = 
netif
->dhcp;

768 
err_t
 
result
 = 
ERR_OK
;

769 
u16_t
 
msecs
;

770 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_discover()\n"));

771 
	`ip_addr_set
(&
dhcp
->
offered_ip_addr
, 
IP_ADDR_ANY
);

773 
result
 = 
	`dhcp_create_request
(
netif
);

774 if (
result
 == 
ERR_OK
) {

775 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_discover: making request\n"));

776 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
, 
DHCP_OPTION_MESSAGE_TYPE_LEN
);

777 
	`dhcp_option_byte
(
dhcp
, 
DHCP_DISCOVER
);

779 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MAX_MSG_SIZE
, 
DHCP_OPTION_MAX_MSG_SIZE_LEN
);

780 
	`dhcp_option_short
(
dhcp
, 576);

782 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_PARAMETER_REQUEST_LIST
, 4 );

783 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_SUBNET_MASK
);

784 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_ROUTER
);

785 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_BROADCAST
);

786 
	`dhcp_option_byte
(
dhcp
, 
DHCP_OPTION_DNS_SERVER
);

788 
	`dhcp_option_trailer
(
dhcp
);

790 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_discover: realloc()ing\n"));

791 
	`pbuf_realloc
(
dhcp
->
p_out
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
 + dhcp->
options_out_len
);

793 
	`udp_connect
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_SERVER_PORT
);

794 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));

795 
	`udp_sendto_if
(
dhcp
->
pcb
, dhcp->
p_out
, 
IP_ADDR_BROADCAST
, 
DHCP_SERVER_PORT
, 
netif
);

796 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_discover: deleting()ing\n"));

797 
	`dhcp_delete_request
(
netif
);

798 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_discover: SELECTING\n"));

799 
	`dhcp_set_state
(
dhcp
, 
DHCP_SELECTING
);

801 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_discover: could not allocate DHCP request\n"));

803 
dhcp
->
tries
++;

804 #if 
LWIP_DHCP_AUTOIP_COOP


806 if(
dhcp
->
tries
 >= 9 && dhcp->
autoip_coop_state
 == 
DHCP_AUTOIP_COOP_STATE_OFF
) {

807 
dhcp
->
autoip_coop_state
 = 
DHCP_AUTOIP_COOP_STATE_ON
;

808 
	`autoip_start
(
netif
);

811 
msecs
 = 
dhcp
->
tries
 < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;

812 
dhcp
->
request_timeout
 = (
msecs
 + 
DHCP_FINE_TIMER_MSECS
 - 1) / DHCP_FINE_TIMER_MSECS;

813 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_discover(): set request timeout %"
U16_F
" msecs\n", 
msecs
));

814 return 
result
;

815 
	}
}

824 
	$dhcp_bind
(struct 
netif
 *netif)

826 
u32_t
 
timeout
;

827 struct 
dhcp
 *dhcp;

828 struct 
ip_addr
 
sn_mask
, 
gw_addr
;

829 
	`LWIP_ERROR
("dhcp_bind: netif != NULL", (
netif
 != 
NULL
), return;);

830 
dhcp
 = 
netif
->dhcp;

831 
	`LWIP_ERROR
("dhcp_bind: dhcp != NULL", (
dhcp
 != 
NULL
), return;);

832 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_bind(netif=%p) %c%c%"
U16_F
"\n", (void*)
netif
, netif->
name
[0], netif->name[1], (
u16_t
)netif->
num
));

835 if (
dhcp
->
offered_t1_renew
 != 0xffffffffUL) {

837 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_bind(): t1 renewal timer %"
U32_F
" secs\n", 
dhcp
->
offered_t1_renew
));

838 
timeout
 = (
dhcp
->
offered_t1_renew
 + 
DHCP_COARSE_TIMER_SECS
 / 2) / DHCP_COARSE_TIMER_SECS;

839 if(
timeout
 > 0xffff) {

840 
timeout
 = 0xffff;

842 
dhcp
->
t1_timeout
 = (
u16_t
)
timeout
;

843 if (
dhcp
->
t1_timeout
 == 0) {

844 
dhcp
->
t1_timeout
 = 1;

846 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_bind(): set request timeout %"
U32_F
" msecs\n", 
dhcp
->
offered_t1_renew
*1000));

849 if (
dhcp
->
offered_t2_rebind
 != 0xffffffffUL) {

850 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_bind(): t2 rebind timer %"
U32_F
" secs\n", 
dhcp
->
offered_t2_rebind
));

851 
timeout
 = (
dhcp
->
offered_t2_rebind
 + 
DHCP_COARSE_TIMER_SECS
 / 2) / DHCP_COARSE_TIMER_SECS;

852 if(
timeout
 > 0xffff) {

853 
timeout
 = 0xffff;

855 
dhcp
->
t2_timeout
 = (
u16_t
)
timeout
;

856 if (
dhcp
->
t2_timeout
 == 0) {

857 
dhcp
->
t2_timeout
 = 1;

859 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_bind(): set request timeout %"
U32_F
" msecs\n", 
dhcp
->
offered_t2_rebind
*1000));

862 
	`ip_addr_set
(&
sn_mask
, &
dhcp
->
offered_sn_mask
);

866 if (
sn_mask
.
addr
 == 0) {

868 
u8_t
 
first_octet
 = 
	`ip4_addr1
(&
sn_mask
);

869 if (
first_octet
 <= 127) {

870 
sn_mask
.
addr
 = 
	`htonl
(0xff000000);

871 } else if (
first_octet
 >= 192) {

872 
sn_mask
.
addr
 = 
	`htonl
(0xffffff00);

874 
sn_mask
.
addr
 = 
	`htonl
(0xffff0000);

878 
	`ip_addr_set
(&
gw_addr
, &
dhcp
->
offered_gw_addr
);

880 if (
gw_addr
.
addr
 == 0) {

882 
gw_addr
.
addr
 = (
dhcp
->
offered_ip_addr
.addr & 
sn_mask
.addr);

884 
gw_addr
.
addr
 |= 
	`htonl
(0x00000001);

887 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_STATE
, ("dhcp_bind(): IP: 0x%08"
X32_F
"\n", 
dhcp
->
offered_ip_addr
.
addr
));

888 
	`netif_set_ipaddr
(
netif
, &
dhcp
->
offered_ip_addr
);

889 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_STATE
, ("dhcp_bind(): SN: 0x%08"
X32_F
"\n", 
sn_mask
.
addr
));

890 
	`netif_set_netmask
(
netif
, &
sn_mask
);

891 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_STATE
, ("dhcp_bind(): GW: 0x%08"
X32_F
"\n", 
gw_addr
.
addr
));

892 
	`netif_set_gw
(
netif
, &
gw_addr
);

894 
	`netif_set_up
(
netif
);

896 
	`dhcp_set_state
(
dhcp
, 
DHCP_BOUND
);

897 
	}
}

904 
err_t


905 
	$dhcp_renew
(struct 
netif
 *netif)

907 struct 
dhcp
 *dhcp = 
netif
->dhcp;

908 
err_t
 
result
;

909 
u16_t
 
msecs
;

910 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_renew()\n"));

911 
	`dhcp_set_state
(
dhcp
, 
DHCP_RENEWING
);

914 
result
 = 
	`dhcp_create_request
(
netif
);

915 if (
result
 == 
ERR_OK
) {

917 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
, 
DHCP_OPTION_MESSAGE_TYPE_LEN
);

918 
	`dhcp_option_byte
(
dhcp
, 
DHCP_REQUEST
);

920 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MAX_MSG_SIZE
, 
DHCP_OPTION_MAX_MSG_SIZE_LEN
);

922 
	`dhcp_option_short
(
dhcp
, 576);

925 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_REQUESTED_IP
, 4);

926 
	`dhcp_option_long
(
dhcp
, 
	`ntohl
(dhcp->
offered_ip_addr
.
addr
));

930 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_SERVER_ID
, 4);

931 
	`dhcp_option_long
(
dhcp
, 
	`ntohl
(dhcp->
server_ip_addr
.
addr
));

934 
	`dhcp_option_trailer
(
dhcp
);

936 
	`pbuf_realloc
(
dhcp
->
p_out
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
 + dhcp->
options_out_len
);

938 
	`udp_connect
(
dhcp
->
pcb
, &dhcp->
server_ip_addr
, 
DHCP_SERVER_PORT
);

939 
	`udp_sendto_if
(
dhcp
->
pcb
, dhcp->
p_out
, &dhcp->
server_ip_addr
, 
DHCP_SERVER_PORT
, 
netif
);

940 
	`dhcp_delete_request
(
netif
);

942 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_renew: RENEWING\n"));

944 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_renew: could not allocate DHCP request\n"));

946 
dhcp
->
tries
++;

948 
msecs
 = 
dhcp
->
tries
 < 10 ? dhcp->tries * 2000 : 20 * 1000;

949 
dhcp
->
request_timeout
 = (
msecs
 + 
DHCP_FINE_TIMER_MSECS
 - 1) / DHCP_FINE_TIMER_MSECS;

950 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_renew(): set request timeout %"
U16_F
" msecs\n", 
msecs
));

951 return 
result
;

952 
	}
}

959 static 
err_t


960 
	$dhcp_rebind
(struct 
netif
 *netif)

962 struct 
dhcp
 *dhcp = 
netif
->dhcp;

963 
err_t
 
result
;

964 
u16_t
 
msecs
;

965 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_rebind()\n"));

966 
	`dhcp_set_state
(
dhcp
, 
DHCP_REBINDING
);

969 
result
 = 
	`dhcp_create_request
(
netif
);

970 if (
result
 == 
ERR_OK
) {

972 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
, 
DHCP_OPTION_MESSAGE_TYPE_LEN
);

973 
	`dhcp_option_byte
(
dhcp
, 
DHCP_REQUEST
);

975 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MAX_MSG_SIZE
, 
DHCP_OPTION_MAX_MSG_SIZE_LEN
);

976 
	`dhcp_option_short
(
dhcp
, 576);

979 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_REQUESTED_IP
, 4);

980 
	`dhcp_option_long
(
dhcp
, 
	`ntohl
(dhcp->
offered_ip_addr
.
addr
));

982 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_SERVER_ID
, 4);

983 
	`dhcp_option_long
(
dhcp
, 
	`ntohl
(dhcp->
server_ip_addr
.
addr
));

986 
	`dhcp_option_trailer
(
dhcp
);

988 
	`pbuf_realloc
(
dhcp
->
p_out
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
 + dhcp->
options_out_len
);

991 
	`udp_connect
(
dhcp
->
pcb
, 
IP_ADDR_ANY
, 
DHCP_SERVER_PORT
);

992 
	`udp_sendto_if
(
dhcp
->
pcb
, dhcp->
p_out
, 
IP_ADDR_BROADCAST
, 
DHCP_SERVER_PORT
, 
netif
);

993 
	`dhcp_delete_request
(
netif
);

994 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_rebind: REBINDING\n"));

996 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_rebind: could not allocate DHCP request\n"));

998 
dhcp
->
tries
++;

999 
msecs
 = 
dhcp
->
tries
 < 10 ? dhcp->tries * 1000 : 10 * 1000;

1000 
dhcp
->
request_timeout
 = (
msecs
 + 
DHCP_FINE_TIMER_MSECS
 - 1) / DHCP_FINE_TIMER_MSECS;

1001 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_rebind(): set request timeout %"
U16_F
" msecs\n", 
msecs
));

1002 return 
result
;

1003 
	}
}

1010 
err_t


1011 
	$dhcp_release
(struct 
netif
 *netif)

1013 struct 
dhcp
 *dhcp = 
netif
->dhcp;

1014 
err_t
 
result
;

1015 
u16_t
 
msecs
;

1016 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_release()\n"));

1019 
	`dhcp_set_state
(
dhcp
, 
DHCP_OFF
);

1021 
dhcp
->
server_ip_addr
.
addr
 = 0;

1022 
dhcp
->
offered_ip_addr
.
addr
 = dhcp->
offered_sn_mask
.addr = 0;

1023 
dhcp
->
offered_gw_addr
.
addr
 = dhcp->
offered_bc_addr
.addr = 0;

1024 
dhcp
->
offered_t0_lease
 = dhcp->
offered_t1_renew
 = dhcp->
offered_t2_rebind
 = 0;

1025 
dhcp
->
dns_count
 = 0;

1028 
result
 = 
	`dhcp_create_request
(
netif
);

1029 if (
result
 == 
ERR_OK
) {

1030 
	`dhcp_option
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
, 
DHCP_OPTION_MESSAGE_TYPE_LEN
);

1031 
	`dhcp_option_byte
(
dhcp
, 
DHCP_RELEASE
);

1033 
	`dhcp_option_trailer
(
dhcp
);

1035 
	`pbuf_realloc
(
dhcp
->
p_out
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
 + dhcp->
options_out_len
);

1037 
	`udp_connect
(
dhcp
->
pcb
, &dhcp->
server_ip_addr
, 
DHCP_SERVER_PORT
);

1038 
	`udp_sendto_if
(
dhcp
->
pcb
, dhcp->
p_out
, &dhcp->
server_ip_addr
, 
DHCP_SERVER_PORT
, 
netif
);

1039 
	`dhcp_delete_request
(
netif
);

1040 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_release: RELEASED, DHCP_OFF\n"));

1042 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_release: could not allocate DHCP request\n"));

1044 
dhcp
->
tries
++;

1045 
msecs
 = 
dhcp
->
tries
 < 10 ? dhcp->tries * 1000 : 10 * 1000;

1046 
dhcp
->
request_timeout
 = (
msecs
 + 
DHCP_FINE_TIMER_MSECS
 - 1) / DHCP_FINE_TIMER_MSECS;

1047 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("dhcp_release(): set request timeout %"
U16_F
" msecs\n", 
msecs
));

1049 
	`netif_set_down
(
netif
);

1051 
	`netif_set_ipaddr
(
netif
, 
IP_ADDR_ANY
);

1052 
	`netif_set_gw
(
netif
, 
IP_ADDR_ANY
);

1053 
	`netif_set_netmask
(
netif
, 
IP_ADDR_ANY
);

1056 return 
result
;

1057 
	}
}

1065 
	$dhcp_stop
(struct 
netif
 *netif)

1067 struct 
dhcp
 *dhcp = 
netif
->dhcp;

1068 
	`LWIP_ERROR
("dhcp_stop: netif != NULL", (
netif
 != 
NULL
), return;);

1070 
netif
->
flags
 &= ~
NETIF_FLAG_DHCP
;

1072 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_stop()\n"));

1074 if (
dhcp
 != 
NULL
) {

1075 if (
dhcp
->
pcb
 != 
NULL
) {

1076 
	`udp_remove
(
dhcp
->
pcb
);

1077 
dhcp
->
pcb
 = 
NULL
;

1079 if (
dhcp
->
p
 != 
NULL
) {

1080 
	`pbuf_free
(
dhcp
->
p
);

1081 
dhcp
->
p
 = 
NULL
;

1084 
	`dhcp_free_reply
(
dhcp
);

1085 
	`mem_free
((void *)
dhcp
);

1086 
netif
->
dhcp
 = 
NULL
;

1088 
	}
}

1098 
	$dhcp_set_state
(struct 
dhcp
 *dhcp, 
u8_t
 
new_state
)

1100 if (
new_state
 != 
dhcp
->
state
) {

1101 
dhcp
->
state
 = 
new_state
;

1102 
dhcp
->
tries
 = 0;

1104 
	}
}

1112 
	$dhcp_option
(struct 
dhcp
 *dhcp, 
u8_t
 
option_type
, u8_t 
option_len
)

1114 
	`LWIP_ASSERT
("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", 
dhcp
->
options_out_len
 + 2U + 
option_len
 <= 
DHCP_OPTIONS_LEN
);

1115 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = 
option_type
;

1116 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = 
option_len
;

1117 
	}
}

1123 
	$dhcp_option_byte
(struct 
dhcp
 *dhcp, 
u8_t
 
value
)

1125 
	`LWIP_ASSERT
("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", 
dhcp
->
options_out_len
 < 
DHCP_OPTIONS_LEN
);

1126 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = 
value
;

1127 
	}
}

1130 
	$dhcp_option_short
(struct 
dhcp
 *dhcp, 
u16_t
 
value
)

1132 
	`LWIP_ASSERT
("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", 
dhcp
->
options_out_len
 + 2U <= 
DHCP_OPTIONS_LEN
);

1133 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = (
u8_t
)((
value
 & 0xff00U) >> 8);

1134 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = (
u8_t
) (
value
 & 0x00ffU);

1135 
	}
}

1138 
	$dhcp_option_long
(struct 
dhcp
 *dhcp, 
u32_t
 
value
)

1140 
	`LWIP_ASSERT
("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", 
dhcp
->
options_out_len
 + 4U <= 
DHCP_OPTIONS_LEN
);

1141 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = (
u8_t
)((
value
 & 0xff000000UL) >> 24);

1142 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = (
u8_t
)((
value
 & 0x00ff0000UL) >> 16);

1143 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = (
u8_t
)((
value
 & 0x0000ff00UL) >> 8);

1144 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = (
u8_t
)((
value
 & 0x000000ffUL));

1145 
	}
}

1157 static 
err_t


1158 
	$dhcp_unfold_reply
(struct 
dhcp
 *dhcp)

1160 
u16_t
 
ret
;

1161 
	`LWIP_ERROR
("dhcp != NULL", (
dhcp
 != 
NULL
), return 
ERR_ARG
;);

1162 
	`LWIP_ERROR
("dhcp->p != NULL", (
dhcp
->
p
 != 
NULL
), return 
ERR_VAL
;);

1164 
	`dhcp_free_reply
(
dhcp
);

1166 if (
dhcp
->
p
->
tot_len
 > (sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
)) {

1167 
dhcp
->
options_in_len
 = dhcp->
p
->
tot_len
 - (sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
);

1168 
dhcp
->
options_in
 = 
	`mem_malloc
(dhcp->
options_in_len
);

1169 if (
dhcp
->
options_in
 == 
NULL
) {

1170 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));

1171 return 
ERR_MEM
;

1174 
dhcp
->
msg_in
 = 
	`mem_malloc
(sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
);

1175 if (
dhcp
->
msg_in
 == 
NULL
) {

1176 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));

1177 
	`mem_free
((void *)
dhcp
->
options_in
);

1178 
dhcp
->
options_in
 = 
NULL
;

1179 return 
ERR_MEM
;

1183 
ret
 = 
	`pbuf_copy_partial
(
dhcp
->
p
, dhcp->
msg_in
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
, 0);

1184 
	`LWIP_ASSERT
("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", 
ret
 == sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
);

1185 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_unfold_reply(): copied %"
U16_F
" bytes into dhcp->msg_in[]\n",

1186 sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
));

1188 if (
dhcp
->
options_in
 != 
NULL
) {

1190 
ret
 = 
	`pbuf_copy_partial
(
dhcp
->
p
, dhcp->
options_in
, dhcp->
options_in_len
, sizeof(struct 
dhcp_msg
) - 
DHCP_OPTIONS_LEN
);

1191 
	`LWIP_ASSERT
("ret == dhcp->options_in_len", 
ret
 == 
dhcp
->
options_in_len
);

1192 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("dhcp_unfold_reply(): copied %"
U16_F
" bytes to dhcp->options_in[]\n",

1193 
dhcp
->
options_in_len
));

1195 
	`LWIP_UNUSED_ARG
(
ret
);

1196 return 
ERR_OK
;

1197 
	}
}

1204 static void 
	$dhcp_free_reply
(struct 
dhcp
 *dhcp)

1206 if (
dhcp
->
msg_in
 != 
NULL
) {

1207 
	`mem_free
((void *)
dhcp
->
msg_in
);

1208 
dhcp
->
msg_in
 = 
NULL
;

1210 if (
dhcp
->
options_in
) {

1211 
	`mem_free
((void *)
dhcp
->
options_in
);

1212 
dhcp
->
options_in
 = 
NULL
;

1213 
dhcp
->
options_in_len
 = 0;

1215 
	`LWIP_DEBUGF
(
DHCP_DEBUG
, ("dhcp_free_reply(): free'd\n"));

1216 
	}
}

1222 static void 
	$dhcp_recv
(void *
arg
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
)

1224 struct 
netif
 *netif = (struct netif *)
arg
;

1225 struct 
dhcp
 *dhcp = 
netif
->dhcp;

1226 struct 
dhcp_msg
 *
reply_msg
 = (struct dhcp_msg *)
p
->
payload
;

1227 
u8_t
 *
options_ptr
;

1228 
u8_t
 
msg_type
;

1229 
u8_t
 
i
;

1230 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("dhcp_recv(pbuf = %p) from DHCP server %"
U16_F
".%"U16_F".%"U16_F".%"U16_F" port %"U16_F"\n", (void*)
p
,

1231 (
u16_t
)(
	`ntohl
(
addr
->addr) >> 24 & 0xff), (u16_t)(ntohl(addr->addr) >> 16 & 0xff),

1232 (
u16_t
)(
	`ntohl
(
addr
->addr) >> 8 & 0xff), (u16_t)(ntohl(addr->addr) & 0xff), 
port
));

1233 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("pbuf->len = %"
U16_F
"\n", 
p
->
len
));

1234 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("pbuf->tot_len = %"
U16_F
"\n", 
p
->
tot_len
));

1236 
	`LWIP_UNUSED_ARG
(
pcb
);

1237 
	`LWIP_UNUSED_ARG
(
addr
);

1238 
	`LWIP_UNUSED_ARG
(
port
);

1239 
dhcp
->
p
 = p;

1241 if (
reply_msg
->
op
 != 
DHCP_BOOTREPLY
) {

1242 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("not a DHCP reply message, but type %"
U16_F
"\n", (
u16_t
)
reply_msg
->
op
));

1243 goto 
free_pbuf_and_return
;

1246 for (
i
 = 0; i < 
netif
->
hwaddr_len
; i++) {

1247 if (
netif
->
hwaddr
[
i
] != 
reply_msg
->
chaddr
[i]) {

1248 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("netif->hwaddr[%"
U16_F
"]==%02"
X16_F
" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",

1249 (
u16_t
)
i
, (u16_t)
netif
->
hwaddr
[i], (u16_t)i, (u16_t)
reply_msg
->
chaddr
[i]));

1250 goto 
free_pbuf_and_return
;

1254 if (
	`ntohl
(
reply_msg
->
xid
) != 
dhcp
->xid) {

1255 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("transaction id mismatch reply_msg->xid(%"
X32_F
")!=dhcp->xid(%"X32_F")\n",
	`ntohl
(
reply_msg
->
xid
),
dhcp
->xid));

1256 goto 
free_pbuf_and_return
;

1259 if (
	`dhcp_unfold_reply
(
dhcp
) != 
ERR_OK
) {

1260 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("problem unfolding DHCP message - too short on memory?\n"));

1261 goto 
free_pbuf_and_return
;

1264 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));

1266 
options_ptr
 = 
	`dhcp_get_option_ptr
(
dhcp
, 
DHCP_OPTION_MESSAGE_TYPE
);

1267 if (
options_ptr
 == 
NULL
) {

1268 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));

1269 goto 
free_pbuf_and_return
;

1273 
msg_type
 = 
	`dhcp_get_option_byte
(
options_ptr
 + 2);

1275 if (
msg_type
 == 
DHCP_ACK
) {

1276 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("DHCP_ACK received\n"));

1278 if (
dhcp
->
state
 == 
DHCP_REQUESTING
) {

1279 
	`dhcp_handle_ack
(
netif
);

1280 
dhcp
->
request_timeout
 = 0;

1281 #if 
DHCP_DOES_ARP_CHECK


1283 
	`dhcp_check
(
netif
);

1286 
	`dhcp_bind
(
netif
);

1290 else if ((
dhcp
->
state
 == 
DHCP_REBOOTING
) || (dhcp->state == 
DHCP_REBINDING
) || (dhcp->state == 
DHCP_RENEWING
)) {

1291 
dhcp
->
request_timeout
 = 0;

1292 
	`dhcp_bind
(
netif
);

1296 else if ((
msg_type
 == 
DHCP_NAK
) &&

1297 ((
dhcp
->
state
 == 
DHCP_REBOOTING
) || (dhcp->state == 
DHCP_REQUESTING
) ||

1298 (
dhcp
->
state
 == 
DHCP_REBINDING
) || (dhcp->state == 
DHCP_RENEWING
 ))) {

1299 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("DHCP_NAK received\n"));

1300 
dhcp
->
request_timeout
 = 0;

1301 
	`dhcp_handle_nak
(
netif
);

1304 else if ((
msg_type
 == 
DHCP_OFFER
) && (
dhcp
->
state
 == 
DHCP_SELECTING
)) {

1305 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));

1306 
dhcp
->
request_timeout
 = 0;

1308 
	`dhcp_handle_offer
(
netif
);

1310 
free_pbuf_and_return
:

1311 
	`pbuf_free
(
p
);

1312 
dhcp
->
p
 = 
NULL
;

1313 
	}
}

1320 static 
err_t


1321 
	$dhcp_create_request
(struct 
netif
 *netif)

1323 struct 
dhcp
 *dhcp;

1324 
u16_t
 
i
;

1325 
	`LWIP_ERROR
("dhcp_create_request: netif != NULL", (
netif
 != 
NULL
), return 
ERR_ARG
;);

1326 
dhcp
 = 
netif
->dhcp;

1327 
	`LWIP_ERROR
("dhcp_create_request: dhcp != NULL", (
dhcp
 != 
NULL
), return 
ERR_VAL
;);

1328 
	`LWIP_ASSERT
("dhcp_create_request: dhcp->p_out == NULL", 
dhcp
->
p_out
 == 
NULL
);

1329 
	`LWIP_ASSERT
("dhcp_create_request: dhcp->msg_out == NULL", 
dhcp
->
msg_out
 == 
NULL
);

1330 
dhcp
->
p_out
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, sizeof(struct 
dhcp_msg
), 
PBUF_RAM
);

1331 if (
dhcp
->
p_out
 == 
NULL
) {

1332 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("dhcp_create_request(): could not allocate pbuf\n"));

1333 return 
ERR_MEM
;

1335 
	`LWIP_ASSERT
("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",

1336 (
dhcp
->
p_out
->
len
 >= sizeof(struct 
dhcp_msg
)));

1339 
dhcp
->
xid
 = xid++;

1340 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("transaction id xid++(%"
X32_F
") dhcp->xid(%"
U32_F
")\n",
xid
,
dhcp
->xid));

1342 
dhcp
->
msg_out
 = (struct 
dhcp_msg
 *)dhcp->
p_out
->
payload
;

1344 
dhcp
->
msg_out
->
op
 = 
DHCP_BOOTREQUEST
;

1346 
dhcp
->
msg_out
->
htype
 = 
DHCP_HTYPE_ETH
;

1348 
dhcp
->
msg_out
->
hlen
 = 
DHCP_HLEN_ETH
;

1349 
dhcp
->
msg_out
->
hops
 = 0;

1350 
dhcp
->
msg_out
->
xid
 = 
	`htonl
(dhcp->xid);

1351 
dhcp
->
msg_out
->
secs
 = 0;

1352 
dhcp
->
msg_out
->
flags
 = 0;

1353 
dhcp
->
msg_out
->
ciaddr
.
addr
 = 
netif
->
ip_addr
.addr;

1354 
dhcp
->
msg_out
->
yiaddr
.
addr
 = 0;

1355 
dhcp
->
msg_out
->
siaddr
.
addr
 = 0;

1356 
dhcp
->
msg_out
->
giaddr
.
addr
 = 0;

1357 for (
i
 = 0; i < 
DHCP_CHADDR_LEN
; i++) {

1359 
dhcp
->
msg_out
->
chaddr
[
i
] = (i < 
netif
->
hwaddr_len
) ? netif->
hwaddr
[i] : 0 ;

1361 for (
i
 = 0; i < 
DHCP_SNAME_LEN
; i++) {

1362 
dhcp
->
msg_out
->
sname
[
i
] = 0;

1364 for (
i
 = 0; i < 
DHCP_FILE_LEN
; i++) {

1365 
dhcp
->
msg_out
->
file
[
i
] = 0;

1367 
dhcp
->
msg_out
->
cookie
 = 
	`htonl
(0x63825363UL);

1368 
dhcp
->
options_out_len
 = 0;

1370 for (
i
 = 0; i < 
DHCP_OPTIONS_LEN
; i++) {

1371 
dhcp
->
msg_out
->
options
[
i
] = (
u8_t
)i;

1373 return 
ERR_OK
;

1374 
	}
}

1382 
	$dhcp_delete_request
(struct 
netif
 *netif)

1384 struct 
dhcp
 *dhcp;

1385 
	`LWIP_ERROR
("dhcp_delete_request: netif != NULL", (
netif
 != 
NULL
), return;);

1386 
dhcp
 = 
netif
->dhcp;

1387 
	`LWIP_ERROR
("dhcp_delete_request: dhcp != NULL", (
dhcp
 != 
NULL
), return;);

1388 
	`LWIP_ASSERT
("dhcp_delete_request: dhcp->p_out != NULL", 
dhcp
->
p_out
 != 
NULL
);

1389 
	`LWIP_ASSERT
("dhcp_delete_request: dhcp->msg_out != NULL", 
dhcp
->
msg_out
 != 
NULL
);

1390 if (
dhcp
->
p_out
 != 
NULL
) {

1391 
	`pbuf_free
(
dhcp
->
p_out
);

1393 
dhcp
->
p_out
 = 
NULL
;

1394 
dhcp
->
msg_out
 = 
NULL
;

1395 
	}
}

1406 
	$dhcp_option_trailer
(struct 
dhcp
 *dhcp)

1408 
	`LWIP_ERROR
("dhcp_option_trailer: dhcp != NULL", (
dhcp
 != 
NULL
), return;);

1409 
	`LWIP_ASSERT
("dhcp_option_trailer: dhcp->msg_out != NULL\n", 
dhcp
->
msg_out
 != 
NULL
);

1410 
	`LWIP_ASSERT
("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", 
dhcp
->
options_out_len
 < 
DHCP_OPTIONS_LEN
);

1411 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = 
DHCP_OPTION_END
;

1413 while ((
dhcp
->
options_out_len
 < 
DHCP_MIN_OPTIONS_LEN
) || (dhcp->options_out_len & 3)) {

1415 
	`LWIP_ASSERT
("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", 
dhcp
->
options_out_len
 < 
DHCP_OPTIONS_LEN
);

1417 
dhcp
->
msg_out
->
options
[dhcp->
options_out_len
++] = 0;

1419 
	}
}

1430 static 
u8_t
 *
	$dhcp_get_option_ptr
(struct 
dhcp
 *dhcp, 
u8_t
 
option_type
)

1432 
u8_t
 
overload
 = 
DHCP_OVERLOAD_NONE
;

1435 if ((
dhcp
->
options_in
 != 
NULL
) && (dhcp->
options_in_len
 > 0)) {

1437 
u8_t
 *
options
 = (u8_t *)
dhcp
->
options_in
;

1438 
u16_t
 
offset
 = 0;

1440 while ((
offset
 < 
dhcp
->
options_in_len
) && (
options
[offset] != 
DHCP_OPTION_END
)) {

1443 if (
options
[
offset
] == 
DHCP_OPTION_OVERLOAD
) {

1444 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("overloaded message detected\n"));

1446 
offset
 += 2;

1447 
overload
 = 
options
[
offset
++];

1450 else if (
options
[
offset
] == 
option_type
) {

1451 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("option found at offset %"
U16_F
" in options\n", 
offset
));

1452 return &
options
[
offset
];

1455 
	`LWIP_DEBUGF
(
DHCP_DEBUG
, ("skipping option %"
U16_F
" in options\n", 
options
[
offset
]));

1457 
offset
++;

1459 
offset
 += 1 + 
options
[offset];

1463 if (
overload
 != 
DHCP_OVERLOAD_NONE
) {

1464 
u16_t
 
field_len
;

1465 if (
overload
 == 
DHCP_OVERLOAD_FILE
) {

1466 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("overloaded file field\n"));

1467 
options
 = (
u8_t
 *)&
dhcp
->
msg_in
->
file
;

1468 
field_len
 = 
DHCP_FILE_LEN
;

1469 } else if (
overload
 == 
DHCP_OVERLOAD_SNAME
) {

1470 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("overloaded sname field\n"));

1471 
options
 = (
u8_t
 *)&
dhcp
->
msg_in
->
sname
;

1472 
field_len
 = 
DHCP_SNAME_LEN
;

1475 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("overloaded sname and file field\n"));

1476 
options
 = (
u8_t
 *)&
dhcp
->
msg_in
->
sname
;

1477 
field_len
 = 
DHCP_FILE_LEN
 + 
DHCP_SNAME_LEN
;

1479 
offset
 = 0;

1482 while ((
offset
 < 
field_len
) && (
options
[offset] != 
DHCP_OPTION_END
)) {

1483 if (
options
[
offset
] == 
option_type
) {

1484 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("option found at offset=%"
U16_F
"\n", 
offset
));

1485 return &
options
[
offset
];

1488 
	`LWIP_DEBUGF
(
DHCP_DEBUG
 | 
LWIP_DBG_TRACE
, ("skipping option %"
U16_F
"\n", 
options
[
offset
]));

1490 
offset
++;

1491 
offset
 += 1 + 
options
[offset];

1496 return 
NULL
;

1497 
	}
}

1507 static 
u8_t


1508 
	$dhcp_get_option_byte
(
u8_t
 *
ptr
)

1510 
	`LWIP_DEBUGF
(
DHCP_DEBUG
, ("option byte value=%"
U16_F
"\n", (
u16_t
)(*
ptr
)));

1511 return *
ptr
;

1512 
	}
}

1523 static 
u16_t


1524 
	$dhcp_get_option_short
(
u8_t
 *
ptr
)

1526 
u16_t
 
value
;

1527 
value
 = *
ptr
++ << 8;

1528 
value
 |= *
ptr
;

1529 
	`LWIP_DEBUGF
(
DHCP_DEBUG
, ("option short value=%"
U16_F
"\n", 
value
));

1530 return 
value
;

1531 
	}
}

1542 static 
u32_t
 
	$dhcp_get_option_long
(
u8_t
 *
ptr
)

1544 
u32_t
 
value
;

1545 
value
 = (
u32_t
)(*
ptr
++) << 24;

1546 
value
 |= (
u32_t
)(*
ptr
++) << 16;

1547 
value
 |= (
u32_t
)(*
ptr
++) << 8;

1548 
value
 |= (
u32_t
)(*
ptr
++);

1549 
	`LWIP_DEBUGF
(
DHCP_DEBUG
, ("option long value=%"
U32_F
"\n", 
value
));

1550 return 
value
;

1551 
	}
}

	@/root/Robux/net/lwip/core/dns.c

75 #include 
	~"lwip/opt.h
"

77 #if 
LWIP_DNS


79 #include 
	~"lwip/udp.h
"

80 #include 
	~"lwip/mem.h
"

81 #include 
	~"lwip/dns.h
"

83 #include 
	~<string.h
>

86 #ifndef 
DNS_SERVER_ADDRESS


87 #define 
	#DNS_SERVER_ADDRESS
 
	`inet_addr
("208.67.222.222")

	)

91 #ifndef 
DNS_SERVER_PORT


92 #define 
	#DNS_SERVER_PORT
 53

	)

96 #ifndef 
DNS_MAX_RETRIES


97 #define 
	#DNS_MAX_RETRIES
 4

	)

101 #ifndef 
DNS_MAX_TTL


102 #define 
	#DNS_MAX_TTL
 604800

	)

106 #define 
	#DNS_FLAG1_RESPONSE
 0x80

	)

107 #define 
	#DNS_FLAG1_OPCODE_STATUS
 0x10

	)

108 #define 
	#DNS_FLAG1_OPCODE_INVERSE
 0x08

	)

109 #define 
	#DNS_FLAG1_OPCODE_STANDARD
 0x00

	)

110 #define 
	#DNS_FLAG1_AUTHORATIVE
 0x04

	)

111 #define 
	#DNS_FLAG1_TRUNC
 0x02

	)

112 #define 
	#DNS_FLAG1_RD
 0x01

	)

113 #define 
	#DNS_FLAG2_RA
 0x80

	)

114 #define 
	#DNS_FLAG2_ERR_MASK
 0x0f

	)

115 #define 
	#DNS_FLAG2_ERR_NONE
 0x00

	)

116 #define 
	#DNS_FLAG2_ERR_NAME
 0x03

	)

119 #define 
	#DNS_STATE_UNUSED
 0

	)

120 #define 
	#DNS_STATE_NEW
 1

	)

121 #define 
	#DNS_STATE_ASKING
 2

	)

122 #define 
	#DNS_STATE_DONE
 3

	)

124 #ifdef 
PACK_STRUCT_USE_INCLUDES


125 #include 
	~"arch/bpstruct.h
"

127 
PACK_STRUCT_BEGIN


129 struct 
	sdns_hdr
 {

130 
u16_t
 
	mid
;

131 
u8_t
 
	mflags1
;

132 
u8_t
 
	mflags2
;

133 
u16_t
 
	mnumquestions
;

134 
u16_t
 
	mnumanswers
;

135 
u16_t
 
	mnumauthrr
;

136 
u16_t
 
	mnumextrarr
;

137 } 
	gPACK_STRUCT_STRUCT
;

138 
	gPACK_STRUCT_END


139 #ifdef 
PACK_STRUCT_USE_INCLUDES


140 #include 
	~"arch/epstruct.h
"

143 #ifdef 
PACK_STRUCT_USE_INCLUDES


144 #include 
	~"arch/bpstruct.h
"

146 
PACK_STRUCT_BEGIN


148 struct 
	sdns_query
 {

151 
u16_t
 
	mtype
;

152 
u16_t
 
	mclass
;

153 } 
	gPACK_STRUCT_STRUCT
;

154 
	gPACK_STRUCT_END


155 #ifdef 
PACK_STRUCT_USE_INCLUDES


156 #include 
	~"arch/epstruct.h
"

159 #ifdef 
PACK_STRUCT_USE_INCLUDES


160 #include 
	~"arch/bpstruct.h
"

162 
PACK_STRUCT_BEGIN


164 struct 
	sdns_answer
 {

167 
u16_t
 
	mtype
;

168 
u16_t
 
	mclass
;

169 
u32_t
 
	mttl
;

170 
u16_t
 
	mlen
;

171 } 
	gPACK_STRUCT_STRUCT
;

172 
	gPACK_STRUCT_END


173 #ifdef 
PACK_STRUCT_USE_INCLUDES


174 #include 
	~"arch/epstruct.h
"

178 struct 
	sdns_table_entry
 {

179 
u8_t
 
	mstate
;

180 
u8_t
 
	mnumdns
;

181 
u8_t
 
	mtmr
;

182 
u8_t
 
	mretries
;

183 
u8_t
 
	mseqno
;

184 
u8_t
 
	merr
;

185 
u32_t
 
	mttl
;

186 char 
	mname
[
DNS_MAX_NAME_LENGTH
];

187 struct 
ip_addr
 
	mipaddr
;

189 
dns_found_callback
 
	mfound
;

190 void *
	marg
;

195 static void 
dns_recv
(void *
s
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
);

196 static void 
dns_check_entries
(void);

203 static struct 
udp_pcb
 *
	gdns_pcb
;

204 static 
u8_t
 
	gdns_seqno
;

205 static struct 
dns_table_entry
 
	gdns_table
[
DNS_TABLE_SIZE
];

206 static struct 
ip_addr
 
	gdns_servers
[
DNS_MAX_SERVERS
];

208 #if (
DNS_USES_STATIC_BUF
 == 1)

209 static 
u8_t
 
	gdns_payload
[
DNS_MSG_SIZE
];

217 
	$dns_init
()

219 struct 
ip_addr
 
dnsserver
;

222 
dnsserver
.
addr
 = 
DNS_SERVER_ADDRESS
;

224 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_init: initializing\n"));

227 if (
dns_pcb
 == 
NULL
) {

228 
dns_pcb
 = 
	`udp_new
();

230 if (
dns_pcb
 != 
NULL
) {

233 
	`LWIP_ASSERT
("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",

234 
DNS_STATE_UNUSED
 == 0);

237 
	`udp_bind
(
dns_pcb
, 
IP_ADDR_ANY
, 0);

238 
	`udp_recv
(
dns_pcb
, 
dns_recv
, 
NULL
);

241 
	`dns_setserver
(0, &
dnsserver
);

244 
	}
}

253 
	$dns_setserver
(
u8_t
 
numdns
, struct 
ip_addr
 *
dnsserver
)

255 if ((
numdns
 < 
DNS_MAX_SERVERS
) && (
dns_pcb
 != 
NULL
) &&

256 (
dnsserver
 != 
NULL
) && (dnsserver->
addr
 !=0 )) {

257 
dns_servers
[
numdns
] = (*
dnsserver
);

259 
	}
}

268 struct 
ip_addr


269 
	$dns_getserver
(
u8_t
 
numdns
)

271 if (
numdns
 < 
DNS_MAX_SERVERS
) {

272 return 
dns_servers
[
numdns
];

274 return *
IP_ADDR_ANY
;

276 
	}
}

283 
	$dns_tmr
(void)

285 if (
dns_pcb
 != 
NULL
) {

286 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_tmr: dns_check_entries\n"));

287 
	`dns_check_entries
();

289 
	}
}

304 static 
u32_t


305 
	$dns_lookup
(const char *
name
)

307 
u8_t
 
i
;

310 for (
i
 = 0; i < 
DNS_TABLE_SIZE
; ++i) {

311 if ((
dns_table
[
i
].
state
 == 
DNS_STATE_DONE
) &&

312 (
	`strcmp
(
name
, 
dns_table
[
i
].name) == 0)) {

313 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_lookup: \"%s\": found = ", 
name
));

314 
	`ip_addr_debug_print
(
DNS_DEBUG
, &(
dns_table
[
i
].
ipaddr
));

315 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("\n"));

316 return 
dns_table
[
i
].
ipaddr
.
addr
;

321 
	}
}

323 #if 
DNS_DOES_NAME_CHECK


334 static 
u8_t


335 
	$dns_compare_name
(unsigned char *
query
, unsigned char *
response
)

337 unsigned char 
n
;

340 
n
 = *
response
++;

342 if ((
n
 & 0xc0) == 0xc0) {

347 while (
n
 > 0) {

348 if ((*
query
) != (*
response
)) {

351 ++
response
;

352 ++
query
;

353 --
n
;

355 ++
query
;

357 } while (*
response
 != 0);

360 
	}
}

370 
	$dns_parse_name
(unsigned char *
query
)

372 unsigned char 
n
;

375 
n
 = *
query
++;

377 if ((
n
 & 0xc0) == 0xc0) {

382 while (
n
 > 0) {

383 ++
query
;

384 --
n
;

387 } while (*
query
 != 0);

389 return 
query
 + 1;

390 
	}
}

401 static 
err_t


402 
	$dns_send
(
u8_t
 
numdns
, const char* 
name
, u8_t 
id
)

404 
err_t
 
err
;

405 struct 
dns_hdr
 *
hdr
;

406 struct 
dns_query
 
qry
;

407 struct 
pbuf
 *
p
;

408 char *
query
, *
nptr
;

409 const char *
pHostname
;

410 
u8_t
 
n
;

412 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_send: dns_servers[%"
U16_F
"] \"%s\": request\n",

413 (
u16_t
)(
numdns
), 
name
));

414 
	`LWIP_ASSERT
("dns server out of array", 
numdns
 < 
DNS_MAX_SERVERS
);

415 
	`LWIP_ASSERT
("dns server has no IP address set", 
dns_servers
[
numdns
].
addr
 != 0);

418 
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, sizeof(struct 
dns_hdr
) + 
DNS_MAX_NAME_LENGTH
 +

419 sizeof(struct 
dns_query
), 
PBUF_RAM
);

420 if (
p
 != 
NULL
) {

421 
	`LWIP_ASSERT
("pbuf must be in one piece", 
p
->
next
 == 
NULL
);

423 
hdr
 = (struct 
dns_hdr
*)
p
->
payload
;

424 
	`memset
(
hdr
, 0, sizeof(struct 
dns_hdr
));

425 
hdr
->
id
 = 
	`htons
(id);

426 
hdr
->
flags1
 = 
DNS_FLAG1_RD
;

427 
hdr
->
numquestions
 = 
	`htons
(1);

428 
query
 = (char*)
hdr
 + sizeof(struct 
dns_hdr
);

429 
pHostname
 = 
name
;

430 --
pHostname
;

434 ++
pHostname
;

435 
nptr
 = 
query
;

436 ++
query
;

437 for(
n
 = 0; *
pHostname
 != '.' && *pHostname != 0; ++pHostname) {

438 *
query
 = *
pHostname
;

439 ++
query
;

440 ++
n
;

442 *
nptr
 = 
n
;

443 } while(*
pHostname
 != 0);

444 *
query
++='\0';

447 
qry
.
type
 = 
	`htons
(
DNS_RRTYPE_A
);

448 
qry
.
class
 = 
	`htons
(
DNS_RRCLASS_IN
);

449 
	`MEMCPY
( 
query
, &
qry
, sizeof(struct 
dns_query
));

452 
	`pbuf_realloc
(
p
, (
query
 + sizeof(struct 
dns_query
)) - ((char*)(p->
payload
)));

455 
	`udp_connect
(
dns_pcb
, &
dns_servers
[
numdns
], 
DNS_SERVER_PORT
);

457 
err
 = 
	`udp_sendto
(
dns_pcb
, 
p
, &
dns_servers
[
numdns
], 
DNS_SERVER_PORT
);

460 
	`pbuf_free
(
p
);

462 
err
 = 
ERR_MEM
;

465 return 
err
;

466 
	}
}

478 
	$dns_check_entry
(
u8_t
 
i
)

480 struct 
dns_table_entry
 *
pEntry
 = &
dns_table
[
i
];

482 
	`LWIP_ASSERT
("array index out of bounds", 
i
 < 
DNS_TABLE_SIZE
);

484 switch(
pEntry
->
state
) {

486 case 
DNS_STATE_NEW
: {

488 
pEntry
->
state
 = 
DNS_STATE_ASKING
;

489 
pEntry
->
numdns
 = 0;

490 
pEntry
->
tmr
 = 1;

491 
pEntry
->
retries
 = 0;

494 
	`dns_send
(
pEntry
->
numdns
, pEntry->
name
, 
i
);

498 case 
DNS_STATE_ASKING
: {

499 if (--
pEntry
->
tmr
 == 0) {

500 if (++
pEntry
->
retries
 == 
DNS_MAX_RETRIES
) {

501 if ((
pEntry
->
numdns
+1<
DNS_MAX_SERVERS
) && (
dns_servers
[pEntry->numdns+1].
addr
!=0)) {

503 
pEntry
->
numdns
++;

504 
pEntry
->
tmr
 = 1;

505 
pEntry
->
retries
 = 0;

508 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_check_entry: \"%s\": timeout\n", 
pEntry
->
name
));

510 if (
pEntry
->
found
)

511 (*
pEntry
->
found
)(pEntry->
name
, 
NULL
, pEntry->
arg
);

513 
pEntry
->
state
 = 
DNS_STATE_UNUSED
;

514 
pEntry
->
found
 = 
NULL
;

520 
pEntry
->
tmr
 = pEntry->
retries
;

523 
	`dns_send
(
pEntry
->
numdns
, pEntry->
name
, 
i
);

528 case 
DNS_STATE_DONE
: {

530 if (--
pEntry
->
ttl
 == 0) {

531 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_check_entry: \"%s\": flush\n", 
pEntry
->
name
));

533 
pEntry
->
state
 = 
DNS_STATE_UNUSED
;

534 
pEntry
->
found
 = 
NULL
;

538 case 
DNS_STATE_UNUSED
:

542 
	`LWIP_ASSERT
("unknown dns_table entry state:", 0);

545 
	}
}

551 
	$dns_check_entries
(void)

553 
u8_t
 
i
;

555 for (
i
 = 0; i < 
DNS_TABLE_SIZE
; ++i) {

556 
	`dns_check_entry
(
i
);

558 
	}
}

566 
	$dns_recv
(void *
arg
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
)

568 
u8_t
 
i
;

569 char *
pHostname
;

570 struct 
dns_hdr
 *
hdr
;

571 struct 
dns_answer
 
ans
;

572 struct 
dns_table_entry
 *
pEntry
;

573 
u8_t
 
nquestions
, 
nanswers
;

574 #if (
DNS_USES_STATIC_BUF
 == 0)

575 
u8_t
 
dns_payload
[
DNS_MSG_SIZE
];

577 #if (
DNS_USES_STATIC_BUF
 == 2)

578 
u8_t
* 
dns_payload
;

581 
	`LWIP_UNUSED_ARG
(
arg
);

582 
	`LWIP_UNUSED_ARG
(
pcb
);

583 
	`LWIP_UNUSED_ARG
(
addr
);

584 
	`LWIP_UNUSED_ARG
(
port
);

587 if (
p
->
tot_len
 > 
DNS_MSG_SIZE
) {

588 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_recv: pbuf too big\n"));

590 goto 
memerr1
;

594 if (
p
->
tot_len
 < (sizeof(struct 
dns_hdr
) + sizeof(struct 
dns_query
) + sizeof(struct 
dns_answer
))) {

595 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_recv: pbuf too small\n"));

597 goto 
memerr1
;

600 #if (
DNS_USES_STATIC_BUF
 == 2)

601 
dns_payload
 = 
	`mem_malloc
(
p
->
tot_len
);

602 if (
dns_payload
 == 
NULL
) {

603 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_recv: mem_malloc error\n"));

605 goto 
memerr1
;

610 if (
	`pbuf_copy_partial
(
p
, 
dns_payload
, p->
tot_len
, 0) == p->tot_len) {

612 
hdr
 = (struct 
dns_hdr
*)
dns_payload
;

613 
i
 = 
	`htons
(
hdr
->
id
);

614 if (
i
 < 
DNS_TABLE_SIZE
) {

615 
pEntry
 = &
dns_table
[
i
];

616 if(
pEntry
->
state
 == 
DNS_STATE_ASKING
) {

618 
pEntry
->
state
 = 
DNS_STATE_DONE
;

619 
pEntry
->
err
 = 
hdr
->
flags2
 & 
DNS_FLAG2_ERR_MASK
;

623 
nquestions
 = 
	`htons
(
hdr
->
numquestions
);

624 
nanswers
 = 
	`htons
(
hdr
->
numanswers
);

627 if (((
hdr
->
flags1
 & 
DNS_FLAG1_RESPONSE
) == 0) || (
pEntry
->
err
 != 0) || (
nquestions
 != 1)) {

628 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_recv: \"%s\": error in flags\n", 
pEntry
->
name
));

630 goto 
responseerr
;

633 #if 
DNS_DOES_NAME_CHECK


635 if (
	`dns_compare_name
((unsigned char *)(
pEntry
->
name
), (unsigned char *)
dns_payload
 + sizeof(struct 
dns_hdr
)) != 0) {

636 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_recv: \"%s\": response not match to query\n", 
pEntry
->
name
));

638 goto 
responseerr
;

643 
pHostname
 = (char *) 
	`dns_parse_name
((unsigned char *)
dns_payload
 + sizeof(struct 
dns_hdr
)) + sizeof(struct 
dns_query
);

645 while(
nanswers
 > 0) {

647 
pHostname
 = (char *) 
	`dns_parse_name
((unsigned char *)pHostname);

650 
	`MEMCPY
(&
ans
, 
pHostname
, sizeof(struct 
dns_answer
));

651 if((
	`ntohs
(
ans
.
type
) == 
DNS_RRTYPE_A
) && (ntohs(ans.
class
) == 
DNS_RRCLASS_IN
) && (ntohs(ans.
len
) == sizeof(struct 
ip_addr
)) ) {

653 
pEntry
->
ttl
 = 
	`ntohl
(
ans
.ttl);

654 if (
pEntry
->
ttl
 > 
DNS_MAX_TTL
) {

655 
pEntry
->
ttl
 = 
DNS_MAX_TTL
;

658 
	`MEMCPY
( &(
pEntry
->
ipaddr
), (
pHostname
+sizeof(struct 
dns_answer
)), sizeof(struct 
ip_addr
));

659 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_recv: \"%s\": response = ", 
pEntry
->
name
));

660 
	`ip_addr_debug_print
(
DNS_DEBUG
, (&(
pEntry
->
ipaddr
)));

661 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("\n"));

663 if (
pEntry
->
found
) {

664 (*
pEntry
->
found
)(pEntry->
name
, &pEntry->
ipaddr
, pEntry->
arg
);

667 goto 
memerr2
;

669 
pHostname
 = pHostname + sizeof(struct 
dns_answer
) + 
	`htons
(
ans
.
len
);

671 --
nanswers
;

673 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_recv: \"%s\": error in response\n", 
pEntry
->
name
));

675 goto 
responseerr
;

681 goto 
memerr2
;

683 
responseerr
:

685 if (
pEntry
->
found
) {

686 (*
pEntry
->
found
)(pEntry->
name
, 
NULL
, pEntry->
arg
);

689 
pEntry
->
state
 = 
DNS_STATE_UNUSED
;

690 
pEntry
->
found
 = 
NULL
;

692 
memerr2
:

693 #if (
DNS_USES_STATIC_BUF
 == 2)

695 
	`mem_free
(
dns_payload
);

698 
memerr1
:

700 
	`pbuf_free
(
p
);

702 
	}
}

712 static 
err_t


713 
	$dns_enqueue
(const char *
name
, 
dns_found_callback
 
found
, void *
callback_arg
)

715 
u8_t
 
i
;

716 
u8_t
 
lseq
, 
lseqi
;

717 struct 
dns_table_entry
 *
pEntry
 = 
NULL
;

720 
lseq
 = 
lseqi
 = 0;

721 for (
i
 = 0; i < 
DNS_TABLE_SIZE
; ++i) {

722 
pEntry
 = &
dns_table
[
i
];

724 if (
pEntry
->
state
 == 
DNS_STATE_UNUSED
)

728 if (
pEntry
->
state
 == 
DNS_STATE_DONE
) {

729 if ((
dns_seqno
 - 
pEntry
->
seqno
) > 
lseq
) {

730 
lseq
 = 
dns_seqno
 - 
pEntry
->
seqno
;

731 
lseqi
 = 
i
;

737 if (
i
 == 
DNS_TABLE_SIZE
) {

738 if ((
lseqi
 >= 
DNS_TABLE_SIZE
) || (
dns_table
[lseqi].
state
 != 
DNS_STATE_DONE
)) {

740 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_enqueue: \"%s\": DNS entries table is full\n", 
name
));

741 return 
ERR_MEM
;

744 
i
 = 
lseqi
;

745 
pEntry
 = &
dns_table
[
i
];

750 
	`LWIP_DEBUGF
(
DNS_DEBUG
, ("dns_enqueue: \"%s\": use DNS entry %"
U16_F
"\n", 
name
, (
u16_t
)(
i
)));

753 
pEntry
->
state
 = 
DNS_STATE_NEW
;

754 
pEntry
->
seqno
 = 
dns_seqno
++;

755 
pEntry
->
found
 = found;

756 
pEntry
->
arg
 = 
callback_arg
;

757 
	`strcpy
(
pEntry
->
name
, name);

760 
	`dns_check_entry
(
i
);

763 return 
ERR_INPROGRESS
;

764 
	}
}

784 
err_t


785 
	$dns_gethostbyname
(const char *
hostname
, struct 
ip_addr
 *
addr
, 
dns_found_callback
 
found
,

786 void *
callback_arg
)

790 if ((
dns_pcb
 == 
NULL
) || (
addr
 == NULL) ||

791 (!
hostname
) || (!hostname[0]) ||

792 (
	`strlen
(
hostname
) >= 
DNS_MAX_NAME_LENGTH
)) {

793 return 
ERR_VAL
;

796 #if 
LWIP_HAVE_LOOPIF


797 if (
	`strcmp
(
hostname
,"localhost")==0) {

798 
addr
->addr = 
INADDR_LOOPBACK
;

799 return 
ERR_OK
;

805 if (((
addr
->addr = 
	`inet_addr
(
hostname
)) != 
INADDR_NONE
) ||

806 ((
addr
->addr = 
	`dns_lookup
(
hostname
)) != 0)) {

807 return 
ERR_OK
;

811 return 
	`dns_enqueue
(
hostname
, 
found
, 
callback_arg
);

812 
	}
}

	@/root/Robux/net/lwip/core/init.c

39 #include 
	~"lwip/opt.h
"

41 #include 
	~"lwip/init.h
"

42 #include 
	~"lwip/stats.h
"

43 #include 
	~"lwip/sys.h
"

44 #include 
	~"lwip/mem.h
"

45 #include 
	~"lwip/memp.h
"

46 #include 
	~"lwip/pbuf.h
"

47 #include 
	~"lwip/netif.h
"

48 #include 
	~"lwip/sockets.h
"

49 #include 
	~"lwip/ip.h
"

50 #include 
	~"lwip/raw.h
"

51 #include 
	~"lwip/udp.h
"

52 #include 
	~"lwip/tcp.h
"

53 #include 
	~"lwip/autoip.h
"

54 #include 
	~"lwip/igmp.h
"

55 #include 
	~"lwip/dns.h
"

56 #include 
	~"netif/etharp.h
"

61 #ifndef 
BYTE_ORDER


64 #if (!
LWIP_ARP
 && 
ARP_QUEUEING
)

67 #if (!
LWIP_UDP
 && 
LWIP_UDPLITE
)

70 #if (!
LWIP_UDP
 && 
LWIP_SNMP
)

73 #if (!
LWIP_UDP
 && 
LWIP_DHCP
)

76 #if (!
LWIP_UDP
 && 
LWIP_IGMP
)

79 #if (!
LWIP_UDP
 && 
LWIP_DNS
)

82 #if (
LWIP_ARP
 && (
ARP_TABLE_SIZE
 > 0x7f))

85 #if (
LWIP_ARP
 && 
ARP_QUEUEING
 && (
MEMP_NUM_ARP_QUEUE
<=0))

88 #if (
LWIP_RAW
 && (
MEMP_NUM_RAW_PCB
<=0))

91 #if (
LWIP_UDP
 && (
MEMP_NUM_UDP_PCB
<=0))

94 #if (
LWIP_TCP
 && (
MEMP_NUM_TCP_PCB
<=0))

97 #if (
LWIP_TCP
 && (
TCP_WND
 > 0xffff))

100 #if (
LWIP_TCP
 && (
TCP_SND_QUEUELEN
 > 0xffff))

103 #if (
LWIP_TCP
 && ((
TCP_MAXRTX
 > 12) || (
TCP_SYNMAXRTX
 > 12)))

106 #if (
LWIP_TCP
 && 
TCP_LISTEN_BACKLOG
 && (
TCP_DEFAULT_LISTEN_BACKLOG
 < 0) || (TCP_DEFAULT_LISTEN_BACKLOG > 0xff))

109 #if (
LWIP_IGMP
 && (
MEMP_NUM_IGMP_GROUP
<=1))

112 #if (
PPP_SUPPORT
 && (
NO_SYS
==1))

115 #if (
LWIP_NETIF_API
 && (
NO_SYS
==1))

118 #if ((
LWIP_SOCKET
 || 
LWIP_NETCONN
) && (
NO_SYS
==1))

121 #if ((
LWIP_NETCONN
 || 
LWIP_SOCKET
) && (
MEMP_NUM_TCPIP_MSG_API
<=0))

124 #if (!
LWIP_NETCONN
 && 
LWIP_SOCKET
)

127 #if (((!
LWIP_DHCP
) || (!
LWIP_AUTOIP
)) && 
LWIP_DHCP_AUTOIP_COOP
)

130 #if (((!
LWIP_DHCP
) || (!
LWIP_ARP
)) && 
DHCP_DOES_ARP_CHECK
)

133 #if (!
LWIP_ARP
 && 
LWIP_AUTOIP
)

136 #if (
LWIP_SNMP
 && (
SNMP_CONCURRENT_REQUESTS
<=0))

139 #if (
LWIP_SNMP
 && (
SNMP_TRAP_DESTINATIONS
<=0))

142 #if (
LWIP_TCP
 && ((
LWIP_EVENT_API
 && 
LWIP_CALLBACK_API
) || (!LWIP_EVENT_API && !LWIP_CALLBACK_API)))

146 #if ((
NO_SYS
==0) && (
MEMP_NUM_SYS_TIMEOUT
 < (
LWIP_TCP
 + 
IP_REASSEMBLY
 + 
LWIP_ARP
 + (2*
LWIP_DHCP
) + 
LWIP_AUTOIP
 + 
LWIP_IGMP
 + 
LWIP_DNS
 + 
PPP_SUPPORT
)))

149 #if (
IP_REASSEMBLY
 && (
MEMP_NUM_REASSDATA
 > 
IP_REASS_MAX_PBUFS
))

152 #if (
MEM_LIBC_MALLOC
 && 
MEM_USE_POOLS
)

155 #if (
MEM_USE_POOLS
 && !
MEMP_USE_CUSTOM_POOLS
)

162 #ifdef 
MEMP_NUM_TCPIP_MSG


165 #ifdef 
MEMP_NUM_API_MSG


168 #ifdef 
TCP_REXMIT_DEBUG


171 #ifdef 
RAW_STATS


174 #ifdef 
ETHARP_QUEUE_FIRST


177 #ifdef 
ETHARP_ALWAYS_INSERT


180 #if 
SO_REUSE


186 #ifdef 
LWIP_DEBUG


188 
	$lwip_sanity_check
(void)

191 #if 
LWIP_NETCONN


192 if (
MEMP_NUM_NETCONN
 > (
MEMP_NUM_TCP_PCB
+
MEMP_NUM_TCP_PCB_LISTEN
+
MEMP_NUM_UDP_PCB
+
MEMP_NUM_RAW_PCB
))

193 
	`LWIP_PLATFORM_DIAG
(("lwip_sanity_check: WARNING: MEMP_NUM_NETCONN should be less than the sum of MEMP_NUM_{TCP,RAW,UDP}_PCB+MEMP_NUM_TCP_PCB_LISTEN\n"));

195 #if 
LWIP_TCP


196 if (
MEMP_NUM_TCP_SEG
 < 
TCP_SND_QUEUELEN
)

197 
	`LWIP_PLATFORM_DIAG
(("lwip_sanity_check: WARNING: MEMP_NUM_TCP_SEG should be at least as big as TCP_SND_QUEUELEN\n"));

198 if (
TCP_SND_QUEUELEN
 < (2 * (
TCP_SND_BUF
/
TCP_MSS
)))

199 
	`LWIP_PLATFORM_DIAG
(("lwip_sanity_check: WARNING: TCP_SND_QUEUELEN must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work\n"));

200 if (
TCP_SNDLOWAT
 > 
TCP_SND_BUF
)

201 
	`LWIP_PLATFORM_DIAG
(("lwip_sanity_check: WARNING: TCP_SNDLOWAT must be less than or equal to TCP_SND_BUF.\n"));

202 if (
TCP_WND
 > (
PBUF_POOL_SIZE
*
PBUF_POOL_BUFSIZE
))

203 
	`LWIP_PLATFORM_DIAG
(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));

204 if (
TCP_WND
 < 
TCP_MSS
)

205 
	`LWIP_PLATFORM_DIAG
(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));

207 
	}
}

209 #define 
	#lwip_sanity_check
()

	)

216 
	$lwip_init
(void)

219 
	`lwip_sanity_check
();

222 
	`stats_init
();

223 
	`sys_init
();

224 
	`mem_init
();

225 
	`memp_init
();

226 
	`pbuf_init
();

227 
	`netif_init
();

228 #if 
LWIP_SOCKET


229 
	`lwip_socket_init
();

231 
	`ip_init
();

232 #if 
LWIP_ARP


233 
	`etharp_init
();

235 #if 
LWIP_RAW


236 
	`raw_init
();

238 #if 
LWIP_UDP


239 
	`udp_init
();

241 #if 
LWIP_TCP


242 
	`tcp_init
();

244 #if 
LWIP_AUTOIP


245 
	`autoip_init
();

247 #if 
LWIP_IGMP


248 
	`igmp_init
();

250 #if 
LWIP_DNS


251 
	`dns_init
();

253 
	}
}

	@/root/Robux/net/lwip/core/ipv4/autoip.c

65 #include 
	~"lwip/opt.h
"

67 #if 
LWIP_AUTOIP


69 #include 
	~"lwip/mem.h
"

70 #include 
	~"lwip/udp.h
"

71 #include 
	~"lwip/ip_addr.h
"

72 #include 
	~"lwip/netif.h
"

73 #include 
	~"lwip/autoip.h
"

74 #include 
	~"netif/etharp.h
"

76 #include 
	~<stdlib.h
>

77 #include 
	~<string.h
>

81 #ifndef 
LWIP_AUTOIP_RAND


82 #define 
	#LWIP_AUTOIP_RAND
(
netif
) ( (((
u32_t
)((netif->
hwaddr
[5]) & 0xff) << 24) | \

83 ((
u32_t
)((
netif
->
hwaddr
[3]) & 0xff) << 16) | \

84 ((
u32_t
)((
netif
->
hwaddr
[2]) & 0xff) << 8) | \

85 ((
u32_t
)((
netif
->
hwaddr
[4]) & 0xff))) + \

86 (
netif
->
autoip
?netif->autoip->
tried_llipaddr
:0))

	)

90 static void 
autoip_handle_arp_conflict
(struct 
netif
 *netif);

93 static void 
autoip_create_rand_addr
(struct 
netif
 *netif, struct 
ip_addr
 *
RandomIPAddr
);

96 static 
err_t
 
autoip_arp_announce
(struct 
netif
 *netif);

99 static 
err_t
 
autoip_bind
(struct 
netif
 *netif);

105 
	$autoip_init
(void)

107 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("autoip_init()\n"));

108 
	}
}

114 
	$autoip_handle_arp_conflict
(struct 
netif
 *netif)

117 unsigned char 
defend
 = 1;

119 if(
defend
) {

120 if(
netif
->
autoip
->
lastconflict
 > 0) {

124 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 1,

128 
	`autoip_start
(
netif
);

130 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 1,

132 
	`autoip_arp_announce
(
netif
);

133 
netif
->
autoip
->
lastconflict
 = 
DEFEND_INTERVAL
 * 
AUTOIP_TICKS_PER_SECOND
;

136 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 1,

139 
	`autoip_start
(
netif
);

141 
	}
}

150 
	$autoip_create_rand_addr
(struct 
netif
 *netif, struct 
ip_addr
 *
RandomIPAddr
)

157 
RandomIPAddr
->
addr
 = (0xA9FE0100 + ((
u32_t
)(((
u8_t
)(
netif
->
hwaddr
[4])) |

158 ((
u32_t
)((
u8_t
)(
netif
->
hwaddr
[5]))) << 8)) + netif->
autoip
->
tried_llipaddr
);

160 if (
RandomIPAddr
->
addr
>0xA9FEFEFF) {

161 
RandomIPAddr
->
addr
 = (0xA9FE0100 + (RandomIPAddr->addr-0xA9FEFEFF));

163 if (
RandomIPAddr
->
addr
<0xA9FE0100) {

164 
RandomIPAddr
->
addr
 = (0xA9FEFEFF - (0xA9FE0100-RandomIPAddr->addr));

166 
RandomIPAddr
->
addr
 = 
	`htonl
(RandomIPAddr->addr);

168 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 1,

169 ("autoip_create_rand_addr(): tried_llipaddr=%"
U16_F
", 0x%08"
X32_F
"\n",

170 (
u16_t
)(
netif
->
autoip
->
tried_llipaddr
), (
u32_t
)(
RandomIPAddr
->
addr
)));

171 
	}
}

178 static 
err_t


179 
	$autoip_arp_announce
(struct 
netif
 *netif)

181 return 
	`etharp_raw
(
netif
, (struct 
eth_addr
 *)netif->
hwaddr
, &
ethbroadcast
,

182 (struct 
eth_addr
 *)
netif
->
hwaddr
, &netif->
autoip
->
llipaddr
, &
ethzero
,

183 &
netif
->
autoip
->
llipaddr
, 
ARP_REQUEST
);

184 
	}
}

191 static 
err_t


192 
	$autoip_bind
(struct 
netif
 *netif)

194 struct 
autoip
 *autoip = 
netif
->autoip;

195 struct 
ip_addr
 
sn_mask
, 
gw_addr
;

197 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3,

198 ("autoip_bind(netif=%p) %c%c%"
U16_F
" 0x%08"
X32_F
"\n",

199 (void*)
netif
, netif->
name
[0], netif->name[1], (
u16_t
)netif->
num
, 
autoip
->
llipaddr
.
addr
));

201 
	`IP4_ADDR
(&
sn_mask
, 255, 255, 0, 0);

202 
	`IP4_ADDR
(&
gw_addr
, 0, 0, 0, 0);

204 
	`netif_set_ipaddr
(
netif
, &
autoip
->
llipaddr
);

205 
	`netif_set_netmask
(
netif
, &
sn_mask
);

206 
	`netif_set_gw
(
netif
, &
gw_addr
);

209 
	`netif_set_up
(
netif
);

211 return 
ERR_OK
;

212 
	}
}

219 
err_t


220 
	$autoip_start
(struct 
netif
 *netif)

222 struct 
autoip
 *autoip = 
netif
->autoip;

223 
err_t
 
result
 = 
ERR_OK
;

225 if(
	`netif_is_up
(
netif
)) {

226 
	`netif_set_down
(
netif
);

232 
netif
->
ip_addr
.
addr
 = 0;

233 
netif
->
netmask
.
addr
 = 0;

234 
netif
->
gw
.
addr
 = 0;

236 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
,

237 ("autoip_start(netif=%p) %c%c%"
U16_F
"\n", (void*)
netif
, netif->
name
[0],

238 
netif
->
name
[1], (
u16_t
)netif->
num
));

239 if(
autoip
 == 
NULL
) {

241 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
,

243 
autoip
 = 
	`mem_malloc
(sizeof(struct autoip));

244 if(
autoip
 == 
NULL
) {

245 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
,

247 return 
ERR_MEM
;

249 
	`memset
( 
autoip
, 0, sizeof(struct autoip));

251 
netif
->
autoip
 = autoip;

252 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
, ("autoip_start(): allocated autoip"));

254 
autoip
->
state
 = 
AUTOIP_STATE_OFF
;

255 
autoip
->
ttw
 = 0;

256 
autoip
->
sent_num
 = 0;

257 
	`memset
(&
autoip
->
llipaddr
, 0, sizeof(struct 
ip_addr
));

258 
autoip
->
lastconflict
 = 0;

261 
	`autoip_create_rand_addr
(
netif
, &(
autoip
->
llipaddr
));

262 
autoip
->
tried_llipaddr
++;

263 
autoip
->
state
 = 
AUTOIP_STATE_PROBING
;

264 
autoip
->
sent_num
 = 0;

270 
autoip
->
ttw
 = (
u16_t
)(
	`LWIP_AUTOIP_RAND
(
netif
) % (
PROBE_WAIT
 * 
AUTOIP_TICKS_PER_SECOND
));

278 if(
autoip
->
tried_llipaddr
 > 
MAX_CONFLICTS
) {

279 
autoip
->
ttw
 = 
RATE_LIMIT_INTERVAL
 * 
AUTOIP_TICKS_PER_SECOND
;

282 return 
result
;

283 
	}
}

290 
err_t


291 
	$autoip_stop
(struct 
netif
 *netif)

293 
netif
->
autoip
->
state
 = 
AUTOIP_STATE_OFF
;

294 
	`netif_set_down
(
netif
);

295 return 
ERR_OK
;

296 
	}
}

302 
	$autoip_tmr
()

304 struct 
netif
 *netif = 
netif_list
;

306 while (
netif
 != 
NULL
) {

308 if (
netif
->
autoip
 != 
NULL
) {

309 if(
netif
->
autoip
->
lastconflict
 > 0) {

310 
netif
->
autoip
->
lastconflict
--;

313 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
,

314 ("autoip_tmr() AutoIP-State: %"
U16_F
", ttw=%"U16_F"\n",

315 (
u16_t
)(
netif
->
autoip
->
state
), netif->autoip->
ttw
));

317 switch(
netif
->
autoip
->
state
) {

318 case 
AUTOIP_STATE_PROBING
:

319 if(
netif
->
autoip
->
ttw
 > 0) {

320 
netif
->
autoip
->
ttw
--;

322 if(
netif
->
autoip
->
sent_num
 == 
PROBE_NUM
) {

323 
netif
->
autoip
->
state
 = 
AUTOIP_STATE_ANNOUNCING
;

324 
netif
->
autoip
->
sent_num
 = 0;

325 
netif
->
autoip
->
ttw
 = 
ANNOUNCE_WAIT
 * 
AUTOIP_TICKS_PER_SECOND
;

327 
	`etharp_request
(
netif
, &(netif->
autoip
->
llipaddr
));

328 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3,

330 
netif
->
autoip
->
sent_num
++;

332 
netif
->
autoip
->
ttw
 = (
u16_t
)((
	`LWIP_AUTOIP_RAND
(netif) %

333 ((
PROBE_MAX
 - 
PROBE_MIN
) * 
AUTOIP_TICKS_PER_SECOND
) ) +

334 
PROBE_MIN
 * 
AUTOIP_TICKS_PER_SECOND
);

339 case 
AUTOIP_STATE_ANNOUNCING
:

340 if(
netif
->
autoip
->
ttw
 > 0) {

341 
netif
->
autoip
->
ttw
--;

343 if(
netif
->
autoip
->
sent_num
 == 0) {

347 
	`autoip_bind
(
netif
);

350 if(
netif
->
autoip
->
sent_num
 == 
ANNOUNCE_NUM
) {

351 
netif
->
autoip
->
state
 = 
AUTOIP_STATE_BOUND
;

352 
netif
->
autoip
->
sent_num
 = 0;

353 
netif
->
autoip
->
ttw
 = 0;

355 
	`autoip_arp_announce
(
netif
);

356 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3,

358 
netif
->
autoip
->
sent_num
++;

359 
netif
->
autoip
->
ttw
 = 
ANNOUNCE_INTERVAL
 * 
AUTOIP_TICKS_PER_SECOND
;

366 
netif
 = netif->
next
;

368 
	}
}

377 
	$autoip_arp_reply
(struct 
netif
 *netif, struct 
etharp_hdr
 *
hdr
)

379 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("autoip_arp_reply()\n"));

380 if ((
netif
->
autoip
 != 
NULL
) && (netif->autoip->
state
 != 
AUTOIP_STATE_OFF
)) {

386 struct 
ip_addr
 
sipaddr
, 
dipaddr
;

387 struct 
eth_addr
 
netifaddr
;

388 
netifaddr
.
addr
[0] = 
netif
->
hwaddr
[0];

389 
netifaddr
.
addr
[1] = 
netif
->
hwaddr
[1];

390 
netifaddr
.
addr
[2] = 
netif
->
hwaddr
[2];

391 
netifaddr
.
addr
[3] = 
netif
->
hwaddr
[3];

392 
netifaddr
.
addr
[4] = 
netif
->
hwaddr
[4];

393 
netifaddr
.
addr
[5] = 
netif
->
hwaddr
[5];

398 
	`SMEMCPY
(&
sipaddr
, &
hdr
->sipaddr, sizeof(sipaddr));

399 
	`SMEMCPY
(&
dipaddr
, &
hdr
->dipaddr, sizeof(dipaddr));

401 if ((
netif
->
autoip
->
state
 == 
AUTOIP_STATE_PROBING
) ||

402 ((
netif
->
autoip
->
state
 == 
AUTOIP_STATE_ANNOUNCING
) &&

403 (
netif
->
autoip
->
sent_num
 == 0))) {

410 if ((
	`ip_addr_cmp
(&
sipaddr
, &
netif
->
autoip
->
llipaddr
)) ||

411 (
	`ip_addr_cmp
(&
dipaddr
, &
netif
->
autoip
->
llipaddr
) &&

412 !
	`eth_addr_cmp
(&
netifaddr
, &
hdr
->
shwaddr
))) {

413 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 1,

415 
	`autoip_start
(
netif
);

422 if (
	`ip_addr_cmp
(&
sipaddr
, &
netif
->
autoip
->
llipaddr
) &&

423 !
	`eth_addr_cmp
(&
netifaddr
, &
hdr
->
shwaddr
)) {

424 
	`LWIP_DEBUGF
(
AUTOIP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 1,

426 
	`autoip_handle_arp_conflict
(
netif
);

430 
	}
}

	@/root/Robux/net/lwip/core/ipv4/icmp.c

42 #include 
	~"lwip/opt.h
"

44 #if 
LWIP_ICMP


46 #include 
	~"lwip/icmp.h
"

47 #include 
	~"lwip/inet.h
"

48 #include 
	~"lwip/inet_chksum.h
"

49 #include 
	~"lwip/ip.h
"

50 #include 
	~"lwip/def.h
"

51 #include 
	~"lwip/stats.h
"

52 #include 
	~"lwip/snmp.h
"

54 #include 
	~<string.h
>

57 #define 
	#ICMP_DEST_UNREACH_DATASIZE
 8

	)

69 
	$icmp_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
)

71 
u8_t
 
type
;

72 #ifdef 
LWIP_DEBUG


73 
u8_t
 
code
;

75 struct 
icmp_echo_hdr
 *
iecho
;

76 struct 
ip_hdr
 *
iphdr
;

77 struct 
ip_addr
 
tmpaddr
;

78 
s16_t
 
hlen
;

80 
	`ICMP_STATS_INC
(
icmp
.
recv
);

81 
	`snmp_inc_icmpinmsgs
();

84 
iphdr
 = 
p
->
payload
;

85 
hlen
 = 
	`IPH_HL
(
iphdr
) * 4;

86 if (
	`pbuf_header
(
p
, -
hlen
) || (p->
tot_len
 < sizeof(
u16_t
)*2)) {

87 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: short ICMP (%"
U16_F
" bytes) received\n", 
p
->
tot_len
));

88 goto 
lenerr
;

91 
type
 = *((
u8_t
 *)
p
->
payload
);

92 #ifdef 
LWIP_DEBUG


93 
code
 = *(((
u8_t
 *)
p
->
payload
)+1);

95 switch (
type
) {

96 case 
ICMP_ECHO
:

98 if (
	`ip_addr_isbroadcast
(&
iphdr
->
dest
, 
inp
) || 
	`ip_addr_ismulticast
(&iphdr->dest)) {

99 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: Not echoing to multicast or broadcast pings\n"));

100 
	`ICMP_STATS_INC
(
icmp
.
err
);

101 
	`pbuf_free
(
p
);

104 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: ping\n"));

105 if (
p
->
tot_len
 < sizeof(struct 
icmp_echo_hdr
)) {

106 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: bad ICMP echo received\n"));

107 goto 
lenerr
;

109 if (
	`inet_chksum_pbuf
(
p
) != 0) {

110 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: checksum failed for received ICMP echo\n"));

111 
	`pbuf_free
(
p
);

112 
	`ICMP_STATS_INC
(
icmp
.
chkerr
);

113 
	`snmp_inc_icmpinerrors
();

116 if (
	`pbuf_header
(
p
, (
PBUF_IP_HLEN
 + 
PBUF_LINK_HLEN
))) {

120 struct 
pbuf
 *
r
;

122 if (
	`pbuf_header
(
p
, 
hlen
)) {

123 
	`LWIP_ASSERT
("icmp_input: moving p->payload to ip header failed\n", 0);

124 goto 
memerr
;

127 
r
 = 
	`pbuf_alloc
(
PBUF_LINK
, 
p
->
tot_len
, 
PBUF_RAM
);

128 if (
r
 == 
NULL
) {

129 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: allocating new pbuf failed\n"));

130 goto 
memerr
;

132 
	`LWIP_ASSERT
("check that first pbuf can hold struct the ICMP header",

133 (
r
->
len
 >= 
hlen
 + sizeof(struct 
icmp_echo_hdr
)));

135 if (
	`pbuf_copy
(
r
, 
p
) != 
ERR_OK
) {

136 
	`LWIP_ASSERT
("icmp_input: copying to new pbuf failed\n", 0);

137 goto 
memerr
;

139 
iphdr
 = 
r
->
payload
;

141 if (
	`pbuf_header
(
r
, -
hlen
)) {

142 
	`LWIP_ASSERT
("icmp_input: restoring original p->payload failed\n", 0);

143 goto 
memerr
;

146 
	`pbuf_free
(
p
);

148 
p
 = 
r
;

151 if (
	`pbuf_header
(
p
, -(
s16_t
)(
PBUF_IP_HLEN
 + 
PBUF_LINK_HLEN
))) {

152 
	`LWIP_ASSERT
("icmp_input: restoring original p->payload failed\n", 0);

153 goto 
memerr
;

159 
iecho
 = 
p
->
payload
;

160 
tmpaddr
.
addr
 = 
iphdr
->
src
.addr;

161 
iphdr
->
src
.
addr
 = iphdr->
dest
.addr;

162 
iphdr
->
dest
.
addr
 = 
tmpaddr
.addr;

163 
	`ICMPH_TYPE_SET
(
iecho
, 
ICMP_ER
);

165 if (
iecho
->
chksum
 >= 
	`htons
(0xffff - (
ICMP_ECHO
 << 8))) {

166 
iecho
->
chksum
 += 
	`htons
(
ICMP_ECHO
 << 8) + 1;

168 
iecho
->
chksum
 += 
	`htons
(
ICMP_ECHO
 << 8);

172 
	`IPH_TTL_SET
(
iphdr
, 
ICMP_TTL
);

173 
	`IPH_CHKSUM_SET
(
iphdr
, 0);

174 #if 
CHECKSUM_GEN_IP


175 
	`IPH_CHKSUM_SET
(
iphdr
, 
	`inet_chksum
(iphdr, 
IP_HLEN
));

178 
	`ICMP_STATS_INC
(
icmp
.
xmit
);

180 
	`snmp_inc_icmpoutmsgs
();

182 
	`snmp_inc_icmpoutechoreps
();

184 if(
	`pbuf_header
(
p
, 
hlen
)) {

185 
	`LWIP_ASSERT
("Can't move over header in packet", 0);

187 
err_t
 
ret
;

188 
ret
 = 
	`ip_output_if
(
p
, &(
iphdr
->
src
), 
IP_HDRINCL
,

189 
ICMP_TTL
, 0, 
IP_PROTO_ICMP
, 
inp
);

190 if (
ret
 != 
ERR_OK
) {

191 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: ip_output_if returned an error: %c.\n", 
ret
));

196 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: ICMP type %"
S16_F
" code %"S16_F" not supported.\n",

197 (
s16_t
)
type
, (s16_t)
code
));

198 
	`ICMP_STATS_INC
(
icmp
.
proterr
);

199 
	`ICMP_STATS_INC
(
icmp
.
drop
);

201 
	`pbuf_free
(
p
);

203 
lenerr
:

204 
	`pbuf_free
(
p
);

205 
	`ICMP_STATS_INC
(
icmp
.
lenerr
);

206 
	`snmp_inc_icmpinerrors
();

208 
memerr
:

209 
	`pbuf_free
(
p
);

210 
	`ICMP_STATS_INC
(
icmp
.
err
);

211 
	`snmp_inc_icmpinerrors
();

213 
	}
}

225 
	$icmp_dest_unreach
(struct 
pbuf
 *
p
, enum 
icmp_dur_type
 
t
)

227 struct 
pbuf
 *
q
;

228 struct 
ip_hdr
 *
iphdr
;

229 struct 
icmp_dur_hdr
 *
idur
;

232 
q
 = 
	`pbuf_alloc
(
PBUF_IP
, sizeof(struct 
icmp_dur_hdr
) + 
IP_HLEN
 + 
ICMP_DEST_UNREACH_DATASIZE
,

233 
PBUF_RAM
);

234 if (
q
 == 
NULL
) {

235 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));

238 
	`LWIP_ASSERT
("check that first pbuf can hold icmp message",

239 (
q
->
len
 >= (sizeof(struct 
icmp_dur_hdr
) + 
IP_HLEN
 + 
ICMP_DEST_UNREACH_DATASIZE
)));

241 
iphdr
 = 
p
->
payload
;

243 
idur
 = 
q
->
payload
;

244 
	`ICMPH_TYPE_SET
(
idur
, 
ICMP_DUR
);

245 
	`ICMPH_CODE_SET
(
idur
, 
t
);

247 
	`SMEMCPY
((
u8_t
 *)
q
->
payload
 + sizeof(struct 
icmp_dur_hdr
), 
p
->payload,

248 
IP_HLEN
 + 
ICMP_DEST_UNREACH_DATASIZE
);

251 
idur
->
chksum
 = 0;

252 
idur
->
chksum
 = 
	`inet_chksum
(idur, 
q
->
len
);

253 
	`ICMP_STATS_INC
(
icmp
.
xmit
);

255 
	`snmp_inc_icmpoutmsgs
();

257 
	`snmp_inc_icmpoutdestunreachs
();

259 
	`ip_output
(
q
, 
NULL
, &(
iphdr
->
src
), 
ICMP_TTL
, 0, 
IP_PROTO_ICMP
);

260 
	`pbuf_free
(
q
);

261 
	}
}

263 #if 
IP_FORWARD
 || 
IP_REASSEMBLY


272 
	$icmp_time_exceeded
(struct 
pbuf
 *
p
, enum 
icmp_te_type
 
t
)

274 struct 
pbuf
 *
q
;

275 struct 
ip_hdr
 *
iphdr
;

276 struct 
icmp_te_hdr
 *
tehdr
;

279 
q
 = 
	`pbuf_alloc
(
PBUF_IP
, sizeof(struct 
icmp_dur_hdr
) + 
IP_HLEN
 + 
ICMP_DEST_UNREACH_DATASIZE
,

280 
PBUF_RAM
);

281 if (
q
 == 
NULL
) {

282 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));

285 
	`LWIP_ASSERT
("check that first pbuf can hold icmp message",

286 (
q
->
len
 >= (sizeof(struct 
icmp_dur_hdr
) + 
IP_HLEN
 + 
ICMP_DEST_UNREACH_DATASIZE
)));

288 
iphdr
 = 
p
->
payload
;

289 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_time_exceeded from "));

290 
	`ip_addr_debug_print
(
ICMP_DEBUG
, &(
iphdr
->
src
));

291 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, (" to "));

292 
	`ip_addr_debug_print
(
ICMP_DEBUG
, &(
iphdr
->
dest
));

293 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("\n"));

295 
tehdr
 = 
q
->
payload
;

296 
	`ICMPH_TYPE_SET
(
tehdr
, 
ICMP_TE
);

297 
	`ICMPH_CODE_SET
(
tehdr
, 
t
);

300 
	`SMEMCPY
((
u8_t
 *)
q
->
payload
 + sizeof(struct 
icmp_dur_hdr
), (u8_t *)
p
->payload,

301 
IP_HLEN
 + 
ICMP_DEST_UNREACH_DATASIZE
);

304 
tehdr
->
chksum
 = 0;

305 
tehdr
->
chksum
 = 
	`inet_chksum
(tehdr, 
q
->
len
);

306 
	`ICMP_STATS_INC
(
icmp
.
xmit
);

308 
	`snmp_inc_icmpoutmsgs
();

310 
	`snmp_inc_icmpouttimeexcds
();

311 
	`ip_output
(
q
, 
NULL
, &(
iphdr
->
src
), 
ICMP_TTL
, 0, 
IP_PROTO_ICMP
);

312 
	`pbuf_free
(
q
);

313 
	}
}

	@/root/Robux/net/lwip/core/ipv4/igmp.c

80 #include 
	~"lwip/opt.h
"

82 #if 
LWIP_IGMP


84 #include 
	~"lwip/igmp.h
"

85 #include 
	~"lwip/debug.h
"

86 #include 
	~"lwip/def.h
"

87 #include 
	~"lwip/mem.h
"

88 #include 
	~"lwip/ip.h
"

89 #include 
	~"lwip/inet.h
"

90 #include 
	~"lwip/inet_chksum.h
"

91 #include 
	~"lwip/netif.h
"

92 #include 
	~"lwip/icmp.h
"

93 #include 
	~"lwip/udp.h
"

94 #include 
	~"lwip/tcp.h
"

95 #include 
	~"lwip/stats.h
"

97 #include 
	~"string.h
"

103 static struct 
igmp_group
* 
	gigmp_group_list
;

104 static struct 
ip_addr
 
	gallsystems
;

105 static struct 
ip_addr
 
	gallrouters
;

111 
	$igmp_init
(void)

113 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_init: initializing\n"));

115 
	`IP4_ADDR
(&
allsystems
, 224, 0, 0, 1);

116 
	`IP4_ADDR
(&
allrouters
, 224, 0, 0, 2);

117 
	}
}

119 #ifdef 
LWIP_DEBUG


124 
	$igmp_dump_group_list
()

126 struct 
igmp_group
 *
group
 = 
igmp_group_list
;

128 while (
group
 != 
NULL
) {

129 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_dump_group_list: [%"
U32_F
"] ", (
u32_t
)(
group
->
group_state
)));

130 
	`ip_addr_debug_print
(
IGMP_DEBUG
, &
group
->
group_address
);

131 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (" on if %x\n", (int) 
group
->
interface
));

132 
group
 = group->
next
;

134 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("\n"));

135 
	}
}

137 #define 
	#igmp_dump_group_list
()

	)

145 
err_t


146 
	$igmp_start
(struct 
netif
 *netif)

148 struct 
igmp_group
* 
group
;

150 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_start: starting IGMP processing on if %x\n", (int) 
netif
));

152 
group
 = 
	`igmp_lookup_group
(
netif
, &
allsystems
);

154 if (
group
 != 
NULL
) {

155 
group
->
group_state
 = 
IGMP_GROUP_IDLE_MEMBER
;

156 
group
->
use
++;

159 if (
netif
->
igmp_mac_filter
 != 
NULL
) {

160 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_start: igmp_mac_filter(ADD "));

161 
	`ip_addr_debug_print
(
IGMP_DEBUG
, &
allsystems
);

162 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (") on if %x\n", (int) 
netif
));

163 
netif
->
	`igmp_mac_filter
( netif, &
allsystems
, 
IGMP_ADD_MAC_FILTER
);

166 return 
ERR_OK
;

169 return 
ERR_MEM
;

170 
	}
}

177 
err_t


178 
	$igmp_stop
(struct 
netif
 *netif)

180 struct 
igmp_group
 *
group
 = 
igmp_group_list
;

181 struct 
igmp_group
 *
prev
 = 
NULL
;

182 struct 
igmp_group
 *
next
;

185 while (
group
 != 
NULL
) {

186 
next
 = 
group
->next;

188 if (
group
->
interface
 == 
netif
) {

190 if (
group
 == 
igmp_group_list
) {

191 
igmp_group_list
 = 
next
;

194 if (
prev
 != 
NULL
) {

195 
prev
->
next
 = next;

198 if (
netif
->
igmp_mac_filter
 != 
NULL
) {

199 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_stop: igmp_mac_filter(DEL "));

200 
	`ip_addr_debug_print
(
IGMP_DEBUG
, &
group
->
group_address
);

201 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (") on if %x\n", (int) 
netif
));

202 
netif
->
	`igmp_mac_filter
(netif, &(
group
->
group_address
), 
IGMP_DEL_MAC_FILTER
);

205 
	`memp_free
(
MEMP_IGMP_GROUP
, 
group
);

208 
prev
 = 
group
;

211 
group
 = 
next
;

213 return 
ERR_OK
;

214 
	}
}

222 
	$igmp_report_groups
( struct 
netif
 *netif)

224 struct 
igmp_group
 *
group
 = 
igmp_group_list
;

226 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_report_groups: sending IGMP reports on if %x\n", (int) 
netif
));

228 while (
group
 != 
NULL
) {

229 if (
group
->
interface
 == 
netif
) {

230 
	`igmp_delaying_member
( 
group
, 
IGMP_JOIN_DELAYING_MEMBER_TMR
);

232 
group
 = group->
next
;

234 
	}
}

244 struct 
igmp_group
 *

245 
	$igmp_lookfor_group
(struct 
netif
 *
ifp
, struct 
ip_addr
 *
addr
)

247 struct 
igmp_group
 *
group
 = 
igmp_group_list
;

249 while (
group
 != 
NULL
) {

250 if ((
group
->
interface
 == 
ifp
) && (
	`ip_addr_cmp
(&(group->
group_address
), 
addr
))) {

251 return 
group
;

253 
group
 = group->
next
;

259 return 
NULL
;

260 
	}
}

270 struct 
igmp_group
 *

271 
	$igmp_lookup_group
(struct 
netif
 *
ifp
, struct 
ip_addr
 *
addr
)

273 struct 
igmp_group
 *
group
 = 
igmp_group_list
;

276 
group
 = 
	`igmp_lookfor_group
(
ifp
, 
addr
);

277 if (
group
 != 
NULL
) {

279 return 
group
;

283 
group
 = 
	`memp_malloc
(
MEMP_IGMP_GROUP
);

284 if (
group
 != 
NULL
) {

285 
group
->
interface
 = 
ifp
;

286 
	`ip_addr_set
(&(
group
->
group_address
), 
addr
);

287 
group
->
timer
 = 0;

288 
group
->
group_state
 = 
IGMP_GROUP_NON_MEMBER
;

289 
group
->
last_reporter_flag
 = 0;

290 
group
->
use
 = 0;

291 
group
->
next
 = 
igmp_group_list
;

293 
igmp_group_list
 = 
group
;

296 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_lookup_group: %sallocated a new group with address ", (
group
?"":"impossible to ")));

297 
	`ip_addr_debug_print
(
IGMP_DEBUG
, 
addr
);

298 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (" on if %x\n", (int) 
ifp
));

300 return 
group
;

301 
	}
}

309 
err_t


310 
	$igmp_remove_group
(struct 
igmp_group
 *
group
)

312 
err_t
 
err
 = 
ERR_OK
;

315 if (
igmp_group_list
 == 
group
) {

316 
igmp_group_list
 = 
group
->
next
;

319 struct 
igmp_group
 *
tmpGroup
;

320 for (
tmpGroup
 = 
igmp_group_list
; tmpGroup != 
NULL
; tmpGroup = tmpGroup->
next
) {

321 if (
tmpGroup
->
next
 == 
group
) {

322 
tmpGroup
->
next
 = 
group
->next;

327 if (
tmpGroup
 == 
NULL
)

328 
err
 = 
ERR_ARG
;

331 
	`memp_free
(
MEMP_IGMP_GROUP
, 
group
);

333 return 
err
;

334 
	}
}

344 
	$igmp_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
, struct 
ip_addr
 *
dest
)

346 struct 
ip_hdr
 * 
iphdr
;

347 struct 
igmp_msg
* 
igmp
;

348 struct 
igmp_group
* 
group
;

349 struct 
igmp_group
* 
groupref
;

352 
iphdr
 = 
p
->
payload
;

353 if (
	`pbuf_header
(
p
, -(
s16_t
)(
	`IPH_HL
(
iphdr
) * 4)) || (p->
len
 < 
IGMP_MINLEN
)) {

354 
	`pbuf_free
(
p
);

355 
	`IGMP_STATS_INC
(
igmp
.
lenerr
);

356 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: length error\n"));

360 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: message from "));

361 
	`ip_addr_debug_print
(
IGMP_DEBUG
, &(
iphdr
->
src
));

362 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (" to address "));

363 
	`ip_addr_debug_print
(
IGMP_DEBUG
, &(
iphdr
->
dest
));

364 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (" on if %x\n", (int) 
inp
));

367 
igmp
 = (struct 
igmp_msg
 *)
p
->
payload
;

368 if (
	`inet_chksum
(
igmp
, 
p
->
len
)) {

369 
	`pbuf_free
(
p
);

370 
	`IGMP_STATS_INC
(
igmp
.
chkerr
);

371 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: checksum error\n"));

376 
group
 = 
	`igmp_lookfor_group
(
inp
, 
dest
);

379 if (!
group
) {

380 
	`pbuf_free
(
p
);

381 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: IGMP frame not for us\n"));

386 switch (
igmp
->
igmp_msgtype
) {

387 case 
IGMP_MEMB_QUERY
: {

389 if ((
	`ip_addr_cmp
(
dest
, &
allsystems
)) && (
igmp
->
igmp_group_address
.
addr
 == 0)) {

391 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: General IGMP_MEMB_QUERY on \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(
igmp
->
igmp_maxresp
)));

393 if (
igmp
->
igmp_maxresp
 == 0) {

394 
	`IGMP_STATS_INC
(
igmp
.
v1_rxed
);

395 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\n"));

396 
igmp
->
igmp_maxresp
 = 
IGMP_V1_DELAYING_MEMBER_TMR
;

399 
	`IGMP_STATS_INC
(
igmp
.
group_query_rxed
);

400 
groupref
 = 
igmp_group_list
;

401 while (
groupref
) {

403 if ((
groupref
->
interface
 == 
inp
) && (!(
	`ip_addr_cmp
(&(groupref->
group_address
), &
allsystems
)))) {

404 
	`igmp_delaying_member
( 
groupref
, 
igmp
->
igmp_maxresp
);

406 
groupref
 = groupref->
next
;

410 if (
group
->
group_address
.
addr
 != 0) {

411 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: IGMP_MEMB_QUERY to a specific group "));

412 
	`ip_addr_debug_print
(
IGMP_DEBUG
, &
group
->
group_address
);

413 if (
	`ip_addr_cmp
 (
dest
, &
allsystems
)) {

414 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (" using \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(
igmp
->
igmp_maxresp
)));

416 
group
 = 
	`igmp_lookfor_group
(
inp
, &
igmp
->
igmp_group_address
);

418 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (" with the group address as destination [igmp_maxresp=%i]\n", (int)(
igmp
->
igmp_maxresp
)));

421 if (
group
 != 
NULL
) {

422 
	`IGMP_STATS_INC
(
igmp
.
unicast_query
);

423 
	`igmp_delaying_member
( 
group
, 
igmp
->
igmp_maxresp
);

429 case 
IGMP_V2_MEMB_REPORT
: {

430 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: IGMP_V2_MEMB_REPORT\n"));

432 
	`IGMP_STATS_INC
(
igmp
.
report_rxed
);

433 if (
group
->
group_state
 == 
IGMP_GROUP_DELAYING_MEMBER
) {

435 
group
->
timer
 = 0;

436 
group
->
group_state
 = 
IGMP_GROUP_IDLE_MEMBER
;

437 
group
->
last_reporter_flag
 = 0;

442 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_input: unexpected msg %x in state %x on group %x on if %x\n", (int) 
igmp
->
igmp_msgtype
, (int) 
group
->
group_state
, (int) &group, (int) group->
interface
));

447 
	`pbuf_free
(
p
);

449 
	}
}

458 
err_t


459 
	$igmp_joingroup
(struct 
ip_addr
 *
ifaddr
, struct ip_addr *
groupaddr
)

461 
err_t
 
err
 = 
ERR_VAL
;

462 struct 
igmp_group
 *
group
;

463 struct 
netif
 *netif;

466 
	`LWIP_ERROR
("igmp_joingroup: attempt to join non-multicast address", 
	`ip_addr_ismulticast
(
groupaddr
), return 
ERR_VAL
;);

467 
	`LWIP_ERROR
("igmp_joingroup: attempt to join allsystems address", (!
	`ip_addr_cmp
(
groupaddr
, &
allsystems
)), return 
ERR_VAL
;);

470 
netif
 = 
netif_list
;

471 while (
netif
 != 
NULL
) {

473 if ((
netif
->
flags
 & 
NETIF_FLAG_IGMP
) && ((
	`ip_addr_isany
(
ifaddr
) || 
	`ip_addr_cmp
(&(netif->
ip_addr
), ifaddr)))) {

475 
group
 = 
	`igmp_lookup_group
(
netif
, 
groupaddr
);

477 if (
group
 != 
NULL
) {

479 if (
group
->
group_state
 != 
IGMP_GROUP_NON_MEMBER
) {

480 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_joingroup: join to group not in state IGMP_GROUP_NON_MEMBER\n"));

483 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_joingroup: join to new group: "));

484 
	`ip_addr_debug_print
(
IGMP_DEBUG
, 
groupaddr
);

485 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("\n"));

488 if ((
group
->
use
==0) && (
netif
->
igmp_mac_filter
 != 
NULL
)) {

489 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_joingroup: igmp_mac_filter(ADD "));

490 
	`ip_addr_debug_print
(
IGMP_DEBUG
, 
groupaddr
);

491 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (") on if %x\n", (int) 
netif
));

492 
netif
->
	`igmp_mac_filter
(netif, 
groupaddr
, 
IGMP_ADD_MAC_FILTER
);

495 
	`IGMP_STATS_INC
(
igmp
.
join_sent
);

496 
	`igmp_send
(
group
, 
IGMP_V2_MEMB_REPORT
);

498 
	`igmp_start_timer
(
group
, 
IGMP_JOIN_DELAYING_MEMBER_TMR
);

501 
group
->
group_state
 = 
IGMP_GROUP_DELAYING_MEMBER
;

504 
group
->
use
++;

506 
err
 = 
ERR_OK
;

510 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_joingroup: Not enought memory to join to group\n"));

511 return 
ERR_MEM
;

515 
netif
 = netif->
next
;

518 return 
err
;

519 
	}
}

528 
err_t


529 
	$igmp_leavegroup
(struct 
ip_addr
 *
ifaddr
, struct ip_addr *
groupaddr
)

531 
err_t
 
err
 = 
ERR_VAL
;

532 struct 
igmp_group
 *
group
;

533 struct 
netif
 *netif;

536 
	`LWIP_ERROR
("igmp_leavegroup: attempt to leave non-multicast address", 
	`ip_addr_ismulticast
(
groupaddr
), return 
ERR_VAL
;);

537 
	`LWIP_ERROR
("igmp_leavegroup: attempt to leave allsystems address", (!
	`ip_addr_cmp
(
groupaddr
, &
allsystems
)), return 
ERR_VAL
;);

540 
netif
 = 
netif_list
;

541 while (
netif
 != 
NULL
) {

543 if ((
netif
->
flags
 & 
NETIF_FLAG_IGMP
) && ((
	`ip_addr_isany
(
ifaddr
) || 
	`ip_addr_cmp
(&(netif->
ip_addr
), ifaddr)))) {

545 
group
 = 
	`igmp_lookfor_group
(
netif
, 
groupaddr
);

547 if (
group
 != 
NULL
) {

549 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_leavegroup: Leaving group: "));

550 
	`ip_addr_debug_print
(
IGMP_DEBUG
, 
groupaddr
);

551 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("\n"));

554 if (
group
->
use
 <= 1) {

556 if (
group
->
last_reporter_flag
) {

557 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_leavegroup: sending leaving group\n"));

558 
	`IGMP_STATS_INC
(
igmp
.
leave_sent
);

559 
	`igmp_send
(
group
, 
IGMP_LEAVE_GROUP
);

563 if (
netif
->
igmp_mac_filter
 != 
NULL
) {

564 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_leavegroup: igmp_mac_filter(DEL "));

565 
	`ip_addr_debug_print
(
IGMP_DEBUG
, 
groupaddr
);

566 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (") on if %x\n", (int) 
netif
));

567 
netif
->
	`igmp_mac_filter
(netif, 
groupaddr
, 
IGMP_DEL_MAC_FILTER
);

570 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_leavegroup: remove group: "));

571 
	`ip_addr_debug_print
(
IGMP_DEBUG
, 
groupaddr
);

572 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("\n"));

575 
	`igmp_remove_group
(
group
);

578 
group
->
use
--;

581 
err
 = 
ERR_OK
;

584 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_leavegroup: not member of group\n"));

588 
netif
 = netif->
next
;

591 return 
err
;

592 
	}
}

599 
	$igmp_tmr
(void)

601 struct 
igmp_group
 *
group
 = 
igmp_group_list
;

603 while (
group
 != 
NULL
) {

604 if (
group
->
timer
 != 0) {

605 
group
->
timer
 -= 1;

606 if (
group
->
timer
 == 0) {

607 
	`igmp_timeout
(
group
);

610 
group
 = group->
next
;

612 
	}
}

621 
	$igmp_timeout
(struct 
igmp_group
 *
group
)

624 if (
group
->
group_state
 == 
IGMP_GROUP_DELAYING_MEMBER
) {

625 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_timeout: report membership for group with address "));

626 
	`ip_addr_debug_print
(
IGMP_DEBUG
, &(
group
->
group_address
));

627 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, (" on if %x\n", (int) 
group
->
interface
));

629 
	`igmp_send
(
group
, 
IGMP_V2_MEMB_REPORT
);

631 
	}
}

641 
	$igmp_start_timer
(struct 
igmp_group
 *
group
, 
u8_t
 
max_time
)

646 
group
->
timer
 = 
max_time
;

647 
	}
}

655 
	$igmp_stop_timer
(struct 
igmp_group
 *
group
)

657 
group
->
timer
 = 0;

658 
	}
}

667 
	$igmp_delaying_member
( struct 
igmp_group
 *
group
, 
u8_t
 
maxresp
)

669 if ((
group
->
group_state
 == 
IGMP_GROUP_IDLE_MEMBER
) || ((group->group_state == 
IGMP_GROUP_DELAYING_MEMBER
) && (
maxresp
 > group->
timer
))) {

670 
	`igmp_start_timer
(
group
, (
maxresp
)/2);

671 
group
->
group_state
 = 
IGMP_GROUP_DELAYING_MEMBER
;

673 
	}
}

694 
err_t


695 
	$igmp_ip_output_if
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

696 
u8_t
 
ttl
, u8_t 
proto
, struct 
netif
 *netif)

698 static 
u16_t
 
ip_id
 = 0;

699 struct 
ip_hdr
 * 
iphdr
 = 
NULL
;

700 
u16_t
 * 
ra
 = 
NULL
;

703 if (
	`pbuf_header
(
p
, 
ROUTER_ALERTLEN
)) {

704 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_ip_output_if: not enough room for IP header in pbuf\n"));

705 return 
ERR_BUF
;

709 
ra
 = 
p
->
payload
;

710 
ra
[0] = 
	`htons
 (
ROUTER_ALERT
);

711 
ra
[1] = 0x0000;

714 if (
	`pbuf_header
(
p
, 
IP_HLEN
)) {

715 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_ip_output_if: not enough room for IP header in pbuf\n"));

716 return 
ERR_BUF
;

719 
iphdr
 = 
p
->
payload
;

722 if (
dest
 != 
IP_HDRINCL
) {

724 
	`IPH_TTL_SET
(
iphdr
, 
ttl
);

725 
	`IPH_PROTO_SET
(
iphdr
, 
proto
);

727 
	`ip_addr_set
(&(
iphdr
->
dest
), dest);

729 
	`IPH_VHLTOS_SET
(
iphdr
, 4, ((
IP_HLEN
 + 
ROUTER_ALERTLEN
) / 4), 0 );

730 
	`IPH_LEN_SET
(
iphdr
, 
	`htons
(
p
->
tot_len
));

731 
	`IPH_OFFSET_SET
(
iphdr
, 0);

732 
	`IPH_ID_SET
(
iphdr
, 
	`htons
(
ip_id
));

733 ++
ip_id
;

735 if (
	`ip_addr_isany
(
src
)) {

736 
	`ip_addr_set
(&(
iphdr
->
src
), &(
netif
->
ip_addr
));

738 
	`ip_addr_set
(&(
iphdr
->
src
), src);

741 
	`IPH_CHKSUM_SET
(
iphdr
, 0);

742 #if 
CHECKSUM_GEN_IP


743 
	`IPH_CHKSUM_SET
(
iphdr
, 
	`inet_chksum
(iphdr, (
IP_HLEN
 + 
ROUTER_ALERTLEN
)));

746 
dest
 = &(
iphdr
->dest);

749 #if 
IP_DEBUG


750 
	`ip_debug_print
(
p
);

753 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_ip_output_if: sending to if %x\n", (int) 
netif
));

755 return 
netif
->
	`output
(netif, 
p
, 
dest
);

756 
	}
}

765 
	$igmp_send
(struct 
igmp_group
 *
group
, 
u8_t
 
type
)

767 struct 
pbuf
* 
p
 = 
NULL
;

768 struct 
igmp_msg
* 
igmp
 = 
NULL
;

769 struct 
ip_addr
 
src
 = {0};

770 struct 
ip_addr
* 
dest
 = 
NULL
;

773 
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
IGMP_MINLEN
, 
PBUF_RAM
);

775 if (
p
) {

776 
igmp
 = 
p
->
payload
;

777 
	`LWIP_ASSERT
("igmp_send: check that first pbuf can hold struct igmp_msg",

778 (
p
->
len
 >= sizeof(struct 
igmp_msg
)));

779 
	`ip_addr_set
(&
src
, &((
group
->
interface
)->
ip_addr
));

781 if (
type
 == 
IGMP_V2_MEMB_REPORT
) {

782 
dest
 = &(
group
->
group_address
);

783 
	`IGMP_STATS_INC
(
igmp
.
report_sent
);

784 
	`ip_addr_set
(&(
igmp
->
igmp_group_address
), &(
group
->
group_address
));

785 
group
->
last_reporter_flag
 = 1;

787 if (
type
 == 
IGMP_LEAVE_GROUP
) {

788 
dest
 = &
allrouters
;

789 
	`ip_addr_set
(&(
igmp
->
igmp_group_address
), &(
group
->
group_address
));

793 if ((
type
 == 
IGMP_V2_MEMB_REPORT
) || (type == 
IGMP_LEAVE_GROUP
)) {

794 
igmp
->
igmp_msgtype
 = 
type
;

795 
igmp
->
igmp_maxresp
 = 0;

796 
igmp
->
igmp_checksum
 = 0;

797 
igmp
->
igmp_checksum
 = 
	`inet_chksum
( igmp, 
IGMP_MINLEN
);

799 
	`igmp_ip_output_if
( 
p
, &
src
, 
dest
, 
IGMP_TTL
, 
IP_PROTO_IGMP
, 
group
->
interface
);

802 
	`pbuf_free
 (
p
);

804 
	`LWIP_DEBUGF
(
IGMP_DEBUG
, ("igmp_send: not enough memory for igmp_send\n"));

806 
	}
}

	@/root/Robux/net/lwip/core/ipv4/inet.c

39 #include 
	~"lwip/opt.h
"

41 #include 
	~"lwip/inet.h
"

44 #ifndef 
isprint


45 #define 
	#in_range
(
c
, 
lo
, 
up
) ((
u8_t
)c >= lo && (u8_t)c <= up)

	)

46 #define 
	#isprint
(
c
) 
	`in_range
(c, 0x20, 0x7f)

	)

47 #define 
	#isdigit
(
c
) 
	`in_range
(c, '0', '9')

	)

48 #define 
	#isxdigit
(
c
) (
	`isdigit
(c) || 
	`in_range
(c, 'a', 'f') || in_range(c, 'A', 'F'))

	)

49 #define 
	#islower
(
c
) 
	`in_range
(c, 'a', 'z')

	)

50 #define 
	#isspace
(
c
) (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v')

	)

60 
u32_t


61 
	$inet_addr
(const char *
cp
)

63 struct 
in_addr
 
val
;

65 if (
	`inet_aton
(
cp
, &
val
)) {

66 return (
val
.
s_addr
);

68 return (
INADDR_NONE
);

69 
	}
}

83 
	$inet_aton
(const char *
cp
, struct 
in_addr
 *
addr
)

85 
u32_t
 
val
;

86 int 
base
, 
n
, 
c
;

87 
u32_t
 
parts
[4];

88 
u32_t
 *
pp
 = 
parts
;

90 
c
 = *
cp
;

97 if (!
	`isdigit
(
c
))

99 
val
 = 0;

100 
base
 = 10;

101 if (
c
 == '0') {

102 
c
 = *++
cp
;

103 if (
c
 == 'x' || c == 'X') {

104 
base
 = 16;

105 
c
 = *++
cp
;

107 
base
 = 8;

110 if (
	`isdigit
(
c
)) {

111 
val
 = (val * 
base
) + (int)(
c
 - '0');

112 
c
 = *++
cp
;

113 } else if (
base
 == 16 && 
	`isxdigit
(
c
)) {

114 
val
 = (val << 4) | (int)(
c
 + 10 - (
	`islower
(c) ? 'a' : 'A'));

115 
c
 = *++
cp
;

119 if (
c
 == '.') {

126 if (
pp
 >= 
parts
 + 3)

128 *
pp
++ = 
val
;

129 
c
 = *++
cp
;

136 if (
c
 != '\0' && (!
	`isprint
(c) || !
	`isspace
(c)))

142 
n
 = 
pp
 - 
parts
 + 1;

143 switch (
n
) {

152 if (
val
 > 0xffffffUL)

154 
val
 |= 
parts
[0] << 24;

158 if (
val
 > 0xffff)

160 
val
 |= (
parts
[0] << 24) | (parts[1] << 16);

164 if (
val
 > 0xff)

166 
val
 |= (
parts
[0] << 24) | (parts[1] << 16) | (parts[2] << 8);

169 if (
addr
)

170 
addr
->
s_addr
 = 
	`htonl
(
val
);

172 
	}
}

183 
	$inet_ntoa
(struct 
in_addr
 
addr
)

185 static char 
str
[16];

186 
u32_t
 
s_addr
 = 
addr
.s_addr;

187 char 
inv
[3];

188 char *
rp
;

189 
u8_t
 *
ap
;

190 
u8_t
 
rem
;

191 
u8_t
 
n
;

192 
u8_t
 
i
;

194 
rp
 = 
str
;

195 
ap
 = (
u8_t
 *)&
s_addr
;

196 for(
n
 = 0; n < 4; n++) {

197 
i
 = 0;

199 
rem
 = *
ap
 % (
u8_t
)10;

200 *
ap
 /= (
u8_t
)10;

201 
inv
[
i
++] = '0' + 
rem
;

202 } while(*
ap
);

203 while(
i
--)

204 *
rp
++ = 
inv
[
i
];

205 *
rp
++ = '.';

206 
ap
++;

208 *--
rp
 = 0;

209 return 
str
;

210 
	}
}

225 #if (
LWIP_PLATFORM_BYTESWAP
 == 0) && (
BYTE_ORDER
 == 
LITTLE_ENDIAN
)

233 
u16_t


234 
	$htons
(
u16_t
 
n
)

236 return ((
n
 & 0xff) << 8) | ((n & 0xff00) >> 8);

237 
	}
}

245 
u16_t


246 
	$ntohs
(
u16_t
 
n
)

248 return 
	`htons
(
n
);

249 
	}
}

257 
u32_t


258 
	$htonl
(
u32_t
 
n
)

260 return ((
n
 & 0xff) << 24) |

261 ((
n
 & 0xff00) << 8) |

262 ((
n
 & 0xff0000UL) >> 8) |

263 ((
n
 & 0xff000000UL) >> 24);

264 
	}
}

272 
u32_t


273 
	$ntohl
(
u32_t
 
n
)

275 return 
	`htonl
(
n
);

276 
	}
}

	@/root/Robux/net/lwip/core/ipv4/inet_chksum.c

39 #include 
	~"lwip/opt.h
"

41 #include 
	~"lwip/inet_chksum.h
"

42 #include 
	~"lwip/inet.h
"

55 #ifndef 
LWIP_CHKSUM


56 #define 
	#LWIP_CHKSUM
 
lwip_standard_chksum


	)

57 #ifndef 
LWIP_CHKSUM_ALGORITHM


58 #define 
	#LWIP_CHKSUM_ALGORITHM
 1

	)

62 #ifndef 
LWIP_CHKSUM_ALGORITHM


63 #define 
	#LWIP_CHKSUM_ALGORITHM
 0

	)

67 #define 
	#SWAP_BYTES_IN_WORD
(
w
) ((w & 0xff) << 8) | ((w & 0xff00) >> 8)

	)

69 #define 
	#FOLD_U32T
(
u
) ((u >> 16) + (u & 0x0000ffffUL))

	)

71 #if (
LWIP_CHKSUM_ALGORITHM
 == 1)

82 static 
u16_t


83 
	$lwip_standard_chksum
(void *
dataptr
, 
u16_t
 
len
)

85 
u32_t
 
acc
;

86 
u16_t
 
src
;

87 
u8_t
 *
octetptr
;

89 
acc
 = 0;

91 
octetptr
 = (
u8_t
*)
dataptr
;

92 while (
len
 > 1) {

95 
src
 = (*
octetptr
) << 8;

96 
octetptr
++;

98 
src
 |= (*
octetptr
);

99 
octetptr
++;

100 
acc
 += 
src
;

101 
len
 -= 2;

103 if (
len
 > 0) {

105 
src
 = (*
octetptr
) << 8;

106 
acc
 += 
src
;

109 
acc
 = (acc >> 16) + (acc & 0x0000ffffUL);

110 if ((
acc
 & 0xffff0000) != 0) {

111 
acc
 = (acc >> 16) + (acc & 0x0000ffffUL);

116 return 
	`htons
((
u16_t
)
acc
);

117 
	}
}

120 #if (
LWIP_CHKSUM_ALGORITHM
 == 2)

136 static 
u16_t


137 
	$lwip_standard_chksum
(void *
dataptr
, int 
len
)

139 
u8_t
 *
pb
 = 
dataptr
;

140 
u16_t
 *
ps
, 
t
 = 0;

141 
u32_t
 
sum
 = 0;

142 int 
odd
 = ((
u32_t
)
pb
 & 1);

145 if (
odd
 && 
len
 > 0) {

146 ((
u8_t
 *)&
t
)[1] = *
pb
++;

147 
len
--;

151 
ps
 = (
u16_t
 *)
pb
;

152 while (
len
 > 1) {

153 
sum
 += *
ps
++;

154 
len
 -= 2;

158 if (
len
 > 0) {

159 ((
u8_t
 *)&
t
)[0] = *(u8_t *)
ps
;;

163 
sum
 += 
t
;

167 
sum
 = 
	`FOLD_U32T
(sum);

168 
sum
 = 
	`FOLD_U32T
(sum);

171 if (
odd
) {

172 
sum
 = 
	`SWAP_BYTES_IN_WORD
(sum);

175 return 
sum
;

176 
	}
}

179 #if (
LWIP_CHKSUM_ALGORITHM
 == 3)

192 static 
u16_t


193 
	$lwip_standard_chksum
(void *
dataptr
, int 
len
)

195 
u8_t
 *
pb
 = 
dataptr
;

196 
u16_t
 *
ps
, 
t
 = 0;

197 
u32_t
 *
pl
;

198 
u32_t
 
sum
 = 0, 
tmp
;

200 int 
odd
 = ((
u32_t
)
pb
 & 1);

202 if (
odd
 && 
len
 > 0) {

203 ((
u8_t
 *)&
t
)[1] = *
pb
++;

204 
len
--;

207 
ps
 = (
u16_t
 *)
pb
;

209 if (((
u32_t
)
ps
 & 3) && 
len
 > 1) {

210 
sum
 += *
ps
++;

211 
len
 -= 2;

214 
pl
 = (
u32_t
 *)
ps
;

216 while (
len
 > 7) {

217 
tmp
 = 
sum
 + *
pl
++;

218 if (
tmp
 < 
sum
) {

219 
tmp
++;

222 
sum
 = 
tmp
 + *
pl
++;

223 if (
sum
 < 
tmp
) {

224 
sum
++;

227 
len
 -= 8;

231 
sum
 = 
	`FOLD_U32T
(sum);

233 
ps
 = (
u16_t
 *)
pl
;

236 while (
len
 > 1) {

237 
sum
 += *
ps
++;

238 
len
 -= 2;

242 if (
len
 > 0) {

243 ((
u8_t
 *)&
t
)[0] = *(u8_t *)
ps
;

246 
sum
 += 
t
;

250 
sum
 = 
	`FOLD_U32T
(sum);

251 
sum
 = 
	`FOLD_U32T
(sum);

253 if (
odd
) {

254 
sum
 = 
	`SWAP_BYTES_IN_WORD
(sum);

257 return 
sum
;

258 
	}
}

273 
u16_t


274 
	$inet_chksum_pseudo
(struct 
pbuf
 *
p
,

275 struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

276 
u8_t
 
proto
, 
u16_t
 
proto_len
)

278 
u32_t
 
acc
;

279 struct 
pbuf
 *
q
;

280 
u8_t
 
swapped
;

282 
acc
 = 0;

283 
swapped
 = 0;

285 for(
q
 = 
p
; q != 
NULL
; q = q->
next
) {

286 
	`LWIP_DEBUGF
(
INET_DEBUG
, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",

287 (void *)
q
, (void *)q->
next
));

288 
acc
 += 
	`LWIP_CHKSUM
(
q
->
payload
, q->
len
);

292 
acc
 = 
	`FOLD_U32T
(acc);

293 if (
q
->
len
 % 2 != 0) {

294 
swapped
 = 1 - swapped;

295 
acc
 = 
	`SWAP_BYTES_IN_WORD
(acc);

300 if (
swapped
) {

301 
acc
 = 
	`SWAP_BYTES_IN_WORD
(acc);

303 
acc
 += (
src
->
addr
 & 0xffffUL);

304 
acc
 += ((
src
->
addr
 >> 16) & 0xffffUL);

305 
acc
 += (
dest
->
addr
 & 0xffffUL);

306 
acc
 += ((
dest
->
addr
 >> 16) & 0xffffUL);

307 
acc
 += (
u32_t
)
	`htons
((
u16_t
)
proto
);

308 
acc
 += (
u32_t
)
	`htons
(
proto_len
);

312 
acc
 = 
	`FOLD_U32T
(acc);

313 
acc
 = 
	`FOLD_U32T
(acc);

314 
	`LWIP_DEBUGF
(
INET_DEBUG
, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"
X32_F
"\n", 
acc
));

315 return (
u16_t
)~(
acc
 & 0xffffUL);

316 
	}
}

330 
u16_t


331 
	$inet_chksum_pseudo_partial
(struct 
pbuf
 *
p
,

332 struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

333 
u8_t
 
proto
, 
u16_t
 
proto_len
, u16_t 
chksum_len
)

335 
u32_t
 
acc
;

336 struct 
pbuf
 *
q
;

337 
u8_t
 
swapped
;

338 
u16_t
 
chklen
;

340 
acc
 = 0;

341 
swapped
 = 0;

343 for(
q
 = 
p
; (q != 
NULL
) && (
chksum_len
 > 0); q = q->
next
) {

344 
	`LWIP_DEBUGF
(
INET_DEBUG
, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",

345 (void *)
q
, (void *)q->
next
));

346 
chklen
 = 
q
->
len
;

347 if (
chklen
 > 
chksum_len
) {

348 
chklen
 = 
chksum_len
;

350 
acc
 += 
	`LWIP_CHKSUM
(
q
->
payload
, 
chklen
);

351 
chksum_len
 -= 
chklen
;

352 
	`LWIP_ASSERT
("delete me", 
chksum_len
 < 0x7fff);

355 
acc
 = 
	`FOLD_U32T
(acc);

356 if (
q
->
len
 % 2 != 0) {

357 
swapped
 = 1 - swapped;

358 
acc
 = 
	`SWAP_BYTES_IN_WORD
(acc);

363 if (
swapped
) {

364 
acc
 = 
	`SWAP_BYTES_IN_WORD
(acc);

366 
acc
 += (
src
->
addr
 & 0xffffUL);

367 
acc
 += ((
src
->
addr
 >> 16) & 0xffffUL);

368 
acc
 += (
dest
->
addr
 & 0xffffUL);

369 
acc
 += ((
dest
->
addr
 >> 16) & 0xffffUL);

370 
acc
 += (
u32_t
)
	`htons
((
u16_t
)
proto
);

371 
acc
 += (
u32_t
)
	`htons
(
proto_len
);

375 
acc
 = 
	`FOLD_U32T
(acc);

376 
acc
 = 
	`FOLD_U32T
(acc);

377 
	`LWIP_DEBUGF
(
INET_DEBUG
, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"
X32_F
"\n", 
acc
));

378 return (
u16_t
)~(
acc
 & 0xffffUL);

379 
	}
}

391 
u16_t


392 
	$inet_chksum
(void *
dataptr
, 
u16_t
 
len
)

394 return ~
	`LWIP_CHKSUM
(
dataptr
, 
len
);

395 
	}
}

404 
u16_t


405 
	$inet_chksum_pbuf
(struct 
pbuf
 *
p
)

407 
u32_t
 
acc
;

408 struct 
pbuf
 *
q
;

409 
u8_t
 
swapped
;

411 
acc
 = 0;

412 
swapped
 = 0;

413 for(
q
 = 
p
; q != 
NULL
; q = q->
next
) {

414 
acc
 += 
	`LWIP_CHKSUM
(
q
->
payload
, q->
len
);

415 
acc
 = 
	`FOLD_U32T
(acc);

416 if (
q
->
len
 % 2 != 0) {

417 
swapped
 = 1 - swapped;

418 
acc
 = 
	`SWAP_BYTES_IN_WORD
(acc);

422 if (
swapped
) {

423 
acc
 = 
	`SWAP_BYTES_IN_WORD
(acc);

425 return (
u16_t
)~(
acc
 & 0xffffUL);

426 
	}
}

	@/root/Robux/net/lwip/core/ipv4/ip.c

41 #include 
	~"lwip/opt.h
"

42 #include 
	~"lwip/ip.h
"

43 #include 
	~"lwip/def.h
"

44 #include 
	~"lwip/mem.h
"

45 #include 
	~"lwip/ip_frag.h
"

46 #include 
	~"lwip/inet.h
"

47 #include 
	~"lwip/inet_chksum.h
"

48 #include 
	~"lwip/netif.h
"

49 #include 
	~"lwip/icmp.h
"

50 #include 
	~"lwip/igmp.h
"

51 #include 
	~"lwip/raw.h
"

52 #include 
	~"lwip/udp.h
"

53 #include 
	~"lwip/tcp.h
"

54 #include 
	~"lwip/snmp.h
"

55 #include 
	~"lwip/dhcp.h
"

56 #include 
	~"lwip/stats.h
"

57 #include 
	~"arch/perf.h
"

68 struct 
netif
 *

69 
	$ip_route
(struct 
ip_addr
 *
dest
)

71 struct 
netif
 *netif;

74 for(
netif
 = 
netif_list
; netif != 
NULL
; netif = netif->
next
) {

76 if (
	`netif_is_up
(
netif
)) {

77 if (
	`ip_addr_netcmp
(
dest
, &(
netif
->
ip_addr
), &(netif->
netmask
))) {

79 return 
netif
;

83 if ((
netif_default
 == 
NULL
) || (!
	`netif_is_up
(netif_default))) {

84 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("ip_route: No route to 0x%"
X32_F
"\n", 
dest
->
addr
));

85 
	`IP_STATS_INC
(
ip
.
rterr
);

86 
	`snmp_inc_ipoutnoroutes
();

87 return 
NULL
;

90 return 
netif_default
;

91 
	}
}

93 #if 
IP_FORWARD


104 static struct 
netif
 *

105 
	$ip_forward
(struct 
pbuf
 *
p
, struct 
ip_hdr
 *
iphdr
, struct 
netif
 *
inp
)

107 struct 
netif
 *netif;

109 
PERF_START
;

111 
netif
 = 
	`ip_route
((struct 
ip_addr
 *)&(
iphdr
->
dest
));

112 if (
netif
 == 
NULL
) {

113 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_forward: no forwarding route for 0x%"
X32_F
" found\n",

114 
iphdr
->
dest
.
addr
));

115 
	`snmp_inc_ipoutnoroutes
();

116 return (struct 
netif
 *)
NULL
;

120 if (
netif
 == 
inp
) {

121 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_forward: not bouncing packets back on incoming interface.\n"));

122 
	`snmp_inc_ipoutnoroutes
();

123 return (struct 
netif
 *)
NULL
;

127 
	`IPH_TTL_SET
(
iphdr
, 
	`IPH_TTL
(iphdr) - 1);

129 if (
	`IPH_TTL
(
iphdr
) == 0) {

130 
	`snmp_inc_ipinhdrerrors
();

131 #if 
LWIP_ICMP


133 if (
	`IPH_PROTO
(
iphdr
) != 
IP_PROTO_ICMP
) {

134 
	`icmp_time_exceeded
(
p
, 
ICMP_TE_TTL
);

137 return (struct 
netif
 *)
NULL
;

141 if (
	`IPH_CHKSUM
(
iphdr
) >= 
	`htons
(0xffff - 0x100)) {

142 
	`IPH_CHKSUM_SET
(
iphdr
, 
	`IPH_CHKSUM
(iphdr) + 
	`htons
(0x100) + 1);

144 
	`IPH_CHKSUM_SET
(
iphdr
, 
	`IPH_CHKSUM
(iphdr) + 
	`htons
(0x100));

147 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_forward: forwarding packet to 0x%"
X32_F
"\n",

148 
iphdr
->
dest
.
addr
));

150 
	`IP_STATS_INC
(
ip
.
fw
);

151 
	`IP_STATS_INC
(
ip
.
xmit
);

152 
	`snmp_inc_ipforwdatagrams
();

154 
	`PERF_STOP
("ip_forward");

156 
netif
->
	`output
(netif, 
p
, (struct 
ip_addr
 *)&(
iphdr
->
dest
));

157 return 
netif
;

158 
	}
}

175 
err_t


176 
	$ip_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
)

178 struct 
ip_hdr
 *
iphdr
;

179 struct 
netif
 *netif;

180 
u16_t
 
iphdr_hlen
;

181 
u16_t
 
iphdr_len
;

182 #if 
LWIP_DHCP


183 int 
check_ip_src
=1;

186 
	`IP_STATS_INC
(
ip
.
recv
);

187 
	`snmp_inc_ipinreceives
();

190 
iphdr
 = 
p
->
payload
;

191 if (
	`IPH_V
(
iphdr
) != 4) {

192 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 1, ("IP packet dropped due to bad version number %"
U16_F
"\n", 
	`IPH_V
(
iphdr
)));

193 
	`ip_debug_print
(
p
);

194 
	`pbuf_free
(
p
);

195 
	`IP_STATS_INC
(
ip
.
err
);

196 
	`IP_STATS_INC
(
ip
.
drop
);

197 
	`snmp_inc_ipinhdrerrors
();

198 return 
ERR_OK
;

202 
iphdr_hlen
 = 
	`IPH_HL
(
iphdr
);

204 
iphdr_hlen
 *= 4;

206 
iphdr_len
 = 
	`ntohs
(
	`IPH_LEN
(
iphdr
));

209 if ((
iphdr_hlen
 > 
p
->
len
) || (
iphdr_len
 > p->
tot_len
)) {

210 if (
iphdr_hlen
 > 
p
->
len
)

211 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("IP header (len %"
U16_F
") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",

212 
iphdr_hlen
, 
p
->
len
));

213 if (
iphdr_len
 > 
p
->
tot_len
)

214 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("IP (len %"
U16_F
") is longer than pbuf (len %"U16_F"), "

216 
iphdr_len
, 
p
->
tot_len
));

218 
	`pbuf_free
(
p
);

219 
	`IP_STATS_INC
(
ip
.
lenerr
);

220 
	`IP_STATS_INC
(
ip
.
drop
);

221 
	`snmp_inc_ipindiscards
();

222 return 
ERR_OK
;

226 #if 
CHECKSUM_CHECK_IP


227 if (
	`inet_chksum
(
iphdr
, 
iphdr_hlen
) != 0) {

229 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("Checksum (0x%"
X16_F
") failed, IP packet dropped.\n", 
	`inet_chksum
(
iphdr
, 
iphdr_hlen
)));

230 
	`ip_debug_print
(
p
);

231 
	`pbuf_free
(
p
);

232 
	`IP_STATS_INC
(
ip
.
chkerr
);

233 
	`IP_STATS_INC
(
ip
.
drop
);

234 
	`snmp_inc_ipinhdrerrors
();

235 return 
ERR_OK
;

241 
	`pbuf_realloc
(
p
, 
iphdr_len
);

244 #if 
LWIP_IGMP


245 if (
	`ip_addr_ismulticast
(&(
iphdr
->
dest
))) {

246 if ((
inp
->
flags
 & 
NETIF_FLAG_IGMP
) && (
	`igmp_lookfor_group
(inp, &(
iphdr
->
dest
)))) {

247 
netif
 = 
inp
;

249 
netif
 = 
NULL
;

257 int 
first
 = 1;

258 
netif
 = 
inp
;

260 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_input: iphdr->dest 0x%"
X32_F
" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",

261 
iphdr
->
dest
.
addr
, 
netif
->
ip_addr
.addr,

262 
iphdr
->
dest
.
addr
 & 
netif
->
netmask
.addr,

263 
netif
->
ip_addr
.
addr
 & netif->
netmask
.addr,

264 
iphdr
->
dest
.
addr
 & ~(
netif
->
netmask
.addr)));

267 if ((
	`netif_is_up
(
netif
)) && (!
	`ip_addr_isany
(&(netif->
ip_addr
)))) {

269 if (
	`ip_addr_cmp
(&(
iphdr
->
dest
), &(
netif
->
ip_addr
)) ||

271 
	`ip_addr_isbroadcast
(&(
iphdr
->
dest
), 
netif
)) {

272 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_input: packet accepted on interface %c%c\n",

273 
netif
->
name
[0], netif->name[1]));

278 if (
first
) {

279 
first
 = 0;

280 
netif
 = 
netif_list
;

282 
netif
 = netif->
next
;

284 if (
netif
 == 
inp
) {

285 
netif
 = netif->
next
;

287 } while(
netif
 != 
NULL
);

290 #if 
LWIP_DHCP


295 if (
netif
 == 
NULL
) {

297 if (
	`IPH_PROTO
(
iphdr
) == 
IP_PROTO_UDP
) {

298 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("ip_input: UDP packet to DHCP client port %"
U16_F
"\n",

299 
	`ntohs
(((struct 
udp_hdr
 *)((
u8_t
 *)
iphdr
 + 
iphdr_hlen
))->
dest
)));

300 if (
	`ntohs
(((struct 
udp_hdr
 *)((
u8_t
 *)
iphdr
 + 
iphdr_hlen
))->
dest
) == 
DHCP_CLIENT_PORT
) {

301 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("ip_input: DHCP packet accepted.\n"));

302 
netif
 = 
inp
;

303 
check_ip_src
 = 0;

310 #if 
LWIP_DHCP


311 if (
check_ip_src
)

313 { if ((
	`ip_addr_isbroadcast
(&(
iphdr
->
src
), 
inp
)) ||

314 (
	`ip_addr_ismulticast
(&(
iphdr
->
src
)))) {

316 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("ip_input: packet source is not valid.\n"));

318 
	`pbuf_free
(
p
);

319 
	`IP_STATS_INC
(
ip
.
drop
);

320 
	`snmp_inc_ipinaddrerrors
();

321 
	`snmp_inc_ipindiscards
();

322 return 
ERR_OK
;

327 if (
netif
 == 
NULL
) {

329 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("ip_input: packet not for us.\n"));

330 #if 
IP_FORWARD


332 if (!
	`ip_addr_isbroadcast
(&(
iphdr
->
dest
), 
inp
)) {

334 
	`ip_forward
(
p
, 
iphdr
, 
inp
);

338 
	`snmp_inc_ipinaddrerrors
();

339 
	`snmp_inc_ipindiscards
();

341 
	`pbuf_free
(
p
);

342 return 
ERR_OK
;

345 if ((
	`IPH_OFFSET
(
iphdr
) & 
	`htons
(
IP_OFFMASK
 | 
IP_MF
)) != 0) {

346 #if 
IP_REASSEMBLY


347 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("IP packet is a fragment (id=0x%04"
X16_F
" tot_len=%"
U16_F
" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",

348 
	`ntohs
(
	`IPH_ID
(
iphdr
)), 
p
->
tot_len
, ntohs(
	`IPH_LEN
(iphdr)), !!(
	`IPH_OFFSET
(iphdr) & 
	`htons
(
IP_MF
)), (ntohs(IPH_OFFSET(iphdr)) & 
IP_OFFMASK
)*8));

350 
p
 = 
	`ip_reass
(p);

352 if (
p
 == 
NULL
) {

353 return 
ERR_OK
;

355 
iphdr
 = 
p
->
payload
;

357 
	`pbuf_free
(
p
);

358 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("IP packet dropped since it was fragmented (0x%"
X16_F
") (while IP_REASSEMBLY == 0).\n",

359 
	`ntohs
(
	`IPH_OFFSET
(
iphdr
))));

360 
	`IP_STATS_INC
(
ip
.
opterr
);

361 
	`IP_STATS_INC
(
ip
.
drop
);

363 
	`snmp_inc_ipinunknownprotos
();

364 return 
ERR_OK
;

368 #if 
IP_OPTIONS_ALLOWED
 == 0

370 #if 
LWIP_IGMP


372 if((
iphdr_hlen
 > 
IP_HLEN
 && (
	`IPH_PROTO
(
iphdr
) != 
IP_PROTO_IGMP
)) {

374 if (
iphdr_hlen
 > 
IP_HLEN
) {

376 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));

377 
	`pbuf_free
(
p
);

378 
	`IP_STATS_INC
(
ip
.
opterr
);

379 
	`IP_STATS_INC
(
ip
.
drop
);

381 
	`snmp_inc_ipinunknownprotos
();

382 return 
ERR_OK
;

387 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_input: \n"));

388 
	`ip_debug_print
(
p
);

389 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_input: p->len %"
U16_F
" p->tot_len %"U16_F"\n", 
p
->
len
, p->
tot_len
));

391 #if 
LWIP_RAW


393 if (
	`raw_input
(
p
, 
inp
) == 0)

397 switch (
	`IPH_PROTO
(
iphdr
)) {

398 #if 
LWIP_UDP


399 case 
IP_PROTO_UDP
:

400 #if 
LWIP_UDPLITE


401 case 
IP_PROTO_UDPLITE
:

403 
	`snmp_inc_ipindelivers
();

404 
	`udp_input
(
p
, 
inp
);

407 #if 
LWIP_TCP


408 case 
IP_PROTO_TCP
:

409 
	`snmp_inc_ipindelivers
();

410 
	`tcp_input
(
p
, 
inp
);

413 #if 
LWIP_ICMP


414 case 
IP_PROTO_ICMP
:

415 
	`snmp_inc_ipindelivers
();

416 
	`icmp_input
(
p
, 
inp
);

419 #if 
LWIP_IGMP


420 case 
IP_PROTO_IGMP
:

421 
	`igmp_input
(
p
,
inp
,&(
iphdr
->
dest
));

425 #if 
LWIP_ICMP


427 if (!
	`ip_addr_isbroadcast
(&(
iphdr
->
dest
), 
inp
) &&

428 !
	`ip_addr_ismulticast
(&(
iphdr
->
dest
))) {

429 
p
->
payload
 = 
iphdr
;

430 
	`icmp_dest_unreach
(
p
, 
ICMP_DUR_PROTO
);

433 
	`pbuf_free
(
p
);

435 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("Unsupported transport protocol %"
U16_F
"\n", 
	`IPH_PROTO
(
iphdr
)));

437 
	`IP_STATS_INC
(
ip
.
proterr
);

438 
	`IP_STATS_INC
(
ip
.
drop
);

439 
	`snmp_inc_ipinunknownprotos
();

443 return 
ERR_OK
;

444 
	}
}

471 
err_t


472 
	$ip_output_if
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

473 
u8_t
 
ttl
, u8_t 
tos
,

474 
u8_t
 
proto
, struct 
netif
 *netif)

476 struct 
ip_hdr
 *
iphdr
;

477 static 
u16_t
 
ip_id
 = 0;

479 
	`snmp_inc_ipoutrequests
();

482 if (
dest
 != 
IP_HDRINCL
) {

484 if (
	`pbuf_header
(
p
, 
IP_HLEN
)) {

485 
	`LWIP_DEBUGF
(
IP_DEBUG
 | 2, ("ip_output: not enough room for IP header in pbuf\n"));

487 
	`IP_STATS_INC
(
ip
.
err
);

488 
	`snmp_inc_ipoutdiscards
();

489 return 
ERR_BUF
;

492 
iphdr
 = 
p
->
payload
;

493 
	`LWIP_ASSERT
("check that first pbuf can hold struct ip_hdr",

494 (
p
->
len
 >= sizeof(struct 
ip_hdr
)));

496 
	`IPH_TTL_SET
(
iphdr
, 
ttl
);

497 
	`IPH_PROTO_SET
(
iphdr
, 
proto
);

499 
	`ip_addr_set
(&(
iphdr
->
dest
), dest);

501 
	`IPH_VHLTOS_SET
(
iphdr
, 4, 
IP_HLEN
 / 4, 
tos
);

502 
	`IPH_LEN_SET
(
iphdr
, 
	`htons
(
p
->
tot_len
));

503 
	`IPH_OFFSET_SET
(
iphdr
, 0);

504 
	`IPH_ID_SET
(
iphdr
, 
	`htons
(
ip_id
));

505 ++
ip_id
;

507 if (
	`ip_addr_isany
(
src
)) {

508 
	`ip_addr_set
(&(
iphdr
->
src
), &(
netif
->
ip_addr
));

510 
	`ip_addr_set
(&(
iphdr
->
src
), src);

513 
	`IPH_CHKSUM_SET
(
iphdr
, 0);

514 #if 
CHECKSUM_GEN_IP


515 
	`IPH_CHKSUM_SET
(
iphdr
, 
	`inet_chksum
(iphdr, 
IP_HLEN
));

519 
iphdr
 = 
p
->
payload
;

520 
dest
 = &(
iphdr
->dest);

523 #if 
IP_FRAG


525 if (
netif
->
mtu
 && (
p
->
tot_len
 > netif->mtu))

526 return 
	`ip_frag
(
p
,
netif
,
dest
);

529 
	`IP_STATS_INC
(
ip
.
xmit
);

531 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_output_if: %c%c%"
U16_F
"\n", 
netif
->
name
[0], netif->name[1], netif->
num
));

532 
	`ip_debug_print
(
p
);

534 #if (
LWIP_NETIF_LOOPBACK
 || 
LWIP_HAVE_LOOPIF
)

535 if (
	`ip_addr_cmp
(
dest
, &
netif
->
ip_addr
)) {

537 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("netif_loop_output()"));

539 return 
	`netif_loop_output
(
netif
, 
p
, 
dest
);

543 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("netif->output()"));

545 return 
netif
->
	`output
(netif, 
p
, 
dest
);

547 
	}
}

566 
err_t


567 
	$ip_output
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

568 
u8_t
 
ttl
, u8_t 
tos
, u8_t 
proto
)

570 struct 
netif
 *netif;

572 if ((
netif
 = 
	`ip_route
(
dest
)) == 
NULL
) {

573 return 
ERR_RTE
;

576 return 
	`ip_output_if
(
p
, 
src
, 
dest
, 
ttl
, 
tos
, 
proto
, 
netif
);

577 
	}
}

579 #if 
IP_DEBUG


584 
	$ip_debug_print
(struct 
pbuf
 *
p
)

586 struct 
ip_hdr
 *
iphdr
 = 
p
->
payload
;

587 
u8_t
 *
payload
;

589 
payload
 = (
u8_t
 *)
iphdr
 + 
IP_HLEN
;

591 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("IP header:\n"));

592 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

593 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("|%2"
S16_F
" |%2"S16_F" | 0x%02"
X16_F
" | %5"
U16_F
" | (v, hl, tos, len)\n",

594 
	`IPH_V
(
iphdr
),

595 
	`IPH_HL
(
iphdr
),

596 
	`IPH_TOS
(
iphdr
),

597 
	`ntohs
(
	`IPH_LEN
(
iphdr
))));

598 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

599 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %5"
U16_F
" |%"U16_F"%"U16_F"%"U16_F"| %4"U16_F" | (id, flags, offset)\n",

600 
	`ntohs
(
	`IPH_ID
(
iphdr
)),

601 
	`ntohs
(
	`IPH_OFFSET
(
iphdr
)) >> 15 & 1,

602 
	`ntohs
(
	`IPH_OFFSET
(
iphdr
)) >> 14 & 1,

603 
	`ntohs
(
	`IPH_OFFSET
(
iphdr
)) >> 13 & 1,

604 
	`ntohs
(
	`IPH_OFFSET
(
iphdr
)) & 
IP_OFFMASK
));

605 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

606 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %3"
U16_F
" | %3"U16_F" | 0x%04"
X16_F
" | (ttl, proto, chksum)\n",

607 
	`IPH_TTL
(
iphdr
),

608 
	`IPH_PROTO
(
iphdr
),

609 
	`ntohs
(
	`IPH_CHKSUM
(
iphdr
))));

610 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

611 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %3"
U16_F
" | %3"U16_F" | %3"U16_F" | %3"U16_F" | (src)\n",

612 
	`ip4_addr1
(&
iphdr
->
src
),

613 
	`ip4_addr2
(&
iphdr
->
src
),

614 
	`ip4_addr3
(&
iphdr
->
src
),

615 
	`ip4_addr4
(&
iphdr
->
src
)));

616 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

617 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %3"
U16_F
" | %3"U16_F" | %3"U16_F" | %3"U16_F" | (dest)\n",

618 
	`ip4_addr1
(&
iphdr
->
dest
),

619 
	`ip4_addr2
(&
iphdr
->
dest
),

620 
	`ip4_addr3
(&
iphdr
->
dest
),

621 
	`ip4_addr4
(&
iphdr
->
dest
)));

622 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

623 
	}
}

	@/root/Robux/net/lwip/core/ipv4/ip_addr.c

39 #include 
	~"lwip/opt.h
"

40 #include 
	~"lwip/ip_addr.h
"

41 #include 
	~"lwip/inet.h
"

42 #include 
	~"lwip/netif.h
"

44 #define 
	#IP_ADDR_ANY_VALUE
 0x00000000UL

	)

45 #define 
	#IP_ADDR_BROADCAST_VALUE
 0xffffffffUL

	)

48 const struct 
ip_addr
 
	gip_addr_any
 = { 
IP_ADDR_ANY_VALUE
 };

49 const struct 
ip_addr
 
	gip_addr_broadcast
 = { 
IP_ADDR_BROADCAST_VALUE
 };

58 
u8_t
 
	$ip_addr_isbroadcast
(struct 
ip_addr
 *
addr
, struct 
netif
 *netif)

60 
u32_t
 
addr2test
;

62 
addr2test
 = 
addr
->addr;

64 if ((~
addr2test
 == 
IP_ADDR_ANY_VALUE
) ||

65 (
addr2test
 == 
IP_ADDR_ANY_VALUE
))

68 else if ((
netif
->
flags
 & 
NETIF_FLAG_BROADCAST
) == 0)

73 else if (
addr2test
 == 
netif
->
ip_addr
.
addr
)

76 else if (
	`ip_addr_netcmp
(
addr
, &(
netif
->
ip_addr
), &(netif->
netmask
))

78 && ((
addr2test
 & ~
netif
->
netmask
.
addr
) ==

79 (
IP_ADDR_BROADCAST_VALUE
 & ~
netif
->
netmask
.
addr
)))

84 
	}
}

	@/root/Robux/net/lwip/core/ipv4/ip_frag.c

41 #include 
	~"lwip/opt.h
"

42 #include 
	~"lwip/ip_frag.h
"

43 #include 
	~"lwip/ip.h
"

44 #include 
	~"lwip/inet.h
"

45 #include 
	~"lwip/inet_chksum.h
"

46 #include 
	~"lwip/netif.h
"

47 #include 
	~"lwip/snmp.h
"

48 #include 
	~"lwip/stats.h
"

49 #include 
	~"lwip/icmp.h
"

51 #include 
	~<string.h
>

53 #if 
IP_REASSEMBLY


67 #ifndef 
IP_REASS_CHECK_OVERLAP


68 #define 
	#IP_REASS_CHECK_OVERLAP
 1

	)

75 #ifndef 
IP_REASS_FREE_OLDEST


76 #define 
	#IP_REASS_FREE_OLDEST
 1

	)

79 #define 
	#IP_REASS_FLAG_LASTFRAG
 0x01

	)

85 struct 
	sip_reass_helper
 {

86 struct 
pbuf
 *
	mnext_pbuf
;

87 
u16_t
 
	mstart
;

88 
u16_t
 
	mend
;

91 #define 
	#IP_ADDRESSES_AND_ID_MATCH
(
iphdrA
, 
iphdrB
) \

92 (
	`ip_addr_cmp
(&(
iphdrA
)->
src
, &(
iphdrB
)->src) && \

93 
	`ip_addr_cmp
(&(
iphdrA
)->
dest
, &(
iphdrB
)->dest) && \

94 
	`IPH_ID
(
iphdrA
) == IPH_ID(
iphdrB
)) ? 1 : 0

	)

97 static struct 
ip_reassdata
 *
	greassdatagrams
;

98 static 
u16_t
 
	gip_reass_pbufcount
;

101 static void 
ip_reass_dequeue_datagram
(struct 
ip_reassdata
 *
ipr
, struct ip_reassdata *
prev
);

102 static int 
ip_reass_free_complete_datagram
(struct 
ip_reassdata
 *
ipr
, struct ip_reassdata *
prev
);

111 
	$ip_reass_tmr
(void)

113 struct 
ip_reassdata
 *
r
, *
prev
 = 
NULL
;

115 
r
 = 
reassdatagrams
;

116 while (
r
 != 
NULL
) {

119 if (
r
->
timer
 > 0) {

120 
r
->
timer
--;

121 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
, ("ip_reass_tmr: timer dec %"
U16_F
"\n",(
u16_t
)
r
->
timer
));

122 
prev
 = 
r
;

123 
r
 = r->
next
;

126 struct 
ip_reassdata
 *
tmp
;

127 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
, ("ip_reass_tmr: timer timed out\n"));

128 
tmp
 = 
r
;

130 
r
 = r->
next
;

132 
	`ip_reass_free_complete_datagram
(
tmp
, 
prev
);

135 
	}
}

147 
	$ip_reass_free_complete_datagram
(struct 
ip_reassdata
 *
ipr
, struct ip_reassdata *
prev
)

149 int 
pbufs_freed
 = 0;

150 struct 
pbuf
 *
p
;

151 struct 
ip_reass_helper
 *
iprh
;

153 
	`LWIP_ASSERT
("prev != ipr", 
prev
 != 
ipr
);

154 if (
prev
 != 
NULL
) {

155 
	`LWIP_ASSERT
("prev->next == ipr", 
prev
->
next
 == 
ipr
);

158 
	`snmp_inc_ipreasmfails
();

159 #if 
LWIP_ICMP


160 
iprh
 = (struct 
ip_reass_helper
 *)
ipr
->
p
->
payload
;

161 if (
iprh
->
start
 == 0) {

164 
p
 = 
ipr
->p;

165 
ipr
->
p
 = 
iprh
->
next_pbuf
;

167 
	`SMEMCPY
(
p
->
payload
, &
ipr
->
iphdr
, 
IP_HLEN
);

168 
	`icmp_time_exceeded
(
p
, 
ICMP_TE_FRAG
);

169 
pbufs_freed
 += 
	`pbuf_clen
(
p
);

170 
	`pbuf_free
(
p
);

176 
p
 = 
ipr
->p;

177 while (
p
 != 
NULL
) {

178 struct 
pbuf
 *
pcur
;

179 
iprh
 = (struct 
ip_reass_helper
 *)
p
->
payload
;

180 
pcur
 = 
p
;

182 
p
 = 
iprh
->
next_pbuf
;

183 
pbufs_freed
 += 
	`pbuf_clen
(
pcur
);

184 
	`pbuf_free
(
pcur
);

187 
	`ip_reass_dequeue_datagram
(
ipr
, 
prev
);

188 
	`LWIP_ASSERT
("ip_reass_pbufcount >= clen", 
ip_reass_pbufcount
 >= 
pbufs_freed
);

189 
ip_reass_pbufcount
 -= 
pbufs_freed
;

191 return 
pbufs_freed
;

192 
	}
}

194 #if 
IP_REASS_FREE_OLDEST


205 
	$ip_reass_remove_oldest_datagram
(struct 
ip_hdr
 *
fraghdr
, int 
pbufs_needed
)

210 struct 
ip_reassdata
 *
r
, *
oldest
, *
prev
;

211 int 
pbufs_freed
 = 0, 
pbufs_freed_current
;

212 int 
other_datagrams
;

217 
oldest
 = 
NULL
;

218 
prev
 = 
NULL
;

219 
other_datagrams
 = 0;

220 
r
 = 
reassdatagrams
;

221 while (
r
 != 
NULL
) {

222 if (!
	`IP_ADDRESSES_AND_ID_MATCH
(&
r
->
iphdr
, 
fraghdr
)) {

224 
other_datagrams
++;

225 if (
oldest
 == 
NULL
) {

226 
oldest
 = 
r
;

227 } else if (
r
->
timer
 <= 
oldest
->timer) {

229 
oldest
 = 
r
;

232 if (
r
->
next
 != 
NULL
) {

233 
prev
 = 
r
;

235 
r
 = r->
next
;

237 if (
oldest
 != 
NULL
) {

238 
pbufs_freed_current
 = 
	`ip_reass_free_complete_datagram
(
oldest
, 
prev
);

239 
pbufs_freed
 += 
pbufs_freed_current
;

241 } while ((
pbufs_freed
 < 
pbufs_needed
) && (
other_datagrams
 > 1));

242 return 
pbufs_freed
;

243 
	}
}

252 static struct 
ip_reassdata
*

253 
	$ip_reass_enqueue_new_datagram
(struct 
ip_hdr
 *
fraghdr
, int 
clen
)

255 struct 
ip_reassdata
* 
ipr
;

257 
ipr
 = 
	`memp_malloc
(
MEMP_REASSDATA
);

258 if (
ipr
 == 
NULL
) {

259 #if 
IP_REASS_FREE_OLDEST


260 if (
	`ip_reass_remove_oldest_datagram
(
fraghdr
, 
clen
) >= clen) {

261 
ipr
 = 
	`memp_malloc
(
MEMP_REASSDATA
);

263 if (
ipr
 == 
NULL
)

266 
	`IPFRAG_STATS_INC
(
ip_frag
.
memerr
);

267 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
,("Failed to alloc reassdata struct\n"));

268 return 
NULL
;

271 
	`memset
(
ipr
, 0, sizeof(struct 
ip_reassdata
));

272 
ipr
->
timer
 = 
IP_REASS_MAXAGE
;

275 
ipr
->
next
 = 
reassdatagrams
;

276 
reassdatagrams
 = 
ipr
;

279 
	`SMEMCPY
(&(
ipr
->
iphdr
), 
fraghdr
, 
IP_HLEN
);

280 return 
ipr
;

281 
	}
}

288 
	$ip_reass_dequeue_datagram
(struct 
ip_reassdata
 *
ipr
, struct ip_reassdata *
prev
)

292 if (
reassdatagrams
 == 
ipr
) {

294 
reassdatagrams
 = 
ipr
->
next
;

297 
	`LWIP_ASSERT
("sanity check linked list", 
prev
 != 
NULL
);

298 
prev
->
next
 = 
ipr
->next;

302 
	`memp_free
(
MEMP_REASSDATA
, 
ipr
);

303 
	}
}

315 
	$ip_reass_chain_frag_into_datagram_and_validate
(struct 
ip_reassdata
 *
ipr
, struct 
pbuf
 *
new_p
)

317 struct 
ip_reass_helper
 *
iprh
, *
iprh_tmp
, *
iprh_prev
=
NULL
;

318 struct 
pbuf
 *
q
;

319 
u16_t
 
offset
,
len
;

320 struct 
ip_hdr
 *
fraghdr
;

321 int 
valid
 = 1;

324 
fraghdr
 = (struct 
ip_hdr
*)
new_p
->
payload
;

325 
len
 = 
	`ntohs
(
	`IPH_LEN
(
fraghdr
)) - 
	`IPH_HL
(fraghdr) * 4;

326 
offset
 = (
	`ntohs
(
	`IPH_OFFSET
(
fraghdr
)) & 
IP_OFFMASK
) * 8;

331 
	`LWIP_ASSERT
("sizeof(struct ip_reass_helper) <= IP_HLEN",

332 sizeof(struct 
ip_reass_helper
) <= 
IP_HLEN
);

333 
iprh
 = (struct 
ip_reass_helper
*)
new_p
->
payload
;

334 
iprh
->
next_pbuf
 = 
NULL
;

335 
iprh
->
start
 = 
offset
;

336 
iprh
->
end
 = 
offset
 + 
len
;

340 for (
q
 = 
ipr
->
p
; q != 
NULL
;) {

341 
iprh_tmp
 = (struct 
ip_reass_helper
*)
q
->
payload
;

342 if (
iprh
->
start
 < 
iprh_tmp
->start) {

344 
iprh
->
next_pbuf
 = 
q
;

345 if (
iprh_prev
 != 
NULL
) {

347 #if 
IP_REASS_CHECK_OVERLAP


348 if ((
iprh
->
start
 < 
iprh_prev
->
end
) || (iprh->end > 
iprh_tmp
->start)) {

350 goto 
freepbuf
;

353 
iprh_prev
->
next_pbuf
 = 
new_p
;

356 
ipr
->
p
 = 
new_p
;

359 } else if(
iprh
->
start
 == 
iprh_tmp
->start) {

361 goto 
freepbuf
;

362 #if 
IP_REASS_CHECK_OVERLAP


363 } else if(
iprh
->
start
 < 
iprh_tmp
->
end
) {

365 goto 
freepbuf
;

369 if (
iprh_prev
 != 
NULL
) {

370 if (
iprh_prev
->
end
 != 
iprh_tmp
->
start
) {

373 
valid
 = 0;

377 
q
 = 
iprh_tmp
->
next_pbuf
;

378 
iprh_prev
 = 
iprh_tmp
;

382 if (
q
 == 
NULL
) {

383 if (
iprh_prev
 != 
NULL
) {

386 #if 
IP_REASS_CHECK_OVERLAP


387 
	`LWIP_ASSERT
("check fragments don't overlap", 
iprh_prev
->
end
 <= 
iprh
->
start
);

389 
iprh_prev
->
next_pbuf
 = 
new_p
;

390 if (
iprh_prev
->
end
 != 
iprh
->
start
) {

391 
valid
 = 0;

394 #if 
IP_REASS_CHECK_OVERLAP


395 
	`LWIP_ASSERT
("no previous fragment, this must be the first fragment!",

396 
ipr
->
p
 == 
NULL
);

399 
ipr
->
p
 = 
new_p
;

405 if ((
ipr
->
flags
 & 
IP_REASS_FLAG_LASTFRAG
) != 0) {

407 if (
valid
) {

410 if (((struct 
ip_reass_helper
*)
ipr
->
p
->
payload
)->
start
 != 0) {

411 
valid
 = 0;

414 
iprh_prev
 = 
iprh
;

415 
q
 = 
iprh
->
next_pbuf
;

416 while (
q
 != 
NULL
) {

417 
iprh
 = (struct 
ip_reass_helper
*)
q
->
payload
;

418 if (
iprh_prev
->
end
 != 
iprh
->
start
) {

419 
valid
 = 0;

422 
iprh_prev
 = 
iprh
;

423 
q
 = 
iprh
->
next_pbuf
;

427 if (
valid
) {

428 
	`LWIP_ASSERT
("sanity check", 
ipr
->
p
 != 
NULL
);

429 
	`LWIP_ASSERT
("sanity check",

430 ((struct 
ip_reass_helper
*)
ipr
->
p
->
payload
) != 
iprh
);

431 
	`LWIP_ASSERT
("validate_datagram:next_pbuf!=NULL",

432 
iprh
->
next_pbuf
 == 
NULL
);

433 
	`LWIP_ASSERT
("validate_datagram:datagram end!=datagram len",

434 
iprh
->
end
 == 
ipr
->
datagram_len
);

441 return 
valid
;

445 #if 
IP_REASS_CHECK_OVERLAP


446 
freepbuf
:

447 
ip_reass_pbufcount
 -= 
	`pbuf_clen
(
new_p
);

448 
	`pbuf_free
(
new_p
);

451 
	}
}

459 struct 
pbuf
 *

460 
	$ip_reass
(struct 
pbuf
 *
p
)

462 struct 
pbuf
 *
r
;

463 struct 
ip_hdr
 *
fraghdr
;

464 struct 
ip_reassdata
 *
ipr
;

465 struct 
ip_reass_helper
 *
iprh
;

466 
u16_t
 
offset
, 
len
;

467 
u8_t
 
clen
;

468 struct 
ip_reassdata
 *
ipr_prev
 = 
NULL
;

470 
	`IPFRAG_STATS_INC
(
ip_frag
.
recv
);

471 
	`snmp_inc_ipreasmreqds
();

473 
fraghdr
 = (struct 
ip_hdr
*)
p
->
payload
;

475 if ((
	`IPH_HL
(
fraghdr
) * 4) != 
IP_HLEN
) {

476 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
,("ip_reass: IP options currently not supported!\n"));

477 
	`IPFRAG_STATS_INC
(
ip_frag
.
err
);

478 goto 
nullreturn
;

481 
offset
 = (
	`ntohs
(
	`IPH_OFFSET
(
fraghdr
)) & 
IP_OFFMASK
) * 8;

482 
len
 = 
	`ntohs
(
	`IPH_LEN
(
fraghdr
)) - 
	`IPH_HL
(fraghdr) * 4;

485 
clen
 = 
	`pbuf_clen
(
p
);

486 if ((
ip_reass_pbufcount
 + 
clen
) > 
IP_REASS_MAX_PBUFS
) {

487 #if 
IP_REASS_FREE_OLDEST


488 if (!
	`ip_reass_remove_oldest_datagram
(
fraghdr
, 
clen
) ||

489 ((
ip_reass_pbufcount
 + 
clen
) > 
IP_REASS_MAX_PBUFS
))

493 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",

494 
ip_reass_pbufcount
, 
clen
, 
IP_REASS_MAX_PBUFS
));

495 
	`IPFRAG_STATS_INC
(
ip_frag
.
memerr
);

498 goto 
nullreturn
;

504 for (
ipr
 = 
reassdatagrams
; ipr != 
NULL
; ipr = ipr->
next
) {

508 if (
	`IP_ADDRESSES_AND_ID_MATCH
(&
ipr
->
iphdr
, 
fraghdr
)) {

509 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
, ("ip_reass: matching previous fragment ID=%"
X16_F
"\n",

510 
	`ntohs
(
	`IPH_ID
(
fraghdr
))));

511 
	`IPFRAG_STATS_INC
(
ip_frag
.
cachehit
);

514 
ipr_prev
 = 
ipr
;

517 if (
ipr
 == 
NULL
) {

519 
ipr
 = 
	`ip_reass_enqueue_new_datagram
(
fraghdr
, 
clen
);

521 if(
ipr
 == 
NULL
) {

522 goto 
nullreturn
;

525 if (((
	`ntohs
(
	`IPH_OFFSET
(
fraghdr
)) & 
IP_OFFMASK
) == 0) &&

526 ((
	`ntohs
(
	`IPH_OFFSET
(&
ipr
->
iphdr
)) & 
IP_OFFMASK
) != 0)) {

531 
	`SMEMCPY
(&
ipr
->
iphdr
, 
fraghdr
, 
IP_HLEN
);

536 
ip_reass_pbufcount
 += 
clen
;

542 if ((
	`ntohs
(
	`IPH_OFFSET
(
fraghdr
)) & 
IP_MF
) == 0) {

543 
ipr
->
flags
 |= 
IP_REASS_FLAG_LASTFRAG
;

544 
ipr
->
datagram_len
 = 
offset
 + 
len
;

545 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
,

546 ("ip_reass: last fragment seen, total len %"
S16_F
"\n",

547 
ipr
->
datagram_len
));

551 if (
	`ip_reass_chain_frag_into_datagram_and_validate
(
ipr
, 
p
)) {

554 
ipr
->
datagram_len
 += 
IP_HLEN
;

557 
r
 = ((struct 
ip_reass_helper
*)
ipr
->
p
->
payload
)->
next_pbuf
;

560 
fraghdr
 = (struct 
ip_hdr
*)(
ipr
->
p
->
payload
);

561 
	`SMEMCPY
(
fraghdr
, &
ipr
->
iphdr
, 
IP_HLEN
);

562 
	`IPH_LEN_SET
(
fraghdr
, 
	`htons
(
ipr
->
datagram_len
));

563 
	`IPH_OFFSET_SET
(
fraghdr
, 0);

564 
	`IPH_CHKSUM_SET
(
fraghdr
, 0);

566 
	`IPH_CHKSUM_SET
(
fraghdr
, 
	`inet_chksum
(fraghdr, 
IP_HLEN
));

568 
p
 = 
ipr
->p;

571 while(
r
 != 
NULL
) {

572 
iprh
 = (struct 
ip_reass_helper
*)
r
->
payload
;

575 
	`pbuf_header
(
r
, -
IP_HLEN
);

576 
	`pbuf_cat
(
p
, 
r
);

577 
r
 = 
iprh
->
next_pbuf
;

580 
	`ip_reass_dequeue_datagram
(
ipr
, 
ipr_prev
);

583 
ip_reass_pbufcount
 -= 
	`pbuf_clen
(
p
);

586 return 
p
;

589 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
,("ip_reass_pbufcount: %d out\n", 
ip_reass_pbufcount
));

590 return 
NULL
;

592 
nullreturn
:

593 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
,("ip_reass: nullreturn\n"));

594 
	`IPFRAG_STATS_INC
(
ip_frag
.
drop
);

595 
	`pbuf_free
(
p
);

596 return 
NULL
;

597 
	}
}

600 #if 
IP_FRAG


601 #if 
IP_FRAG_USES_STATIC_BUF


602 static 
u8_t
 
	gbuf
[
LWIP_MEM_ALIGN_SIZE
(
IP_FRAG_MAX_MTU
)];

618 
err_t


619 
	$ip_frag
(struct 
pbuf
 *
p
, struct 
netif
 *netif, struct 
ip_addr
 *
dest
)

621 struct 
pbuf
 *
rambuf
;

622 #if 
IP_FRAG_USES_STATIC_BUF


623 struct 
pbuf
 *
header
;

625 struct 
pbuf
 *
newpbuf
;

626 struct 
ip_hdr
 *
original_iphdr
;

628 struct 
ip_hdr
 *
iphdr
;

629 
u16_t
 
nfb
;

630 
u16_t
 
left
, 
cop
;

631 
u16_t
 
mtu
 = 
netif
->mtu;

632 
u16_t
 
ofo
, 
omf
;

633 
u16_t
 
last
;

634 
u16_t
 
poff
 = 
IP_HLEN
;

635 
u16_t
 
tmp
;

636 #if !
IP_FRAG_USES_STATIC_BUF


637 
u16_t
 
newpbuflen
 = 0;

638 
u16_t
 
left_to_copy
;

642 #if 
IP_FRAG_USES_STATIC_BUF


647 
rambuf
 = 
	`pbuf_alloc
(
PBUF_LINK
, 0, 
PBUF_REF
);

648 if (
rambuf
 == 
NULL
) {

649 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));

650 return 
ERR_MEM
;

652 
rambuf
->
tot_len
 = rambuf->
len
 = 
mtu
;

653 
rambuf
->
payload
 = 
	`LWIP_MEM_ALIGN
((void *)
buf
);

656 
iphdr
 = 
rambuf
->
payload
;

657 
	`SMEMCPY
(
iphdr
, 
p
->
payload
, 
IP_HLEN
);

659 
original_iphdr
 = 
p
->
payload
;

660 
iphdr
 = 
original_iphdr
;

664 
tmp
 = 
	`ntohs
(
	`IPH_OFFSET
(
iphdr
));

665 
ofo
 = 
tmp
 & 
IP_OFFMASK
;

666 
omf
 = 
tmp
 & 
IP_MF
;

668 
left
 = 
p
->
tot_len
 - 
IP_HLEN
;

670 
nfb
 = (
mtu
 - 
IP_HLEN
) / 8;

672 while (
left
) {

673 
last
 = (
left
 <= 
mtu
 - 
IP_HLEN
);

676 
tmp
 = 
omf
 | (
IP_OFFMASK
 & (
ofo
));

677 if (!
last
)

678 
tmp
 = tmp | 
IP_MF
;

681 
cop
 = 
last
 ? 
left
 : 
nfb
 * 8;

683 #if 
IP_FRAG_USES_STATIC_BUF


684 
poff
 += 
	`pbuf_copy_partial
(
p
, (
u8_t
*)
iphdr
 + 
IP_HLEN
, 
cop
, poff);

691 
rambuf
 = 
	`pbuf_alloc
(
PBUF_LINK
, 
IP_HLEN
, 
PBUF_RAM
);

692 if (
rambuf
 == 
NULL
) {

693 return 
ERR_MEM
;

695 
	`LWIP_ASSERT
("this needs a pbuf in one piece!",

696 (
p
->
len
 >= (
IP_HLEN
)));

697 
	`SMEMCPY
(
rambuf
->
payload
, 
original_iphdr
, 
IP_HLEN
);

698 
iphdr
 = 
rambuf
->
payload
;

701 
p
->
payload
 = (
u8_t
 *)p->payload + 
poff
;

702 
p
->
len
 -= 
poff
;

704 
left_to_copy
 = 
cop
;

705 while (
left_to_copy
) {

706 
newpbuflen
 = (
left_to_copy
 < 
p
->
len
) ? left_to_copy : p->len;

708 if (!
newpbuflen
) {

709 
p
 = p->
next
;

712 
newpbuf
 = 
	`pbuf_alloc
(
PBUF_RAW
, 0, 
PBUF_REF
);

713 if (
newpbuf
 == 
NULL
) {

714 
	`pbuf_free
(
rambuf
);

715 return 
ERR_MEM
;

718 
newpbuf
->
payload
 = 
p
->payload;

719 
newpbuf
->
len
 = newpbuf->
tot_len
 = 
newpbuflen
;

723 
	`pbuf_cat
(
rambuf
, 
newpbuf
);

724 
left_to_copy
 -= 
newpbuflen
;

725 if (
left_to_copy
)

726 
p
 = p->
next
;

728 
poff
 = 
newpbuflen
;

732 
	`IPH_OFFSET_SET
(
iphdr
, 
	`htons
(
tmp
));

733 
	`IPH_LEN_SET
(
iphdr
, 
	`htons
(
cop
 + 
IP_HLEN
));

734 
	`IPH_CHKSUM_SET
(
iphdr
, 0);

735 
	`IPH_CHKSUM_SET
(
iphdr
, 
	`inet_chksum
(iphdr, 
IP_HLEN
));

737 #if 
IP_FRAG_USES_STATIC_BUF


738 if (
last
)

739 
	`pbuf_realloc
(
rambuf
, 
left
 + 
IP_HLEN
);

746 
header
 = 
	`pbuf_alloc
(
PBUF_LINK
, 0, 
PBUF_RAM
);

747 if (
header
 != 
NULL
) {

748 
	`pbuf_chain
(
header
, 
rambuf
);

749 
netif
->
	`output
(netif, 
header
, 
dest
);

750 
	`IPFRAG_STATS_INC
(
ip_frag
.
xmit
);

751 
	`snmp_inc_ipfragcreates
();

752 
	`pbuf_free
(
header
);

754 
	`LWIP_DEBUGF
(
IP_REASS_DEBUG
, ("ip_frag: pbuf_alloc() for header failed\n"));

755 
	`pbuf_free
(
rambuf
);

756 return 
ERR_MEM
;

762 
netif
->
	`output
(netif, 
rambuf
, 
dest
);

763 
	`IPFRAG_STATS_INC
(
ip_frag
.
xmit
);

772 
	`pbuf_free
(
rambuf
);

774 
left
 -= 
cop
;

775 
ofo
 += 
nfb
;

777 #if 
IP_FRAG_USES_STATIC_BUF


778 
	`pbuf_free
(
rambuf
);

780 
	`snmp_inc_ipfragoks
();

781 return 
ERR_OK
;

782 
	}
}

	@/root/Robux/net/lwip/core/ipv6/icmp6.c

36 #include 
	~"lwip/opt.h
"

38 #if 
LWIP_ICMP


40 #include 
	~"lwip/icmp.h
"

41 #include 
	~"lwip/inet.h
"

42 #include 
	~"lwip/ip.h
"

43 #include 
	~"lwip/def.h
"

44 #include 
	~"lwip/stats.h
"

47 
	$icmp_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
)

49 
u8_t
 
type
;

50 struct 
icmp_echo_hdr
 *
iecho
;

51 struct 
ip_hdr
 *
iphdr
;

52 struct 
ip_addr
 
tmpaddr
;

54 
	`ICMP_STATS_INC
(
icmp
.
recv
);

58 
type
 = ((
u8_t
 *)
p
->
payload
)[0];

60 switch (
type
) {

61 case 
ICMP6_ECHO
:

62 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: ping\n"));

64 if (
p
->
tot_len
 < sizeof(struct 
icmp_echo_hdr
)) {

65 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: bad ICMP echo received\n"));

67 
	`pbuf_free
(
p
);

68 
	`ICMP_STATS_INC
(
icmp
.
lenerr
);

71 
iecho
 = 
p
->
payload
;

72 
iphdr
 = (struct 
ip_hdr
 *)((
u8_t
 *)
p
->
payload
 - 
IP_HLEN
);

73 if (
	`inet_chksum_pbuf
(
p
) != 0) {

74 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: checksum failed for received ICMP echo (%"
X16_F
")\n", 
	`inet_chksum_pseudo
(
p
, &(
iphdr
->
src
), &(iphdr->
dest
), 
IP_PROTO_ICMP
, p->
tot_len
)));

75 
	`ICMP_STATS_INC
(
icmp
.
chkerr
);

78 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp: p->len %"
S16_F
" p->tot_len %"S16_F"\n", 
p
->
len
, p->
tot_len
));

79 
	`ip_addr_set
(&
tmpaddr
, &(
iphdr
->
src
));

80 
	`ip_addr_set
(&(
iphdr
->
src
), &(iphdr->
dest
));

81 
	`ip_addr_set
(&(
iphdr
->
dest
), &
tmpaddr
);

82 
iecho
->
type
 = 
ICMP6_ER
;

84 if (
iecho
->
chksum
 >= 
	`htons
(0xffff - (
ICMP6_ECHO
 << 8))) {

85 
iecho
->
chksum
 += 
	`htons
(
ICMP6_ECHO
 << 8) + 1;

87 
iecho
->
chksum
 += 
	`htons
(
ICMP6_ECHO
 << 8);

89 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: checksum failed for received ICMP echo (%"
X16_F
")\n", 
	`inet_chksum_pseudo
(
p
, &(
iphdr
->
src
), &(iphdr->
dest
), 
IP_PROTO_ICMP
, p->
tot_len
)));

90 
	`ICMP_STATS_INC
(
icmp
.
xmit
);

93 
	`ip_output_if
 (
p
, &(
iphdr
->
src
), 
IP_HDRINCL
,

94 
iphdr
->
hoplim
, 
IP_PROTO_ICMP
, 
inp
);

97 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_input: ICMP type %"
S16_F
" not supported.\n", (
s16_t
)
type
));

98 
	`ICMP_STATS_INC
(
icmp
.
proterr
);

99 
	`ICMP_STATS_INC
(
icmp
.
drop
);

102 
	`pbuf_free
(
p
);

103 
	}
}

106 
	$icmp_dest_unreach
(struct 
pbuf
 *
p
, enum 
icmp_dur_type
 
t
)

108 struct 
pbuf
 *
q
;

109 struct 
ip_hdr
 *
iphdr
;

110 struct 
icmp_dur_hdr
 *
idur
;

113 
q
 = 
	`pbuf_alloc
(
PBUF_IP
, 8 + 
IP_HLEN
 + 8, 
PBUF_RAM
);

115 if (
q
 == 
NULL
) {

116 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));

117 
	`pbuf_free
(
p
);

120 
	`LWIP_ASSERT
("check that first pbuf can hold icmp message",

121 (
q
->
len
 >= (8 + 
IP_HLEN
 + 8)));

123 
iphdr
 = 
p
->
payload
;

125 
idur
 = 
q
->
payload
;

126 
idur
->
type
 = (
u8_t
)
ICMP6_DUR
;

127 
idur
->
icode
 = (
u8_t
)
t
;

129 
	`SMEMCPY
((
u8_t
 *)
q
->
payload
 + 8, 
p
->payload, 
IP_HLEN
 + 8);

132 
idur
->
chksum
 = 0;

133 
idur
->
chksum
 = 
	`inet_chksum
(idur, 
q
->
len
);

134 
	`ICMP_STATS_INC
(
icmp
.
xmit
);

136 
	`ip_output
(
q
, 
NULL
,

137 (struct 
ip_addr
 *)&(
iphdr
->
src
), 
ICMP_TTL
, 
IP_PROTO_ICMP
);

138 
	`pbuf_free
(
q
);

139 
	}
}

142 
	$icmp_time_exceeded
(struct 
pbuf
 *
p
, enum 
icmp_te_type
 
t
)

144 struct 
pbuf
 *
q
;

145 struct 
ip_hdr
 *
iphdr
;

146 struct 
icmp_te_hdr
 *
tehdr
;

148 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_time_exceeded\n"));

151 
q
 = 
	`pbuf_alloc
(
PBUF_IP
, 8 + 
IP_HLEN
 + 8, 
PBUF_RAM
);

153 if (
q
 == 
NULL
) {

154 
	`LWIP_DEBUGF
(
ICMP_DEBUG
, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));

155 
	`pbuf_free
(
p
);

158 
	`LWIP_ASSERT
("check that first pbuf can hold icmp message",

159 (
q
->
len
 >= (8 + 
IP_HLEN
 + 8)));

161 
iphdr
 = 
p
->
payload
;

163 
tehdr
 = 
q
->
payload
;

164 
tehdr
->
type
 = (
u8_t
)
ICMP6_TE
;

165 
tehdr
->
icode
 = (
u8_t
)
t
;

168 
	`SMEMCPY
((
u8_t
 *)
q
->
payload
 + 8, (u8_t *)
p
->payload, 
IP_HLEN
 + 8);

171 
tehdr
->
chksum
 = 0;

172 
tehdr
->
chksum
 = 
	`inet_chksum
(tehdr, 
q
->
len
);

173 
	`ICMP_STATS_INC
(
icmp
.
xmit
);

174 
	`ip_output
(
q
, 
NULL
,

175 (struct 
ip_addr
 *)&(
iphdr
->
src
), 
ICMP_TTL
, 
IP_PROTO_ICMP
);

176 
	`pbuf_free
(
q
);

177 
	}
}

	@/root/Robux/net/lwip/core/ipv6/inet6.c

40 #include 
	~"lwip/opt.h
"

42 #include 
	~"lwip/def.h
"

43 #include 
	~"lwip/inet.h
"

54 static 
u32_t


55 
	$chksum
(void *
dataptr
, 
u16_t
 
len
)

57 
u16_t
 *
sdataptr
 = 
dataptr
;

58 
u32_t
 
acc
;

61 for(
acc
 = 0; 
len
 > 1; len -= 2) {

62 
acc
 += *
sdataptr
++;

66 if (
len
 == 1) {

67 
acc
 += 
	`htons
((
u16_t
)(*(
u8_t
 *)
dataptr
) << 8);

70 return 
acc
;

72 
	}
}

79 
u16_t


80 
	$inet_chksum_pseudo
(struct 
pbuf
 *
p
,

81 struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

82 
u8_t
 
proto
, 
u32_t
 
proto_len
)

84 
u32_t
 
acc
;

85 struct 
pbuf
 *
q
;

86 
u8_t
 
swapped
, 
i
;

88 
acc
 = 0;

89 
swapped
 = 0;

90 for(
q
 = 
p
; q != 
NULL
; q = q->
next
) {

91 
acc
 += 
	`chksum
(
q
->
payload
, q->
len
);

92 while (
acc
 >> 16) {

93 
acc
 = (acc & 0xffff) + (acc >> 16);

95 if (
q
->
len
 % 2 != 0) {

96 
swapped
 = 1 - swapped;

97 
acc
 = ((acc & 0xff) << 8) | ((acc & 0xff00) >> 8);

101 if (
swapped
) {

102 
acc
 = ((acc & 0xff) << 8) | ((acc & 0xff00) >> 8);

105 for(
i
 = 0; i < 8; i++) {

106 
acc
 += ((
u16_t
 *)
src
->
addr
)[
i
] & 0xffff;

107 
acc
 += ((
u16_t
 *)
dest
->
addr
)[
i
] & 0xffff;

108 while (
acc
 >> 16) {

109 
acc
 = (acc & 0xffff) + (acc >> 16);

112 
acc
 += (
u16_t
)
	`htons
((u16_t)
proto
);

113 
acc
 += ((
u16_t
 *)&
proto_len
)[0] & 0xffff;

114 
acc
 += ((
u16_t
 *)&
proto_len
)[1] & 0xffff;

116 while (
acc
 >> 16) {

117 
acc
 = (acc & 0xffff) + (acc >> 16);

119 return ~(
acc
 & 0xffff);

120 
	}
}

128 
u16_t


129 
	$inet_chksum
(void *
dataptr
, 
u16_t
 
len
)

131 
u32_t
 
acc
, 
sum
;

133 
acc
 = 
	`chksum
(
dataptr
, 
len
);

134 
sum
 = (
acc
 & 0xffff) + (acc >> 16);

135 
sum
 += (sum >> 16);

136 return ~(
sum
 & 0xffff);

137 
	}
}

139 
u16_t


140 
	$inet_chksum_pbuf
(struct 
pbuf
 *
p
)

142 
u32_t
 
acc
;

143 struct 
pbuf
 *
q
;

144 
u8_t
 
swapped
;

146 
acc
 = 0;

147 
swapped
 = 0;

148 for(
q
 = 
p
; q != 
NULL
; q = q->
next
) {

149 
acc
 += 
	`chksum
(
q
->
payload
, q->
len
);

150 while (
acc
 >> 16) {

151 
acc
 = (acc & 0xffff) + (acc >> 16);

153 if (
q
->
len
 % 2 != 0) {

154 
swapped
 = 1 - swapped;

155 
acc
 = (acc & 0xff << 8) | (acc & 0xff00 >> 8);

159 if (
swapped
) {

160 
acc
 = ((acc & 0xff) << 8) | ((acc & 0xff00) >> 8);

162 return ~(
acc
 & 0xffff);

163 
	}
}

	@/root/Robux/net/lwip/core/ipv6/ip6.c

42 #include 
	~"lwip/opt.h
"

44 #include 
	~"lwip/def.h
"

45 #include 
	~"lwip/mem.h
"

46 #include 
	~"lwip/ip.h
"

47 #include 
	~"lwip/inet.h
"

48 #include 
	~"lwip/netif.h
"

49 #include 
	~"lwip/icmp.h
"

50 #include 
	~"lwip/udp.h
"

51 #include 
	~"lwip/tcp.h
"

53 #include 
	~"lwip/stats.h
"

55 #include 
	~"arch/perf.h
"

63 
	$ip_init
(void)

65 
	}
}

74 struct 
netif
 *

75 
	$ip_route
(struct 
ip_addr
 *
dest
)

77 struct 
netif
 *netif;

79 for(
netif
 = 
netif_list
; netif != 
NULL
; netif = netif->
next
) {

80 if (
	`ip_addr_netcmp
(
dest
, &(
netif
->
ip_addr
), &(netif->
netmask
))) {

81 return 
netif
;

85 return 
netif_default
;

86 
	}
}

96 
	$ip_forward
(struct 
pbuf
 *
p
, struct 
ip_hdr
 *
iphdr
)

98 struct 
netif
 *netif;

100 
PERF_START
;

102 if ((
netif
 = 
	`ip_route
((struct 
ip_addr
 *)&(
iphdr
->
dest
))) == 
NULL
) {

104 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_input: no forwarding route found for "));

105 #if 
IP_DEBUG


106 
	`ip_addr_debug_print
(
IP_DEBUG
, ((struct 
ip_addr
 *)&(
iphdr
->
dest
)));

108 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("\n"));

109 
	`pbuf_free
(
p
);

113 if (--
iphdr
->
hoplim
 == 0) {

114 #if 
LWIP_ICMP


116 if (
iphdr
->
nexthdr
 != 
IP_PROTO_ICMP
) {

117 
	`icmp_time_exceeded
(
p
, 
ICMP_TE_TTL
);

120 
	`pbuf_free
(
p
);

132 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_forward: forwarding packet to "));

133 #if 
IP_DEBUG


134 
	`ip_addr_debug_print
(
IP_DEBUG
, ((struct 
ip_addr
 *)&(
iphdr
->
dest
)));

136 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("\n"));

138 
	`IP_STATS_INC
(
ip
.
fw
);

139 
	`IP_STATS_INC
(
ip
.
xmit
);

141 
	`PERF_STOP
("ip_forward");

143 
netif
->
	`output
(netif, 
p
, (struct 
ip_addr
 *)&(
iphdr
->
dest
));

144 
	}
}

157 
	$ip_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
) {

158 struct 
ip_hdr
 *
iphdr
;

159 struct 
netif
 *netif;

162 
PERF_START
;

164 #if 
IP_DEBUG


165 
	`ip_debug_print
(
p
);

169 
	`IP_STATS_INC
(
ip
.
recv
);

172 
iphdr
 = 
p
->
payload
;

175 if (
iphdr
->
v
 != 6) {

176 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("IP packet dropped due to bad version number\n"));

177 #if 
IP_DEBUG


178 
	`ip_debug_print
(
p
);

180 
	`pbuf_free
(
p
);

181 
	`IP_STATS_INC
(
ip
.
err
);

182 
	`IP_STATS_INC
(
ip
.
drop
);

187 for(
netif
 = 
netif_list
; netif != 
NULL
; netif = netif->
next
) {

188 #if 
IP_DEBUG


189 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_input: iphdr->dest "));

190 
	`ip_addr_debug_print
(
IP_DEBUG
, ((struct 
ip_addr
 *)&(
iphdr
->
dest
)));

191 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("netif->ip_addr "));

192 
	`ip_addr_debug_print
(
IP_DEBUG
, ((struct 
ip_addr
 *)&(
iphdr
->
dest
)));

193 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("\n"));

195 if (
	`ip_addr_cmp
(&(
iphdr
->
dest
), &(
netif
->
ip_addr
))) {

201 if (
netif
 == 
NULL
) {

203 #if 
IP_FORWARD


204 
	`ip_forward
(
p
, 
iphdr
);

206 
	`pbuf_free
(
p
);

210 
	`pbuf_realloc
(
p
, 
IP_HLEN
 + 
	`ntohs
(
iphdr
->
len
));

213 #if 
IP_DEBUG


219 if(
	`pbuf_header
(
p
, -
IP_HLEN
)) {

220 
	`LWIP_ASSERT
("Can't move over header in packet", 0);

224 switch (
iphdr
->
nexthdr
) {

225 case 
IP_PROTO_UDP
:

226 
	`udp_input
(
p
, 
inp
);

228 case 
IP_PROTO_TCP
:

229 
	`tcp_input
(
p
, 
inp
);

231 #if 
LWIP_ICMP


232 case 
IP_PROTO_ICMP
:

233 
	`icmp_input
(
p
, 
inp
);

237 #if 
LWIP_ICMP


239 
	`icmp_dest_unreach
(
p
, 
ICMP_DUR_PROTO
);

241 
	`pbuf_free
(
p
);

242 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("Unsupported transport protocol %"
U16_F
"\n",

243 
iphdr
->
nexthdr
));

245 
	`IP_STATS_INC
(
ip
.
proterr
);

246 
	`IP_STATS_INC
(
ip
.
drop
);

248 
	`PERF_STOP
("ip_input");

249 
	}
}

259 
err_t


260 
	$ip_output_if
 (struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

261 
u8_t
 
ttl
,

262 
u8_t
 
proto
, struct 
netif
 *netif)

264 struct 
ip_hdr
 *
iphdr
;

266 
PERF_START
;

268 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("len %"
U16_F
" tot_len %"U16_F"\n", 
p
->
len
, p->
tot_len
));

269 if (
	`pbuf_header
(
p
, 
IP_HLEN
)) {

270 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_output: not enough room for IP header in pbuf\n"));

271 
	`IP_STATS_INC
(
ip
.
err
);

273 return 
ERR_BUF
;

275 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("len %"
U16_F
" tot_len %"U16_F"\n", 
p
->
len
, p->
tot_len
));

277 
iphdr
 = 
p
->
payload
;

280 if (
dest
 != 
IP_HDRINCL
) {

281 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("!IP_HDRLINCL\n"));

282 
iphdr
->
hoplim
 = 
ttl
;

283 
iphdr
->
nexthdr
 = 
proto
;

284 
iphdr
->
len
 = 
	`htons
(
p
->
tot_len
 - 
IP_HLEN
);

285 
	`ip_addr_set
(&(
iphdr
->
dest
), dest);

287 
iphdr
->
v
 = 6;

289 if (
	`ip_addr_isany
(
src
)) {

290 
	`ip_addr_set
(&(
iphdr
->
src
), &(
netif
->
ip_addr
));

292 
	`ip_addr_set
(&(
iphdr
->
src
), src);

296 
dest
 = &(
iphdr
->dest);

299 
	`IP_STATS_INC
(
ip
.
xmit
);

301 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_output_if: %c%c (len %"
U16_F
")\n", 
netif
->
name
[0], netif->name[1], 
p
->
tot_len
));

302 #if 
IP_DEBUG


303 
	`ip_debug_print
(
p
);

306 
	`PERF_STOP
("ip_output_if");

307 return 
netif
->
	`output
(netif, 
p
, 
dest
);

308 
	}
}

316 
err_t


317 
	$ip_output
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

318 
u8_t
 
ttl
, u8_t 
proto
)

320 struct 
netif
 *netif;

321 if ((
netif
 = 
	`ip_route
(
dest
)) == 
NULL
) {

322 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("ip_output: No route to 0x%"
X32_F
"\n", 
dest
->
addr
));

323 
	`IP_STATS_INC
(
ip
.
rterr
);

324 return 
ERR_RTE
;

327 return 
	`ip_output_if
 (
p
, 
src
, 
dest
, 
ttl
, 
proto
, 
netif
);

328 
	}
}

330 #if 
IP_DEBUG


332 
	$ip_debug_print
(struct 
pbuf
 *
p
)

334 struct 
ip_hdr
 *
iphdr
 = 
p
->
payload
;

336 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("IP header:\n"));

337 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

338 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("|%2"
S16_F
" | %"
X16_F
"%"X16_F" | %"X16_F"%"X16_F" | (v, traffic class, flow label)\n",

339 
iphdr
->
v
,

340 
iphdr
->
tclass1
, iphdr->
tclass2
,

341 
iphdr
->
flow1
, iphdr->
flow2
));

342 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

343 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %5"
U16_F
" | %2"U16_F" | %2"U16_F" | (len, nexthdr, hoplim)\n",

344 
	`ntohs
(
iphdr
->
len
),

345 
iphdr
->
nexthdr
,

346 
iphdr
->
hoplim
));

347 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

348 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (src)\n",

349 (
	`ntohl
(
iphdr
->
src
.
addr
[0]) >> 16) & 0xffff,

350 
	`ntohl
(
iphdr
->
src
.
addr
[0]) & 0xffff));

351 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (src)\n",

352 (
	`ntohl
(
iphdr
->
src
.
addr
[1]) >> 16) & 0xffff,

353 
	`ntohl
(
iphdr
->
src
.
addr
[1]) & 0xffff));

354 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (src)\n",

355 (
	`ntohl
(
iphdr
->
src
.
addr
[2]) >> 16) & 0xffff,

356 
	`ntohl
(
iphdr
->
src
.
addr
[2]) & 0xffff));

357 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (src)\n",

358 (
	`ntohl
(
iphdr
->
src
.
addr
[3]) >> 16) & 0xffff,

359 
	`ntohl
(
iphdr
->
src
.
addr
[3]) & 0xffff));

360 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

361 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (dest)\n",

362 (
	`ntohl
(
iphdr
->
dest
.
addr
[0]) >> 16) & 0xffff,

363 
	`ntohl
(
iphdr
->
dest
.
addr
[0]) & 0xffff));

364 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (dest)\n",

365 (
	`ntohl
(
iphdr
->
dest
.
addr
[1]) >> 16) & 0xffff,

366 
	`ntohl
(
iphdr
->
dest
.
addr
[1]) & 0xffff));

367 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (dest)\n",

368 (
	`ntohl
(
iphdr
->
dest
.
addr
[2]) >> 16) & 0xffff,

369 
	`ntohl
(
iphdr
->
dest
.
addr
[2]) & 0xffff));

370 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("| %4"
X32_F
" | %4"X32_F" | (dest)\n",

371 (
	`ntohl
(
iphdr
->
dest
.
addr
[3]) >> 16) & 0xffff,

372 
	`ntohl
(
iphdr
->
dest
.
addr
[3]) & 0xffff));

373 
	`LWIP_DEBUGF
(
IP_DEBUG
, ("+-------------------------------+\n"));

374 
	}
}

	@/root/Robux/net/lwip/core/ipv6/ip6_addr.c

33 #include 
	~"lwip/opt.h
"

34 #include 
	~"lwip/ip_addr.h
"

35 #include 
	~"lwip/inet.h
"

37 
u8_t


38 
	$ip_addr_netcmp
(struct 
ip_addr
 *
addr1
, struct ip_addr *
addr2
,

39 struct 
ip_addr
 *
mask
)

41 return((
addr1
->
addr
[0] & 
mask
->addr[0]) == (
addr2
->addr[0] & mask->addr[0]) &&

42 (
addr1
->
addr
[1] & 
mask
->addr[1]) == (
addr2
->addr[1] & mask->addr[1]) &&

43 (
addr1
->
addr
[2] & 
mask
->addr[2]) == (
addr2
->addr[2] & mask->addr[2]) &&

44 (
addr1
->
addr
[3] & 
mask
->addr[3]) == (
addr2
->addr[3] & mask->addr[3]));

46 
	}
}

48 
u8_t


49 
	$ip_addr_cmp
(struct 
ip_addr
 *
addr1
, struct ip_addr *
addr2
)

51 return(
addr1
->
addr
[0] == 
addr2
->addr[0] &&

52 
addr1
->
addr
[1] == 
addr2
->addr[1] &&

53 
addr1
->
addr
[2] == 
addr2
->addr[2] &&

54 
addr1
->
addr
[3] == 
addr2
->addr[3]);

55 
	}
}

58 
	$ip_addr_set
(struct 
ip_addr
 *
dest
, struct ip_addr *
src
)

60 
	`SMEMCPY
(
dest
, 
src
, sizeof(struct 
ip_addr
));

65 
	}
}

67 
u8_t


68 
	$ip_addr_isany
(struct 
ip_addr
 *
addr
)

70 if (
addr
 == 
NULL
) return 1;

71 return((
addr
->addr[0] | addr->addr[1] | addr->addr[2] | addr->addr[3]) == 0);

72 
	}
}

	@/root/Robux/net/lwip/core/mem.c

56 #include 
	~"lwip/opt.h
"

58 #if !
MEM_LIBC_MALLOC


60 #include 
	~"lwip/def.h
"

61 #include 
	~"lwip/mem.h
"

62 #include 
	~"lwip/sys.h
"

63 #include 
	~"lwip/stats.h
"

65 #include 
	~<string.h
>

67 #if 
MEM_USE_POOLS


73 struct 
	smem_helper


75 
memp_t
 
	mpoolnr
;

86 
	$mem_malloc
(
mem_size_t
 
size
)

88 struct 
mem_helper
 *
element
;

89 
memp_t
 
poolnr
;

91 for (
poolnr
 = 
MEMP_POOL_FIRST
; poolnr <= 
MEMP_POOL_LAST
; poolnr++) {

94 if ((
size
 + sizeof(struct 
mem_helper
)) <= 
memp_sizes
[
poolnr
]) {

98 if (
poolnr
 > 
MEMP_POOL_LAST
) {

99 
	`LWIP_ASSERT
("mem_malloc(): no pool is that big!", 0);

100 return 
NULL
;

102 
element
 = (struct 
mem_helper
*)
	`memp_malloc
(
poolnr
);

103 if (
element
 == 
NULL
) {

107 return 
NULL
;

111 
element
->
poolnr
 = poolnr;

113 
element
++;

115 return 
element
;

116 
	}
}

126 
	$mem_free
(void *
rmem
)

128 struct 
mem_helper
 *
hmem
 = (struct mem_helper*)
rmem
;

130 
	`LWIP_ASSERT
("rmem != NULL", (
rmem
 != 
NULL
));

131 
	`LWIP_ASSERT
("rmem == MEM_ALIGN(rmem)", (
rmem
 == 
	`LWIP_MEM_ALIGN
(rmem)));

134 
hmem
--;

136 
	`LWIP_ASSERT
("hmem != NULL", (
hmem
 != 
NULL
));

137 
	`LWIP_ASSERT
("hmem == MEM_ALIGN(hmem)", (
hmem
 == 
	`LWIP_MEM_ALIGN
(hmem)));

138 
	`LWIP_ASSERT
("hmem->poolnr < MEMP_MAX", (
hmem
->
poolnr
 < 
MEMP_MAX
));

141 
	`memp_free
(
hmem
->
poolnr
, hmem);

142 
	}
}

152 struct 
	smem
 {

154 
mem_size_t
 
	mnext
;

156 
mem_size_t
 
	mprev
;

158 
u8_t
 
	mused
;

164 #ifndef 
MIN_SIZE


165 #define 
	#MIN_SIZE
 12

	)

168 #define 
	#MIN_SIZE_ALIGNED
 
	`LWIP_MEM_ALIGN_SIZE
(
MIN_SIZE
)

	)

169 #define 
	#SIZEOF_STRUCT_MEM
 
	`LWIP_MEM_ALIGN_SIZE
(sizeof(struct 
mem
))

	)

170 #define 
	#MEM_SIZE_ALIGNED
 
	`LWIP_MEM_ALIGN_SIZE
(
MEM_SIZE
)

	)

173 static 
u8_t
 
	gram_heap
[
MEM_SIZE_ALIGNED
 + (2*
SIZEOF_STRUCT_MEM
) + 
MEM_ALIGNMENT
];

175 static 
u8_t
 *
	gram
;

177 static struct 
mem
 *
	gram_end
;

179 static struct 
mem
 *
	glfree
;

182 static 
sys_sem_t
 
	gmem_sem
;

184 #if 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


186 static volatile 
u8_t
 
	gmem_free_count
;

189 #define 
	#LWIP_MEM_FREE_DECL_PROTECT
() 
	`SYS_ARCH_DECL_PROTECT
(
lev_free
)

	)

190 #define 
	#LWIP_MEM_FREE_PROTECT
() 
	`SYS_ARCH_PROTECT
(
lev_free
)

	)

191 #define 
	#LWIP_MEM_FREE_UNPROTECT
() 
	`SYS_ARCH_UNPROTECT
(
lev_free
)

	)

192 #define 
	#LWIP_MEM_ALLOC_DECL_PROTECT
() 
	`SYS_ARCH_DECL_PROTECT
(
lev_alloc
)

	)

193 #define 
	#LWIP_MEM_ALLOC_PROTECT
() 
	`SYS_ARCH_PROTECT
(
lev_alloc
)

	)

194 #define 
	#LWIP_MEM_ALLOC_UNPROTECT
() 
	`SYS_ARCH_UNPROTECT
(
lev_alloc
)

	)

199 #define 
	#LWIP_MEM_FREE_DECL_PROTECT
()

	)

200 #define 
	#LWIP_MEM_FREE_PROTECT
() 
	`sys_arch_sem_wait
(
mem_sem
, 0)

	)

201 #define 
	#LWIP_MEM_FREE_UNPROTECT
() 
	`sys_sem_signal
(
mem_sem
)

	)

203 #define 
	#LWIP_MEM_ALLOC_DECL_PROTECT
()

	)

204 #define 
	#LWIP_MEM_ALLOC_PROTECT
()

	)

205 #define 
	#LWIP_MEM_ALLOC_UNPROTECT
()

	)

222 
	$plug_holes
(struct 
mem
 *mem)

224 struct 
mem
 *
nmem
;

225 struct 
mem
 *
pmem
;

227 
	`LWIP_ASSERT
("plug_holes: mem >= ram", (
u8_t
 *)
mem
 >= 
ram
);

228 
	`LWIP_ASSERT
("plug_holes: mem < ram_end", (
u8_t
 *)
mem
 < (u8_t *)
ram_end
);

229 
	`LWIP_ASSERT
("plug_holes: mem->used == 0", 
mem
->
used
 == 0);

232 
	`LWIP_ASSERT
("plug_holes: mem->next <= MEM_SIZE_ALIGNED", 
mem
->
next
 <= 
MEM_SIZE_ALIGNED
);

234 
nmem
 = (struct 
mem
 *)&
ram
[mem->
next
];

235 if (
mem
 != 
nmem
 && nmem->
used
 == 0 && (
u8_t
 *)nmem != (u8_t *)
ram_end
) {

237 if (
lfree
 == 
nmem
) {

238 
lfree
 = 
mem
;

240 
mem
->
next
 = 
nmem
->next;

241 ((struct 
mem
 *)&
ram
[
nmem
->
next
])->
prev
 = (
u8_t
 *)mem - ram;

245 
pmem
 = (struct 
mem
 *)&
ram
[mem->
prev
];

246 if (
pmem
 != 
mem
 && pmem->
used
 == 0) {

248 if (
lfree
 == 
mem
) {

249 
lfree
 = 
pmem
;

251 
pmem
->
next
 = 
mem
->next;

252 ((struct 
mem
 *)&
ram
[mem->
next
])->
prev
 = (
u8_t
 *)
pmem
 - ram;

254 
	}
}

260 
	$mem_init
(void)

262 struct 
mem
 *mem;

264 
	`LWIP_ASSERT
("Sanity check alignment",

265 (
SIZEOF_STRUCT_MEM
 & (
MEM_ALIGNMENT
-1)) == 0);

268 
ram
 = 
	`LWIP_MEM_ALIGN
(
ram_heap
);

270 
mem
 = (struct mem *)
ram
;

271 
mem
->
next
 = 
MEM_SIZE_ALIGNED
;

272 
mem
->
prev
 = 0;

273 
mem
->
used
 = 0;

275 
ram_end
 = (struct 
mem
 *)&
ram
[
MEM_SIZE_ALIGNED
];

276 
ram_end
->
used
 = 1;

277 
ram_end
->
next
 = 
MEM_SIZE_ALIGNED
;

278 
ram_end
->
prev
 = 
MEM_SIZE_ALIGNED
;

280 
mem_sem
 = 
	`sys_sem_new
(1);

283 
lfree
 = (struct 
mem
 *)
ram
;

285 
	`MEM_STATS_AVAIL
(
avail
, 
MEM_SIZE_ALIGNED
);

286 
	}
}

295 
	$mem_free
(void *
rmem
)

297 struct 
mem
 *mem;

298 
	`LWIP_MEM_FREE_DECL_PROTECT
();

300 if (
rmem
 == 
NULL
) {

301 
	`LWIP_DEBUGF
(
MEM_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("mem_free(p == NULL) was called.\n"));

304 
	`LWIP_ASSERT
("mem_free: sanity check alignment", (((
mem_ptr_t
)
rmem
) & (
MEM_ALIGNMENT
-1)) == 0);

306 
	`LWIP_ASSERT
("mem_free: legal memory", (
u8_t
 *)
rmem
 >= (u8_t *)
ram
 &&

307 (
u8_t
 *)
rmem
 < (u8_t *)
ram_end
);

309 if ((
u8_t
 *)
rmem
 < (u8_t *)
ram
 || (u8_t *)rmem >= (u8_t *)
ram_end
) {

310 
	`SYS_ARCH_DECL_PROTECT
(
lev
);

311 
	`LWIP_DEBUGF
(
MEM_DEBUG
 | 3, ("mem_free: illegal memory\n"));

313 
	`SYS_ARCH_PROTECT
(
lev
);

314 
	`MEM_STATS_INC
(
illegal
);

315 
	`SYS_ARCH_UNPROTECT
(
lev
);

319 
	`LWIP_MEM_FREE_PROTECT
();

321 
mem
 = (struct mem *)((
u8_t
 *)
rmem
 - 
SIZEOF_STRUCT_MEM
);

323 
	`LWIP_ASSERT
("mem_free: mem->used", 
mem
->
used
);

325 
mem
->
used
 = 0;

327 if (
mem
 < 
lfree
) {

329 
lfree
 = 
mem
;

332 
	`MEM_STATS_DEC_USED
(
used
, 
mem
->
next
 - ((
u8_t
 *)mem - 
ram
));

335 
	`plug_holes
(
mem
);

336 #if 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


337 
mem_free_count
 = 1;

339 
	`LWIP_MEM_FREE_UNPROTECT
();

340 
	}
}

355 
	$mem_realloc
(void *
rmem
, 
mem_size_t
 
newsize
)

357 
mem_size_t
 
size
;

358 
mem_size_t
 
ptr
, 
ptr2
;

359 struct 
mem
 *mem, *
mem2
;

361 
	`LWIP_MEM_FREE_DECL_PROTECT
();

365 
newsize
 = 
	`LWIP_MEM_ALIGN_SIZE
(newsize);

367 if(
newsize
 < 
MIN_SIZE_ALIGNED
) {

369 
newsize
 = 
MIN_SIZE_ALIGNED
;

372 if (
newsize
 > 
MEM_SIZE_ALIGNED
) {

373 return 
NULL
;

376 
	`LWIP_ASSERT
("mem_realloc: legal memory", (
u8_t
 *)
rmem
 >= (u8_t *)
ram
 &&

377 (
u8_t
 *)
rmem
 < (u8_t *)
ram_end
);

379 if ((
u8_t
 *)
rmem
 < (u8_t *)
ram
 || (u8_t *)rmem >= (u8_t *)
ram_end
) {

380 
	`SYS_ARCH_DECL_PROTECT
(
lev
);

381 
	`LWIP_DEBUGF
(
MEM_DEBUG
 | 3, ("mem_realloc: illegal memory\n"));

383 
	`SYS_ARCH_PROTECT
(
lev
);

384 
	`MEM_STATS_INC
(
illegal
);

385 
	`SYS_ARCH_UNPROTECT
(
lev
);

386 return 
rmem
;

389 
mem
 = (struct mem *)((
u8_t
 *)
rmem
 - 
SIZEOF_STRUCT_MEM
);

391 
ptr
 = (
u8_t
 *)
mem
 - 
ram
;

393 
size
 = 
mem
->
next
 - 
ptr
 - 
SIZEOF_STRUCT_MEM
;

394 
	`LWIP_ASSERT
("mem_realloc can only shrink memory", 
newsize
 <= 
size
);

395 if (
newsize
 > 
size
) {

397 return 
NULL
;

399 if (
newsize
 == 
size
) {

401 return 
rmem
;

405 
	`LWIP_MEM_FREE_PROTECT
();

407 
	`MEM_STATS_DEC_USED
(
used
, (
size
 - 
newsize
));

409 
mem2
 = (struct 
mem
 *)&
ram
[mem->
next
];

410 if(
mem2
->
used
 == 0) {

412 
mem_size_t
 
next
;

414 
next
 = 
mem2
->next;

416 
ptr2
 = 
ptr
 + 
SIZEOF_STRUCT_MEM
 + 
newsize
;

417 if (
lfree
 == 
mem2
) {

418 
lfree
 = (struct 
mem
 *)&
ram
[
ptr2
];

420 
mem2
 = (struct 
mem
 *)&
ram
[
ptr2
];

421 
mem2
->
used
 = 0;

423 
mem2
->
next
 = next;

425 
mem2
->
prev
 = 
ptr
;

427 
mem
->
next
 = 
ptr2
;

431 if (
mem2
->
next
 != 
MEM_SIZE_ALIGNED
) {

432 ((struct 
mem
 *)&
ram
[
mem2
->
next
])->
prev
 = 
ptr2
;

435 } else if (
newsize
 + 
SIZEOF_STRUCT_MEM
 + 
MIN_SIZE_ALIGNED
 <= 
size
) {

443 
ptr2
 = 
ptr
 + 
SIZEOF_STRUCT_MEM
 + 
newsize
;

444 
mem2
 = (struct 
mem
 *)&
ram
[
ptr2
];

445 if (
mem2
 < 
lfree
) {

446 
lfree
 = 
mem2
;

448 
mem2
->
used
 = 0;

449 
mem2
->
next
 = 
mem
->next;

450 
mem2
->
prev
 = 
ptr
;

451 
mem
->
next
 = 
ptr2
;

452 if (
mem2
->
next
 != 
MEM_SIZE_ALIGNED
) {

453 ((struct 
mem
 *)&
ram
[
mem2
->
next
])->
prev
 = 
ptr2
;

463 #if 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


464 
mem_free_count
 = 1;

466 
	`LWIP_MEM_FREE_UNPROTECT
();

467 return 
rmem
;

468 
	}
}

480 
	$mem_malloc
(
mem_size_t
 
size
)

482 
mem_size_t
 
ptr
, 
ptr2
;

483 struct 
mem
 *mem, *
mem2
;

484 #if 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


485 
u8_t
 
local_mem_free_count
 = 0;

487 
	`LWIP_MEM_ALLOC_DECL_PROTECT
();

489 if (
size
 == 0) {

490 return 
NULL
;

495 
size
 = 
	`LWIP_MEM_ALIGN_SIZE
(size);

497 if(
size
 < 
MIN_SIZE_ALIGNED
) {

499 
size
 = 
MIN_SIZE_ALIGNED
;

502 if (
size
 > 
MEM_SIZE_ALIGNED
) {

503 return 
NULL
;

507 
	`sys_arch_sem_wait
(
mem_sem
, 0);

508 
	`LWIP_MEM_ALLOC_PROTECT
();

509 #if 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


512 
local_mem_free_count
 = 0;

518 for (
ptr
 = (
u8_t
 *)
lfree
 - 
ram
; ptr < 
MEM_SIZE_ALIGNED
 - 
size
;

519 
ptr
 = ((struct 
mem
 *)&
ram
[ptr])->
next
) {

520 
mem
 = (struct mem *)&
ram
[
ptr
];

521 #if 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


522 
mem_free_count
 = 0;

523 
	`LWIP_MEM_ALLOC_UNPROTECT
();

525 
	`LWIP_MEM_ALLOC_PROTECT
();

526 if (
mem_free_count
 != 0) {

527 
local_mem_free_count
 = 
mem_free_count
;

529 
mem_free_count
 = 0;

532 if ((!
mem
->
used
) &&

533 (
mem
->
next
 - (
ptr
 + 
SIZEOF_STRUCT_MEM
)) >= 
size
) {

537 if (
mem
->
next
 - (
ptr
 + 
SIZEOF_STRUCT_MEM
) >= (
size
 + SIZEOF_STRUCT_MEM + 
MIN_SIZE_ALIGNED
)) {

548 
ptr2
 = 
ptr
 + 
SIZEOF_STRUCT_MEM
 + 
size
;

550 
mem2
 = (struct 
mem
 *)&
ram
[
ptr2
];

551 
mem2
->
used
 = 0;

552 
mem2
->
next
 = 
mem
->next;

553 
mem2
->
prev
 = 
ptr
;

555 
mem
->
next
 = 
ptr2
;

556 
mem
->
used
 = 1;

558 if (
mem2
->
next
 != 
MEM_SIZE_ALIGNED
) {

559 ((struct 
mem
 *)&
ram
[
mem2
->
next
])->
prev
 = 
ptr2
;

561 
	`MEM_STATS_INC_USED
(
used
, (
size
 + 
SIZEOF_STRUCT_MEM
));

570 
mem
->
used
 = 1;

571 
	`MEM_STATS_INC_USED
(
used
, 
mem
->
next
 - ((
u8_t
 *)mem - 
ram
));

574 if (
mem
 == 
lfree
) {

576 while (
lfree
->
used
 && lfree != 
ram_end
) {

577 
	`LWIP_MEM_ALLOC_UNPROTECT
();

579 
	`LWIP_MEM_ALLOC_PROTECT
();

580 
lfree
 = (struct 
mem
 *)&
ram
[lfree->
next
];

582 
	`LWIP_ASSERT
("mem_malloc: !lfree->used", ((
lfree
 == 
ram_end
) || (!lfree->
used
)));

584 
	`LWIP_MEM_ALLOC_UNPROTECT
();

585 
	`sys_sem_signal
(
mem_sem
);

586 
	`LWIP_ASSERT
("mem_malloc: allocated memory not above ram_end.",

587 (
mem_ptr_t
)
mem
 + 
SIZEOF_STRUCT_MEM
 + 
size
 <= (mem_ptr_t)
ram_end
);

588 
	`LWIP_ASSERT
("mem_malloc: allocated memory properly aligned.",

589 (unsigned long)((
u8_t
 *)
mem
 + 
SIZEOF_STRUCT_MEM
) % 
MEM_ALIGNMENT
 == 0);

590 
	`LWIP_ASSERT
("mem_malloc: sanity check alignment",

591 (((
mem_ptr_t
)
mem
) & (
MEM_ALIGNMENT
-1)) == 0);

593 return (
u8_t
 *)
mem
 + 
SIZEOF_STRUCT_MEM
;

596 #if 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


598 } while(
local_mem_free_count
 != 0);

600 
	`LWIP_DEBUGF
(
MEM_DEBUG
 | 2, ("mem_malloc: could not allocate %"
S16_F
" bytes\n", (
s16_t
)
size
));

601 
	`MEM_STATS_INC
(
err
);

602 
	`LWIP_MEM_ALLOC_UNPROTECT
();

603 
	`sys_sem_signal
(
mem_sem
);

604 return 
NULL
;

605 
	}
}

618 void *
	$mem_calloc
(
mem_size_t
 
count
, mem_size_t 
size
)

620 void *
p
;

623 
p
 = 
	`mem_malloc
(
count
 * 
size
);

624 if (
p
) {

626 
	`memset
(
p
, 0, 
count
 * 
size
);

628 return 
p
;

629 
	}
}

	@/root/Robux/net/lwip/core/memp.c

41 #include 
	~"lwip/opt.h
"

43 #include 
	~"lwip/memp.h
"

44 #include 
	~"lwip/pbuf.h
"

45 #include 
	~"lwip/udp.h
"

46 #include 
	~"lwip/raw.h
"

47 #include 
	~"lwip/tcp.h
"

48 #include 
	~"lwip/igmp.h
"

49 #include 
	~"lwip/api.h
"

50 #include 
	~"lwip/api_msg.h
"

51 #include 
	~"lwip/tcpip.h
"

52 #include 
	~"lwip/sys.h
"

53 #include 
	~"lwip/stats.h
"

54 #include 
	~"netif/etharp.h
"

55 #include 
	~"lwip/ip_frag.h
"

57 #include 
	~<string.h
>

59 struct 
	smemp
 {

60 struct 
memp
 *
	mnext
;

61 #if 
MEMP_OVERFLOW_CHECK


62 const char *
	mfile
;

63 int 
	mline
;

67 #if 
MEMP_OVERFLOW_CHECK


76 #ifndef 
MEMP_SANITY_REGION_BEFORE


77 #define 
	#MEMP_SANITY_REGION_BEFORE
 16

	)

79 #if 
MEMP_SANITY_REGION_BEFORE
 > 0

80 #define 
	#MEMP_SANITY_REGION_BEFORE_ALIGNED
 
	`LWIP_MEM_ALIGN_SIZE
(
MEMP_SANITY_REGION_BEFORE
)

	)

82 #define 
	#MEMP_SANITY_REGION_BEFORE_ALIGNED
 0

	)

84 #ifndef 
MEMP_SANITY_REGION_AFTER


85 #define 
	#MEMP_SANITY_REGION_AFTER
 16

	)

87 #if 
MEMP_SANITY_REGION_AFTER
 > 0

88 #define 
	#MEMP_SANITY_REGION_AFTER_ALIGNED
 
	`LWIP_MEM_ALIGN_SIZE
(
MEMP_SANITY_REGION_AFTER
)

	)

90 #define 
	#MEMP_SANITY_REGION_AFTER_ALIGNED
 0

	)

94 #define 
	#MEMP_SIZE
 (
	`LWIP_MEM_ALIGN_SIZE
(sizeof(struct 
memp
)) + 
MEMP_SANITY_REGION_BEFORE_ALIGNED
)

	)

95 #define 
	#MEMP_ALIGN_SIZE
(
x
) (
	`LWIP_MEM_ALIGN_SIZE
(x) + 
MEMP_SANITY_REGION_AFTER_ALIGNED
)

	)

103 #define 
	#MEMP_SIZE
 0

	)

104 #define 
	#MEMP_ALIGN_SIZE
(
x
) (
	`LWIP_MEM_ALIGN_SIZE
(x))

	)

110 static struct 
memp
 *
	gmemp_tab
[
MEMP_MAX
];

113 #if !
MEM_USE_POOLS


116 const 
u16_t
 
	gmemp_sizes
[
MEMP_MAX
] = {

117 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
) 
	`MEMP_ALIGN_SIZE
(size),

	)

118 #include 
	~"lwip/memp_std.h
"

122 static const 
u16_t
 
	gmemp_num
[
MEMP_MAX
] = {

123 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
) (num),

	)

124 #include 
	~"lwip/memp_std.h
"

128 #ifdef 
LWIP_DEBUG


129 static const char *
	gmemp_desc
[
MEMP_MAX
] = {

130 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
) (desc),

	)

131 #include 
	~"lwip/memp_std.h
"

136 static 
u8_t
 
	gmemp_memory
[
MEM_ALIGNMENT
 - 1

137 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
) + ( (num) * (
MEMP_SIZE
 + 
	`MEMP_ALIGN_SIZE
(size) ) )

	)

138 #include 
	~"lwip/memp_std.h
"

141 #if 
MEMP_SANITY_CHECK


146 
	$memp_sanity
(void)

148 
s16_t
 
i
, 
c
;

149 struct 
memp
 *
m
, *
n
;

151 for (
i
 = 0; i < 
MEMP_MAX
; i++) {

152 for (
m
 = 
memp_tab
[
i
]; m != 
NULL
; m = m->
next
) {

153 
c
 = 1;

154 for (
n
 = 
memp_tab
[
i
]; n != 
NULL
; n = n->
next
) {

155 if (
n
 == 
m
 && --
c
 < 0) {

162 
	}
}

164 #if 
MEMP_OVERFLOW_CHECK


173 
	$memp_overflow_check_element
(struct 
memp
 *
p
, 
u16_t
 
memp_size
)

175 
u16_t
 
k
;

176 
u8_t
 *
m
;

177 #if 
MEMP_SANITY_REGION_BEFORE_ALIGNED
 > 0

178 
m
 = (
u8_t
*)
p
 + 
MEMP_SIZE
 - 
MEMP_SANITY_REGION_BEFORE_ALIGNED
;

179 for (
k
 = 0; k < 
MEMP_SANITY_REGION_BEFORE_ALIGNED
; k++) {

180 if (
m
[
k
] != 0xcd) {

181 
	`LWIP_ASSERT
("detected memp underflow!", 0);

185 #if 
MEMP_SANITY_REGION_AFTER_ALIGNED
 > 0

186 
m
 = (
u8_t
*)
p
 + 
MEMP_SIZE
 + 
memp_size
 - 
MEMP_SANITY_REGION_AFTER_ALIGNED
;

187 for (
k
 = 0; k < 
MEMP_SANITY_REGION_AFTER_ALIGNED
; k++) {

188 if (
m
[
k
] != 0xcd) {

189 
	`LWIP_ASSERT
("detected memp overflow!", 0);

193 
	}
}

201 
	$memp_overflow_check_all
(void)

203 
u16_t
 
i
, 
j
;

204 struct 
memp
 *
p
;

206 
p
 = 
	`LWIP_MEM_ALIGN
(
memp_memory
);

207 for (
i
 = 0; i < 
MEMP_MAX
; ++i) {

208 
p
 = p;

209 for (
j
 = 0; j < 
memp_num
[
i
]; ++j) {

210 
	`memp_overflow_check_element
(
p
, 
memp_sizes
[
i
]);

211 
p
 = (struct 
memp
*)((
u8_t
*)p + 
MEMP_SIZE
 + 
memp_sizes
[
i
]);

214 
	}
}

220 
	$memp_overflow_init
(void)

222 
u16_t
 
i
, 
j
;

223 struct 
memp
 *
p
;

224 
u8_t
 *
m
;

226 
p
 = 
	`LWIP_MEM_ALIGN
(
memp_memory
);

227 for (
i
 = 0; i < 
MEMP_MAX
; ++i) {

228 
p
 = p;

229 for (
j
 = 0; j < 
memp_num
[
i
]; ++j) {

230 #if 
MEMP_SANITY_REGION_BEFORE_ALIGNED
 > 0

231 
m
 = (
u8_t
*)
p
 + 
MEMP_SIZE
 - 
MEMP_SANITY_REGION_BEFORE_ALIGNED
;

232 
	`memset
(
m
, 0xcd, 
MEMP_SANITY_REGION_BEFORE_ALIGNED
);

234 #if 
MEMP_SANITY_REGION_AFTER_ALIGNED
 > 0

235 
m
 = (
u8_t
*)
p
 + 
MEMP_SIZE
 + 
memp_sizes
[
i
] - 
MEMP_SANITY_REGION_AFTER_ALIGNED
;

236 
	`memset
(
m
, 0xcd, 
MEMP_SANITY_REGION_AFTER_ALIGNED
);

238 
p
 = (struct 
memp
*)((
u8_t
*)p + 
MEMP_SIZE
 + 
memp_sizes
[
i
]);

241 
	}
}

250 
	$memp_init
(void)

252 struct 
memp
 *memp;

253 
u16_t
 
i
, 
j
;

255 for (
i
 = 0; i < 
MEMP_MAX
; ++i) {

256 
	`MEMP_STATS_AVAIL
(
used
, 
i
, 0);

257 
	`MEMP_STATS_AVAIL
(
max
, 
i
, 0);

258 
	`MEMP_STATS_AVAIL
(
err
, 
i
, 0);

259 
	`MEMP_STATS_AVAIL
(
avail
, 
i
, 
memp_num
[i]);

262 
memp
 = 
	`LWIP_MEM_ALIGN
(
memp_memory
);

264 for (
i
 = 0; i < 
MEMP_MAX
; ++i) {

265 
memp_tab
[
i
] = 
NULL
;

267 for (
j
 = 0; j < 
memp_num
[
i
]; ++j) {

268 
memp
->
next
 = 
memp_tab
[
i
];

269 
memp_tab
[
i
] = 
memp
;

270 
memp
 = (struct memp *)((
u8_t
 *)memp + 
MEMP_SIZE
 + 
memp_sizes
[
i
]);

273 #if 
MEMP_OVERFLOW_CHECK


274 
	`memp_overflow_init
();

276 
	`memp_overflow_check_all
();

278 
	}
}

292 #if !
MEMP_OVERFLOW_CHECK


293 
	$memp_malloc
(
memp_t
 
type
)

295 
	$memp_malloc_fn
(
memp_t
 
type
, const char* 
file
, const int 
line
)

298 struct 
memp
 *memp;

299 
	`SYS_ARCH_DECL_PROTECT
(
old_level
);

301 
	`LWIP_ERROR
("memp_malloc: type < MEMP_MAX", (
type
 < 
MEMP_MAX
), return 
NULL
;);

303 
	`SYS_ARCH_PROTECT
(
old_level
);

304 #if 
MEMP_OVERFLOW_CHECK
 >= 2

305 
	`memp_overflow_check_all
();

308 
memp
 = 
memp_tab
[
type
];

310 if (
memp
 != 
NULL
) {

311 
memp_tab
[
type
] = 
memp
->
next
;

312 #if 
MEMP_OVERFLOW_CHECK


313 
memp
->
next
 = 
NULL
;

314 
memp
->
file
 = file;

315 
memp
->
line
 = line;

317 
	`MEMP_STATS_INC_USED
(
used
, 
type
);

318 
	`LWIP_ASSERT
("memp_malloc: memp properly aligned",

319 ((
mem_ptr_t
)
memp
 % 
MEM_ALIGNMENT
) == 0);

320 
memp
 = (struct memp*)((
u8_t
*)memp + 
MEMP_SIZE
);

322 
	`LWIP_DEBUGF
(
MEMP_DEBUG
 | 2, ("memp_malloc: out of memory in pool %s\n", 
memp_desc
[
type
]));

323 
	`MEMP_STATS_INC
(
err
, 
type
);

326 
	`SYS_ARCH_UNPROTECT
(
old_level
);

328 return 
memp
;

329 
	}
}

338 
	$memp_free
(
memp_t
 
type
, void *
mem
)

340 struct 
memp
 *memp;

341 
	`SYS_ARCH_DECL_PROTECT
(
old_level
);

343 if (
mem
 == 
NULL
) {

346 
	`LWIP_ASSERT
("memp_free: mem properly aligned",

347 ((
mem_ptr_t
)
mem
 % 
MEM_ALIGNMENT
) == 0);

349 
memp
 = (struct memp *)((
u8_t
*)
mem
 - 
MEMP_SIZE
);

351 
	`SYS_ARCH_PROTECT
(
old_level
);

352 #if 
MEMP_OVERFLOW_CHECK


353 #if 
MEMP_OVERFLOW_CHECK
 >= 2

354 
	`memp_overflow_check_all
();

356 
	`memp_overflow_check_element
(
memp
, 
memp_sizes
[
type
]);

360 
	`MEMP_STATS_DEC
(
used
, 
type
);

362 
memp
->
next
 = 
memp_tab
[
type
];

363 
memp_tab
[
type
] = 
memp
;

365 #if 
MEMP_SANITY_CHECK


366 
	`LWIP_ASSERT
("memp sanity", 
	`memp_sanity
());

369 
	`SYS_ARCH_UNPROTECT
(
old_level
);

370 
	}
}

	@/root/Robux/net/lwip/core/netif.c

39 #include 
	~"lwip/opt.h
"

41 #include 
	~"lwip/def.h
"

42 #include 
	~"lwip/ip_addr.h
"

43 #include 
	~"lwip/netif.h
"

44 #include 
	~"lwip/tcp.h
"

45 #include 
	~"lwip/snmp.h
"

46 #include 
	~"lwip/igmp.h
"

47 #include 
	~"netif/etharp.h
"

48 #if 
ENABLE_LOOPBACK


49 #include 
	~"lwip/sys.h
"

50 #if 
LWIP_NETIF_LOOPBACK_MULTITHREADING


51 #include 
	~"lwip/tcpip.h
"

55 #if 
LWIP_NETIF_STATUS_CALLBACK


56 #define 
	#NETIF_STATUS_CALLBACK
(
n
) { if (n->
status_callback
) (n->status_callback)(n); }

	)

58 #define 
	#NETIF_STATUS_CALLBACK
(
n
) { }

	)

61 #if 
LWIP_NETIF_LINK_CALLBACK


62 #define 
	#NETIF_LINK_CALLBACK
(
n
) { if (n->
link_callback
) (n->link_callback)(n); }

	)

64 #define 
	#NETIF_LINK_CALLBACK
(
n
) { }

	)

67 struct 
netif
 *
	gnetif_list
;

68 struct 
netif
 *
	gnetif_default
;

84 struct 
netif
 *

85 
netif_add
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
, struct ip_addr *
netmask
,

86 struct 
ip_addr
 *
gw
,

87 void *
state
,

88 
	$err_t
 (* 
init
)(struct 
netif
 *netif),

89 
	$err_t
 (* 
input
)(struct 
pbuf
 *
p
, struct 
netif
 *netif))

91 static 
u8_t
 
netifnum
 = 0;

94 
netif
->
ip_addr
.
addr
 = 0;

95 
netif
->
netmask
.
addr
 = 0;

96 
netif
->
gw
.
addr
 = 0;

97 
netif
->
flags
 = 0;

98 #if 
LWIP_DHCP


100 
netif
->
dhcp
 = 
NULL
;

102 #if 
LWIP_AUTOIP


104 
netif
->
autoip
 = 
NULL
;

106 #if 
LWIP_NETIF_STATUS_CALLBACK


107 
netif
->
status_callback
 = 
NULL
;

109 #if 
LWIP_NETIF_LINK_CALLBACK


110 
netif
->
link_callback
 = 
NULL
;

112 #if 
LWIP_IGMP


113 
netif
->
igmp_mac_filter
 = 
NULL
;

115 #if 
ENABLE_LOOPBACK


116 
netif
->
loop_first
 = 
NULL
;

117 
netif
->
loop_last
 = 
NULL
;

121 
netif
->
state
 = state;

122 
netif
->
num
 = 
netifnum
++;

123 
netif
->
input
 = input;

124 #if 
LWIP_NETIF_HWADDRHINT


125 
netif
->
addr_hint
 = 
NULL
;

127 #if 
ENABLE_LOOPBACK
 && 
LWIP_LOOPBACK_MAX_PBUFS


128 
netif
->
loop_cnt_current
 = 0;

131 
	`netif_set_addr
(
netif
, 
ipaddr
, 
netmask
, 
gw
);

134 if (
	`init
(
netif
) != 
ERR_OK
) {

135 return 
NULL
;

139 
netif
->
next
 = 
netif_list
;

140 
netif_list
 = 
netif
;

141 
	`snmp_inc_iflist
();

143 #if 
LWIP_IGMP


145 if (
netif
->
flags
 & 
NETIF_FLAG_IGMP
) {

146 
	`igmp_start
( 
netif
);

150 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("netif: added interface %c%c IP addr ",

151 
netif
->
name
[0], netif->name[1]));

152 
	`ip_addr_debug_print
(
NETIF_DEBUG
, 
ipaddr
);

153 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, (" netmask "));

154 
	`ip_addr_debug_print
(
NETIF_DEBUG
, 
netmask
);

155 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, (" gw "));

156 
	`ip_addr_debug_print
(
NETIF_DEBUG
, 
gw
);

157 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("\n"));

158 return 
netif
;

159 
	}
}

171 
	$netif_set_addr
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
, struct ip_addr *
netmask
,

172 struct 
ip_addr
 *
gw
)

174 
	`netif_set_ipaddr
(
netif
, 
ipaddr
);

175 
	`netif_set_netmask
(
netif
, 
netmask
);

176 
	`netif_set_gw
(
netif
, 
gw
);

177 
	}
}

184 void 
	$netif_remove
(struct 
netif
 * netif)

186 if ( 
netif
 == 
NULL
 ) return;

188 #if 
LWIP_IGMP


190 if (
netif
->
flags
 & 
NETIF_FLAG_IGMP
) {

191 
	`igmp_stop
( 
netif
);

195 
	`snmp_delete_ipaddridx_tree
(
netif
);

198 if (
netif_list
 == 
netif
) {

199 
netif_list
 = 
netif
->
next
;

200 
	`snmp_dec_iflist
();

204 struct 
netif
 * 
tmpNetif
;

205 for (
tmpNetif
 = 
netif_list
; tmpNetif != 
NULL
; tmpNetif = tmpNetif->
next
) {

206 if (
tmpNetif
->
next
 == 
netif
) {

207 
tmpNetif
->
next
 = 
netif
->next;

208 
	`snmp_dec_iflist
();

212 if (
tmpNetif
 == 
NULL
)

216 if (
netif_default
 == 
netif
)

218 
	`netif_set_default
(
NULL
);

219 
	`LWIP_DEBUGF
( 
NETIF_DEBUG
, ("netif_remove: removed netif\n") );

220 
	}
}

228 struct 
netif
 *

229 
	$netif_find
(char *
name
)

231 struct 
netif
 *netif;

232 
u8_t
 
num
;

234 if (
name
 == 
NULL
) {

235 return 
NULL
;

238 
num
 = 
name
[2] - '0';

240 for(
netif
 = 
netif_list
; netif != 
NULL
; netif = netif->
next
) {

241 if (
num
 == 
netif
->num &&

242 
name
[0] == 
netif
->name[0] &&

243 
name
[1] == 
netif
->name[1]) {

244 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("netif_find: found %c%c\n", 
name
[0], name[1]));

245 return 
netif
;

248 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("netif_find: didn't find %c%c\n", 
name
[0], name[1]));

249 return 
NULL
;

250 
	}
}

262 
	$netif_set_ipaddr
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
)

266 #if 
LWIP_TCP


267 struct 
tcp_pcb
 *
pcb
;

268 struct 
tcp_pcb_listen
 *
lpcb
;

271 if ((
	`ip_addr_cmp
(
ipaddr
, &(
netif
->
ip_addr
))) == 0)

274 
	`LWIP_DEBUGF
(
NETIF_DEBUG
 | 1, ("netif_set_ipaddr: netif address being changed\n"));

275 
pcb
 = 
tcp_active_pcbs
;

276 while (
pcb
 != 
NULL
) {

278 if (
	`ip_addr_cmp
(&(
pcb
->
local_ip
), &(
netif
->
ip_addr
))) {

280 struct 
tcp_pcb
 *
next
 = 
pcb
->next;

281 
	`LWIP_DEBUGF
(
NETIF_DEBUG
 | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)
pcb
));

282 
	`tcp_abort
(
pcb
);

283 
pcb
 = 
next
;

285 
pcb
 = pcb->
next
;

288 for (
lpcb
 = 
tcp_listen_pcbs
.
listen_pcbs
; lpcb != 
NULL
; lpcb = lpcb->
next
) {

290 if ((!(
	`ip_addr_isany
(&(
lpcb
->
local_ip
)))) &&

291 (
	`ip_addr_cmp
(&(
lpcb
->
local_ip
), &(
netif
->
ip_addr
)))) {

294 
	`ip_addr_set
(&(
lpcb
->
local_ip
), 
ipaddr
);

299 
	`snmp_delete_ipaddridx_tree
(
netif
);

300 
	`snmp_delete_iprteidx_tree
(0,
netif
);

302 
	`ip_addr_set
(&(
netif
->
ip_addr
), 
ipaddr
);

303 
	`snmp_insert_ipaddridx_tree
(
netif
);

304 
	`snmp_insert_iprteidx_tree
(0,
netif
);

306 
	`LWIP_DEBUGF
(
NETIF_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 3, ("netif: IP address of interface %c%c set to %"
U16_F
".%"U16_F".%"U16_F".%"U16_F"\n",

307 
netif
->
name
[0], netif->name[1],

308 
	`ip4_addr1
(&
netif
->
ip_addr
),

309 
	`ip4_addr2
(&
netif
->
ip_addr
),

310 
	`ip4_addr3
(&
netif
->
ip_addr
),

311 
	`ip4_addr4
(&
netif
->
ip_addr
)));

312 
	}
}

323 
	$netif_set_gw
(struct 
netif
 *netif, struct 
ip_addr
 *
gw
)

325 
	`ip_addr_set
(&(
netif
->
gw
), gw);

326 
	`LWIP_DEBUGF
(
NETIF_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 3, ("netif: GW address of interface %c%c set to %"
U16_F
".%"U16_F".%"U16_F".%"U16_F"\n",

327 
netif
->
name
[0], netif->name[1],

328 
	`ip4_addr1
(&
netif
->
gw
),

329 
	`ip4_addr2
(&
netif
->
gw
),

330 
	`ip4_addr3
(&
netif
->
gw
),

331 
	`ip4_addr4
(&
netif
->
gw
)));

332 
	}
}

344 
	$netif_set_netmask
(struct 
netif
 *netif, struct 
ip_addr
 *
netmask
)

346 
	`snmp_delete_iprteidx_tree
(0, 
netif
);

348 
	`ip_addr_set
(&(
netif
->
netmask
), netmask);

349 
	`snmp_insert_iprteidx_tree
(0, 
netif
);

350 
	`LWIP_DEBUGF
(
NETIF_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
 | 3, ("netif: netmask of interface %c%c set to %"
U16_F
".%"U16_F".%"U16_F".%"U16_F"\n",

351 
netif
->
name
[0], netif->name[1],

352 
	`ip4_addr1
(&
netif
->
netmask
),

353 
	`ip4_addr2
(&
netif
->
netmask
),

354 
	`ip4_addr3
(&
netif
->
netmask
),

355 
	`ip4_addr4
(&
netif
->
netmask
)));

356 
	}
}

365 
	$netif_set_default
(struct 
netif
 *netif)

367 if (
netif
 == 
NULL
)

370 
	`snmp_delete_iprteidx_tree
(1, 
netif
);

375 
	`snmp_insert_iprteidx_tree
(1, 
netif
);

377 
netif_default
 = 
netif
;

378 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("netif: setting default interface %c%c\n",

379 
netif
 ? netif->
name
[0] : '\'', netif ? netif->name[1] : '\''));

380 
	}
}

391 void 
	$netif_set_up
(struct 
netif
 *netif)

393 if ( !(
netif
->
flags
 & 
NETIF_FLAG_UP
 )) {

394 
netif
->
flags
 |= 
NETIF_FLAG_UP
;

396 #if 
LWIP_SNMP


397 
	`snmp_get_sysuptime
(&
netif
->
ts
);

400 
	`NETIF_LINK_CALLBACK
(
netif
);

401 
	`NETIF_STATUS_CALLBACK
(
netif
);

403 #if 
LWIP_ARP


409 if (
netif
->
flags
 & 
NETIF_FLAG_ETHARP
) {

410 
	`etharp_query
(
netif
, &(netif->
ip_addr
), 
NULL
);

415 
	}
}

425 void 
	$netif_set_down
(struct 
netif
 *netif)

427 if ( 
netif
->
flags
 & 
NETIF_FLAG_UP
 )

429 
netif
->
flags
 &= ~
NETIF_FLAG_UP
;

430 #if 
LWIP_SNMP


431 
	`snmp_get_sysuptime
(&
netif
->
ts
);

434 
	`NETIF_LINK_CALLBACK
(
netif
);

435 
	`NETIF_STATUS_CALLBACK
(
netif
);

437 
	}
}

442 
u8_t
 
	$netif_is_up
(struct 
netif
 *netif)

444 return (
netif
->
flags
 & 
NETIF_FLAG_UP
)?1:0;

445 
	}
}

447 #if 
LWIP_NETIF_STATUS_CALLBACK


451 void 
netif_set_status_callback
(struct 
netif
 *netif, void (* 
status_callback
)(struct netif *netif ))

453 if ( 
netif
 )

454 
netif
->
status_callback
 = status_callback;

455 
	}
}

458 #if 
LWIP_NETIF_LINK_CALLBACK


462 void 
	$netif_set_link_up
(struct 
netif
 *netif )

464 
netif
->
flags
 |= 
NETIF_FLAG_LINK_UP
;

466 #if 
LWIP_ARP


472 if (
netif
->
flags
 & 
NETIF_FLAG_ETHARP
) {

473 
	`etharp_query
(
netif
, &(netif->
ip_addr
), 
NULL
);

477 #if 
LWIP_IGMP


479 if (
netif
->
flags
 & 
NETIF_FLAG_IGMP
) {

480 
	`igmp_report_groups
( 
netif
);

484 
	`NETIF_LINK_CALLBACK
(
netif
);

485 
	}
}

490 void 
	$netif_set_link_down
(struct 
netif
 *netif )

492 
netif
->
flags
 &= ~
NETIF_FLAG_LINK_UP
;

493 
	`NETIF_LINK_CALLBACK
(
netif
);

494 
	}
}

499 
u8_t
 
	$netif_is_link_up
(struct 
netif
 *netif)

501 return (
netif
->
flags
 & 
NETIF_FLAG_LINK_UP
) ? 1 : 0;

502 
	}
}

507 void 
netif_set_link_callback
(struct 
netif
 *netif, void (* 
link_callback
)(struct netif *netif ))

509 if (
netif
) {

510 
netif
->
link_callback
 = link_callback;

512 
	}
}

515 #if 
ENABLE_LOOPBACK


530 
err_t


531 
	$netif_loop_output
(struct 
netif
 *netif, struct 
pbuf
 *
p
,

532 struct 
ip_addr
 *
ipaddr
)

534 struct 
pbuf
 *
r
;

535 
err_t
 
err
;

536 struct 
pbuf
 *
last
;

537 #if 
LWIP_LOOPBACK_MAX_PBUFS


538 
u8_t
 
clen
 = 0;

540 
	`SYS_ARCH_DECL_PROTECT
(
lev
);

541 
	`LWIP_UNUSED_ARG
(
ipaddr
);

544 
r
 = 
	`pbuf_alloc
(
PBUF_LINK
, 
p
->
tot_len
, 
PBUF_RAM
);

545 if (
r
 == 
NULL
) {

546 return 
ERR_MEM
;

548 #if 
LWIP_LOOPBACK_MAX_PBUFS


549 
clen
 = 
	`pbuf_clen
(
r
);

551 if(((
netif
->
loop_cnt_current
 + 
clen
) < netif->loop_cnt_current) ||

552 ((
netif
->
loop_cnt_current
 + 
clen
) > 
LWIP_LOOPBACK_MAX_PBUFS
)) {

553 
	`pbuf_free
(
r
);

554 
r
 = 
NULL
;

555 return 
ERR_MEM
;

557 
netif
->
loop_cnt_current
 += 
clen
;

561 if ((
err
 = 
	`pbuf_copy
(
r
, 
p
)) != 
ERR_OK
) {

562 
	`pbuf_free
(
r
);

563 
r
 = 
NULL
;

564 return 
err
;

571 for (
last
 = 
r
; last->
next
 != 
NULL
; last = last->next);

573 
	`SYS_ARCH_PROTECT
(
lev
);

574 if(
netif
->
loop_first
 != 
NULL
) {

575 
	`LWIP_ASSERT
("if first != NULL, last must also be != NULL", 
netif
->
loop_last
 != 
NULL
);

576 
netif
->
loop_last
->
next
 = 
r
;

577 
netif
->
loop_last
 = 
last
;

579 
netif
->
loop_first
 = 
r
;

580 
netif
->
loop_last
 = 
last
;

582 
	`SYS_ARCH_UNPROTECT
(
lev
);

584 #if 
LWIP_NETIF_LOOPBACK_MULTITHREADING


586 
	`tcpip_callback
(
netif_poll
, 
netif
);

589 return 
ERR_OK
;

590 
	}
}

599 
	$netif_poll
(struct 
netif
 *netif)

601 struct 
pbuf
 *
in
;

602 
	`SYS_ARCH_DECL_PROTECT
(
lev
);

606 
	`SYS_ARCH_PROTECT
(
lev
);

607 
in
 = 
netif
->
loop_first
;

608 if(
in
 != 
NULL
) {

609 struct 
pbuf
 *
in_end
 = 
in
;

610 #if 
LWIP_LOOPBACK_MAX_PBUFS


611 
u8_t
 
clen
 = 
	`pbuf_clen
(
in
);

613 
	`LWIP_ASSERT
("netif->loop_cnt_current underflow",

614 ((
netif
->
loop_cnt_current
 - 
clen
) < netif->loop_cnt_current));

615 
netif
->
loop_cnt_current
 -= 
clen
;

617 while(
in_end
->
len
 != in_end->
tot_len
) {

618 
	`LWIP_ASSERT
("bogus pbuf: len != tot_len but next == NULL!", 
in_end
->
next
 != 
NULL
);

619 
in_end
 = in_end->
next
;

622 if(
in_end
 == 
netif
->
loop_last
) {

624 
netif
->
loop_first
 = netif->
loop_last
 = 
NULL
;

627 
netif
->
loop_first
 = 
in_end
->
next
;

628 
	`LWIP_ASSERT
("should not be null since first != last!", 
netif
->
loop_first
 != 
NULL
);

631 
in_end
->
next
 = 
NULL
;

633 
	`SYS_ARCH_UNPROTECT
(
lev
);

635 if(
in
 != 
NULL
) {

637 if(
	`ip_input
(
in
, 
netif
) != 
ERR_OK
) {

638 
	`pbuf_free
(
in
);

641 
in
 = 
NULL
;

644 } while(
netif
->
loop_first
 != 
NULL
);

645 
	}
}

647 #if !
LWIP_NETIF_LOOPBACK_MULTITHREADING


652 
	$netif_poll_all
(void)

654 struct 
netif
 *netif = 
netif_list
;

656 while (
netif
 != 
NULL
) {

657 
	`netif_poll
(
netif
);

659 
netif
 = netif->
next
;

661 
	}
}

	@/root/Robux/net/lwip/core/pbuf.c

64 #include 
	~"lwip/opt.h
"

66 #include 
	~"lwip/stats.h
"

67 #include 
	~"lwip/def.h
"

68 #include 
	~"lwip/mem.h
"

69 #include 
	~"lwip/memp.h
"

70 #include 
	~"lwip/pbuf.h
"

71 #include 
	~"lwip/sys.h
"

72 #include 
	~"arch/perf.h
"

74 #include 
	~<string.h
>

76 #define 
	#SIZEOF_STRUCT_PBUF
 
	`LWIP_MEM_ALIGN_SIZE
(sizeof(struct 
pbuf
))

	)

79 #define 
	#PBUF_POOL_BUFSIZE_ALIGNED
 
	`LWIP_MEM_ALIGN_SIZE
(
PBUF_POOL_BUFSIZE
)

	)

112 struct 
pbuf
 *

113 
	$pbuf_alloc
(
pbuf_layer
 
layer
, 
u16_t
 
length
, 
pbuf_type
 
type
)

115 struct 
pbuf
 *
p
, *
q
, *
r
;

116 
u16_t
 
offset
;

117 
s32_t
 
rem_len
;

118 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("pbuf_alloc(length=%"
U16_F
")\n", 
length
));

121 
offset
 = 0;

122 switch (
layer
) {

123 case 
PBUF_TRANSPORT
:

125 
offset
 += 
PBUF_TRANSPORT_HLEN
;

127 case 
PBUF_IP
:

129 
offset
 += 
PBUF_IP_HLEN
;

131 case 
PBUF_LINK
:

133 
offset
 += 
PBUF_LINK_HLEN
;

135 case 
PBUF_RAW
:

138 
	`LWIP_ASSERT
("pbuf_alloc: bad pbuf layer", 0);

139 return 
NULL
;

142 switch (
type
) {

143 case 
PBUF_POOL
:

145 
p
 = 
	`memp_malloc
(
MEMP_PBUF_POOL
);

146 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)
p
));

147 if (
p
 == 
NULL
) {

148 return 
NULL
;

150 
p
->
type
 = type;

151 
p
->
next
 = 
NULL
;

154 
p
->
payload
 = 
	`LWIP_MEM_ALIGN
((void *)((
u8_t
 *)p + (
SIZEOF_STRUCT_PBUF
 + 
offset
)));

155 
	`LWIP_ASSERT
("pbuf_alloc: pbuf p->payload properly aligned",

156 ((
mem_ptr_t
)
p
->
payload
 % 
MEM_ALIGNMENT
) == 0);

158 
p
->
tot_len
 = 
length
;

160 
p
->
len
 = 
	`LWIP_MIN
(
length
, 
PBUF_POOL_BUFSIZE_ALIGNED
 - 
	`LWIP_MEM_ALIGN_SIZE
(
offset
));

161 
	`LWIP_ASSERT
("check p->payload + p->len does not overflow pbuf",

162 ((
u8_t
*)
p
->
payload
 + p->
len
 <=

163 (
u8_t
*)
p
 + 
SIZEOF_STRUCT_PBUF
 + 
PBUF_POOL_BUFSIZE_ALIGNED
));

165 
p
->
ref
 = 1;

170 
r
 = 
p
;

172 
rem_len
 = 
length
 - 
p
->
len
;

174 while (
rem_len
 > 0) {

175 
q
 = 
	`memp_malloc
(
MEMP_PBUF_POOL
);

176 if (
q
 == 
NULL
) {

178 
	`pbuf_free
(
p
);

180 return 
NULL
;

182 
q
->
type
 = type;

183 
q
->
flags
 = 0;

184 
q
->
next
 = 
NULL
;

186 
r
->
next
 = 
q
;

188 
	`LWIP_ASSERT
("rem_len < max_u16_t", 
rem_len
 < 0xffff);

189 
q
->
tot_len
 = (
u16_t
)
rem_len
;

191 
q
->
len
 = 
	`LWIP_MIN
((
u16_t
)
rem_len
, 
PBUF_POOL_BUFSIZE_ALIGNED
);

192 
q
->
payload
 = (void *)((
u8_t
 *)q + 
SIZEOF_STRUCT_PBUF
);

193 
	`LWIP_ASSERT
("pbuf_alloc: pbuf q->payload properly aligned",

194 ((
mem_ptr_t
)
q
->
payload
 % 
MEM_ALIGNMENT
) == 0);

195 
	`LWIP_ASSERT
("check p->payload + p->len does not overflow pbuf",

196 ((
u8_t
*)
p
->
payload
 + p->
len
 <=

197 (
u8_t
*)
p
 + 
SIZEOF_STRUCT_PBUF
 + 
PBUF_POOL_BUFSIZE_ALIGNED
));

198 
q
->
ref
 = 1;

200 
rem_len
 -= 
q
->
len
;

202 
r
 = 
q
;

208 case 
PBUF_RAM
:

210 
p
 = (struct 
pbuf
*)
	`mem_malloc
(
	`LWIP_MEM_ALIGN_SIZE
(
SIZEOF_STRUCT_PBUF
 + 
offset
) + LWIP_MEM_ALIGN_SIZE(
length
));

211 if (
p
 == 
NULL
) {

212 return 
NULL
;

215 
p
->
payload
 = 
	`LWIP_MEM_ALIGN
((void *)((
u8_t
 *)p + 
SIZEOF_STRUCT_PBUF
 + 
offset
));

216 
p
->
len
 = p->
tot_len
 = 
length
;

217 
p
->
next
 = 
NULL
;

218 
p
->
type
 = type;

220 
	`LWIP_ASSERT
("pbuf_alloc: pbuf->payload properly aligned",

221 ((
mem_ptr_t
)
p
->
payload
 % 
MEM_ALIGNMENT
) == 0);

224 case 
PBUF_ROM
:

226 case 
PBUF_REF
:

228 
p
 = 
	`memp_malloc
(
MEMP_PBUF
);

229 if (
p
 == 
NULL
) {

230 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",

231 (
type
 == 
PBUF_ROM
) ? "ROM" : "REF"));

232 return 
NULL
;

235 
p
->
payload
 = 
NULL
;

236 
p
->
len
 = p->
tot_len
 = 
length
;

237 
p
->
next
 = 
NULL
;

238 
p
->
type
 = type;

241 
	`LWIP_ASSERT
("pbuf_alloc: erroneous type", 0);

242 return 
NULL
;

245 
p
->
ref
 = 1;

247 
p
->
flags
 = 0;

248 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("pbuf_alloc(length=%"
U16_F
") == %p\n", 
length
, (void *)
p
));

249 return 
p
;

250 
	}
}

269 
	$pbuf_realloc
(struct 
pbuf
 *
p
, 
u16_t
 
new_len
)

271 struct 
pbuf
 *
q
;

272 
u16_t
 
rem_len
;

273 
s32_t
 
grow
;

275 
	`LWIP_ASSERT
("pbuf_realloc: p != NULL", 
p
 != 
NULL
);

276 
	`LWIP_ASSERT
("pbuf_realloc: sane p->type", 
p
->
type
 == 
PBUF_POOL
 ||

277 
p
->
type
 == 
PBUF_ROM
 ||

278 
p
->
type
 == 
PBUF_RAM
 ||

279 
p
->
type
 == 
PBUF_REF
);

282 if (
new_len
 >= 
p
->
tot_len
) {

289 
grow
 = 
new_len
 - 
p
->
tot_len
;

292 
rem_len
 = 
new_len
;

293 
q
 = 
p
;

295 while (
rem_len
 > 
q
->
len
) {

297 
rem_len
 -= 
q
->
len
;

299 
	`LWIP_ASSERT
("grow < max_u16_t", 
grow
 < 0xffff);

300 
q
->
tot_len
 += (
u16_t
)
grow
;

302 
q
 = q->
next
;

303 
	`LWIP_ASSERT
("pbuf_realloc: q != NULL", 
q
 != 
NULL
);

310 if ((
q
->
type
 == 
PBUF_RAM
) && (
rem_len
 != q->
len
)) {

312 
q
 = 
	`mem_realloc
(q, (
u8_t
 *)q->
payload
 - (u8_t *)q + 
rem_len
);

313 
	`LWIP_ASSERT
("mem_realloc give q == NULL", 
q
 != 
NULL
);

316 
q
->
len
 = 
rem_len
;

317 
q
->
tot_len
 = q->
len
;

320 if (
q
->
next
 != 
NULL
) {

322 
	`pbuf_free
(
q
->
next
);

325 
q
->
next
 = 
NULL
;

327 
	}
}

349 
u8_t


350 
	$pbuf_header
(struct 
pbuf
 *
p
, 
s16_t
 
header_size_increment
)

352 
u16_t
 
type
;

353 void *
payload
;

354 
u16_t
 
increment_magnitude
;

356 
	`LWIP_ASSERT
("p != NULL", 
p
 != 
NULL
);

357 if ((
header_size_increment
 == 0) || (
p
 == 
NULL
))

360 if (
header_size_increment
 < 0){

361 
increment_magnitude
 = -
header_size_increment
;

363 
	`LWIP_ERROR
("increment_magnitude <= p->len", (
increment_magnitude
 <= 
p
->
len
), return 1;);

365 
increment_magnitude
 = 
header_size_increment
;

370 
	`LWIP_ASSERT
("p->type == PBUF_RAM || p->type == PBUF_POOL",

371 
p
->
type
 == 
PBUF_RAM
 || p->type == 
PBUF_POOL
);

373 
	`LWIP_ASSERT
("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",

374 (
u8_t
 *)
p
->
payload
 - 
increment_magnitude
 >= (u8_t *)p + 
SIZEOF_STRUCT_PBUF
);

378 
type
 = 
p
->type;

380 
payload
 = 
p
->payload;

383 if (
type
 == 
PBUF_RAM
 || type == 
PBUF_POOL
) {

385 
p
->
payload
 = (
u8_t
 *)p->payload - 
header_size_increment
;

387 if ((
u8_t
 *)
p
->
payload
 < (u8_t *)p + 
SIZEOF_STRUCT_PBUF
) {

388 
	`LWIP_DEBUGF
( 
PBUF_DEBUG
 | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",

389 (void *)
p
->
payload
,

390 (void *)(
p
 + 1)));\

392 
p
->
payload
 = payload;

397 } else if (
type
 == 
PBUF_REF
 || type == 
PBUF_ROM
) {

399 if ((
header_size_increment
 < 0) && (
increment_magnitude
 <= 
p
->
len
)) {

401 
p
->
payload
 = (
u8_t
 *)p->payload - 
header_size_increment
;

410 
	`LWIP_ASSERT
("bad pbuf type", 0);

414 
p
->
len
 += 
header_size_increment
;

415 
p
->
tot_len
 += 
header_size_increment
;

417 
	`LWIP_DEBUGF
(
PBUF_DEBUG
, ("pbuf_header: old %p new %p (%"
S16_F
")\n",

418 (void *)
payload
, (void *)
p
->payload, 
header_size_increment
));

421 
	}
}

456 
u8_t


457 
	$pbuf_free
(struct 
pbuf
 *
p
)

459 
u16_t
 
type
;

460 struct 
pbuf
 *
q
;

461 
u8_t
 
count
;

463 if (
p
 == 
NULL
) {

464 
	`LWIP_ASSERT
("p != NULL", 
p
 != 
NULL
);

466 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("pbuf_free(p == NULL) was called.\n"));

469 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("pbuf_free(%p)\n", (void *)
p
));

471 
PERF_START
;

473 
	`LWIP_ASSERT
("pbuf_free: sane type",

474 
p
->
type
 == 
PBUF_RAM
 || p->type == 
PBUF_ROM
 ||

475 
p
->
type
 == 
PBUF_REF
 || p->type == 
PBUF_POOL
);

477 
count
 = 0;

480 while (
p
 != 
NULL
) {

481 
u16_t
 
ref
;

482 
	`SYS_ARCH_DECL_PROTECT
(
old_level
);

486 
	`SYS_ARCH_PROTECT
(
old_level
);

488 
	`LWIP_ASSERT
("pbuf_free: p->ref > 0", 
p
->
ref
 > 0);

490 
ref
 = --(
p
->ref);

491 
	`SYS_ARCH_UNPROTECT
(
old_level
);

493 if (
ref
 == 0) {

495 
q
 = 
p
->
next
;

496 
	`LWIP_DEBUGF
( 
PBUF_DEBUG
 | 2, ("pbuf_free: deallocating %p\n", (void *)
p
));

497 
type
 = 
p
->type;

499 if (
type
 == 
PBUF_POOL
) {

500 
	`memp_free
(
MEMP_PBUF_POOL
, 
p
);

502 } else if (
type
 == 
PBUF_ROM
 || type == 
PBUF_REF
) {

503 
	`memp_free
(
MEMP_PBUF
, 
p
);

506 
	`mem_free
(
p
);

508 
count
++;

510 
p
 = 
q
;

514 
	`LWIP_DEBUGF
( 
PBUF_DEBUG
 | 2, ("pbuf_free: %p has ref %"
U16_F
", ending here.\n", (void *)
p
, 
ref
));

516 
p
 = 
NULL
;

519 
	`PERF_STOP
("pbuf_free");

521 return 
count
;

522 
	}
}

531 
u8_t


532 
	$pbuf_clen
(struct 
pbuf
 *
p
)

534 
u8_t
 
len
;

536 
len
 = 0;

537 while (
p
 != 
NULL
) {

538 ++
len
;

539 
p
 = p->
next
;

541 return 
len
;

542 
	}
}

551 
	$pbuf_ref
(struct 
pbuf
 *
p
)

553 
	`SYS_ARCH_DECL_PROTECT
(
old_level
);

555 if (
p
 != 
NULL
) {

556 
	`SYS_ARCH_PROTECT
(
old_level
);

557 ++(
p
->
ref
);

558 
	`SYS_ARCH_UNPROTECT
(
old_level
);

560 
	}
}

573 
	$pbuf_cat
(struct 
pbuf
 *
h
, struct pbuf *
t
)

575 struct 
pbuf
 *
p
;

577 
	`LWIP_ERROR
("(h != NULL) && (t != NULL) (programmer violates API)",

578 ((
h
 != 
NULL
) && (
t
 != NULL)), return;);

581 for (
p
 = 
h
; p->
next
 != 
NULL
; p = p->next) {

583 
p
->
tot_len
 += 
t
->tot_len;

586 
	`LWIP_ASSERT
("p->tot_len == p->len (of last pbuf in chain)", 
p
->
tot_len
 == p->
len
);

587 
	`LWIP_ASSERT
("p->next == NULL", 
p
->
next
 == 
NULL
);

589 
p
->
tot_len
 += 
t
->tot_len;

591 
p
->
next
 = 
t
;

595 
	}
}

614 
	$pbuf_chain
(struct 
pbuf
 *
h
, struct pbuf *
t
)

616 
	`pbuf_cat
(
h
, 
t
);

618 
	`pbuf_ref
(
t
);

619 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_FRESH
 | 2, ("pbuf_chain: %p references %p\n", (void *)
h
, (void *)
t
));

620 
	}
}

630 struct 
pbuf
 *

631 
	$pbuf_dechain
(struct 
pbuf
 *
p
)

633 struct 
pbuf
 *
q
;

634 
u8_t
 
tail_gone
 = 1;

636 
q
 = 
p
->
next
;

638 if (
q
 != 
NULL
) {

640 
	`LWIP_ASSERT
("p->tot_len == p->len + q->tot_len", 
q
->
tot_len
 == 
p
->tot_len - p->
len
);

642 
q
->
tot_len
 = 
p
->tot_len - p->
len
;

644 
p
->
next
 = 
NULL
;

646 
p
->
tot_len
 = p->
len
;

648 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_STATE
, ("pbuf_dechain: unreferencing %p\n", (void *)
q
));

649 
tail_gone
 = 
	`pbuf_free
(
q
);

650 if (
tail_gone
 > 0) {

651 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_STATE
,

652 ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)
q
));

657 
	`LWIP_ASSERT
("p->tot_len == p->len", 
p
->
tot_len
 == p->
len
);

658 return ((
tail_gone
 > 0) ? 
NULL
 : 
q
);

659 
	}
}

679 
err_t


680 
	$pbuf_copy
(struct 
pbuf
 *
p_to
, struct pbuf *
p_from
)

682 
u16_t
 
offset_to
=0, 
offset_from
=0, 
len
;

684 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("pbuf_copy(%p, %p)\n",

685 (void*)
p_to
, (void*)
p_from
));

688 
	`LWIP_ERROR
("pbuf_copy: target not big enough to hold source", ((
p_to
 != 
NULL
) &&

689 (
p_from
 != 
NULL
) && (
p_to
->
tot_len
 >= p_from->tot_len)), return 
ERR_ARG
;);

694 
	`LWIP_ASSERT
("p_to != NULL", 
p_to
 != 
NULL
);

696 if ((
p_to
->
len
 - 
offset_to
) >= (
p_from
->len - 
offset_from
)) {

698 
len
 = 
p_from
->len - 
offset_from
;

701 
len
 = 
p_to
->len - 
offset_to
;

703 
	`MEMCPY
((
u8_t
*)
p_to
->
payload
 + 
offset_to
, (u8_t*)
p_from
->payload + 
offset_from
, 
len
);

704 
offset_to
 += 
len
;

705 
offset_from
 += 
len
;

706 
	`LWIP_ASSERT
("offset_to <= p_to->len", 
offset_to
 <= 
p_to
->
len
);

707 if (
offset_to
 == 
p_to
->
len
) {

709 
offset_to
 = 0;

710 
p_to
 = p_to->
next
;

712 
	`LWIP_ASSERT
("offset_from <= p_from->len", 
offset_from
 <= 
p_from
->
len
);

713 if (
offset_from
 >= 
p_from
->
len
) {

715 
offset_from
 = 0;

716 
p_from
 = p_from->
next
;

719 if((
p_from
 != 
NULL
) && (p_from->
len
 == p_from->
tot_len
)) {

721 
	`LWIP_ERROR
("pbuf_copy() does not allow packet queues!\n",

722 (
p_from
->
next
 == 
NULL
), return 
ERR_VAL
;);

724 if((
p_to
 != 
NULL
) && (p_to->
len
 == p_to->
tot_len
)) {

726 
	`LWIP_ERROR
("pbuf_copy() does not allow packet queues!\n",

727 (
p_to
->
next
 == 
NULL
), return 
ERR_VAL
;);

729 } while (
p_from
);

730 
	`LWIP_DEBUGF
(
PBUF_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("pbuf_copy: end of chain reached.\n"));

731 return 
ERR_OK
;

732 
	}
}

743 
u16_t


744 
	$pbuf_copy_partial
(struct 
pbuf
 *
buf
, void *
dataptr
, 
u16_t
 
len
, u16_t 
offset
)

746 struct 
pbuf
 *
p
;

747 
u16_t
 
left
;

748 
u16_t
 
buf_copy_len
;

749 
u16_t
 
copied_total
 = 0;

751 
	`LWIP_ERROR
("netbuf_copy_partial: invalid buf", (
buf
 != 
NULL
), return 0;);

752 
	`LWIP_ERROR
("netbuf_copy_partial: invalid dataptr", (
dataptr
 != 
NULL
), return 0;);

754 
left
 = 0;

756 if((
buf
 == 
NULL
) || (
dataptr
 == NULL)) {

761 for(
p
 = 
buf
; 
len
 != 0 && p != 
NULL
; p = p->
next
) {

762 if ((
offset
 != 0) && (offset >= 
p
->
len
)) {

764 
offset
 -= 
p
->
len
;

767 
buf_copy_len
 = 
p
->
len
 - 
offset
;

768 if (
buf_copy_len
 > 
len
)

769 
buf_copy_len
 = 
len
;

771 
	`MEMCPY
(&((char*)
dataptr
)[
left
], &((char*)
p
->
payload
)[
offset
], 
buf_copy_len
);

772 
copied_total
 += 
buf_copy_len
;

773 
left
 += 
buf_copy_len
;

774 
len
 -= 
buf_copy_len
;

775 
offset
 = 0;

778 return 
copied_total
;

779 
	}
}

	@/root/Robux/net/lwip/core/raw.c

41 #include 
	~"lwip/opt.h
"

43 #if 
LWIP_RAW


45 #include 
	~"lwip/def.h
"

46 #include 
	~"lwip/memp.h
"

47 #include 
	~"lwip/inet.h
"

48 #include 
	~"lwip/ip_addr.h
"

49 #include 
	~"lwip/netif.h
"

50 #include 
	~"lwip/raw.h
"

51 #include 
	~"lwip/stats.h
"

52 #include 
	~"lwip/snmp.h
"

53 #include 
	~"arch/perf.h
"

55 #include 
	~<string.h
>

58 static struct 
raw_pcb
 *
	graw_pcbs
;

77 
u8_t


78 
	$raw_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
)

80 struct 
raw_pcb
 *
pcb
, *
prev
;

81 struct 
ip_hdr
 *
iphdr
;

82 
s16_t
 
proto
;

83 
u8_t
 
eaten
 = 0;

85 
	`LWIP_UNUSED_ARG
(
inp
);

87 
iphdr
 = 
p
->
payload
;

88 
proto
 = 
	`IPH_PROTO
(
iphdr
);

90 
prev
 = 
NULL
;

91 
pcb
 = 
raw_pcbs
;

94 while ((
eaten
 == 0) && (
pcb
 != 
NULL
)) {

95 if (
pcb
->
protocol
 == 
proto
) {

97 if (
pcb
->
recv
 != 
NULL
) {

99 if (
pcb
->
	`recv
(pcb->
recv_arg
, pcb, 
p
, &(
iphdr
->
src
)) != 0)

102 
p
 = 
NULL
;

103 
eaten
 = 1;

104 if (
prev
 != 
NULL
) {

107 
prev
->
next
 = 
pcb
->next;

108 
pcb
->
next
 = 
raw_pcbs
;

109 
raw_pcbs
 = 
pcb
;

116 
prev
 = 
pcb
;

117 
pcb
 = pcb->
next
;

119 return 
eaten
;

120 
	}
}

136 
err_t


137 
	$raw_bind
(struct 
raw_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
)

139 
	`ip_addr_set
(&
pcb
->
local_ip
, 
ipaddr
);

140 return 
ERR_OK
;

141 
	}
}

156 
err_t


157 
	$raw_connect
(struct 
raw_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
)

159 
	`ip_addr_set
(&
pcb
->
remote_ip
, 
ipaddr
);

160 return 
ERR_OK
;

161 
	}
}

178 
raw_recv
(struct 
raw_pcb
 *
pcb
,

179 
	$u8_t
 (* 
recv
)(void *
arg
, struct 
raw_pcb
 *
upcb
, struct 
pbuf
 *
p
,

180 struct 
ip_addr
 *
addr
),

181 void *
recv_arg
)

184 
pcb
->
recv
 = recv;

185 
pcb
->
recv_arg
 = recv_arg;

186 
	}
}

200 
err_t


201 
	$raw_sendto
(struct 
raw_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
ipaddr
)

203 
err_t
 
err
;

204 struct 
netif
 *netif;

205 struct 
ip_addr
 *
src_ip
;

206 struct 
pbuf
 *
q
;

208 
	`LWIP_DEBUGF
(
RAW_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("raw_sendto\n"));

211 if (
	`pbuf_header
(
p
, 
IP_HLEN
)) {

213 
q
 = 
	`pbuf_alloc
(
PBUF_IP
, 0, 
PBUF_RAM
);

215 if (
q
 == 
NULL
) {

216 
	`LWIP_DEBUGF
(
RAW_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("raw_sendto: could not allocate header\n"));

217 return 
ERR_MEM
;

220 
	`pbuf_chain
(
q
, 
p
);

222 
	`LWIP_DEBUGF
(
RAW_DEBUG
, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)
q
, (void *)
p
));

225 
q
 = 
p
;

226 if(
	`pbuf_header
(
q
, -
IP_HLEN
)) {

227 
	`LWIP_ASSERT
("Can't restore header we just removed!", 0);

228 return 
ERR_MEM
;

232 if ((
netif
 = 
	`ip_route
(
ipaddr
)) == 
NULL
) {

233 
	`LWIP_DEBUGF
(
RAW_DEBUG
 | 1, ("raw_sendto: No route to 0x%"
X32_F
"\n", 
ipaddr
->
addr
));

235 if (
q
 != 
p
) {

236 
	`pbuf_free
(
q
);

238 return 
ERR_RTE
;

241 if (
	`ip_addr_isany
(&
pcb
->
local_ip
)) {

243 
src_ip
 = &(
netif
->
ip_addr
);

246 
src_ip
 = &(
pcb
->
local_ip
);

249 #if 
LWIP_NETIF_HWADDRHINT


250 
netif
->
addr_hint
 = &(
pcb
->addr_hint);

252 
err
 = 
	`ip_output_if
 (
q
, 
src_ip
, 
ipaddr
, 
pcb
->
ttl
, pcb->
tos
, pcb->
protocol
, 
netif
);

253 #if 
LWIP_NETIF_HWADDRHINT


254 
netif
->
addr_hint
 = 
NULL
;

258 if (
q
 != 
p
) {

260 
	`pbuf_free
(
q
);

262 return 
err
;

263 
	}
}

272 
err_t


273 
	$raw_send
(struct 
raw_pcb
 *
pcb
, struct 
pbuf
 *
p
)

275 return 
	`raw_sendto
(
pcb
, 
p
, &pcb->
remote_ip
);

276 
	}
}

287 
	$raw_remove
(struct 
raw_pcb
 *
pcb
)

289 struct 
raw_pcb
 *
pcb2
;

291 if (
raw_pcbs
 == 
pcb
) {

293 
raw_pcbs
 = raw_pcbs->
next
;

296 for(
pcb2
 = 
raw_pcbs
; pcb2 != 
NULL
; pcb2 = pcb2->
next
) {

298 if (
pcb2
->
next
 != 
NULL
 && pcb2->next == 
pcb
) {

300 
pcb2
->
next
 = 
pcb
->next;

304 
	`memp_free
(
MEMP_RAW_PCB
, 
pcb
);

305 
	}
}

317 struct 
raw_pcb
 *

318 
	$raw_new
(
u8_t
 
proto
) {

319 struct 
raw_pcb
 *
pcb
;

321 
	`LWIP_DEBUGF
(
RAW_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("raw_new\n"));

323 
pcb
 = 
	`memp_malloc
(
MEMP_RAW_PCB
);

325 if (
pcb
 != 
NULL
) {

327 
	`memset
(
pcb
, 0, sizeof(struct 
raw_pcb
));

328 
pcb
->
protocol
 = 
proto
;

329 
pcb
->
ttl
 = 
RAW_TTL
;

330 
pcb
->
next
 = 
raw_pcbs
;

331 
raw_pcbs
 = 
pcb
;

333 return 
pcb
;

334 
	}
}

	@/root/Robux/net/lwip/core/snmp/asn1_dec.c

37 #include 
	~"lwip/opt.h
"

39 #if 
LWIP_SNMP


41 #include 
	~"lwip/snmp_asn1.h
"

51 
err_t


52 
	$snmp_asn1_dec_type
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 *
type
)

54 
u16_t
 
plen
, 
base
;

55 
u8_t
 *
msg_ptr
;

57 
plen
 = 0;

58 while (
p
 != 
NULL
)

60 
base
 = 
plen
;

61 
plen
 += 
p
->
len
;

62 if (
ofs
 < 
plen
)

64 
msg_ptr
 = 
p
->
payload
;

65 
msg_ptr
 += 
ofs
 - 
base
;

66 *
type
 = *
msg_ptr
;

67 return 
ERR_OK
;

69 
p
 = p->
next
;

72 return 
ERR_ARG
;

73 
	}
}

84 
err_t


85 
	$snmp_asn1_dec_length
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 *
octets_used
, u16_t *
length
)

87 
u16_t
 
plen
, 
base
;

88 
u8_t
 *
msg_ptr
;

90 
plen
 = 0;

91 while (
p
 != 
NULL
)

93 
base
 = 
plen
;

94 
plen
 += 
p
->
len
;

95 if (
ofs
 < 
plen
)

97 
msg_ptr
 = 
p
->
payload
;

98 
msg_ptr
 += 
ofs
 - 
base
;

100 if (*
msg_ptr
 < 0x80)

103 *
octets_used
 = 1;

104 *
length
 = *
msg_ptr
;

105 return 
ERR_OK
;

107 else if (*
msg_ptr
 == 0x80)

110 
u8_t
 
zeros
;

111 
u8_t
 
i
;

113 *
length
 = 0;

114 
zeros
 = 0;

115 while (
zeros
 != 2)

117 
i
 = 2;

118 while (
i
 > 0)

120 
i
--;

121 (*
length
) += 1;

122 
ofs
 += 1;

123 if (
ofs
 >= 
plen
)

126 
p
 = p->
next
;

127 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

128 
msg_ptr
 = 
p
->
payload
;

129 
plen
 += 
p
->
len
;

134 
msg_ptr
++;

136 if (*
msg_ptr
 == 0)

138 
zeros
++;

139 if (
zeros
 == 2)

142 
i
 = 0;

147 
zeros
 = 0;

151 *
octets_used
 = 1;

152 return 
ERR_OK
;

154 else if (*
msg_ptr
 == 0x81)

157 
ofs
 += 1;

158 if (
ofs
 >= 
plen
)

161 
p
 = p->
next
;

162 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

163 
msg_ptr
 = 
p
->
payload
;

168 
msg_ptr
++;

170 *
length
 = *
msg_ptr
;

171 *
octets_used
 = 2;

172 return 
ERR_OK
;

174 else if (*
msg_ptr
 == 0x82)

176 
u8_t
 
i
;

179 
i
 = 2;

180 while (
i
 > 0)

182 
i
--;

183 
ofs
 += 1;

184 if (
ofs
 >= 
plen
)

187 
p
 = p->
next
;

188 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

189 
msg_ptr
 = 
p
->
payload
;

190 
plen
 += 
p
->
len
;

195 
msg_ptr
++;

197 if (
i
 == 0)

200 *
length
 |= *
msg_ptr
;

205 *
length
 = (*
msg_ptr
) << 8;

208 *
octets_used
 = 3;

209 return 
ERR_OK
;

215 *
octets_used
 = 1 + ((*
msg_ptr
) & 0x7f);

216 return 
ERR_ARG
;

219 
p
 = p->
next
;

223 return 
ERR_ARG
;

224 
	}
}

239 
err_t


240 
	$snmp_asn1_dec_u32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, 
u32_t
 *
value
)

242 
u16_t
 
plen
, 
base
;

243 
u8_t
 *
msg_ptr
;

245 
plen
 = 0;

246 while (
p
 != 
NULL
)

248 
base
 = 
plen
;

249 
plen
 += 
p
->
len
;

250 if (
ofs
 < 
plen
)

252 
msg_ptr
 = 
p
->
payload
;

253 
msg_ptr
 += 
ofs
 - 
base
;

254 if ((
len
 > 0) && (len < 6))

257 *
value
 = 0;

258 if (*
msg_ptr
 & 0x80)

261 return 
ERR_ARG
;

266 if ((
len
 > 1) && (*
msg_ptr
 == 0))

269 
len
--;

270 
ofs
 += 1;

271 if (
ofs
 >= 
plen
)

274 
p
 = p->
next
;

275 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

276 
msg_ptr
 = 
p
->
payload
;

277 
plen
 += 
p
->
len
;

282 
msg_ptr
++;

287 while (
len
 > 1)

289 
len
--;

290 *
value
 |= *
msg_ptr
;

291 *
value
 <<= 8;

292 
ofs
 += 1;

293 if (
ofs
 >= 
plen
)

296 
p
 = p->
next
;

297 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

298 
msg_ptr
 = 
p
->
payload
;

299 
plen
 += 
p
->
len
;

304 
msg_ptr
++;

307 *
value
 |= *
msg_ptr
;

308 return 
ERR_OK
;

312 return 
ERR_ARG
;

315 
p
 = p->
next
;

318 return 
ERR_ARG
;

319 
	}
}

332 
err_t


333 
	$snmp_asn1_dec_s32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, 
s32_t
 *
value
)

335 
u16_t
 
plen
, 
base
;

336 
u8_t
 *
msg_ptr
;

337 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


338 
u8_t
 *
lsb_ptr
 = (u8_t*)
value
;

340 #if 
BYTE_ORDER
 == 
BIG_ENDIAN


341 
u8_t
 *
lsb_ptr
 = (u8_t*)
value
 + sizeof(
s32_t
) - 1;

343 
u8_t
 
sign
;

345 
plen
 = 0;

346 while (
p
 != 
NULL
)

348 
base
 = 
plen
;

349 
plen
 += 
p
->
len
;

350 if (
ofs
 < 
plen
)

352 
msg_ptr
 = 
p
->
payload
;

353 
msg_ptr
 += 
ofs
 - 
base
;

354 if ((
len
 > 0) && (len < 5))

356 if (*
msg_ptr
 & 0x80)

359 *
value
 = -1;

360 
sign
 = 1;

365 *
value
 = 0;

366 
sign
 = 0;

369 while (
len
 > 1)

371 
len
--;

372 if (
sign
)

374 *
lsb_ptr
 &= *
msg_ptr
;

375 *
value
 <<= 8;

376 *
lsb_ptr
 |= 255;

380 *
lsb_ptr
 |= *
msg_ptr
;

381 *
value
 <<= 8;

383 
ofs
 += 1;

384 if (
ofs
 >= 
plen
)

387 
p
 = p->
next
;

388 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

389 
msg_ptr
 = 
p
->
payload
;

390 
plen
 += 
p
->
len
;

395 
msg_ptr
++;

398 if (
sign
)

400 *
lsb_ptr
 &= *
msg_ptr
;

404 *
lsb_ptr
 |= *
msg_ptr
;

406 return 
ERR_OK
;

410 return 
ERR_ARG
;

413 
p
 = p->
next
;

416 return 
ERR_ARG
;

417 
	}
}

428 
err_t


429 
	$snmp_asn1_dec_oid
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, struct 
snmp_obj_id
 *
oid
)

431 
u16_t
 
plen
, 
base
;

432 
u8_t
 *
msg_ptr
;

433 
s32_t
 *
oid_ptr
;

435 
plen
 = 0;

436 while (
p
 != 
NULL
)

438 
base
 = 
plen
;

439 
plen
 += 
p
->
len
;

440 if (
ofs
 < 
plen
)

442 
msg_ptr
 = 
p
->
payload
;

443 
msg_ptr
 += 
ofs
 - 
base
;

445 
oid
->
len
 = 0;

446 
oid_ptr
 = &
oid
->
id
[0];

447 if (
len
 > 0)

450 if (*
msg_ptr
 == 0x2B)

453 *
oid_ptr
 = 1;

454 
oid_ptr
++;

455 *
oid_ptr
 = 3;

456 
oid_ptr
++;

458 else if (*
msg_ptr
 < 40)

460 *
oid_ptr
 = 0;

461 
oid_ptr
++;

462 *
oid_ptr
 = *
msg_ptr
;

463 
oid_ptr
++;

465 else if (*
msg_ptr
 < 80)

467 *
oid_ptr
 = 1;

468 
oid_ptr
++;

469 *
oid_ptr
 = (*
msg_ptr
) - 40;

470 
oid_ptr
++;

474 *
oid_ptr
 = 2;

475 
oid_ptr
++;

476 *
oid_ptr
 = (*
msg_ptr
) - 80;

477 
oid_ptr
++;

479 
oid
->
len
 = 2;

485 return 
ERR_OK
;

487 
len
--;

488 if (
len
 > 0)

490 
ofs
 += 1;

491 if (
ofs
 >= 
plen
)

494 
p
 = p->
next
;

495 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

496 
msg_ptr
 = 
p
->
payload
;

497 
plen
 += 
p
->
len
;

502 
msg_ptr
++;

505 while ((
len
 > 0) && (
oid
->len < 
LWIP_SNMP_OBJ_ID_LEN
))

508 if (*
msg_ptr
 & 0x80)

510 
s32_t
 
sub_id
 = 0;

512 while ((*
msg_ptr
 & 0x80) && (
len
 > 1))

514 
len
--;

515 
sub_id
 = (sub_id << 7) + (*
msg_ptr
 & ~0x80);

516 
ofs
 += 1;

517 if (
ofs
 >= 
plen
)

520 
p
 = p->
next
;

521 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

522 
msg_ptr
 = 
p
->
payload
;

523 
plen
 += 
p
->
len
;

528 
msg_ptr
++;

531 if (!(*
msg_ptr
 & 0x80) && (
len
 > 0))

534 
len
--;

535 
sub_id
 = (sub_id << 7) + *
msg_ptr
;

536 *
oid_ptr
 = 
sub_id
;

542 
len
--;

543 *
oid_ptr
 = *
msg_ptr
;

545 if (
len
 > 0)

548 
ofs
 += 1;

549 if (
ofs
 >= 
plen
)

552 
p
 = p->
next
;

553 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

554 
msg_ptr
 = 
p
->
payload
;

555 
plen
 += 
p
->
len
;

560 
msg_ptr
++;

563 
oid_ptr
++;

564 
oid
->
len
++;

566 if (
len
 == 0)

569 return 
ERR_OK
;

574 return 
ERR_ARG
;

578 
p
 = p->
next
;

581 return 
ERR_ARG
;

582 
	}
}

595 
err_t


596 
	$snmp_asn1_dec_raw
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, u16_t 
raw_len
, 
u8_t
 *
raw
)

598 
u16_t
 
plen
, 
base
;

599 
u8_t
 *
msg_ptr
;

601 if (
len
 > 0)

603 
plen
 = 0;

604 while (
p
 != 
NULL
)

606 
base
 = 
plen
;

607 
plen
 += 
p
->
len
;

608 if (
ofs
 < 
plen
)

610 
msg_ptr
 = 
p
->
payload
;

611 
msg_ptr
 += 
ofs
 - 
base
;

612 if (
raw_len
 >= 
len
)

614 while (
len
 > 1)

617 
len
--;

618 *
raw
 = *
msg_ptr
;

619 
raw
++;

620 
ofs
 += 1;

621 if (
ofs
 >= 
plen
)

624 
p
 = p->
next
;

625 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

626 
msg_ptr
 = 
p
->
payload
;

627 
plen
 += 
p
->
len
;

632 
msg_ptr
++;

636 *
raw
 = *
msg_ptr
;

637 return 
ERR_OK
;

642 return 
ERR_ARG
;

645 
p
 = p->
next
;

648 return 
ERR_ARG
;

653 return 
ERR_OK
;

655 
	}
}

	@/root/Robux/net/lwip/core/snmp/asn1_enc.c

37 #include 
	~"lwip/opt.h
"

39 #if 
LWIP_SNMP


41 #include 
	~"lwip/snmp_asn1.h
"

50 
	$snmp_asn1_enc_length_cnt
(
u16_t
 
length
, 
u8_t
 *
octets_needed
)

52 if (
length
 < 0x80U)

54 *
octets_needed
 = 1;

56 else if (
length
 < 0x100U)

58 *
octets_needed
 = 2;

62 *
octets_needed
 = 3;

64 
	}
}

77 
	$snmp_asn1_enc_u32t_cnt
(
u32_t
 
value
, 
u16_t
 *
octets_needed
)

79 if (
value
 < 0x80UL)

81 *
octets_needed
 = 1;

83 else if (
value
 < 0x8000UL)

85 *
octets_needed
 = 2;

87 else if (
value
 < 0x800000UL)

89 *
octets_needed
 = 3;

91 else if (
value
 < 0x80000000UL)

93 *
octets_needed
 = 4;

97 *
octets_needed
 = 5;

99 
	}
}

110 
	$snmp_asn1_enc_s32t_cnt
(
s32_t
 
value
, 
u16_t
 *
octets_needed
)

112 if (
value
 < 0)

114 
value
 = ~value;

116 if (
value
 < 0x80L)

118 *
octets_needed
 = 1;

120 else if (
value
 < 0x8000L)

122 *
octets_needed
 = 2;

124 else if (
value
 < 0x800000L)

126 *
octets_needed
 = 3;

130 *
octets_needed
 = 4;

132 
	}
}

142 
	$snmp_asn1_enc_oid_cnt
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, 
u16_t
 *
octets_needed
)

144 
s32_t
 
sub_id
;

145 
u8_t
 
cnt
;

147 
cnt
 = 0;

148 if (
ident_len
 > 1)

151 
cnt
++;

152 
ident_len
 -= 2;

153 
ident
 += 2;

155 while(
ident_len
 > 0)

157 
ident_len
--;

158 
sub_id
 = *
ident
;

160 
sub_id
 >>= 7;

161 
cnt
++;

162 while(
sub_id
 > 0)

164 
sub_id
 >>= 7;

165 
cnt
++;

167 
ident
++;

169 *
octets_needed
 = 
cnt
;

170 
	}
}

180 
err_t


181 
	$snmp_asn1_enc_type
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
type
)

183 
u16_t
 
plen
, 
base
;

184 
u8_t
 *
msg_ptr
;

186 
plen
 = 0;

187 while (
p
 != 
NULL
)

189 
base
 = 
plen
;

190 
plen
 += 
p
->
len
;

191 if (
ofs
 < 
plen
)

193 
msg_ptr
 = 
p
->
payload
;

194 
msg_ptr
 += 
ofs
 - 
base
;

195 *
msg_ptr
 = 
type
;

196 return 
ERR_OK
;

198 
p
 = p->
next
;

201 return 
ERR_ARG
;

202 
	}
}

212 
err_t


213 
	$snmp_asn1_enc_length
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
length
)

215 
u16_t
 
plen
, 
base
;

216 
u8_t
 *
msg_ptr
;

218 
plen
 = 0;

219 while (
p
 != 
NULL
)

221 
base
 = 
plen
;

222 
plen
 += 
p
->
len
;

223 if (
ofs
 < 
plen
)

225 
msg_ptr
 = 
p
->
payload
;

226 
msg_ptr
 += 
ofs
 - 
base
;

228 if (
length
 < 0x80)

230 *
msg_ptr
 = 
length
;

231 return 
ERR_OK
;

233 else if (
length
 < 0x100)

235 *
msg_ptr
 = 0x81;

236 
ofs
 += 1;

237 if (
ofs
 >= 
plen
)

240 
p
 = p->
next
;

241 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

242 
msg_ptr
 = 
p
->
payload
;

247 
msg_ptr
++;

249 *
msg_ptr
 = 
length
;

250 return 
ERR_OK
;

254 
u8_t
 
i
;

257 *
msg_ptr
 = 0x82;

258 
i
 = 2;

259 while (
i
 > 0)

261 
i
--;

262 
ofs
 += 1;

263 if (
ofs
 >= 
plen
)

266 
p
 = p->
next
;

267 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

268 
msg_ptr
 = 
p
->
payload
;

269 
plen
 += 
p
->
len
;

274 
msg_ptr
++;

276 if (
i
 == 0)

279 *
msg_ptr
 = 
length
;

284 *
msg_ptr
 = 
length
 >> 8;

287 return 
ERR_OK
;

290 
p
 = p->
next
;

293 return 
ERR_ARG
;

294 
	}
}

307 
err_t


308 
	$snmp_asn1_enc_u32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
octets_needed
, 
u32_t
 
value
)

310 
u16_t
 
plen
, 
base
;

311 
u8_t
 *
msg_ptr
;

313 
plen
 = 0;

314 while (
p
 != 
NULL
)

316 
base
 = 
plen
;

317 
plen
 += 
p
->
len
;

318 if (
ofs
 < 
plen
)

320 
msg_ptr
 = 
p
->
payload
;

321 
msg_ptr
 += 
ofs
 - 
base
;

323 if (
octets_needed
 == 5)

326 
octets_needed
--;

327 *
msg_ptr
 = 0x00;

328 
ofs
 += 1;

329 if (
ofs
 >= 
plen
)

332 
p
 = p->
next
;

333 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

334 
msg_ptr
 = 
p
->
payload
;

335 
plen
 += 
p
->
len
;

340 
msg_ptr
++;

343 while (
octets_needed
 > 1)

345 
octets_needed
--;

346 *
msg_ptr
 = 
value
 >> (
octets_needed
 << 3);

347 
ofs
 += 1;

348 if (
ofs
 >= 
plen
)

351 
p
 = p->
next
;

352 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

353 
msg_ptr
 = 
p
->
payload
;

354 
plen
 += 
p
->
len
;

359 
msg_ptr
++;

363 *
msg_ptr
 = 
value
;

364 return 
ERR_OK
;

366 
p
 = p->
next
;

369 return 
ERR_ARG
;

370 
	}
}

383 
err_t


384 
	$snmp_asn1_enc_s32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
octets_needed
, 
s32_t
 
value
)

386 
u16_t
 
plen
, 
base
;

387 
u8_t
 *
msg_ptr
;

389 
plen
 = 0;

390 while (
p
 != 
NULL
)

392 
base
 = 
plen
;

393 
plen
 += 
p
->
len
;

394 if (
ofs
 < 
plen
)

396 
msg_ptr
 = 
p
->
payload
;

397 
msg_ptr
 += 
ofs
 - 
base
;

399 while (
octets_needed
 > 1)

401 
octets_needed
--;

402 *
msg_ptr
 = 
value
 >> (
octets_needed
 << 3);

403 
ofs
 += 1;

404 if (
ofs
 >= 
plen
)

407 
p
 = p->
next
;

408 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

409 
msg_ptr
 = 
p
->
payload
;

410 
plen
 += 
p
->
len
;

415 
msg_ptr
++;

419 *
msg_ptr
 = 
value
;

420 return 
ERR_OK
;

422 
p
 = p->
next
;

425 return 
ERR_ARG
;

426 
	}
}

437 
err_t


438 
	$snmp_asn1_enc_oid
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
ident_len
, 
s32_t
 *
ident
)

440 
u16_t
 
plen
, 
base
;

441 
u8_t
 *
msg_ptr
;

443 
plen
 = 0;

444 while (
p
 != 
NULL
)

446 
base
 = 
plen
;

447 
plen
 += 
p
->
len
;

448 if (
ofs
 < 
plen
)

450 
msg_ptr
 = 
p
->
payload
;

451 
msg_ptr
 += 
ofs
 - 
base
;

453 if (
ident_len
 > 1)

455 if ((
ident
[0] == 1) && (ident[1] == 3))

458 *
msg_ptr
 = 0x2b;

463 *
msg_ptr
 = (
ident
[0] * 40) + ident[1];

465 
ofs
 += 1;

466 if (
ofs
 >= 
plen
)

469 
p
 = p->
next
;

470 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

471 
msg_ptr
 = 
p
->
payload
;

472 
plen
 += 
p
->
len
;

477 
msg_ptr
++;

479 
ident_len
 -= 2;

480 
ident
 += 2;

486 return 
ERR_ARG
;

488 while (
ident_len
 > 0)

490 
s32_t
 
sub_id
;

491 
u8_t
 
shift
, 
tail
;

493 
ident_len
--;

494 
sub_id
 = *
ident
;

495 
tail
 = 0;

496 
shift
 = 28;

497 while(
shift
 > 0)

499 
u8_t
 
code
;

501 
code
 = 
sub_id
 >> 
shift
;

502 if ((
code
 != 0) || (
tail
 != 0))

504 
tail
 = 1;

505 *
msg_ptr
 = 
code
 | 0x80;

506 
ofs
 += 1;

507 if (
ofs
 >= 
plen
)

510 
p
 = p->
next
;

511 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

512 
msg_ptr
 = 
p
->
payload
;

513 
plen
 += 
p
->
len
;

518 
msg_ptr
++;

521 
shift
 -= 7;

523 *
msg_ptr
 = (
u8_t
)
sub_id
 & 0x7F;

524 if (
ident_len
 > 0)

526 
ofs
 += 1;

527 if (
ofs
 >= 
plen
)

530 
p
 = p->
next
;

531 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

532 
msg_ptr
 = 
p
->
payload
;

533 
plen
 += 
p
->
len
;

538 
msg_ptr
++;

542 
ident
++;

544 return 
ERR_OK
;

546 
p
 = p->
next
;

549 return 
ERR_ARG
;

550 
	}
}

561 
err_t


562 
	$snmp_asn1_enc_raw
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
raw_len
, u8_t *
raw
)

564 
u16_t
 
plen
, 
base
;

565 
u8_t
 *
msg_ptr
;

567 
plen
 = 0;

568 while (
p
 != 
NULL
)

570 
base
 = 
plen
;

571 
plen
 += 
p
->
len
;

572 if (
ofs
 < 
plen
)

574 
msg_ptr
 = 
p
->
payload
;

575 
msg_ptr
 += 
ofs
 - 
base
;

577 while (
raw_len
 > 1)

580 
raw_len
--;

581 *
msg_ptr
 = *
raw
;

582 
raw
++;

583 
ofs
 += 1;

584 if (
ofs
 >= 
plen
)

587 
p
 = p->
next
;

588 if (
p
 == 
NULL
) { return 
ERR_ARG
; }

589 
msg_ptr
 = 
p
->
payload
;

590 
plen
 += 
p
->
len
;

595 
msg_ptr
++;

598 if (
raw_len
 > 0)

601 *
msg_ptr
 = *
raw
;

603 return 
ERR_OK
;

605 
p
 = p->
next
;

608 return 
ERR_ARG
;

609 
	}
}

	@/root/Robux/net/lwip/core/snmp/mib2.c

38 #include 
	~"lwip/opt.h
"

40 #if 
LWIP_SNMP


42 #include 
	~"lwip/snmp.h
"

43 #include 
	~"lwip/netif.h
"

44 #include 
	~"lwip/ip.h
"

45 #include 
	~"lwip/ip_frag.h
"

46 #include 
	~"lwip/tcp.h
"

47 #include 
	~"lwip/udp.h
"

48 #include 
	~"lwip/snmp_asn1.h
"

49 #include 
	~"lwip/snmp_structs.h
"

50 #include 
	~"netif/etharp.h
"

65 #define 
	#SNMP_ENTERPRISE_ID
 26381

	)

66 #define 
	#SNMP_SYSOBJID_LEN
 7

	)

67 #define 
	#SNMP_SYSOBJID
 {1, 3, 6, 1, 4, 1, 
SNMP_ENTERPRISE_ID
}

	)

69 #ifndef 
SNMP_SYSSERVICES


70 #define 
	#SNMP_SYSSERVICES
 ((1 << 6) | (1 << 3) | ((
IP_FORWARD
) << 2))

	)

73 #ifndef 
SNMP_GET_SYSUPTIME


74 #define 
	#SNMP_GET_SYSUPTIME
(
sysuptime
)

	)

77 static void 
system_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

78 static void 
system_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

79 static 
u8_t
 
system_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

80 static void 
system_set_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

81 static void 
interfaces_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

82 static void 
interfaces_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

83 static void 
ifentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

84 static void 
ifentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

85 #if !
SNMP_SAFE_REQUESTS


86 static 
u8_t
 
ifentry_set_test
 (struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

87 static void 
ifentry_set_value
 (struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

89 static void 
atentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

90 static void 
atentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

91 static void 
ip_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

92 static void 
ip_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

93 static 
u8_t
 
ip_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

94 static void 
ip_addrentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

95 static void 
ip_addrentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

96 static void 
ip_rteentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

97 static void 
ip_rteentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

98 static void 
ip_ntomentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

99 static void 
ip_ntomentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

100 static void 
icmp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

101 static void 
icmp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

102 #if 
LWIP_TCP


103 static void 
tcp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

104 static void 
tcp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

105 #ifdef 
THIS_SEEMS_UNUSED


106 static void 
tcpconnentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

107 static void 
tcpconnentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

110 static void 
udp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

111 static void 
udp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

112 static void 
udpentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

113 static void 
udpentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

114 static void 
snmp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

115 static void 
snmp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

116 static 
u8_t
 
snmp_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

117 static void 
snmp_set_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

121 const 
mib_scalar_node
 
	gsnmp_scalar
 = {

122 &
snmp_get_object_def
,

123 &
snmp_get_value
,

124 &
snmp_set_test
,

125 &
snmp_set_value
,

126 
MIB_NODE_SC
,

129 const 
s32_t
 
	gsnmp_ids
[28] = {

133 struct 
mib_node
* const 
	gsnmp_nodes
[28] = {

134 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

135 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

136 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

137 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

138 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

139 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

140 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

141 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

142 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

143 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

144 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

145 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

146 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar,

147 (struct 
mib_node
* const)&
snmp_scalar
, (struct mib_node* const)&snmp_scalar

149 const struct 
mib_array_node
 
	gsnmp
 = {

150 &
noleafs_get_object_def
,

151 &
noleafs_get_value
,

152 &
noleafs_set_test
,

153 &
noleafs_set_value
,

154 
MIB_NODE_AR
,

156 
snmp_ids
,

157 
snmp_nodes


166 struct 
mib_list_rootnode
 
	gudp_root
 = {

167 &
noleafs_get_object_def
,

168 &
noleafs_get_value
,

169 &
noleafs_set_test
,

170 &
noleafs_set_value
,

171 
MIB_NODE_LR
,

173 
NULL
,

174 
NULL
,

177 const 
s32_t
 
	gudpentry_ids
[2] = { 1, 2 };

178 struct 
mib_node
* const 
	gudpentry_nodes
[2] = {

179 (struct 
mib_node
* const)&
udp_root
, (struct mib_node* const)&udp_root,

181 const struct 
mib_array_node
 
	gudpentry
 = {

182 &
noleafs_get_object_def
,

183 &
noleafs_get_value
,

184 &
noleafs_set_test
,

185 &
noleafs_set_value
,

186 
MIB_NODE_AR
,

188 
udpentry_ids
,

189 
udpentry_nodes


192 
s32_t
 
	gudptable_id
 = 1;

193 struct 
mib_node
* 
	gudptable_node
 = (struct mib_node* const)&
udpentry
;

194 struct 
mib_ram_array_node
 
	gudptable
 = {

195 &
noleafs_get_object_def
,

196 &
noleafs_get_value
,

197 &
noleafs_set_test
,

198 &
noleafs_set_value
,

199 
MIB_NODE_RA
,

201 &
udptable_id
,

202 &
udptable_node


205 const 
mib_scalar_node
 
	gudp_scalar
 = {

206 &
udp_get_object_def
,

207 &
udp_get_value
,

208 &
noleafs_set_test
,

209 &
noleafs_set_value
,

210 
MIB_NODE_SC
,

213 const 
s32_t
 
	gudp_ids
[5] = { 1, 2, 3, 4, 5 };

214 struct 
mib_node
* const 
	gudp_nodes
[5] = {

215 (struct 
mib_node
* const)&
udp_scalar
, (struct mib_node* const)&udp_scalar,

216 (struct 
mib_node
* const)&
udp_scalar
, (struct mib_node* const)&udp_scalar,

217 (struct 
mib_node
* const)&
udptable


219 const struct 
mib_array_node
 
	gudp
 = {

220 &
noleafs_get_object_def
,

221 &
noleafs_get_value
,

222 &
noleafs_set_test
,

223 &
noleafs_set_value
,

224 
MIB_NODE_AR
,

226 
udp_ids
,

227 
udp_nodes


231 #if 
LWIP_TCP


234 struct 
mib_list_rootnode
 
	gtcpconntree_root
 = {

235 &
noleafs_get_object_def
,

236 &
noleafs_get_value
,

237 &
noleafs_set_test
,

238 &
noleafs_set_value
,

239 
MIB_NODE_LR
,

241 
NULL
,

242 
NULL
,

245 const 
s32_t
 
	gtcpconnentry_ids
[5] = { 1, 2, 3, 4, 5 };

246 struct 
mib_node
* const 
	gtcpconnentry_nodes
[5] = {

247 (struct 
mib_node
* const)&
tcpconntree_root
, (struct mib_node* const)&tcpconntree_root,

248 (struct 
mib_node
* const)&
tcpconntree_root
, (struct mib_node* const)&tcpconntree_root,

249 (struct 
mib_node
* const)&
tcpconntree_root


251 const struct 
mib_array_node
 
	gtcpconnentry
 = {

252 &
noleafs_get_object_def
,

253 &
noleafs_get_value
,

254 &
noleafs_set_test
,

255 &
noleafs_set_value
,

256 
MIB_NODE_AR
,

258 
tcpconnentry_ids
,

259 
tcpconnentry_nodes


262 
s32_t
 
	gtcpconntable_id
 = 1;

263 struct 
mib_node
* 
	gtcpconntable_node
 = (struct mib_node* const)&
tcpconnentry
;

264 struct 
mib_ram_array_node
 
	gtcpconntable
 = {

265 &
noleafs_get_object_def
,

266 &
noleafs_get_value
,

267 &
noleafs_set_test
,

268 &
noleafs_set_value
,

269 
MIB_NODE_RA
,

273 &
tcpconntable_id
,

274 &
tcpconntable_node


277 const 
mib_scalar_node
 
	gtcp_scalar
 = {

278 &
tcp_get_object_def
,

279 &
tcp_get_value
,

280 &
noleafs_set_test
,

281 &
noleafs_set_value
,

282 
MIB_NODE_SC
,

285 const 
s32_t
 
	gtcp_ids
[15] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

286 struct 
mib_node
* const 
	gtcp_nodes
[15] = {

287 (struct 
mib_node
* const)&
tcp_scalar
, (struct mib_node* const)&tcp_scalar,

288 (struct 
mib_node
* const)&
tcp_scalar
, (struct mib_node* const)&tcp_scalar,

289 (struct 
mib_node
* const)&
tcp_scalar
, (struct mib_node* const)&tcp_scalar,

290 (struct 
mib_node
* const)&
tcp_scalar
, (struct mib_node* const)&tcp_scalar,

291 (struct 
mib_node
* const)&
tcp_scalar
, (struct mib_node* const)&tcp_scalar,

292 (struct 
mib_node
* const)&
tcp_scalar
, (struct mib_node* const)&tcp_scalar,

293 (struct 
mib_node
* const)&
tcpconntable
, (struct mib_node* const)&
tcp_scalar
,

294 (struct 
mib_node
* const)&
tcp_scalar


296 const struct 
mib_array_node
 
	gtcp
 = {

297 &
noleafs_get_object_def
,

298 &
noleafs_get_value
,

299 &
noleafs_set_test
,

300 &
noleafs_set_value
,

301 
MIB_NODE_AR
,

303 
tcp_ids
,

304 
tcp_nodes


309 const 
mib_scalar_node
 
	gicmp_scalar
 = {

310 &
icmp_get_object_def
,

311 &
icmp_get_value
,

312 &
noleafs_set_test
,

313 &
noleafs_set_value
,

314 
MIB_NODE_SC
,

317 const 
s32_t
 
	gicmp_ids
[26] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 };

318 struct 
mib_node
* const 
	gicmp_nodes
[26] = {

319 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

320 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

321 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

322 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

323 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

324 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

325 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

326 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

327 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

328 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

329 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

330 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar,

331 (struct 
mib_node
* const)&
icmp_scalar
, (struct mib_node* const)&icmp_scalar

333 const struct 
mib_array_node
 
	gicmp
 = {

334 &
noleafs_get_object_def
,

335 &
noleafs_get_value
,

336 &
noleafs_set_test
,

337 &
noleafs_set_value
,

338 
MIB_NODE_AR
,

340 
icmp_ids
,

341 
icmp_nodes


345 struct 
mib_list_rootnode
 
	gipntomtree_root
 = {

346 &
noleafs_get_object_def
,

347 &
noleafs_get_value
,

348 &
noleafs_set_test
,

349 &
noleafs_set_value
,

350 
MIB_NODE_LR
,

352 
NULL
,

353 
NULL
,

356 const 
s32_t
 
	gipntomentry_ids
[4] = { 1, 2, 3, 4 };

357 struct 
mib_node
* const 
	gipntomentry_nodes
[4] = {

358 (struct 
mib_node
* const)&
ipntomtree_root
, (struct mib_node* const)&ipntomtree_root,

359 (struct 
mib_node
* const)&
ipntomtree_root
, (struct mib_node* const)&ipntomtree_root

361 const struct 
mib_array_node
 
	gipntomentry
 = {

362 &
noleafs_get_object_def
,

363 &
noleafs_get_value
,

364 &
noleafs_set_test
,

365 &
noleafs_set_value
,

366 
MIB_NODE_AR
,

368 
ipntomentry_ids
,

369 
ipntomentry_nodes


372 
s32_t
 
	gipntomtable_id
 = 1;

373 struct 
mib_node
* 
	gipntomtable_node
 = (struct mib_node* const)&
ipntomentry
;

374 struct 
mib_ram_array_node
 
	gipntomtable
 = {

375 &
noleafs_get_object_def
,

376 &
noleafs_get_value
,

377 &
noleafs_set_test
,

378 &
noleafs_set_value
,

379 
MIB_NODE_RA
,

381 &
ipntomtable_id
,

382 &
ipntomtable_node


386 struct 
mib_list_rootnode
 
	giprtetree_root
 = {

387 &
noleafs_get_object_def
,

388 &
noleafs_get_value
,

389 &
noleafs_set_test
,

390 &
noleafs_set_value
,

391 
MIB_NODE_LR
,

393 
NULL
,

394 
NULL
,

397 const 
s32_t
 
	giprteentry_ids
[13] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };

398 struct 
mib_node
* const 
	giprteentry_nodes
[13] = {

399 (struct 
mib_node
* const)&
iprtetree_root
, (struct mib_node* const)&iprtetree_root,

400 (struct 
mib_node
* const)&
iprtetree_root
, (struct mib_node* const)&iprtetree_root,

401 (struct 
mib_node
* const)&
iprtetree_root
, (struct mib_node* const)&iprtetree_root,

402 (struct 
mib_node
* const)&
iprtetree_root
, (struct mib_node* const)&iprtetree_root,

403 (struct 
mib_node
* const)&
iprtetree_root
, (struct mib_node* const)&iprtetree_root,

404 (struct 
mib_node
* const)&
iprtetree_root
, (struct mib_node* const)&iprtetree_root,

405 (struct 
mib_node
* const)&
iprtetree_root


407 const struct 
mib_array_node
 
	giprteentry
 = {

408 &
noleafs_get_object_def
,

409 &
noleafs_get_value
,

410 &
noleafs_set_test
,

411 &
noleafs_set_value
,

412 
MIB_NODE_AR
,

414 
iprteentry_ids
,

415 
iprteentry_nodes


418 
s32_t
 
	giprtetable_id
 = 1;

419 struct 
mib_node
* 
	giprtetable_node
 = (struct mib_node* const)&
iprteentry
;

420 struct 
mib_ram_array_node
 
	giprtetable
 = {

421 &
noleafs_get_object_def
,

422 &
noleafs_get_value
,

423 &
noleafs_set_test
,

424 &
noleafs_set_value
,

425 
MIB_NODE_RA
,

427 &
iprtetable_id
,

428 &
iprtetable_node


432 struct 
mib_list_rootnode
 
	gipaddrtree_root
 = {

433 &
noleafs_get_object_def
,

434 &
noleafs_get_value
,

435 &
noleafs_set_test
,

436 &
noleafs_set_value
,

437 
MIB_NODE_LR
,

439 
NULL
,

440 
NULL
,

443 const 
s32_t
 
	gipaddrentry_ids
[5] = { 1, 2, 3, 4, 5 };

444 struct 
mib_node
* const 
	gipaddrentry_nodes
[5] = {

445 (struct 
mib_node
* const)&
ipaddrtree_root
,

446 (struct 
mib_node
* const)&
ipaddrtree_root
,

447 (struct 
mib_node
* const)&
ipaddrtree_root
,

448 (struct 
mib_node
* const)&
ipaddrtree_root
,

449 (struct 
mib_node
* const)&
ipaddrtree_root


451 const struct 
mib_array_node
 
	gipaddrentry
 = {

452 &
noleafs_get_object_def
,

453 &
noleafs_get_value
,

454 &
noleafs_set_test
,

455 &
noleafs_set_value
,

456 
MIB_NODE_AR
,

458 
ipaddrentry_ids
,

459 
ipaddrentry_nodes


462 
s32_t
 
	gipaddrtable_id
 = 1;

463 struct 
mib_node
* 
	gipaddrtable_node
 = (struct mib_node* const)&
ipaddrentry
;

464 struct 
mib_ram_array_node
 
	gipaddrtable
 = {

465 &
noleafs_get_object_def
,

466 &
noleafs_get_value
,

467 &
noleafs_set_test
,

468 &
noleafs_set_value
,

469 
MIB_NODE_RA
,

471 &
ipaddrtable_id
,

472 &
ipaddrtable_node


476 const 
mib_scalar_node
 
	gip_scalar
 = {

477 &
ip_get_object_def
,

478 &
ip_get_value
,

479 &
ip_set_test
,

480 &
noleafs_set_value
,

481 
MIB_NODE_SC
,

484 const 
s32_t
 
	gip_ids
[23] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 };

485 struct 
mib_node
* const 
	gip_nodes
[23] = {

486 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

487 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

488 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

489 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

490 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

491 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

492 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

493 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

494 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&ip_scalar,

495 (struct 
mib_node
* const)&
ip_scalar
, (struct mib_node* const)&
ipaddrtable
,

496 (struct 
mib_node
* const)&
iprtetable
, (struct mib_node* const)&
ipntomtable
,

497 (struct 
mib_node
* const)&
ip_scalar


499 const struct 
mib_array_node
 
	gmib2_ip
 = {

500 &
noleafs_get_object_def
,

501 &
noleafs_get_value
,

502 &
noleafs_set_test
,

503 &
noleafs_set_value
,

504 
MIB_NODE_AR
,

506 
ip_ids
,

507 
ip_nodes


511 struct 
mib_list_rootnode
 
	garptree_root
 = {

512 &
noleafs_get_object_def
,

513 &
noleafs_get_value
,

514 &
noleafs_set_test
,

515 &
noleafs_set_value
,

516 
MIB_NODE_LR
,

518 
NULL
,

519 
NULL
,

522 const 
s32_t
 
	gatentry_ids
[3] = { 1, 2, 3 };

523 struct 
mib_node
* const 
	gatentry_nodes
[3] = {

524 (struct 
mib_node
* const)&
arptree_root
,

525 (struct 
mib_node
* const)&
arptree_root
,

526 (struct 
mib_node
* const)&
arptree_root


528 const struct 
mib_array_node
 
	gatentry
 = {

529 &
noleafs_get_object_def
,

530 &
noleafs_get_value
,

531 &
noleafs_set_test
,

532 &
noleafs_set_value
,

533 
MIB_NODE_AR
,

535 
atentry_ids
,

536 
atentry_nodes


539 const 
s32_t
 
	gattable_id
 = 1;

540 struct 
mib_node
* const 
	gattable_node
 = (struct mib_node* const)&
atentry
;

541 const struct 
mib_array_node
 
	gattable
 = {

542 &
noleafs_get_object_def
,

543 &
noleafs_get_value
,

544 &
noleafs_set_test
,

545 &
noleafs_set_value
,

546 
MIB_NODE_AR
,

548 &
attable_id
,

549 &
attable_node


553 
s32_t
 
	gat_id
 = 1;

554 struct 
mib_node
* 
	gmib2_at_node
 = (struct mib_node* const)&
attable
;

555 struct 
mib_ram_array_node
 
	gat
 = {

556 &
noleafs_get_object_def
,

557 &
noleafs_get_value
,

558 &
noleafs_set_test
,

559 &
noleafs_set_value
,

560 
MIB_NODE_RA
,

562 &
at_id
,

563 &
mib2_at_node


567 struct 
mib_list_rootnode
 
	giflist_root
 = {

568 &
ifentry_get_object_def
,

569 &
ifentry_get_value
,

570 #if 
SNMP_SAFE_REQUESTS


571 &
noleafs_set_test
,

572 &
noleafs_set_value
,

574 &
ifentry_set_test
,

575 &
ifentry_set_value
,

577 
MIB_NODE_LR
,

579 
NULL
,

580 
NULL
,

583 const 
s32_t
 
	gifentry_ids
[22] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 };

584 struct 
mib_node
* const 
	gifentry_nodes
[22] = {

585 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

586 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

587 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

588 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

589 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

590 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

591 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

592 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

593 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

594 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root,

595 (struct 
mib_node
* const)&
iflist_root
, (struct mib_node* const)&iflist_root

597 const struct 
mib_array_node
 
	gifentry
 = {

598 &
noleafs_get_object_def
,

599 &
noleafs_get_value
,

600 &
noleafs_set_test
,

601 &
noleafs_set_value
,

602 
MIB_NODE_AR
,

604 
ifentry_ids
,

605 
ifentry_nodes


608 
s32_t
 
	giftable_id
 = 1;

609 struct 
mib_node
* 
	giftable_node
 = (struct mib_node* const)&
ifentry
;

610 struct 
mib_ram_array_node
 
	giftable
 = {

611 &
noleafs_get_object_def
,

612 &
noleafs_get_value
,

613 &
noleafs_set_test
,

614 &
noleafs_set_value
,

615 
MIB_NODE_RA
,

617 &
iftable_id
,

618 &
iftable_node


622 const 
mib_scalar_node
 
	ginterfaces_scalar
 = {

623 &
interfaces_get_object_def
,

624 &
interfaces_get_value
,

625 &
noleafs_set_test
,

626 &
noleafs_set_value
,

627 
MIB_NODE_SC
,

630 const 
s32_t
 
	ginterfaces_ids
[2] = { 1, 2 };

631 struct 
mib_node
* const 
	ginterfaces_nodes
[2] = {

632 (struct 
mib_node
* const)&
interfaces_scalar
, (struct mib_node* const)&
iftable


634 const struct 
mib_array_node
 
	ginterfaces
 = {

635 &
noleafs_get_object_def
,

636 &
noleafs_get_value
,

637 &
noleafs_set_test
,

638 &
noleafs_set_value
,

639 
MIB_NODE_AR
,

641 
interfaces_ids
,

642 
interfaces_nodes


648 const 
mib_scalar_node
 
	gsys_tem_scalar
 = {

649 &
system_get_object_def
,

650 &
system_get_value
,

651 &
system_set_test
,

652 &
system_set_value
,

653 
MIB_NODE_SC
,

656 const 
s32_t
 
	gsys_tem_ids
[7] = { 1, 2, 3, 4, 5, 6, 7 };

657 struct 
mib_node
* const 
	gsys_tem_nodes
[7] = {

658 (struct 
mib_node
* const)&
sys_tem_scalar
, (struct mib_node* const)&sys_tem_scalar,

659 (struct 
mib_node
* const)&
sys_tem_scalar
, (struct mib_node* const)&sys_tem_scalar,

660 (struct 
mib_node
* const)&
sys_tem_scalar
, (struct mib_node* const)&sys_tem_scalar,

661 (struct 
mib_node
* const)&
sys_tem_scalar


664 const struct 
mib_array_node
 
	gsys_tem
 = {

665 &
noleafs_get_object_def
,

666 &
noleafs_get_value
,

667 &
noleafs_set_test
,

668 &
noleafs_set_value
,

669 
MIB_NODE_AR
,

671 
sys_tem_ids
,

672 
sys_tem_nodes


676 #if 
LWIP_TCP


677 #define 
	#MIB2_GROUPS
 8

	)

679 #define 
	#MIB2_GROUPS
 7

	)

681 const 
s32_t
 
	gmib2_ids
[
MIB2_GROUPS
] =

688 #if 
LWIP_TCP


694 struct 
mib_node
* const 
	gmib2_nodes
[
MIB2_GROUPS
] = {

695 (struct 
mib_node
* const)&
sys_tem
,

696 (struct 
mib_node
* const)&
interfaces
,

697 (struct 
mib_node
* const)&
at
,

698 (struct 
mib_node
* const)&
mib2_ip
,

699 (struct 
mib_node
* const)&
icmp
,

700 #if 
LWIP_TCP


701 (struct 
mib_node
* const)&
tcp
,

703 (struct 
mib_node
* const)&
udp
,

704 (struct 
mib_node
* const)&
snmp


707 const struct 
mib_array_node
 
	gmib2
 = {

708 &
noleafs_get_object_def
,

709 &
noleafs_get_value
,

710 &
noleafs_set_test
,

711 &
noleafs_set_value
,

712 
MIB_NODE_AR
,

713 
MIB2_GROUPS
,

714 
mib2_ids
,

715 
mib2_nodes


719 const 
s32_t
 
	gmgmt_ids
[1] = { 1 };

720 struct 
mib_node
* const 
	gmgmt_nodes
[1] = { (struct mib_node* const)&
mib2
 };

721 const struct 
mib_array_node
 
	gmgmt
 = {

722 &
noleafs_get_object_def
,

723 &
noleafs_get_value
,

724 &
noleafs_set_test
,

725 &
noleafs_set_value
,

726 
MIB_NODE_AR
,

728 
mgmt_ids
,

729 
mgmt_nodes


733 #if 
SNMP_PRIVATE_MIB


734 
s32_t
 
	ginternet_ids
[2] = { 2, 4 };

735 struct 
mib_node
* const 
	ginternet_nodes
[2] = { (struct mib_node* const)&
mgmt
, (struct mib_node* const)&
private
 };

736 const struct 
mib_array_node
 
	ginternet
 = {

737 &
noleafs_get_object_def
,

738 &
noleafs_get_value
,

739 &
noleafs_set_test
,

740 &
noleafs_set_value
,

741 
MIB_NODE_AR
,

743 
internet_ids
,

744 
internet_nodes


747 const 
s32_t
 
	ginternet_ids
[1] = { 2 };

748 struct 
mib_node
* const 
	ginternet_nodes
[1] = { (struct mib_node* const)&
mgmt
 };

749 const struct 
mib_array_node
 
	ginternet
 = {

750 &
noleafs_get_object_def
,

751 &
noleafs_get_value
,

752 &
noleafs_set_test
,

753 &
noleafs_set_value
,

754 
MIB_NODE_AR
,

756 
internet_ids
,

757 
internet_nodes


762 static struct 
snmp_obj_id
 
	gsysobjid
 = {
SNMP_SYSOBJID_LEN
, 
SNMP_SYSOBJID
};

764 static struct 
snmp_obj_id
 
	gsnmpgrp_id
 = {7,{1,3,6,1,2,1,11}};

766 static const 
s32_t
 
	gsysservices
 = 
SNMP_SYSSERVICES
;

769 static const 
u8_t
 
	gsysdescr_len_default
 = 4;

770 static const 
u8_t
 
	gsysdescr_default
[] = "lwIP";

771 static 
u8_t
* 
	gsysdescr_len_ptr
 = (u8_t*)&
sysdescr_len_default
;

772 static 
u8_t
* 
	gsysdescr_ptr
 = (u8_t*)&
sysdescr_default
[0];

774 static const 
u8_t
 
	gsyscontact_len_default
 = 0;

775 static const 
u8_t
 
	gsyscontact_default
[] = "";

776 static 
u8_t
* 
	gsyscontact_len_ptr
 = (u8_t*)&
syscontact_len_default
;

777 static 
u8_t
* 
	gsyscontact_ptr
 = (u8_t*)&
syscontact_default
[0];

779 static const 
u8_t
 
	gsysname_len_default
 = 8;

780 static const 
u8_t
 
	gsysname_default
[] = "FQDN-unk";

781 static 
u8_t
* 
	gsysname_len_ptr
 = (u8_t*)&
sysname_len_default
;

782 static 
u8_t
* 
	gsysname_ptr
 = (u8_t*)&
sysname_default
[0];

784 static const 
u8_t
 
	gsyslocation_len_default
 = 0;

785 static const 
u8_t
 
	gsyslocation_default
[] = "";

786 static 
u8_t
* 
	gsyslocation_len_ptr
 = (u8_t*)&
syslocation_len_default
;

787 static 
u8_t
* 
	gsyslocation_ptr
 = (u8_t*)&
syslocation_default
[0];

789 static const 
u8_t
 
	gsnmpenableauthentraps_default
 = 2;

790 static 
u8_t
* 
	gsnmpenableauthentraps_ptr
 = (u8_t*)&
snmpenableauthentraps_default
;

793 static const struct 
snmp_obj_id
 
	gifspecific
 = {2, {0, 0}};

795 static const struct 
snmp_obj_id
 
	giprouteinfo
 = {2, {0, 0}};

800 static 
u32_t
 
	gsysuptime
 = 0;

803 static 
u32_t
 
	gipinreceives
 = 0,

804 
	gipinhdrerrors
 = 0,

805 
	gipinaddrerrors
 = 0,

806 
	gipforwdatagrams
 = 0,

807 
	gipinunknownprotos
 = 0,

808 
	gipindiscards
 = 0,

809 
	gipindelivers
 = 0,

810 
	gipoutrequests
 = 0,

811 
	gipoutdiscards
 = 0,

812 
	gipoutnoroutes
 = 0,

813 
	gipreasmreqds
 = 0,

814 
	gipreasmoks
 = 0,

815 
	gipreasmfails
 = 0,

816 
	gipfragoks
 = 0,

817 
	gipfragfails
 = 0,

818 
	gipfragcreates
 = 0,

819 
	giproutingdiscards
 = 0;

821 static 
u32_t
 
	gicmpinmsgs
 = 0,

822 
	gicmpinerrors
 = 0,

823 
	gicmpindestunreachs
 = 0,

824 
	gicmpintimeexcds
 = 0,

825 
	gicmpinparmprobs
 = 0,

826 
	gicmpinsrcquenchs
 = 0,

827 
	gicmpinredirects
 = 0,

828 
	gicmpinechos
 = 0,

829 
	gicmpinechoreps
 = 0,

830 
	gicmpintimestamps
 = 0,

831 
	gicmpintimestampreps
 = 0,

832 
	gicmpinaddrmasks
 = 0,

833 
	gicmpinaddrmaskreps
 = 0,

834 
	gicmpoutmsgs
 = 0,

835 
	gicmpouterrors
 = 0,

836 
	gicmpoutdestunreachs
 = 0,

837 
	gicmpouttimeexcds
 = 0,

838 
	gicmpoutparmprobs
 = 0,

839 
	gicmpoutsrcquenchs
 = 0,

840 
	gicmpoutredirects
 = 0,

841 
	gicmpoutechos
 = 0,

842 
	gicmpoutechoreps
 = 0,

843 
	gicmpouttimestamps
 = 0,

844 
	gicmpouttimestampreps
 = 0,

845 
	gicmpoutaddrmasks
 = 0,

846 
	gicmpoutaddrmaskreps
 = 0;

848 static 
u32_t
 
	gtcpactiveopens
 = 0,

849 
	gtcppassiveopens
 = 0,

850 
	gtcpattemptfails
 = 0,

851 
	gtcpestabresets
 = 0,

852 
	gtcpinsegs
 = 0,

853 
	gtcpoutsegs
 = 0,

854 
	gtcpretranssegs
 = 0,

855 
	gtcpinerrs
 = 0,

856 
	gtcpoutrsts
 = 0;

858 static 
u32_t
 
	gudpindatagrams
 = 0,

859 
	gudpnoports
 = 0,

860 
	gudpinerrors
 = 0,

861 
	gudpoutdatagrams
 = 0;

863 static 
u32_t
 
	gsnmpinpkts
 = 0,

864 
	gsnmpoutpkts
 = 0,

865 
	gsnmpinbadversions
 = 0,

866 
	gsnmpinbadcommunitynames
 = 0,

867 
	gsnmpinbadcommunityuses
 = 0,

868 
	gsnmpinasnparseerrs
 = 0,

869 
	gsnmpintoobigs
 = 0,

870 
	gsnmpinnosuchnames
 = 0,

871 
	gsnmpinbadvalues
 = 0,

872 
	gsnmpinreadonlys
 = 0,

873 
	gsnmpingenerrs
 = 0,

874 
	gsnmpintotalreqvars
 = 0,

875 
	gsnmpintotalsetvars
 = 0,

876 
	gsnmpingetrequests
 = 0,

877 
	gsnmpingetnexts
 = 0,

878 
	gsnmpinsetrequests
 = 0,

879 
	gsnmpingetresponses
 = 0,

880 
	gsnmpintraps
 = 0,

881 
	gsnmpouttoobigs
 = 0,

882 
	gsnmpoutnosuchnames
 = 0,

883 
	gsnmpoutbadvalues
 = 0,

884 
	gsnmpoutgenerrs
 = 0,

885 
	gsnmpoutgetrequests
 = 0,

886 
	gsnmpoutgetnexts
 = 0,

887 
	gsnmpoutsetrequests
 = 0,

888 
	gsnmpoutgetresponses
 = 0,

889 
	gsnmpouttraps
 = 0;

901 void 
	$ocstrncpy
(
u8_t
 *
dst
, u8_t *
src
, u8_t 
n
)

903 while (
n
 > 0)

905 
n
--;

906 *
dst
++ = *
src
++;

908 
	}
}

917 void 
	$objectidncpy
(
s32_t
 *
dst
, s32_t *
src
, 
u8_t
 
n
)

919 while(
n
 > 0)

921 
n
--;

922 *
dst
++ = *
src
++;

924 
	}
}

932 void 
	$snmp_set_sysdesr
(
u8_t
 *
str
, u8_t *
len
)

934 if (
str
 != 
NULL
)

936 
sysdescr_ptr
 = 
str
;

937 
sysdescr_len_ptr
 = 
len
;

939 
	}
}

941 void 
	$snmp_get_sysobjid_ptr
(struct 
snmp_obj_id
 **
oid
)

943 *
oid
 = &
sysobjid
;

944 
	}
}

951 void 
	$snmp_set_sysobjid
(struct 
snmp_obj_id
 *
oid
)

953 
sysobjid
 = *
oid
;

954 
	}
}

960 void 
	$snmp_inc_sysuptime
(void)

962 
sysuptime
++;

963 
	}
}

965 void 
	$snmp_add_sysuptime
(
u32_t
 
value
)

967 
sysuptime
+=
value
;

968 
	}
}

970 void 
	$snmp_get_sysuptime
(
u32_t
 *
value
)

972 
	`SNMP_GET_SYSUPTIME
(
sysuptime
);

973 *
value
 = 
sysuptime
;

974 
	}
}

983 void 
	$snmp_set_syscontact
(
u8_t
 *
ocstr
, u8_t *
ocstrlen
)

985 if (
ocstr
 != 
NULL
)

987 
syscontact_ptr
 = 
ocstr
;

988 
syscontact_len_ptr
 = 
ocstrlen
;

990 
	}
}

999 void 
	$snmp_set_sysname
(
u8_t
 *
ocstr
, u8_t *
ocstrlen
)

1001 if (
ocstr
 != 
NULL
)

1003 
sysname_ptr
 = 
ocstr
;

1004 
sysname_len_ptr
 = 
ocstrlen
;

1006 
	}
}

1015 void 
	$snmp_set_syslocation
(
u8_t
 *
ocstr
, u8_t *
ocstrlen
)

1017 if (
ocstr
 != 
NULL
)

1019 
syslocation_ptr
 = 
ocstr
;

1020 
syslocation_len_ptr
 = 
ocstrlen
;

1022 
	}
}

1025 void 
	$snmp_add_ifinoctets
(struct 
netif
 *
ni
, 
u32_t
 
value
)

1027 
ni
->
ifinoctets
 += 
value
;

1028 
	}
}

1030 void 
	$snmp_inc_ifinucastpkts
(struct 
netif
 *
ni
)

1032 (
ni
->
ifinucastpkts
)++;

1033 
	}
}

1035 void 
	$snmp_inc_ifinnucastpkts
(struct 
netif
 *
ni
)

1037 (
ni
->
ifinnucastpkts
)++;

1038 
	}
}

1040 void 
	$snmp_inc_ifindiscards
(struct 
netif
 *
ni
)

1042 (
ni
->
ifindiscards
)++;

1043 
	}
}

1045 void 
	$snmp_add_ifoutoctets
(struct 
netif
 *
ni
, 
u32_t
 
value
)

1047 
ni
->
ifoutoctets
 += 
value
;

1048 
	}
}

1050 void 
	$snmp_inc_ifoutucastpkts
(struct 
netif
 *
ni
)

1052 (
ni
->
ifoutucastpkts
)++;

1053 
	}
}

1055 void 
	$snmp_inc_ifoutnucastpkts
(struct 
netif
 *
ni
)

1057 (
ni
->
ifoutnucastpkts
)++;

1058 
	}
}

1060 void 
	$snmp_inc_ifoutdiscards
(struct 
netif
 *
ni
)

1062 (
ni
->
ifoutdiscards
)++;

1063 
	}
}

1065 void 
	$snmp_inc_iflist
(void)

1067 struct 
mib_list_node
 *
if_node
 = 
NULL
;

1069 
	`snmp_mib_node_insert
(&
iflist_root
, iflist_root.
count
 + 1, &
if_node
);

1071 
iftable
.
maxlength
 = 1;

1072 
	}
}

1074 void 
	$snmp_dec_iflist
(void)

1076 
	`snmp_mib_node_delete
(&
iflist_root
, iflist_root.
tail
);

1078 if(
iflist_root
.
count
 == 0) 
iftable
.
maxlength
 = 0;

1079 
	}
}

1085 void 
	$snmp_insert_arpidx_tree
(struct 
netif
 *
ni
, struct 
ip_addr
 *
ip
)

1087 struct 
mib_list_rootnode
 *
at_rn
;

1088 struct 
mib_list_node
 *
at_node
;

1089 struct 
ip_addr
 
hip
;

1090 
s32_t
 
arpidx
[5];

1091 
u8_t
 
level
, 
tree
;

1093 
	`LWIP_ASSERT
("ni != NULL", 
ni
 != 
NULL
);

1094 
	`snmp_netiftoifindex
(
ni
, &
arpidx
[0]);

1095 
hip
.
addr
 = 
	`ntohl
(
ip
->addr);

1096 
	`snmp_iptooid
(&
hip
, &
arpidx
[1]);

1098 for (
tree
 = 0; tree < 2; tree++)

1100 if (
tree
 == 0)

1102 
at_rn
 = &
arptree_root
;

1106 
at_rn
 = &
ipntomtree_root
;

1108 for (
level
 = 0; level < 5; level++)

1110 
at_node
 = 
NULL
;

1111 
	`snmp_mib_node_insert
(
at_rn
, 
arpidx
[
level
], &
at_node
);

1112 if ((
level
 != 4) && (
at_node
 != 
NULL
))

1114 if (
at_node
->
nptr
 == 
NULL
)

1116 
at_rn
 = 
	`snmp_mib_lrn_alloc
();

1117 
at_node
->
nptr
 = (struct 
mib_node
*)
at_rn
;

1118 if (
at_rn
 != 
NULL
)

1120 if (
level
 == 3)

1122 if (
tree
 == 0)

1124 
at_rn
->
get_object_def
 = 
atentry_get_object_def
;

1125 
at_rn
->
get_value
 = 
atentry_get_value
;

1129 
at_rn
->
get_object_def
 = 
ip_ntomentry_get_object_def
;

1130 
at_rn
->
get_value
 = 
ip_ntomentry_get_value
;

1132 
at_rn
->
set_test
 = 
noleafs_set_test
;

1133 
at_rn
->
set_value
 = 
noleafs_set_value
;

1139 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("snmp_insert_arpidx_tree() insert failed, mem full"));

1145 
at_rn
 = (struct 
mib_list_rootnode
*)
at_node
->
nptr
;

1151 
at
.
maxlength
 = 1;

1152 
ipntomtable
.
maxlength
 = 1;

1153 
	}
}

1159 void 
	$snmp_delete_arpidx_tree
(struct 
netif
 *
ni
, struct 
ip_addr
 *
ip
)

1161 struct 
mib_list_rootnode
 *
at_rn
, *
next
, *
del_rn
[5];

1162 struct 
mib_list_node
 *
at_n
, *
del_n
[5];

1163 struct 
ip_addr
 
hip
;

1164 
s32_t
 
arpidx
[5];

1165 
u8_t
 
fc
, 
tree
, 
level
, 
del_cnt
;

1167 
	`snmp_netiftoifindex
(
ni
, &
arpidx
[0]);

1168 
hip
.
addr
 = 
	`ntohl
(
ip
->addr);

1169 
	`snmp_iptooid
(&
hip
, &
arpidx
[1]);

1171 for (
tree
 = 0; tree < 2; tree++)

1174 if (
tree
 == 0)

1176 
at_rn
 = &
arptree_root
;

1180 
at_rn
 = &
ipntomtree_root
;

1182 
level
 = 0;

1183 
del_cnt
 = 0;

1184 while ((
level
 < 5) && (
at_rn
 != 
NULL
))

1186 
fc
 = 
	`snmp_mib_node_find
(
at_rn
, 
arpidx
[
level
], &
at_n
);

1187 if (
fc
 == 0)

1190 
del_cnt
 = 0;

1191 
at_rn
 = 
NULL
;

1193 else if (
fc
 == 1)

1195 
del_rn
[
del_cnt
] = 
at_rn
;

1196 
del_n
[
del_cnt
] = 
at_n
;

1197 
del_cnt
++;

1198 
at_rn
 = (struct 
mib_list_rootnode
*)(
at_n
->
nptr
);

1200 else if (
fc
 == 2)

1203 
del_cnt
 = 0;

1204 
at_rn
 = (struct 
mib_list_rootnode
*)(
at_n
->
nptr
);

1206 
level
++;

1209 while (
del_cnt
 > 0)

1211 
del_cnt
--;

1213 
at_rn
 = 
del_rn
[
del_cnt
];

1214 
at_n
 = 
del_n
[
del_cnt
];

1216 
next
 = 
	`snmp_mib_node_delete
(
at_rn
, 
at_n
);

1217 if (
next
 != 
NULL
)

1219 
	`LWIP_ASSERT
("next_count == 0",
next
->
count
 == 0);

1220 
	`snmp_mib_lrn_free
(
next
);

1225 if(
arptree_root
.
count
 == 0) 
at
.
maxlength
 = 0;

1226 if(
ipntomtree_root
.
count
 == 0) 
ipntomtable
.
maxlength
 = 0;

1227 
	}
}

1229 void 
	$snmp_inc_ipinreceives
(void)

1231 
ipinreceives
++;

1232 
	}
}

1234 void 
	$snmp_inc_ipinhdrerrors
(void)

1236 
ipinhdrerrors
++;

1237 
	}
}

1239 void 
	$snmp_inc_ipinaddrerrors
(void)

1241 
ipinaddrerrors
++;

1242 
	}
}

1244 void 
	$snmp_inc_ipforwdatagrams
(void)

1246 
ipforwdatagrams
++;

1247 
	}
}

1249 void 
	$snmp_inc_ipinunknownprotos
(void)

1251 
ipinunknownprotos
++;

1252 
	}
}

1254 void 
	$snmp_inc_ipindiscards
(void)

1256 
ipindiscards
++;

1257 
	}
}

1259 void 
	$snmp_inc_ipindelivers
(void)

1261 
ipindelivers
++;

1262 
	}
}

1264 void 
	$snmp_inc_ipoutrequests
(void)

1266 
ipoutrequests
++;

1267 
	}
}

1269 void 
	$snmp_inc_ipoutdiscards
(void)

1271 
ipoutdiscards
++;

1272 
	}
}

1274 void 
	$snmp_inc_ipoutnoroutes
(void)

1276 
ipoutnoroutes
++;

1277 
	}
}

1279 void 
	$snmp_inc_ipreasmreqds
(void)

1281 
ipreasmreqds
++;

1282 
	}
}

1284 void 
	$snmp_inc_ipreasmoks
(void)

1286 
ipreasmoks
++;

1287 
	}
}

1289 void 
	$snmp_inc_ipreasmfails
(void)

1291 
ipreasmfails
++;

1292 
	}
}

1294 void 
	$snmp_inc_ipfragoks
(void)

1296 
ipfragoks
++;

1297 
	}
}

1299 void 
	$snmp_inc_ipfragfails
(void)

1301 
ipfragfails
++;

1302 
	}
}

1304 void 
	$snmp_inc_ipfragcreates
(void)

1306 
ipfragcreates
++;

1307 
	}
}

1309 void 
	$snmp_inc_iproutingdiscards
(void)

1311 
iproutingdiscards
++;

1312 
	}
}

1318 void 
	$snmp_insert_ipaddridx_tree
(struct 
netif
 *
ni
)

1320 struct 
mib_list_rootnode
 *
ipa_rn
;

1321 struct 
mib_list_node
 *
ipa_node
;

1322 struct 
ip_addr
 
ip
;

1323 
s32_t
 
ipaddridx
[4];

1324 
u8_t
 
level
;

1326 
	`LWIP_ASSERT
("ni != NULL", 
ni
 != 
NULL
);

1327 
ip
.
addr
 = 
	`ntohl
(
ni
->
ip_addr
.addr);

1328 
	`snmp_iptooid
(&
ip
, &
ipaddridx
[0]);

1330 
level
 = 0;

1331 
ipa_rn
 = &
ipaddrtree_root
;

1332 while (
level
 < 4)

1334 
ipa_node
 = 
NULL
;

1335 
	`snmp_mib_node_insert
(
ipa_rn
, 
ipaddridx
[
level
], &
ipa_node
);

1336 if ((
level
 != 3) && (
ipa_node
 != 
NULL
))

1338 if (
ipa_node
->
nptr
 == 
NULL
)

1340 
ipa_rn
 = 
	`snmp_mib_lrn_alloc
();

1341 
ipa_node
->
nptr
 = (struct 
mib_node
*)
ipa_rn
;

1342 if (
ipa_rn
 != 
NULL
)

1344 if (
level
 == 2)

1346 
ipa_rn
->
get_object_def
 = 
ip_addrentry_get_object_def
;

1347 
ipa_rn
->
get_value
 = 
ip_addrentry_get_value
;

1348 
ipa_rn
->
set_test
 = 
noleafs_set_test
;

1349 
ipa_rn
->
set_value
 = 
noleafs_set_value
;

1355 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("snmp_insert_ipaddridx_tree() insert failed, mem full"));

1361 
ipa_rn
 = (struct 
mib_list_rootnode
*)
ipa_node
->
nptr
;

1364 
level
++;

1367 
ipaddrtable
.
maxlength
 = 1;

1368 
	}
}

1374 void 
	$snmp_delete_ipaddridx_tree
(struct 
netif
 *
ni
)

1376 struct 
mib_list_rootnode
 *
ipa_rn
, *
next
, *
del_rn
[4];

1377 struct 
mib_list_node
 *
ipa_n
, *
del_n
[4];

1378 struct 
ip_addr
 
ip
;

1379 
s32_t
 
ipaddridx
[4];

1380 
u8_t
 
fc
, 
level
, 
del_cnt
;

1382 
	`LWIP_ASSERT
("ni != NULL", 
ni
 != 
NULL
);

1383 
ip
.
addr
 = 
	`ntohl
(
ni
->
ip_addr
.addr);

1384 
	`snmp_iptooid
(&
ip
, &
ipaddridx
[0]);

1387 
level
 = 0;

1388 
del_cnt
 = 0;

1389 
ipa_rn
 = &
ipaddrtree_root
;

1390 while ((
level
 < 4) && (
ipa_rn
 != 
NULL
))

1392 
fc
 = 
	`snmp_mib_node_find
(
ipa_rn
, 
ipaddridx
[
level
], &
ipa_n
);

1393 if (
fc
 == 0)

1396 
del_cnt
 = 0;

1397 
ipa_rn
 = 
NULL
;

1399 else if (
fc
 == 1)

1401 
del_rn
[
del_cnt
] = 
ipa_rn
;

1402 
del_n
[
del_cnt
] = 
ipa_n
;

1403 
del_cnt
++;

1404 
ipa_rn
 = (struct 
mib_list_rootnode
*)(
ipa_n
->
nptr
);

1406 else if (
fc
 == 2)

1409 
del_cnt
 = 0;

1410 
ipa_rn
 = (struct 
mib_list_rootnode
*)(
ipa_n
->
nptr
);

1412 
level
++;

1415 while (
del_cnt
 > 0)

1417 
del_cnt
--;

1419 
ipa_rn
 = 
del_rn
[
del_cnt
];

1420 
ipa_n
 = 
del_n
[
del_cnt
];

1422 
next
 = 
	`snmp_mib_node_delete
(
ipa_rn
, 
ipa_n
);

1423 if (
next
 != 
NULL
)

1425 
	`LWIP_ASSERT
("next_count == 0",
next
->
count
 == 0);

1426 
	`snmp_mib_lrn_free
(
next
);

1430 if (
ipaddrtree_root
.
count
 == 0) 
ipaddrtable
.
maxlength
 = 0;

1431 
	}
}

1443 void 
	$snmp_insert_iprteidx_tree
(
u8_t
 
dflt
, struct 
netif
 *
ni
)

1445 
u8_t
 
insert
 = 0;

1446 struct 
ip_addr
 
dst
;

1448 if (
dflt
 != 0)

1451 
dst
.
addr
 = 0;

1452 
insert
 = 1;

1457 
dst
.
addr
 = 
	`ntohl
(
ni
->
ip_addr
.addr & ni->
netmask
.addr);

1459 if (
dst
.
addr
 != 0) 
insert
 = 1;

1461 if (
insert
)

1463 struct 
mib_list_rootnode
 *
iprte_rn
;

1464 struct 
mib_list_node
 *
iprte_node
;

1465 
s32_t
 
iprteidx
[4];

1466 
u8_t
 
level
;

1468 
	`snmp_iptooid
(&
dst
, &
iprteidx
[0]);

1469 
level
 = 0;

1470 
iprte_rn
 = &
iprtetree_root
;

1471 while (
level
 < 4)

1473 
iprte_node
 = 
NULL
;

1474 
	`snmp_mib_node_insert
(
iprte_rn
, 
iprteidx
[
level
], &
iprte_node
);

1475 if ((
level
 != 3) && (
iprte_node
 != 
NULL
))

1477 if (
iprte_node
->
nptr
 == 
NULL
)

1479 
iprte_rn
 = 
	`snmp_mib_lrn_alloc
();

1480 
iprte_node
->
nptr
 = (struct 
mib_node
*)
iprte_rn
;

1481 if (
iprte_rn
 != 
NULL
)

1483 if (
level
 == 2)

1485 
iprte_rn
->
get_object_def
 = 
ip_rteentry_get_object_def
;

1486 
iprte_rn
->
get_value
 = 
ip_rteentry_get_value
;

1487 
iprte_rn
->
set_test
 = 
noleafs_set_test
;

1488 
iprte_rn
->
set_value
 = 
noleafs_set_value
;

1494 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("snmp_insert_iprteidx_tree() insert failed, mem full"));

1500 
iprte_rn
 = (struct 
mib_list_rootnode
*)
iprte_node
->
nptr
;

1503 
level
++;

1507 
iprtetable
.
maxlength
 = 1;

1508 
	}
}

1518 void 
	$snmp_delete_iprteidx_tree
(
u8_t
 
dflt
, struct 
netif
 *
ni
)

1520 
u8_t
 
delete
 = 0;

1521 struct 
ip_addr
 
dst
;

1523 if (
dflt
 != 0)

1526 
dst
.
addr
 = 0;

1527 
delete
 = 1;

1532 
dst
.
addr
 = 
	`ntohl
(
ni
->
ip_addr
.addr & ni->
netmask
.addr);

1534 if (
dst
.
addr
 != 0) 
delete
 = 1;

1536 if (
delete
)

1538 struct 
mib_list_rootnode
 *
iprte_rn
, *
next
, *
del_rn
[4];

1539 struct 
mib_list_node
 *
iprte_n
, *
del_n
[4];

1540 
s32_t
 
iprteidx
[4];

1541 
u8_t
 
fc
, 
level
, 
del_cnt
;

1543 
	`snmp_iptooid
(&
dst
, &
iprteidx
[0]);

1545 
level
 = 0;

1546 
del_cnt
 = 0;

1547 
iprte_rn
 = &
iprtetree_root
;

1548 while ((
level
 < 4) && (
iprte_rn
 != 
NULL
))

1550 
fc
 = 
	`snmp_mib_node_find
(
iprte_rn
, 
iprteidx
[
level
], &
iprte_n
);

1551 if (
fc
 == 0)

1554 
del_cnt
 = 0;

1555 
iprte_rn
 = 
NULL
;

1557 else if (
fc
 == 1)

1559 
del_rn
[
del_cnt
] = 
iprte_rn
;

1560 
del_n
[
del_cnt
] = 
iprte_n
;

1561 
del_cnt
++;

1562 
iprte_rn
 = (struct 
mib_list_rootnode
*)(
iprte_n
->
nptr
);

1564 else if (
fc
 == 2)

1567 
del_cnt
 = 0;

1568 
iprte_rn
 = (struct 
mib_list_rootnode
*)(
iprte_n
->
nptr
);

1570 
level
++;

1573 while (
del_cnt
 > 0)

1575 
del_cnt
--;

1577 
iprte_rn
 = 
del_rn
[
del_cnt
];

1578 
iprte_n
 = 
del_n
[
del_cnt
];

1580 
next
 = 
	`snmp_mib_node_delete
(
iprte_rn
, 
iprte_n
);

1581 if (
next
 != 
NULL
)

1583 
	`LWIP_ASSERT
("next_count == 0",
next
->
count
 == 0);

1584 
	`snmp_mib_lrn_free
(
next
);

1589 if (
iprtetree_root
.
count
 == 0) 
iprtetable
.
maxlength
 = 0;

1590 
	}
}

1593 void 
	$snmp_inc_icmpinmsgs
(void)

1595 
icmpinmsgs
++;

1596 
	}
}

1598 void 
	$snmp_inc_icmpinerrors
(void)

1600 
icmpinerrors
++;

1601 
	}
}

1603 void 
	$snmp_inc_icmpindestunreachs
(void)

1605 
icmpindestunreachs
++;

1606 
	}
}

1608 void 
	$snmp_inc_icmpintimeexcds
(void)

1610 
icmpintimeexcds
++;

1611 
	}
}

1613 void 
	$snmp_inc_icmpinparmprobs
(void)

1615 
icmpinparmprobs
++;

1616 
	}
}

1618 void 
	$snmp_inc_icmpinsrcquenchs
(void)

1620 
icmpinsrcquenchs
++;

1621 
	}
}

1623 void 
	$snmp_inc_icmpinredirects
(void)

1625 
icmpinredirects
++;

1626 
	}
}

1628 void 
	$snmp_inc_icmpinechos
(void)

1630 
icmpinechos
++;

1631 
	}
}

1633 void 
	$snmp_inc_icmpinechoreps
(void)

1635 
icmpinechoreps
++;

1636 
	}
}

1638 void 
	$snmp_inc_icmpintimestamps
(void)

1640 
icmpintimestamps
++;

1641 
	}
}

1643 void 
	$snmp_inc_icmpintimestampreps
(void)

1645 
icmpintimestampreps
++;

1646 
	}
}

1648 void 
	$snmp_inc_icmpinaddrmasks
(void)

1650 
icmpinaddrmasks
++;

1651 
	}
}

1653 void 
	$snmp_inc_icmpinaddrmaskreps
(void)

1655 
icmpinaddrmaskreps
++;

1656 
	}
}

1658 void 
	$snmp_inc_icmpoutmsgs
(void)

1660 
icmpoutmsgs
++;

1661 
	}
}

1663 void 
	$snmp_inc_icmpouterrors
(void)

1665 
icmpouterrors
++;

1666 
	}
}

1668 void 
	$snmp_inc_icmpoutdestunreachs
(void)

1670 
icmpoutdestunreachs
++;

1671 
	}
}

1673 void 
	$snmp_inc_icmpouttimeexcds
(void)

1675 
icmpouttimeexcds
++;

1676 
	}
}

1678 void 
	$snmp_inc_icmpoutparmprobs
(void)

1680 
icmpoutparmprobs
++;

1681 
	}
}

1683 void 
	$snmp_inc_icmpoutsrcquenchs
(void)

1685 
icmpoutsrcquenchs
++;

1686 
	}
}

1688 void 
	$snmp_inc_icmpoutredirects
(void)

1690 
icmpoutredirects
++;

1691 
	}
}

1693 void 
	$snmp_inc_icmpoutechos
(void)

1695 
icmpoutechos
++;

1696 
	}
}

1698 void 
	$snmp_inc_icmpoutechoreps
(void)

1700 
icmpoutechoreps
++;

1701 
	}
}

1703 void 
	$snmp_inc_icmpouttimestamps
(void)

1705 
icmpouttimestamps
++;

1706 
	}
}

1708 void 
	$snmp_inc_icmpouttimestampreps
(void)

1710 
icmpouttimestampreps
++;

1711 
	}
}

1713 void 
	$snmp_inc_icmpoutaddrmasks
(void)

1715 
icmpoutaddrmasks
++;

1716 
	}
}

1718 void 
	$snmp_inc_icmpoutaddrmaskreps
(void)

1720 
icmpoutaddrmaskreps
++;

1721 
	}
}

1723 void 
	$snmp_inc_tcpactiveopens
(void)

1725 
tcpactiveopens
++;

1726 
	}
}

1728 void 
	$snmp_inc_tcppassiveopens
(void)

1730 
tcppassiveopens
++;

1731 
	}
}

1733 void 
	$snmp_inc_tcpattemptfails
(void)

1735 
tcpattemptfails
++;

1736 
	}
}

1738 void 
	$snmp_inc_tcpestabresets
(void)

1740 
tcpestabresets
++;

1741 
	}
}

1743 void 
	$snmp_inc_tcpinsegs
(void)

1745 
tcpinsegs
++;

1746 
	}
}

1748 void 
	$snmp_inc_tcpoutsegs
(void)

1750 
tcpoutsegs
++;

1751 
	}
}

1753 void 
	$snmp_inc_tcpretranssegs
(void)

1755 
tcpretranssegs
++;

1756 
	}
}

1758 void 
	$snmp_inc_tcpinerrs
(void)

1760 
tcpinerrs
++;

1761 
	}
}

1763 void 
	$snmp_inc_tcpoutrsts
(void)

1765 
tcpoutrsts
++;

1766 
	}
}

1768 void 
	$snmp_inc_udpindatagrams
(void)

1770 
udpindatagrams
++;

1771 
	}
}

1773 void 
	$snmp_inc_udpnoports
(void)

1775 
udpnoports
++;

1776 
	}
}

1778 void 
	$snmp_inc_udpinerrors
(void)

1780 
udpinerrors
++;

1781 
	}
}

1783 void 
	$snmp_inc_udpoutdatagrams
(void)

1785 
udpoutdatagrams
++;

1786 
	}
}

1792 void 
	$snmp_insert_udpidx_tree
(struct 
udp_pcb
 *
pcb
)

1794 struct 
mib_list_rootnode
 *
udp_rn
;

1795 struct 
mib_list_node
 *
udp_node
;

1796 struct 
ip_addr
 
ip
;

1797 
s32_t
 
udpidx
[5];

1798 
u8_t
 
level
;

1800 
	`LWIP_ASSERT
("pcb != NULL", 
pcb
 != 
NULL
);

1801 
ip
.
addr
 = 
	`ntohl
(
pcb
->
local_ip
.addr);

1802 
	`snmp_iptooid
(&
ip
, &
udpidx
[0]);

1803 
udpidx
[4] = 
pcb
->
local_port
;

1805 
udp_rn
 = &
udp_root
;

1806 for (
level
 = 0; level < 5; level++)

1808 
udp_node
 = 
NULL
;

1809 
	`snmp_mib_node_insert
(
udp_rn
, 
udpidx
[
level
], &
udp_node
);

1810 if ((
level
 != 4) && (
udp_node
 != 
NULL
))

1812 if (
udp_node
->
nptr
 == 
NULL
)

1814 
udp_rn
 = 
	`snmp_mib_lrn_alloc
();

1815 
udp_node
->
nptr
 = (struct 
mib_node
*)
udp_rn
;

1816 if (
udp_rn
 != 
NULL
)

1818 if (
level
 == 3)

1820 
udp_rn
->
get_object_def
 = 
udpentry_get_object_def
;

1821 
udp_rn
->
get_value
 = 
udpentry_get_value
;

1822 
udp_rn
->
set_test
 = 
noleafs_set_test
;

1823 
udp_rn
->
set_value
 = 
noleafs_set_value
;

1829 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("snmp_insert_udpidx_tree() insert failed, mem full"));

1835 
udp_rn
 = (struct 
mib_list_rootnode
*)
udp_node
->
nptr
;

1839 
udptable
.
maxlength
 = 1;

1840 
	}
}

1846 void 
	$snmp_delete_udpidx_tree
(struct 
udp_pcb
 *
pcb
)

1848 struct 
mib_list_rootnode
 *
udp_rn
, *
next
, *
del_rn
[5];

1849 struct 
mib_list_node
 *
udp_n
, *
del_n
[5];

1850 struct 
ip_addr
 
ip
;

1851 
s32_t
 
udpidx
[5];

1852 
u8_t
 
bindings
, 
fc
, 
level
, 
del_cnt
;

1854 
	`LWIP_ASSERT
("pcb != NULL", 
pcb
 != 
NULL
);

1855 
ip
.
addr
 = 
	`ntohl
(
pcb
->
local_ip
.addr);

1856 
	`snmp_iptooid
(&
ip
, &
udpidx
[0]);

1857 
udpidx
[4] = 
pcb
->
local_port
;

1861 
bindings
 = 0;

1862 
pcb
 = 
udp_pcbs
;

1863 while ((
pcb
 != 
NULL
))

1865 if ((
pcb
->
local_ip
.
addr
 == 
ip
.addr) &&

1866 (
pcb
->
local_port
 == 
udpidx
[4]))

1868 
bindings
++;

1870 
pcb
 = pcb->
next
;

1872 if (
bindings
 == 1)

1876 
level
 = 0;

1877 
del_cnt
 = 0;

1878 
udp_rn
 = &
udp_root
;

1879 while ((
level
 < 5) && (
udp_rn
 != 
NULL
))

1881 
fc
 = 
	`snmp_mib_node_find
(
udp_rn
, 
udpidx
[
level
], &
udp_n
);

1882 if (
fc
 == 0)

1885 
del_cnt
 = 0;

1886 
udp_rn
 = 
NULL
;

1888 else if (
fc
 == 1)

1890 
del_rn
[
del_cnt
] = 
udp_rn
;

1891 
del_n
[
del_cnt
] = 
udp_n
;

1892 
del_cnt
++;

1893 
udp_rn
 = (struct 
mib_list_rootnode
*)(
udp_n
->
nptr
);

1895 else if (
fc
 == 2)

1898 
del_cnt
 = 0;

1899 
udp_rn
 = (struct 
mib_list_rootnode
*)(
udp_n
->
nptr
);

1901 
level
++;

1904 while (
del_cnt
 > 0)

1906 
del_cnt
--;

1908 
udp_rn
 = 
del_rn
[
del_cnt
];

1909 
udp_n
 = 
del_n
[
del_cnt
];

1911 
next
 = 
	`snmp_mib_node_delete
(
udp_rn
, 
udp_n
);

1912 if (
next
 != 
NULL
)

1914 
	`LWIP_ASSERT
("next_count == 0",
next
->
count
 == 0);

1915 
	`snmp_mib_lrn_free
(
next
);

1920 if (
udp_root
.
count
 == 0) 
udptable
.
maxlength
 = 0;

1921 
	}
}

1924 void 
	$snmp_inc_snmpinpkts
(void)

1926 
snmpinpkts
++;

1927 
	}
}

1929 void 
	$snmp_inc_snmpoutpkts
(void)

1931 
snmpoutpkts
++;

1932 
	}
}

1934 void 
	$snmp_inc_snmpinbadversions
(void)

1936 
snmpinbadversions
++;

1937 
	}
}

1939 void 
	$snmp_inc_snmpinbadcommunitynames
(void)

1941 
snmpinbadcommunitynames
++;

1942 
	}
}

1944 void 
	$snmp_inc_snmpinbadcommunityuses
(void)

1946 
snmpinbadcommunityuses
++;

1947 
	}
}

1949 void 
	$snmp_inc_snmpinasnparseerrs
(void)

1951 
snmpinasnparseerrs
++;

1952 
	}
}

1954 void 
	$snmp_inc_snmpintoobigs
(void)

1956 
snmpintoobigs
++;

1957 
	}
}

1959 void 
	$snmp_inc_snmpinnosuchnames
(void)

1961 
snmpinnosuchnames
++;

1962 
	}
}

1964 void 
	$snmp_inc_snmpinbadvalues
(void)

1966 
snmpinbadvalues
++;

1967 
	}
}

1969 void 
	$snmp_inc_snmpinreadonlys
(void)

1971 
snmpinreadonlys
++;

1972 
	}
}

1974 void 
	$snmp_inc_snmpingenerrs
(void)

1976 
snmpingenerrs
++;

1977 
	}
}

1979 void 
	$snmp_add_snmpintotalreqvars
(
u8_t
 
value
)

1981 
snmpintotalreqvars
 += 
value
;

1982 
	}
}

1984 void 
	$snmp_add_snmpintotalsetvars
(
u8_t
 
value
)

1986 
snmpintotalsetvars
 += 
value
;

1987 
	}
}

1989 void 
	$snmp_inc_snmpingetrequests
(void)

1991 
snmpingetrequests
++;

1992 
	}
}

1994 void 
	$snmp_inc_snmpingetnexts
(void)

1996 
snmpingetnexts
++;

1997 
	}
}

1999 void 
	$snmp_inc_snmpinsetrequests
(void)

2001 
snmpinsetrequests
++;

2002 
	}
}

2004 void 
	$snmp_inc_snmpingetresponses
(void)

2006 
snmpingetresponses
++;

2007 
	}
}

2009 void 
	$snmp_inc_snmpintraps
(void)

2011 
snmpintraps
++;

2012 
	}
}

2014 void 
	$snmp_inc_snmpouttoobigs
(void)

2016 
snmpouttoobigs
++;

2017 
	}
}

2019 void 
	$snmp_inc_snmpoutnosuchnames
(void)

2021 
snmpoutnosuchnames
++;

2022 
	}
}

2024 void 
	$snmp_inc_snmpoutbadvalues
(void)

2026 
snmpoutbadvalues
++;

2027 
	}
}

2029 void 
	$snmp_inc_snmpoutgenerrs
(void)

2031 
snmpoutgenerrs
++;

2032 
	}
}

2034 void 
	$snmp_inc_snmpoutgetrequests
(void)

2036 
snmpoutgetrequests
++;

2037 
	}
}

2039 void 
	$snmp_inc_snmpoutgetnexts
(void)

2041 
snmpoutgetnexts
++;

2042 
	}
}

2044 void 
	$snmp_inc_snmpoutsetrequests
(void)

2046 
snmpoutsetrequests
++;

2047 
	}
}

2049 void 
	$snmp_inc_snmpoutgetresponses
(void)

2051 
snmpoutgetresponses
++;

2052 
	}
}

2054 void 
	$snmp_inc_snmpouttraps
(void)

2056 
snmpouttraps
++;

2057 
	}
}

2059 void 
	$snmp_get_snmpgrpid_ptr
(struct 
snmp_obj_id
 **
oid
)

2061 *
oid
 = &
snmpgrp_id
;

2062 
	}
}

2064 void 
	$snmp_set_snmpenableauthentraps
(
u8_t
 *
value
)

2066 if (
value
 != 
NULL
)

2068 
snmpenableauthentraps_ptr
 = 
value
;

2070 
	}
}

2072 void 
	$snmp_get_snmpenableauthentraps
(
u8_t
 *
value
)

2074 *
value
 = *
snmpenableauthentraps_ptr
;

2075 
	}
}

2078 
	$noleafs_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

2080 if (
ident_len
){}

2081 if (
ident
){}

2082 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2083 
	}
}

2086 
	$noleafs_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2088 if (
od
){}

2089 if (
len
){}

2090 if (
value
){}

2091 
	}
}

2093 
u8_t


2094 
	$noleafs_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2096 if (
od
){}

2097 if (
len
){}

2098 if (
value
){}

2101 
	}
}

2104 
	$noleafs_set_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2106 if (
od
){}

2107 if (
len
){}

2108 if (
value
){}

2109 
	}
}

2120 
	$system_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

2122 
u8_t
 
id
;

2125 
ident_len
 += 1;

2126 
ident
 -= 1;

2127 if (
ident_len
 == 2)

2129 
od
->
id_inst_len
 = 
ident_len
;

2130 
od
->
id_inst_ptr
 = 
ident
;

2132 
id
 = 
ident
[0];

2133 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("get_object_def system.%"
U16_F
".0\n",(
u16_t
)
id
));

2134 switch (
id
)

2137 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2138 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2139 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

2140 
od
->
v_len
 = *
sysdescr_len_ptr
;

2143 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2144 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2145 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
);

2146 
od
->
v_len
 = 
sysobjid
.
len
 * sizeof(
s32_t
);

2149 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2150 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2151 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_TIMETICKS
);

2152 
od
->
v_len
 = sizeof(
u32_t
);

2155 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2156 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2157 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

2158 
od
->
v_len
 = *
syscontact_len_ptr
;

2161 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2162 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2163 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

2164 
od
->
v_len
 = *
sysname_len_ptr
;

2167 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2168 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2169 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

2170 
od
->
v_len
 = *
syslocation_len_ptr
;

2173 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2174 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2175 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

2176 
od
->
v_len
 = sizeof(
s32_t
);

2179 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("system_get_object_def: no such object\n"));

2180 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2186 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("system_get_object_def: no scalar\n"));

2187 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2189 
	}
}

2200 
	$system_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2202 
u8_t
 
id
;

2204 
id
 = 
od
->
id_inst_ptr
[0];

2205 switch (
id
)

2208 
	`ocstrncpy
(
value
,
sysdescr_ptr
,
len
);

2211 
	`objectidncpy
((
s32_t
*)
value
,(s32_t*)
sysobjid
.
id
,
len
 / sizeof(s32_t));

2215 
	`snmp_get_sysuptime
(
value
);

2219 
	`ocstrncpy
(
value
,
syscontact_ptr
,
len
);

2222 
	`ocstrncpy
(
value
,
sysname_ptr
,
len
);

2225 
	`ocstrncpy
(
value
,
syslocation_ptr
,
len
);

2229 
s32_t
 *
sint_ptr
 = 
value
;

2230 *
sint_ptr
 = 
sysservices
;

2234 
	}
}

2236 static 
u8_t


2237 
	$system_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2239 
u8_t
 
id
, 
set_ok
;

2241 if (
value
) {}

2242 
set_ok
 = 0;

2243 
id
 = 
od
->
id_inst_ptr
[0];

2244 switch (
id
)

2247 if ((
syscontact_ptr
 != 
syscontact_default
) &&

2248 (
len
 <= 255))

2250 
set_ok
 = 1;

2254 if ((
sysname_ptr
 != 
sysname_default
) &&

2255 (
len
 <= 255))

2257 
set_ok
 = 1;

2261 if ((
syslocation_ptr
 != 
syslocation_default
) &&

2262 (
len
 <= 255))

2264 
set_ok
 = 1;

2268 return 
set_ok
;

2269 
	}
}

2272 
	$system_set_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2274 
u8_t
 
id
;

2276 
id
 = 
od
->
id_inst_ptr
[0];

2277 switch (
id
)

2280 
	`ocstrncpy
(
syscontact_ptr
,
value
,
len
);

2281 *
syscontact_len_ptr
 = 
len
;

2284 
	`ocstrncpy
(
sysname_ptr
,
value
,
len
);

2285 *
sysname_len_ptr
 = 
len
;

2288 
	`ocstrncpy
(
syslocation_ptr
,
value
,
len
);

2289 *
syslocation_len_ptr
 = 
len
;

2292 
	}
}

2302 
	$interfaces_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

2305 
ident_len
 += 1;

2306 
ident
 -= 1;

2307 if (
ident_len
 == 2)

2309 
od
->
id_inst_len
 = 
ident_len
;

2310 
od
->
id_inst_ptr
 = 
ident
;

2312 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2313 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2314 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

2315 
od
->
v_len
 = sizeof(
s32_t
);

2319 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("interfaces_get_object_def: no scalar\n"));

2320 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2322 
	}
}

2333 
	$interfaces_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2335 if (
len
){}

2336 if (
od
->
id_inst_ptr
[0] == 1)

2338 
s32_t
 *
sint_ptr
 = 
value
;

2339 *
sint_ptr
 = 
iflist_root
.
count
;

2341 
	}
}

2351 
	$ifentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

2353 
u8_t
 
id
;

2356 
ident_len
 += 1;

2357 
ident
 -= 1;

2358 if (
ident_len
 == 2)

2360 
od
->
id_inst_len
 = 
ident_len
;

2361 
od
->
id_inst_ptr
 = 
ident
;

2363 
id
 = 
ident
[0];

2364 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("get_object_def ifentry.%"
U16_F
"\n",(
u16_t
)
id
));

2365 switch (
id
)

2371 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2372 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2373 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

2374 
od
->
v_len
 = sizeof(
s32_t
);

2377 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2378 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2379 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

2381 
od
->
v_len
 = 2;

2385 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2386 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2387 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_GAUGE
);

2388 
od
->
v_len
 = sizeof(
u32_t
);

2392 struct 
netif
 *netif;

2394 
	`snmp_ifindextonetif
(
ident
[1], &
netif
);

2395 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2396 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2397 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

2398 
od
->
v_len
 = 
netif
->
hwaddr_len
;

2402 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2403 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2404 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

2405 
od
->
v_len
 = sizeof(
s32_t
);

2408 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2409 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2410 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_TIMETICKS
);

2411 
od
->
v_len
 = sizeof(
u32_t
);

2424 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2425 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2426 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
);

2427 
od
->
v_len
 = sizeof(
u32_t
);

2431 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2432 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2433 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
);

2434 
od
->
v_len
 = 
ifspecific
.
len
 * sizeof(
s32_t
);

2437 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ifentry_get_object_def: no such object\n"));

2438 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2444 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ifentry_get_object_def: no scalar\n"));

2445 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2447 
	}
}

2458 
	$ifentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2460 struct 
netif
 *netif;

2461 
u8_t
 
id
;

2463 
	`snmp_ifindextonetif
(
od
->
id_inst_ptr
[1], &
netif
);

2464 
id
 = 
od
->
id_inst_ptr
[0];

2465 switch (
id
)

2469 
s32_t
 *
sint_ptr
 = 
value
;

2470 *
sint_ptr
 = 
od
->
id_inst_ptr
[1];

2474 
	`ocstrncpy
(
value
,(
u8_t
*)
netif
->
name
,
len
);

2478 
s32_t
 *
sint_ptr
 = 
value
;

2479 *
sint_ptr
 = 
netif
->
link_type
;

2484 
s32_t
 *
sint_ptr
 = 
value
;

2485 *
sint_ptr
 = 
netif
->
mtu
;

2490 
u32_t
 *
uint_ptr
 = 
value
;

2491 *
uint_ptr
 = 
netif
->
link_speed
;

2495 
	`ocstrncpy
(
value
,
netif
->
hwaddr
,
len
);

2498 #if 
LWIP_NETIF_LINK_CALLBACK


2500 
s32_t
 *
sint_ptr
 = 
value
;

2501 if (
	`netif_is_up
(
netif
))

2503 if (
	`netif_is_link_up
(
netif
))

2505 *
sint_ptr
 = 1;

2509 *
sint_ptr
 = 7;

2514 *
sint_ptr
 = 2;

2521 
s32_t
 *
sint_ptr
 = 
value
;

2522 if (
	`netif_is_up
(
netif
))

2524 *
sint_ptr
 = 1;

2528 *
sint_ptr
 = 2;

2534 
u32_t
 *
uint_ptr
 = 
value
;

2535 *
uint_ptr
 = 
netif
->
ts
;

2540 
u32_t
 *
uint_ptr
 = 
value
;

2541 *
uint_ptr
 = 
netif
->
ifinoctets
;

2546 
u32_t
 *
uint_ptr
 = 
value
;

2547 *
uint_ptr
 = 
netif
->
ifinucastpkts
;

2552 
u32_t
 *
uint_ptr
 = 
value
;

2553 *
uint_ptr
 = 
netif
->
ifinnucastpkts
;

2558 
u32_t
 *
uint_ptr
 = 
value
;

2559 *
uint_ptr
 = 
netif
->
ifindiscards
;

2566 
u32_t
 *
uint_ptr
 = 
value
;

2567 *
uint_ptr
 = 0;

2572 
u32_t
 *
uint_ptr
 = 
value
;

2573 *
uint_ptr
 = 
netif
->
ifoutoctets
;

2578 
u32_t
 *
uint_ptr
 = 
value
;

2579 *
uint_ptr
 = 
netif
->
ifoutucastpkts
;

2584 
u32_t
 *
uint_ptr
 = 
value
;

2585 *
uint_ptr
 = 
netif
->
ifoutnucastpkts
;

2590 
u32_t
 *
uint_ptr
 = 
value
;

2591 *
uint_ptr
 = 
netif
->
ifoutdiscards
;

2597 
u32_t
 *
uint_ptr
 = 
value
;

2598 *
uint_ptr
 = 0;

2604 
u32_t
 *
uint_ptr
 = 
value
;

2605 *
uint_ptr
 = 0;

2609 
	`objectidncpy
((
s32_t
*)
value
,(s32_t*)
ifspecific
.
id
,
len
 / sizeof(s32_t));

2612 
	}
}

2614 #if !
SNMP_SAFE_REQUESTS


2615 static 
u8_t


2616 
	$ifentry_set_test
 (struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2618 struct 
netif
 *netif;

2619 
u8_t
 
id
, 
set_ok
;

2621 
set_ok
 = 0;

2622 
	`snmp_ifindextonetif
(
od
->
id_inst_ptr
[1], &
netif
);

2623 
id
 = 
od
->
id_inst_ptr
[0];

2624 switch (
id
)

2628 
s32_t
 *
sint_ptr
 = 
value
;

2629 if (*
sint_ptr
 == 1 || *sint_ptr == 2)

2630 
set_ok
 = 1;

2634 return 
set_ok
;

2635 
	}
}

2638 
	$ifentry_set_value
 (struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2640 struct 
netif
 *netif;

2641 
u8_t
 
id
;

2643 
	`snmp_ifindextonetif
(
od
->
id_inst_ptr
[1], &
netif
);

2644 
id
 = 
od
->
id_inst_ptr
[0];

2645 switch (
id
)

2649 
s32_t
 *
sint_ptr
 = 
value
;

2650 if (*
sint_ptr
 == 1)

2652 
	`netif_set_up
(
netif
);

2654 else if (*
sint_ptr
 == 2)

2656 
	`netif_set_down
(
netif
);

2661 
	}
}

2672 
	$atentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

2675 
ident_len
 += 5;

2676 
ident
 -= 5;

2678 if (
ident_len
 == 6)

2680 
od
->
id_inst_len
 = 
ident_len
;

2681 
od
->
id_inst_ptr
 = 
ident
;

2683 switch (
ident
[0])

2686 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2687 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2688 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

2689 
od
->
v_len
 = sizeof(
s32_t
);

2692 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2693 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2694 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

2695 
od
->
v_len
 = 6;

2698 
od
->
instance
 = 
MIB_OBJECT_TAB
;

2699 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2700 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
);

2701 
od
->
v_len
 = 4;

2704 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("atentry_get_object_def: no such object\n"));

2705 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2711 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("atentry_get_object_def: no scalar\n"));

2712 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2714 
	}
}

2717 
	$atentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2719 #if 
LWIP_ARP


2720 
u8_t
 
id
;

2721 struct 
eth_addr
* 
ethaddr_ret
;

2722 struct 
ip_addr
* 
ipaddr_ret
;

2724 struct 
ip_addr
 
ip
;

2725 struct 
netif
 *netif;

2727 if (
len
) {}

2729 
	`snmp_ifindextonetif
(
od
->
id_inst_ptr
[1], &
netif
);

2730 
	`snmp_oidtoip
(&
od
->
id_inst_ptr
[2], &
ip
);

2731 
ip
.
addr
 = 
	`htonl
(ip.addr);

2733 #if 
LWIP_ARP


2734 if (
	`etharp_find_addr
(
netif
, &
ip
, &
ethaddr_ret
, &
ipaddr_ret
) > -1)

2736 
id
 = 
od
->
id_inst_ptr
[0];

2737 switch (
id
)

2741 
s32_t
 *
sint_ptr
 = 
value
;

2742 *
sint_ptr
 = 
od
->
id_inst_ptr
[1];

2747 struct 
eth_addr
 *
dst
 = 
value
;

2749 *
dst
 = *
ethaddr_ret
;

2754 struct 
ip_addr
 *
dst
 = 
value
;

2756 *
dst
 = *
ipaddr_ret
;

2762 
	}
}

2765 
	$ip_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

2767 
u8_t
 
id
;

2770 
ident_len
 += 1;

2771 
ident
 -= 1;

2772 if (
ident_len
 == 2)

2774 
od
->
id_inst_len
 = 
ident_len
;

2775 
od
->
id_inst_ptr
 = 
ident
;

2777 
id
 = 
ident
[0];

2778 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("get_object_def ip.%"
U16_F
".0\n",(
u16_t
)
id
));

2779 switch (
id
)

2783 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2784 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

2785 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

2786 
od
->
v_len
 = sizeof(
s32_t
);

2805 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2806 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2807 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
);

2808 
od
->
v_len
 = sizeof(
u32_t
);

2811 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

2812 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

2813 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

2814 
od
->
v_len
 = sizeof(
s32_t
);

2817 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_get_object_def: no such object\n"));

2818 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2824 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_get_object_def: no scalar\n"));

2825 
od
->
instance
 = 
MIB_OBJECT_NONE
;

2827 
	}
}

2830 
	$ip_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2832 
u8_t
 
id
;

2834 if (
len
) {}

2835 
id
 = 
od
->
id_inst_ptr
[0];

2836 switch (
id
)

2840 
s32_t
 *
sint_ptr
 = 
value
;

2841 #if 
IP_FORWARD


2843 *
sint_ptr
 = 1;

2846 *
sint_ptr
 = 2;

2852 
s32_t
 *
sint_ptr
 = 
value
;

2853 *
sint_ptr
 = 
IP_DEFAULT_TTL
;

2858 
u32_t
 *
uint_ptr
 = 
value
;

2859 *
uint_ptr
 = 
ipinreceives
;

2864 
u32_t
 *
uint_ptr
 = 
value
;

2865 *
uint_ptr
 = 
ipinhdrerrors
;

2870 
u32_t
 *
uint_ptr
 = 
value
;

2871 *
uint_ptr
 = 
ipinaddrerrors
;

2876 
u32_t
 *
uint_ptr
 = 
value
;

2877 *
uint_ptr
 = 
ipforwdatagrams
;

2882 
u32_t
 *
uint_ptr
 = 
value
;

2883 *
uint_ptr
 = 
ipinunknownprotos
;

2888 
u32_t
 *
uint_ptr
 = 
value
;

2889 *
uint_ptr
 = 
ipindiscards
;

2894 
u32_t
 *
uint_ptr
 = 
value
;

2895 *
uint_ptr
 = 
ipindelivers
;

2900 
u32_t
 *
uint_ptr
 = 
value
;

2901 *
uint_ptr
 = 
ipoutrequests
;

2906 
u32_t
 *
uint_ptr
 = 
value
;

2907 *
uint_ptr
 = 
ipoutdiscards
;

2912 
u32_t
 *
uint_ptr
 = 
value
;

2913 *
uint_ptr
 = 
ipoutnoroutes
;

2918 
s32_t
 *
sint_ptr
 = 
value
;

2919 #if 
IP_REASSEMBLY


2920 *
sint_ptr
 = 
IP_REASS_MAXAGE
;

2922 *
sint_ptr
 = 0;

2928 
u32_t
 *
uint_ptr
 = 
value
;

2929 *
uint_ptr
 = 
ipreasmreqds
;

2934 
u32_t
 *
uint_ptr
 = 
value
;

2935 *
uint_ptr
 = 
ipreasmoks
;

2940 
u32_t
 *
uint_ptr
 = 
value
;

2941 *
uint_ptr
 = 
ipreasmfails
;

2946 
u32_t
 *
uint_ptr
 = 
value
;

2947 *
uint_ptr
 = 
ipfragoks
;

2952 
u32_t
 *
uint_ptr
 = 
value
;

2953 *
uint_ptr
 = 
ipfragfails
;

2958 
u32_t
 *
uint_ptr
 = 
value
;

2959 *
uint_ptr
 = 
ipfragcreates
;

2965 
u32_t
 *
uint_ptr
 = 
value
;

2966 *
uint_ptr
 = 
iproutingdiscards
;

2970 
	}
}

2982 static 
u8_t


2983 
	$ip_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

2985 
u8_t
 
id
, 
set_ok
;

2986 
s32_t
 *
sint_ptr
 = 
value
;

2988 if (
len
) {}

2989 
set_ok
 = 0;

2990 
id
 = 
od
->
id_inst_ptr
[0];

2991 switch (
id
)

2994 #if 
IP_FORWARD


2996 if (*
sint_ptr
 == 1)

2999 if (*
sint_ptr
 == 2)

3002 
set_ok
 = 1;

3006 if (*
sint_ptr
 == 
IP_DEFAULT_TTL
)

3008 
set_ok
 = 1;

3012 return 
set_ok
;

3013 
	}
}

3016 
	$ip_addrentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3019 
ident_len
 += 4;

3020 
ident
 -= 4;

3022 if (
ident_len
 == 5)

3024 
u8_t
 
id
;

3026 
od
->
id_inst_len
 = 
ident_len
;

3027 
od
->
id_inst_ptr
 = 
ident
;

3029 
id
 = 
ident
[0];

3030 switch (
id
)

3034 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3035 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3036 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
);

3037 
od
->
v_len
 = 4;

3042 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3043 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3044 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3045 
od
->
v_len
 = sizeof(
s32_t
);

3048 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_addrentry_get_object_def: no such object\n"));

3049 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3055 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_addrentry_get_object_def: no scalar\n"));

3056 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3058 
	}
}

3061 
	$ip_addrentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3063 
u8_t
 
id
;

3064 
u16_t
 
ifidx
;

3065 struct 
ip_addr
 
ip
;

3066 struct 
netif
 *netif = 
netif_list
;

3068 if (
len
) {}

3069 
	`snmp_oidtoip
(&
od
->
id_inst_ptr
[1], &
ip
);

3070 
ip
.
addr
 = 
	`htonl
(ip.addr);

3071 
ifidx
 = 0;

3072 while ((
netif
 != 
NULL
) && !
	`ip_addr_cmp
(&
ip
, &netif->
ip_addr
))

3074 
netif
 = netif->
next
;

3075 
ifidx
++;

3078 if (
netif
 != 
NULL
)

3080 
id
 = 
od
->
id_inst_ptr
[0];

3081 switch (
id
)

3085 struct 
ip_addr
 *
dst
 = 
value
;

3086 *
dst
 = 
netif
->
ip_addr
;

3091 
s32_t
 *
sint_ptr
 = 
value
;

3092 *
sint_ptr
 = 
ifidx
 + 1;

3097 struct 
ip_addr
 *
dst
 = 
value
;

3098 *
dst
 = 
netif
->
netmask
;

3103 
s32_t
 *
sint_ptr
 = 
value
;

3107 *
sint_ptr
 = 
ip_addr_broadcast
.
addr
 & 1;

3112 
s32_t
 *
sint_ptr
 = 
value
;

3113 #if 
IP_REASSEMBLY


3118 *
sint_ptr
 = (
IP_HLEN
 + ((
IP_REASS_MAX_PBUFS
/2) *

3119 (
PBUF_POOL_BUFSIZE
 - 
PBUF_LINK_HLEN
 - 
IP_HLEN
)));

3123 *
sint_ptr
 = 0;

3129 
	}
}

3137 
	$ip_rteentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3139 
u8_t
 
id
;

3142 
ident_len
 += 4;

3143 
ident
 -= 4;

3145 if (
ident_len
 == 5)

3147 
od
->
id_inst_len
 = 
ident_len
;

3148 
od
->
id_inst_ptr
 = 
ident
;

3150 
id
 = 
ident
[0];

3151 switch (
id
)

3156 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3157 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

3158 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
);

3159 
od
->
v_len
 = 4;

3169 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3170 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

3171 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3172 
od
->
v_len
 = sizeof(
s32_t
);

3175 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3176 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3177 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3178 
od
->
v_len
 = sizeof(
s32_t
);

3182 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3183 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3184 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
);

3185 
od
->
v_len
 = 
iprouteinfo
.
len
 * sizeof(
s32_t
);

3188 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_rteentry_get_object_def: no such object\n"));

3189 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3195 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_rteentry_get_object_def: no scalar\n"));

3196 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3198 
	}
}

3201 
	$ip_rteentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3203 struct 
netif
 *netif;

3204 struct 
ip_addr
 
dest
;

3205 
s32_t
 *
ident
;

3206 
u8_t
 
id
;

3208 
ident
 = 
od
->
id_inst_ptr
;

3209 
	`snmp_oidtoip
(&
ident
[1], &
dest
);

3210 
dest
.
addr
 = 
	`htonl
(dest.addr);

3212 if (
dest
.
addr
 == 0)

3215 
netif
 = 
netif_default
;

3220 
netif
 = 
netif_list
;

3221 while ((
netif
 != 
NULL
) &&

3222 !
	`ip_addr_netcmp
(&
dest
, &(
netif
->
ip_addr
), &(netif->
netmask
)) )

3224 
netif
 = netif->
next
;

3227 if (
netif
 != 
NULL
)

3229 
id
 = 
ident
[0];

3230 switch (
id
)

3234 struct 
ip_addr
 *
dst
 = 
value
;

3236 if (
dest
.
addr
 == 0)

3239 
dst
->
addr
 = 0;

3244 
dst
->
addr
 = 
netif
->
ip_addr
.addr & netif->
netmask
.addr;

3250 
s32_t
 *
sint_ptr
 = 
value
;

3252 
	`snmp_netiftoifindex
(
netif
, 
sint_ptr
);

3257 
s32_t
 *
sint_ptr
 = 
value
;

3259 if (
dest
.
addr
 == 0)

3262 *
sint_ptr
 = 1;

3267 *
sint_ptr
 = 0;

3276 
s32_t
 *
sint_ptr
 = 
value
;

3278 *
sint_ptr
 = -1;

3283 struct 
ip_addr
 *
dst
 = 
value
;

3285 if (
dest
.
addr
 == 0)

3288 *
dst
 = 
netif
->
gw
;

3293 *
dst
 = 
netif
->
ip_addr
;

3299 
s32_t
 *
sint_ptr
 = 
value
;

3301 if (
dest
.
addr
 == 0)

3304 *
sint_ptr
 = 4;

3309 *
sint_ptr
 = 3;

3315 
s32_t
 *
sint_ptr
 = 
value
;

3317 *
sint_ptr
 = 2;

3322 
s32_t
 *
sint_ptr
 = 
value
;

3325 *
sint_ptr
 = 0;

3330 struct 
ip_addr
 *
dst
 = 
value
;

3332 if (
dest
.
addr
 == 0)

3335 
dst
->
addr
 = 0;

3340 *
dst
 = 
netif
->
netmask
;

3345 
	`objectidncpy
((
s32_t
*)
value
,(s32_t*)
iprouteinfo
.
id
,
len
 / sizeof(s32_t));

3349 
	}
}

3352 
	$ip_ntomentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3355 
ident_len
 += 5;

3356 
ident
 -= 5;

3358 if (
ident_len
 == 6)

3360 
u8_t
 
id
;

3362 
od
->
id_inst_len
 = 
ident_len
;

3363 
od
->
id_inst_ptr
 = 
ident
;

3365 
id
 = 
ident
[0];

3366 switch (
id
)

3370 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3371 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

3372 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3373 
od
->
v_len
 = sizeof(
s32_t
);

3376 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3377 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

3378 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
);

3379 
od
->
v_len
 = 6;

3382 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3383 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

3384 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
);

3385 
od
->
v_len
 = 4;

3388 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_ntomentry_get_object_def: no such object\n"));

3389 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3395 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ip_ntomentry_get_object_def: no scalar\n"));

3396 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3398 
	}
}

3401 
	$ip_ntomentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3403 #if 
LWIP_ARP


3404 
u8_t
 
id
;

3405 struct 
eth_addr
* 
ethaddr_ret
;

3406 struct 
ip_addr
* 
ipaddr_ret
;

3408 struct 
ip_addr
 
ip
;

3409 struct 
netif
 *netif;

3411 if (
len
) {}

3413 
	`snmp_ifindextonetif
(
od
->
id_inst_ptr
[1], &
netif
);

3414 
	`snmp_oidtoip
(&
od
->
id_inst_ptr
[2], &
ip
);

3415 
ip
.
addr
 = 
	`htonl
(ip.addr);

3417 #if 
LWIP_ARP


3418 if (
	`etharp_find_addr
(
netif
, &
ip
, &
ethaddr_ret
, &
ipaddr_ret
) > -1)

3420 
id
 = 
od
->
id_inst_ptr
[0];

3421 switch (
id
)

3425 
s32_t
 *
sint_ptr
 = 
value
;

3426 *
sint_ptr
 = 
od
->
id_inst_ptr
[1];

3431 struct 
eth_addr
 *
dst
 = 
value
;

3433 *
dst
 = *
ethaddr_ret
;

3438 struct 
ip_addr
 *
dst
 = 
value
;

3440 *
dst
 = *
ipaddr_ret
;

3445 
s32_t
 *
sint_ptr
 = 
value
;

3447 *
sint_ptr
 = 3;

3453 
	}
}

3456 
	$icmp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3459 
ident_len
 += 1;

3460 
ident
 -= 1;

3461 if ((
ident_len
 == 2) &&

3462 (
ident
[0] > 0) && (ident[0] < 27))

3464 
od
->
id_inst_len
 = 
ident_len
;

3465 
od
->
id_inst_ptr
 = 
ident
;

3467 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

3468 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3469 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
);

3470 
od
->
v_len
 = sizeof(
u32_t
);

3474 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("icmp_get_object_def: no scalar\n"));

3475 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3477 
	}
}

3480 
	$icmp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3482 
u32_t
 *
uint_ptr
 = 
value
;

3483 
u8_t
 
id
;

3485 if (
len
){}

3486 
id
 = 
od
->
id_inst_ptr
[0];

3487 switch (
id
)

3490 *
uint_ptr
 = 
icmpinmsgs
;

3493 *
uint_ptr
 = 
icmpinerrors
;

3496 *
uint_ptr
 = 
icmpindestunreachs
;

3499 *
uint_ptr
 = 
icmpintimeexcds
;

3502 *
uint_ptr
 = 
icmpinparmprobs
;

3505 *
uint_ptr
 = 
icmpinsrcquenchs
;

3508 *
uint_ptr
 = 
icmpinredirects
;

3511 *
uint_ptr
 = 
icmpinechos
;

3514 *
uint_ptr
 = 
icmpinechoreps
;

3517 *
uint_ptr
 = 
icmpintimestamps
;

3520 *
uint_ptr
 = 
icmpintimestampreps
;

3523 *
uint_ptr
 = 
icmpinaddrmasks
;

3526 *
uint_ptr
 = 
icmpinaddrmaskreps
;

3529 *
uint_ptr
 = 
icmpoutmsgs
;

3532 *
uint_ptr
 = 
icmpouterrors
;

3535 *
uint_ptr
 = 
icmpoutdestunreachs
;

3538 *
uint_ptr
 = 
icmpouttimeexcds
;

3541 *
uint_ptr
 = 
icmpoutparmprobs
;

3544 *
uint_ptr
 = 
icmpoutsrcquenchs
;

3547 *
uint_ptr
 = 
icmpoutredirects
;

3550 *
uint_ptr
 = 
icmpoutechos
;

3553 *
uint_ptr
 = 
icmpoutechoreps
;

3556 *
uint_ptr
 = 
icmpouttimestamps
;

3559 *
uint_ptr
 = 
icmpouttimestampreps
;

3562 *
uint_ptr
 = 
icmpoutaddrmasks
;

3565 *
uint_ptr
 = 
icmpoutaddrmaskreps
;

3568 
	}
}

3570 #if 
LWIP_TCP


3573 
	$tcp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3575 
u8_t
 
id
;

3578 
ident_len
 += 1;

3579 
ident
 -= 1;

3580 if (
ident_len
 == 2)

3582 
od
->
id_inst_len
 = 
ident_len
;

3583 
od
->
id_inst_ptr
 = 
ident
;

3585 
id
 = 
ident
[0];

3586 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("get_object_def tcp.%"
U16_F
".0\n",(
u16_t
)
id
));

3588 switch (
id
)

3594 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

3595 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3596 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3597 
od
->
v_len
 = sizeof(
s32_t
);

3608 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

3609 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3610 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
);

3611 
od
->
v_len
 = sizeof(
u32_t
);

3614 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3615 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3616 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_GAUGE
);

3617 
od
->
v_len
 = sizeof(
u32_t
);

3620 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("tcp_get_object_def: no such object\n"));

3621 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3627 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("tcp_get_object_def: no scalar\n"));

3628 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3630 
	}
}

3633 
	$tcp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3635 
u32_t
 *
uint_ptr
 = 
value
;

3636 
s32_t
 *
sint_ptr
 = 
value
;

3637 
u8_t
 
id
;

3639 if (
len
){}

3640 
id
 = 
od
->
id_inst_ptr
[0];

3641 switch (
id
)

3644 *
sint_ptr
 = 4;

3649 *
sint_ptr
 = 1000;

3654 *
sint_ptr
 = 60000;

3657 *
sint_ptr
 = 
MEMP_NUM_TCP_PCB
;

3660 *
uint_ptr
 = 
tcpactiveopens
;

3663 *
uint_ptr
 = 
tcppassiveopens
;

3666 *
uint_ptr
 = 
tcpattemptfails
;

3669 *
uint_ptr
 = 
tcpestabresets
;

3673 
u16_t
 
tcpcurrestab
 = 0;

3674 struct 
tcp_pcb
 *
pcb
 = 
tcp_active_pcbs
;

3675 while (
pcb
 != 
NULL
)

3677 if ((
pcb
->
state
 == 
ESTABLISHED
) ||

3678 (
pcb
->
state
 == 
CLOSE_WAIT
))

3680 
tcpcurrestab
++;

3682 
pcb
 = pcb->
next
;

3684 *
uint_ptr
 = 
tcpcurrestab
;

3688 *
uint_ptr
 = 
tcpinsegs
;

3691 *
uint_ptr
 = 
tcpoutsegs
;

3694 *
uint_ptr
 = 
tcpretranssegs
;

3697 *
uint_ptr
 = 
tcpinerrs
;

3700 *
uint_ptr
 = 
tcpoutrsts
;

3703 
	}
}

3704 #ifdef 
THIS_SEEMS_UNUSED


3706 
	$tcpconnentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3709 
ident_len
 += 10;

3710 
ident
 -= 10;

3712 if (
ident_len
 == 11)

3714 
u8_t
 
id
;

3716 
od
->
id_inst_len
 = 
ident_len
;

3717 
od
->
id_inst_ptr
 = 
ident
;

3719 
id
 = 
ident
[0];

3720 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("get_object_def tcp.%"
U16_F
".0\n",(
u16_t
)
id
));

3722 switch (
id
)

3725 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3726 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

3727 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3728 
od
->
v_len
 = sizeof(
s32_t
);

3732 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3733 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3734 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
);

3735 
od
->
v_len
 = 4;

3739 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3740 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3741 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3742 
od
->
v_len
 = sizeof(
s32_t
);

3745 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("tcpconnentry_get_object_def: no such object\n"));

3746 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3752 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("tcpconnentry_get_object_def: no such object\n"));

3753 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3755 
	}
}

3758 
	$tcpconnentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3760 struct 
ip_addr
 
lip
, 
rip
;

3761 
u16_t
 
lport
, 
rport
;

3762 
s32_t
 *
ident
;

3764 
ident
 = 
od
->
id_inst_ptr
;

3765 
	`snmp_oidtoip
(&
ident
[1], &
lip
);

3766 
lip
.
addr
 = 
	`htonl
(lip.addr);

3767 
lport
 = 
ident
[5];

3768 
	`snmp_oidtoip
(&
ident
[6], &
rip
);

3769 
rip
.
addr
 = 
	`htonl
(rip.addr);

3770 
rport
 = 
ident
[10];

3773 
	}
}

3778 
	$udp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3781 
ident_len
 += 1;

3782 
ident
 -= 1;

3783 if ((
ident_len
 == 2) &&

3784 (
ident
[0] > 0) && (ident[0] < 6))

3786 
od
->
id_inst_len
 = 
ident_len
;

3787 
od
->
id_inst_ptr
 = 
ident
;

3789 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

3790 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3791 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
);

3792 
od
->
v_len
 = sizeof(
u32_t
);

3796 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("udp_get_object_def: no scalar\n"));

3797 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3799 
	}
}

3802 
	$udp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3804 
u32_t
 *
uint_ptr
 = 
value
;

3805 
u8_t
 
id
;

3807 if (
len
){}

3808 
id
 = 
od
->
id_inst_ptr
[0];

3809 switch (
id
)

3812 *
uint_ptr
 = 
udpindatagrams
;

3815 *
uint_ptr
 = 
udpnoports
;

3818 *
uint_ptr
 = 
udpinerrors
;

3821 *
uint_ptr
 = 
udpoutdatagrams
;

3824 
	}
}

3827 
	$udpentry_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3830 
ident_len
 += 5;

3831 
ident
 -= 5;

3833 if (
ident_len
 == 6)

3835 
od
->
id_inst_len
 = 
ident_len
;

3836 
od
->
id_inst_ptr
 = 
ident
;

3838 switch (
ident
[0])

3841 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3842 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3843 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
);

3844 
od
->
v_len
 = 4;

3847 
od
->
instance
 = 
MIB_OBJECT_TAB
;

3848 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3849 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3850 
od
->
v_len
 = sizeof(
s32_t
);

3853 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("udpentry_get_object_def: no such object\n"));

3854 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3860 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("udpentry_get_object_def: no scalar\n"));

3861 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3863 
	}
}

3866 
	$udpentry_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3868 
u8_t
 
id
;

3869 struct 
udp_pcb
 *
pcb
;

3870 struct 
ip_addr
 
ip
;

3871 
u16_t
 
port
;

3873 if (
len
){}

3874 
	`snmp_oidtoip
(&
od
->
id_inst_ptr
[1], &
ip
);

3875 
ip
.
addr
 = 
	`htonl
(ip.addr);

3876 
port
 = 
od
->
id_inst_ptr
[5];

3878 
pcb
 = 
udp_pcbs
;

3879 while ((
pcb
 != 
NULL
) &&

3880 !((
pcb
->
local_ip
.
addr
 == 
ip
.addr) &&

3881 (
pcb
->
local_port
 == 
port
)))

3883 
pcb
 = pcb->
next
;

3886 if (
pcb
 != 
NULL
)

3888 
id
 = 
od
->
id_inst_ptr
[0];

3889 switch (
id
)

3893 struct 
ip_addr
 *
dst
 = 
value
;

3894 *
dst
 = 
pcb
->
local_ip
;

3899 
s32_t
 *
sint_ptr
 = 
value
;

3900 *
sint_ptr
 = 
pcb
->
local_port
;

3905 
	}
}

3908 
	$snmp_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
)

3911 
ident_len
 += 1;

3912 
ident
 -= 1;

3913 if (
ident_len
 == 2)

3915 
u8_t
 
id
;

3917 
od
->
id_inst_len
 = 
ident_len
;

3918 
od
->
id_inst_ptr
 = 
ident
;

3920 
id
 = 
ident
[0];

3921 switch (
id
)

3950 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

3951 
od
->
access
 = 
MIB_OBJECT_READ_ONLY
;

3952 
od
->
asn_type
 = (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
);

3953 
od
->
v_len
 = sizeof(
u32_t
);

3956 
od
->
instance
 = 
MIB_OBJECT_SCALAR
;

3957 
od
->
access
 = 
MIB_OBJECT_READ_WRITE
;

3958 
od
->
asn_type
 = (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
);

3959 
od
->
v_len
 = sizeof(
s32_t
);

3962 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("snmp_get_object_def: no such object\n"));

3963 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3969 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("snmp_get_object_def: no scalar\n"));

3970 
od
->
instance
 = 
MIB_OBJECT_NONE
;

3972 
	}
}

3975 
	$snmp_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

3977 
u32_t
 *
uint_ptr
 = 
value
;

3978 
u8_t
 
id
;

3980 if (
len
){}

3981 
id
 = 
od
->
id_inst_ptr
[0];

3982 switch (
id
)

3985 *
uint_ptr
 = 
snmpinpkts
;

3988 *
uint_ptr
 = 
snmpoutpkts
;

3991 *
uint_ptr
 = 
snmpinbadversions
;

3994 *
uint_ptr
 = 
snmpinbadcommunitynames
;

3997 *
uint_ptr
 = 
snmpinbadcommunityuses
;

4000 *
uint_ptr
 = 
snmpinasnparseerrs
;

4003 *
uint_ptr
 = 
snmpintoobigs
;

4006 *
uint_ptr
 = 
snmpinnosuchnames
;

4009 *
uint_ptr
 = 
snmpinbadvalues
;

4012 *
uint_ptr
 = 
snmpinreadonlys
;

4015 *
uint_ptr
 = 
snmpingenerrs
;

4018 *
uint_ptr
 = 
snmpintotalreqvars
;

4021 *
uint_ptr
 = 
snmpintotalsetvars
;

4024 *
uint_ptr
 = 
snmpingetrequests
;

4027 *
uint_ptr
 = 
snmpingetnexts
;

4030 *
uint_ptr
 = 
snmpinsetrequests
;

4033 *
uint_ptr
 = 
snmpingetresponses
;

4036 *
uint_ptr
 = 
snmpintraps
;

4039 *
uint_ptr
 = 
snmpouttoobigs
;

4042 *
uint_ptr
 = 
snmpoutnosuchnames
;

4045 *
uint_ptr
 = 
snmpoutbadvalues
;

4048 *
uint_ptr
 = 
snmpoutgenerrs
;

4051 *
uint_ptr
 = 
snmpoutgetrequests
;

4054 *
uint_ptr
 = 
snmpoutgetnexts
;

4057 *
uint_ptr
 = 
snmpoutsetrequests
;

4060 *
uint_ptr
 = 
snmpoutgetresponses
;

4063 *
uint_ptr
 = 
snmpouttraps
;

4066 *
uint_ptr
 = *
snmpenableauthentraps_ptr
;

4069 
	}
}

4078 static 
u8_t


4079 
	$snmp_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

4081 
u8_t
 
id
, 
set_ok
;

4083 if (
len
) {}

4084 
set_ok
 = 0;

4085 
id
 = 
od
->
id_inst_ptr
[0];

4086 if (
id
 == 30)

4089 
s32_t
 *
sint_ptr
 = 
value
;

4091 if (
snmpenableauthentraps_ptr
 != &
snmpenableauthentraps_default
)

4094 if ((*
sint_ptr
 == 1) || (*sint_ptr == 2))

4096 
set_ok
 = 1;

4102 if (*
sint_ptr
 == 
snmpenableauthentraps_default
)

4104 
set_ok
 = 1;

4108 return 
set_ok
;

4109 
	}
}

4112 
	$snmp_set_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
)

4114 
u8_t
 
id
;

4116 if (
len
) {}

4117 
id
 = 
od
->
id_inst_ptr
[0];

4118 if (
id
 == 30)

4121 
s32_t
 *
sint_ptr
 = 
value
;

4122 *
snmpenableauthentraps_ptr
 = *
sint_ptr
;

4124 
	}
}

	@/root/Robux/net/lwip/core/snmp/mib_structs.c

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_SNMP


39 #include 
	~"lwip/snmp_structs.h
"

40 #include 
	~"lwip/mem.h
"

43 const 
s32_t
 
	gprefix
[4] = {1, 3, 6, 1};

45 #define 
	#NODE_STACK_SIZE
 (
LWIP_SNMP_OBJ_ID_LEN
)

	)

47 struct 
	snse


50 struct 
mib_node
* 
	mr_ptr
;

52 
s32_t
 
	mr_id
;

54 
u8_t
 
	mr_nl
;

56 static 
u8_t
 
	gnode_stack_cnt
;

57 static struct 
nse
 
	gnode_stack
[
NODE_STACK_SIZE
];

63 
	$push_node
(struct 
nse
* 
node
)

65 
	`LWIP_ASSERT
("node_stack_cnt < NODE_STACK_SIZE",
node_stack_cnt
 < 
NODE_STACK_SIZE
);

66 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("push_node() node=%p id=%"
S32_F
"\n",(void*)(
node
->
r_ptr
),node->
r_id
));

67 if (
node_stack_cnt
 < 
NODE_STACK_SIZE
)

69 
node_stack
[
node_stack_cnt
] = *
node
;

70 
node_stack_cnt
++;

72 
	}
}

78 
	$pop_node
(struct 
nse
* 
node
)

80 if (
node_stack_cnt
 > 0)

82 
node_stack_cnt
--;

83 *
node
 = 
node_stack
[
node_stack_cnt
];

85 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("pop_node() node=%p id=%"
S32_F
"\n",(void *)(
node
->
r_ptr
),node->
r_id
));

86 
	}
}

94 
	$snmp_ifindextonetif
(
s32_t
 
ifindex
, struct 
netif
 **netif)

96 struct 
netif
 *
nif
 = 
netif_list
;

97 
u16_t
 
i
, 
ifidx
;

99 
ifidx
 = 
ifindex
 - 1;

100 
i
 = 0;

101 while ((
nif
 != 
NULL
) && (
i
 < 
ifidx
))

103 
nif
 = nif->
next
;

104 
i
++;

106 *
netif
 = 
nif
;

107 
	}
}

115 
	$snmp_netiftoifindex
(struct 
netif
 *netif, 
s32_t
 *
ifidx
)

117 struct 
netif
 *
nif
 = 
netif_list
;

118 
u16_t
 
i
;

120 
i
 = 0;

121 while (
nif
 != 
netif
)

123 
nif
 = nif->
next
;

124 
i
++;

126 *
ifidx
 = 
i
+1;

127 
	}
}

135 
	$snmp_oidtoip
(
s32_t
 *
ident
, struct 
ip_addr
 *
ip
)

137 
u32_t
 
ipa
;

139 
ipa
 = 
ident
[0];

140 
ipa
 <<= 8;

141 
ipa
 |= 
ident
[1];

142 
ipa
 <<= 8;

143 
ipa
 |= 
ident
[2];

144 
ipa
 <<= 8;

145 
ipa
 |= 
ident
[3];

146 
ip
->
addr
 = 
ipa
;

147 
	}
}

155 
	$snmp_iptooid
(struct 
ip_addr
 *
ip
, 
s32_t
 *
ident
)

157 
u32_t
 
ipa
;

159 
ipa
 = 
ip
->
addr
;

160 
ident
[0] = (
ipa
 >> 24) & 0xff;

161 
ident
[1] = (
ipa
 >> 16) & 0xff;

162 
ident
[2] = (
ipa
 >> 8) & 0xff;

163 
ident
[3] = 
ipa
 & 0xff;

164 
	}
}

166 struct 
mib_list_node
 *

167 
	$snmp_mib_ln_alloc
(
s32_t
 
id
)

169 struct 
mib_list_node
 *
ln
;

171 
ln
 = (struct 
mib_list_node
 *)
	`mem_malloc
(sizeof(struct mib_list_node));

172 if (
ln
 != 
NULL
)

174 
ln
->
prev
 = 
NULL
;

175 
ln
->
next
 = 
NULL
;

176 
ln
->
objid
 = 
id
;

177 
ln
->
nptr
 = 
NULL
;

179 return 
ln
;

180 
	}
}

183 
	$snmp_mib_ln_free
(struct 
mib_list_node
 *
ln
)

185 
	`mem_free
(
ln
);

186 
	}
}

188 struct 
mib_list_rootnode
 *

189 
	$snmp_mib_lrn_alloc
(void)

191 struct 
mib_list_rootnode
 *
lrn
;

193 
lrn
 = (struct 
mib_list_rootnode
*)
	`mem_malloc
(sizeof(struct mib_list_rootnode));

194 if (
lrn
 != 
NULL
)

196 
lrn
->
get_object_def
 = 
noleafs_get_object_def
;

197 
lrn
->
get_value
 = 
noleafs_get_value
;

198 
lrn
->
set_test
 = 
noleafs_set_test
;

199 
lrn
->
set_value
 = 
noleafs_set_value
;

200 
lrn
->
node_type
 = 
MIB_NODE_LR
;

201 
lrn
->
maxlength
 = 0;

202 
lrn
->
head
 = 
NULL
;

203 
lrn
->
tail
 = 
NULL
;

204 
lrn
->
count
 = 0;

206 return 
lrn
;

207 
	}
}

210 
	$snmp_mib_lrn_free
(struct 
mib_list_rootnode
 *
lrn
)

212 
	`mem_free
(
lrn
);

213 
	}
}

226 
s8_t


227 
	$snmp_mib_node_insert
(struct 
mib_list_rootnode
 *
rn
, 
s32_t
 
objid
, struct 
mib_list_node
 **
insn
)

229 struct 
mib_list_node
 *
nn
;

230 
s8_t
 
insert
;

232 
	`LWIP_ASSERT
("rn != NULL",
rn
 != 
NULL
);

235 
insert
 = 0;

236 if (
rn
->
head
 == 
NULL
)

239 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("alloc empty list objid==%"
S32_F
"\n",
objid
));

240 
nn
 = 
	`snmp_mib_ln_alloc
(
objid
);

241 if (
nn
 != 
NULL
)

243 
rn
->
head
 = 
nn
;

244 
rn
->
tail
 = 
nn
;

245 *
insn
 = 
nn
;

246 
insert
 = 1;

250 
insert
 = -1;

255 struct 
mib_list_node
 *
n
;

257 
n
 = 
rn
->
head
;

258 while ((
n
 != 
NULL
) && (
insert
 == 0))

260 if (
n
->
objid
 == objid)

263 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("node already there objid==%"
S32_F
"\n",
objid
));

264 *
insn
 = 
n
;

265 
insert
 = 2;

267 else if (
n
->
objid
 < objid)

269 if (
n
->
next
 == 
NULL
)

272 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("alloc ins tail objid==%"
S32_F
"\n",
objid
));

273 
nn
 = 
	`snmp_mib_ln_alloc
(
objid
);

274 if (
nn
 != 
NULL
)

276 
nn
->
next
 = 
NULL
;

277 
nn
->
prev
 = 
n
;

278 
n
->
next
 = 
nn
;

279 
rn
->
tail
 = 
nn
;

280 *
insn
 = 
nn
;

281 
insert
 = 1;

286 
insert
 = -1;

292 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("traverse list\n"));

293 
n
 = n->
next
;

300 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("alloc ins n->prev, objid==%"
S32_F
", n\n",
objid
));

301 
nn
 = 
	`snmp_mib_ln_alloc
(
objid
);

302 if (
nn
 != 
NULL
)

304 if (
n
->
prev
 == 
NULL
)

307 
nn
->
next
 = 
n
;

308 
nn
->
prev
 = 
NULL
;

309 
rn
->
head
 = 
nn
;

310 
n
->
prev
 = 
nn
;

315 
nn
->
next
 = 
n
;

316 
nn
->
prev
 = 
n
->prev;

317 
n
->
prev
->
next
 = 
nn
;

318 
n
->
prev
 = 
nn
;

320 *
insn
 = 
nn
;

321 
insert
 = 1;

326 
insert
 = -1;

331 if (
insert
 == 1)

333 
rn
->
count
 += 1;

335 
	`LWIP_ASSERT
("insert != 0",
insert
 != 0);

336 return 
insert
;

337 
	}
}

348 
s8_t


349 
	$snmp_mib_node_find
(struct 
mib_list_rootnode
 *
rn
, 
s32_t
 
objid
, struct 
mib_list_node
 **
fn
)

351 
s8_t
 
fc
;

352 struct 
mib_list_node
 *
n
;

354 
	`LWIP_ASSERT
("rn != NULL",
rn
 != 
NULL
);

355 
n
 = 
rn
->
head
;

356 while ((
n
 != 
NULL
) && (n->
objid
 != objid))

358 
n
 = n->
next
;

360 if (
n
 == 
NULL
)

362 
fc
 = 0;

364 else if (
n
->
nptr
 == 
NULL
)

367 
fc
 = 1;

371 struct 
mib_list_rootnode
 *
r
;

373 if (
n
->
nptr
->
node_type
 == 
MIB_NODE_LR
)

375 
r
 = (struct 
mib_list_rootnode
 *)
n
->
nptr
;

376 if (
r
->
count
 > 1)

379 
fc
 = 2;

384 
fc
 = 1;

390 
fc
 = 3;

393 *
fn
 = 
n
;

394 return 
fc
;

395 
	}
}

405 struct 
mib_list_rootnode
 *

406 
	$snmp_mib_node_delete
(struct 
mib_list_rootnode
 *
rn
, struct 
mib_list_node
 *
n
)

408 struct 
mib_list_rootnode
 *
next
;

410 
	`LWIP_ASSERT
("rn != NULL",
rn
 != 
NULL
);

411 
	`LWIP_ASSERT
("n != NULL",
n
 != 
NULL
);

414 
next
 = (struct 
mib_list_rootnode
*)(
n
->
nptr
);

415 
rn
->
count
 -= 1;

417 if (
n
 == 
rn
->
head
)

419 
rn
->
head
 = 
n
->
next
;

420 if (
n
->
next
 != 
NULL
)

423 
n
->
next
->
prev
 = 
NULL
;

426 else if (
n
 == 
rn
->
tail
)

428 
rn
->
tail
 = 
n
->
prev
;

429 if (
n
->
prev
 != 
NULL
)

432 
n
->
prev
->
next
 = 
NULL
;

438 
n
->
prev
->
next
 = n->next;

439 
n
->
next
->
prev
 = n->prev;

441 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("free list objid==%"
S32_F
"\n",
n
->
objid
));

442 
	`snmp_mib_ln_free
(
n
);

443 if (
rn
->
count
 == 0)

445 
rn
->
head
 = 
NULL
;

446 
rn
->
tail
 = 
NULL
;

448 return 
next
;

449 
	}
}

462 struct 
mib_node
 *

463 
	$snmp_search_tree
(struct 
mib_node
 *
node
, 
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
snmp_name_ptr
 *
np
)

465 
u8_t
 
node_type
, 
ext_level
;

467 
ext_level
 = 0;

468 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("node==%p *ident==%"
S32_F
"\n",(void*)
node
,*
ident
));

469 while (
node
 != 
NULL
)

471 
node_type
 = 
node
->node_type;

472 if ((
node_type
 == 
MIB_NODE_AR
) || (node_type == 
MIB_NODE_RA
))

474 struct 
mib_array_node
 *
an
;

475 
u16_t
 
i
;

477 if (
ident_len
 > 0)

480 
an
 = (struct 
mib_array_node
 *)
node
;

481 
i
 = 0;

482 while ((
i
 < 
an
->
maxlength
) && (an->
objid
[i] != *
ident
))

484 
i
++;

486 if (
i
 < 
an
->
maxlength
)

489 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("an->objid[%"
U16_F
"]==%"
S32_F
" *ident==%"S32_F"\n",
i
,
an
->
objid
[i],*
ident
));

490 if (
an
->
nptr
[
i
] == 
NULL
)

494 
np
->
ident_len
 = ident_len;

495 
np
->
ident
 = ident;

496 return (struct 
mib_node
*)
an
;

501 
ident
++;

502 
ident_len
--;

503 
node
 = 
an
->
nptr
[
i
];

509 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("an search failed *ident==%"
S32_F
"\n",*
ident
));

510 return 
NULL
;

516 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("an search failed, short object identifier\n"));

517 return 
NULL
;

520 else if(
node_type
 == 
MIB_NODE_LR
)

522 struct 
mib_list_rootnode
 *
lrn
;

523 struct 
mib_list_node
 *
ln
;

525 if (
ident_len
 > 0)

528 
lrn
 = (struct 
mib_list_rootnode
 *)
node
;

529 
ln
 = 
lrn
->
head
;

531 while ((
ln
 != 
NULL
) && (ln->
objid
 != *
ident
))

533 
ln
 = ln->
next
;

535 if (
ln
 != 
NULL
)

538 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ln->objid==%"
S32_F
" *ident==%"S32_F"\n",
ln
->
objid
,*
ident
));

539 if (
ln
->
nptr
 == 
NULL
)

541 
np
->
ident_len
 = ident_len;

542 
np
->
ident
 = ident;

543 return (struct 
mib_node
*)
lrn
;

548 
ident_len
--;

549 
ident
++;

550 
node
 = 
ln
->
nptr
;

556 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ln search failed *ident==%"
S32_F
"\n",*
ident
));

557 return 
NULL
;

563 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ln search failed, short object identifier\n"));

564 return 
NULL
;

567 else if(
node_type
 == 
MIB_NODE_EX
)

569 struct 
mib_external_node
 *
en
;

570 
u16_t
 
i
, 
len
;

572 if (
ident_len
 > 0)

575 
en
 = (struct 
mib_external_node
 *)
node
;

577 
i
 = 0;

578 
len
 = 
en
->
	`level_length
(en->
addr_inf
,
ext_level
);

579 while ((
i
 < 
len
) && (
en
->
	`ident_cmp
(en->
addr_inf
,
ext_level
,i,*
ident
) != 0))

581 
i
++;

583 if (
i
 < 
len
)

585 
s32_t
 
debug_id
;

587 
en
->
	`get_objid
(en->
addr_inf
,
ext_level
,
i
,&
debug_id
);

588 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("en->objid==%"
S32_F
" *ident==%"S32_F"\n",
debug_id
,*
ident
));

589 if ((
ext_level
 + 1) == 
en
->
tree_levels
)

591 
np
->
ident_len
 = ident_len;

592 
np
->
ident
 = ident;

593 return (struct 
mib_node
*)
en
;

598 
ident_len
--;

599 
ident
++;

600 
ext_level
++;

606 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("en search failed *ident==%"
S32_F
"\n",*
ident
));

607 return 
NULL
;

613 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("en search failed, short object identifier\n"));

614 return 
NULL
;

617 else if (
node_type
 == 
MIB_NODE_SC
)

619 
mib_scalar_node
 *
sn
;

621 
sn
 = (
mib_scalar_node
 *)
node
;

622 if ((
ident_len
 == 1) && (*
ident
 == 0))

624 
np
->
ident_len
 = ident_len;

625 
np
->
ident
 = ident;

626 return (struct 
mib_node
*)
sn
;

631 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("search failed, invalid object identifier length\n"));

632 return 
NULL
;

638 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("search failed node_type %"
U16_F
" unkown\n",(
u16_t
)
node_type
));

639 return 
NULL
;

643 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("search failed node==%p\n",(void*)
node
));

644 return 
NULL
;

645 
	}
}

650 static 
u8_t


651 
	$empty_table
(struct 
mib_node
 *
node
)

653 
u8_t
 
node_type
;

654 
u8_t
 
empty
 = 0;

656 if (
node
 != 
NULL
)

658 
node_type
 = 
node
->node_type;

659 if (
node_type
 == 
MIB_NODE_LR
)

661 struct 
mib_list_rootnode
 *
lrn
;

662 
lrn
 = (struct 
mib_list_rootnode
 *)
node
;

663 if ((
lrn
->
count
 == 0) || (lrn->
head
 == 
NULL
))

665 
empty
 = 1;

668 else if ((
node_type
 == 
MIB_NODE_AR
) || (node_type == 
MIB_NODE_RA
))

670 struct 
mib_array_node
 *
an
;

671 
an
 = (struct 
mib_array_node
 *)
node
;

672 if ((
an
->
maxlength
 == 0) || (an->
nptr
 == 
NULL
))

674 
empty
 = 1;

677 else if (
node_type
 == 
MIB_NODE_EX
)

679 struct 
mib_external_node
 *
en
;

680 
en
 = (struct 
mib_external_node
 *)
node
;

681 if (
en
->
tree_levels
 == 0)

683 
empty
 = 1;

687 return 
empty
;

688 
	}
}

693 struct 
mib_node
 *

694 
	$snmp_expand_tree
(struct 
mib_node
 *
node
, 
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
snmp_obj_id
 *
oidret
)

696 
u8_t
 
node_type
, 
ext_level
, 
climb_tree
;

698 
ext_level
 = 0;

700 
node_stack_cnt
 = 0;

701 while (
node
 != 
NULL
)

703 
climb_tree
 = 0;

704 
node_type
 = 
node
->node_type;

705 if ((
node_type
 == 
MIB_NODE_AR
) || (node_type == 
MIB_NODE_RA
))

707 struct 
mib_array_node
 *
an
;

708 
u16_t
 
i
;

711 
an
 = (struct 
mib_array_node
 *)
node
;

712 if (
ident_len
 > 0)

714 
i
 = 0;

715 while ((
i
 < 
an
->
maxlength
) && (an->
objid
[i] < *
ident
))

717 
i
++;

719 if (
i
 < 
an
->
maxlength
)

721 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("an->objid[%"
U16_F
"]==%"
S32_F
" *ident==%"S32_F"\n",
i
,
an
->
objid
[i],*
ident
));

723 
oidret
->
id
[oidret->
len
] = 
an
->
objid
[
i
];

724 (
oidret
->
len
)++;

726 if (
an
->
nptr
[
i
] == 
NULL
)

728 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("leaf node\n"));

730 if (
an
->
objid
[
i
] > *
ident
)

732 return (struct 
mib_node
*)
an
;

734 else if ((
i
 + 1) < 
an
->
maxlength
)

737 (
oidret
->
len
)--;

738 
oidret
->
id
[oidret->
len
] = 
an
->
objid
[
i
 + 1];

739 (
oidret
->
len
)++;

740 return (struct 
mib_node
*)
an
;

745 (
oidret
->
len
)--;

746 
climb_tree
 = 1;

751 
u8_t
 
j
;

752 struct 
nse
 
cur_node
;

754 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("non-leaf node\n"));

756 
j
 = 
i
 + 1;

757 while ((
j
 < 
an
->
maxlength
) && (
	`empty_table
(an->
nptr
[j])))

759 
j
++;

761 if (
j
 < 
an
->
maxlength
)

763 
cur_node
.
r_ptr
 = 
an
->
nptr
[
j
];

764 
cur_node
.
r_id
 = 
an
->
objid
[
j
];

765 
cur_node
.
r_nl
 = 0;

769 
cur_node
.
r_ptr
 = 
NULL
;

771 
	`push_node
(&
cur_node
);

772 if (
an
->
objid
[
i
] == *
ident
)

774 
ident_len
--;

775 
ident
++;

780 
ident_len
 = 0;

783 
node
 = 
an
->
nptr
[
i
];

789 
climb_tree
 = 1;

794 
u8_t
 
j
;

796 
j
 = 0;

797 while ((
j
 < 
an
->
maxlength
) && 
	`empty_table
(an->
nptr
[j]))

799 
j
++;

801 if (
j
 < 
an
->
maxlength
)

803 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("left an->objid[j]==%"
S32_F
"\n",
an
->
objid
[
j
]));

804 
oidret
->
id
[oidret->
len
] = 
an
->
objid
[
j
];

805 (
oidret
->
len
)++;

806 if (
an
->
nptr
[
j
] == 
NULL
)

809 return (struct 
mib_node
*)
an
;

814 
node
 = 
an
->
nptr
[
j
];

820 
climb_tree
 = 1;

824 else if(
node_type
 == 
MIB_NODE_LR
)

826 struct 
mib_list_rootnode
 *
lrn
;

827 struct 
mib_list_node
 *
ln
;

830 
lrn
 = (struct 
mib_list_rootnode
 *)
node
;

831 if (
ident_len
 > 0)

833 
ln
 = 
lrn
->
head
;

835 while ((
ln
 != 
NULL
) && (ln->
objid
 < *
ident
))

837 
ln
 = ln->
next
;

839 if (
ln
 != 
NULL
)

841 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("ln->objid==%"
S32_F
" *ident==%"S32_F"\n",
ln
->
objid
,*
ident
));

842 
oidret
->
id
[oidret->
len
] = 
ln
->
objid
;

843 (
oidret
->
len
)++;

844 if (
ln
->
nptr
 == 
NULL
)

847 if (
ln
->
objid
 > *
ident
)

849 return (struct 
mib_node
*)
lrn
;

851 else if (
ln
->
next
 != 
NULL
)

854 (
oidret
->
len
)--;

855 
oidret
->
id
[oidret->
len
] = 
ln
->
next
->
objid
;

856 (
oidret
->
len
)++;

857 return (struct 
mib_node
*)
lrn
;

862 (
oidret
->
len
)--;

863 
climb_tree
 = 1;

868 struct 
mib_list_node
 *
jn
;

869 struct 
nse
 
cur_node
;

872 
jn
 = 
ln
->
next
;

873 while ((
jn
 != 
NULL
) && 
	`empty_table
(jn->
nptr
))

875 
jn
 = jn->
next
;

877 if (
jn
 != 
NULL
)

879 
cur_node
.
r_ptr
 = 
jn
->
nptr
;

880 
cur_node
.
r_id
 = 
jn
->
objid
;

881 
cur_node
.
r_nl
 = 0;

885 
cur_node
.
r_ptr
 = 
NULL
;

887 
	`push_node
(&
cur_node
);

888 if (
ln
->
objid
 == *
ident
)

890 
ident_len
--;

891 
ident
++;

896 
ident_len
 = 0;

899 
node
 = 
ln
->
nptr
;

906 
climb_tree
 = 1;

911 struct 
mib_list_node
 *
jn
;

913 
jn
 = 
lrn
->
head
;

914 while ((
jn
 != 
NULL
) && 
	`empty_table
(jn->
nptr
))

916 
jn
 = jn->
next
;

918 if (
jn
 != 
NULL
)

920 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("left jn->objid==%"
S32_F
"\n",
jn
->
objid
));

921 
oidret
->
id
[oidret->
len
] = 
jn
->
objid
;

922 (
oidret
->
len
)++;

923 if (
jn
->
nptr
 == 
NULL
)

926 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("jn->nptr == NULL\n"));

927 return (struct 
mib_node
*)
lrn
;

932 
node
 = 
jn
->
nptr
;

938 
climb_tree
 = 1;

942 else if(
node_type
 == 
MIB_NODE_EX
)

944 struct 
mib_external_node
 *
en
;

945 
s32_t
 
ex_id
;

948 
en
 = (struct 
mib_external_node
 *)
node
;

949 if (
ident_len
 > 0)

951 
u16_t
 
i
, 
len
;

953 
i
 = 0;

954 
len
 = 
en
->
	`level_length
(en->
addr_inf
,
ext_level
);

955 while ((
i
 < 
len
) && (
en
->
	`ident_cmp
(en->
addr_inf
,
ext_level
,i,*
ident
) < 0))

957 
i
++;

959 if (
i
 < 
len
)

962 
en
->
	`get_objid
(en->
addr_inf
,
ext_level
,
i
,&
ex_id
);

963 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("en->objid[%"
U16_F
"]==%"
S32_F
" *ident==%"S32_F"\n",
i
,
ex_id
,*
ident
));

964 
oidret
->
id
[oidret->
len
] = 
ex_id
;

965 (
oidret
->
len
)++;

967 if ((
ext_level
 + 1) == 
en
->
tree_levels
)

969 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("leaf node\n"));

971 if (
ex_id
 > *
ident
)

973 return (struct 
mib_node
*)
en
;

975 else if ((
i
 + 1) < 
len
)

978 
en
->
	`get_objid
(en->
addr_inf
,
ext_level
,
i
 + 1,&
ex_id
);

979 (
oidret
->
len
)--;

980 
oidret
->
id
[oidret->
len
] = 
ex_id
;

981 (
oidret
->
len
)++;

982 return (struct 
mib_node
*)
en
;

987 (
oidret
->
len
)--;

988 
climb_tree
 = 1;

993 
u8_t
 
j
;

994 struct 
nse
 
cur_node
;

996 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("non-leaf node\n"));

998 
j
 = 
i
 + 1;

999 if (
j
 < 
len
)

1002 
cur_node
.
r_ptr
 = 
node
;

1003 
en
->
	`get_objid
(en->
addr_inf
,
ext_level
,
j
,&
cur_node
.
r_id
);

1004 
cur_node
.
r_nl
 = 
ext_level
 + 1;

1008 
cur_node
.
r_ptr
 = 
NULL
;

1010 
	`push_node
(&
cur_node
);

1011 if (
en
->
	`ident_cmp
(en->
addr_inf
,
ext_level
,
i
,*
ident
) == 0)

1013 
ident_len
--;

1014 
ident
++;

1019 
ident_len
 = 0;

1022 
ext_level
++;

1028 
climb_tree
 = 1;

1034 
en
->
	`get_objid
(en->
addr_inf
,
ext_level
,0,&
ex_id
);

1035 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("left en->objid==%"
S32_F
"\n",
ex_id
));

1036 
oidret
->
id
[oidret->
len
] = 
ex_id
;

1037 (
oidret
->
len
)++;

1038 if ((
ext_level
 + 1) == 
en
->
tree_levels
)

1041 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("(ext_level + 1) == en->tree_levels\n"));

1042 return (struct 
mib_node
*)
en
;

1047 
ext_level
++;

1051 else if(
node_type
 == 
MIB_NODE_SC
)

1053 
mib_scalar_node
 *
sn
;

1056 
sn
 = (
mib_scalar_node
 *)
node
;

1057 if (
ident_len
 > 0)

1060 
climb_tree
 = 1;

1065 
oidret
->
id
[oidret->
len
] = 0;

1066 (
oidret
->
len
)++;

1068 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("completed scalar leaf\n"));

1069 return (struct 
mib_node
*)
sn
;

1075 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("expand failed node_type %"
U16_F
" unkown\n",(
u16_t
)
node_type
));

1076 return 
NULL
;

1079 if (
climb_tree
)

1081 struct 
nse
 
child
;

1084 
child
.
r_ptr
 = 
NULL
;

1085 
child
.
r_id
 = 0;

1086 
child
.
r_nl
 = 0;

1087 while ((
node_stack_cnt
 > 0) && (
child
.
r_ptr
 == 
NULL
))

1089 
	`pop_node
(&
child
);

1091 (
oidret
->
len
)--;

1093 if (
child
.
r_ptr
 != 
NULL
)

1096 
ident_len
 = 0;

1097 
oidret
->
id
[oidret->
len
] = 
child
.
r_id
;

1098 
oidret
->
len
++;

1099 
node
 = 
child
.
r_ptr
;

1100 
ext_level
 = 
child
.
r_nl
;

1105 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("expand failed, tree ends here\n"));

1106 return 
NULL
;

1111 
	`LWIP_DEBUGF
(
SNMP_MIB_DEBUG
,("expand failed node==%p\n",(void*)
node
));

1112 return 
NULL
;

1113 
	}
}

1122 
u8_t


1123 
	$snmp_iso_prefix_tst
(
u8_t
 
ident_len
, 
s32_t
 *
ident
)

1125 if ((
ident_len
 > 3) &&

1126 (
ident
[0] == 1) && (ident[1] == 3) &&

1127 (
ident
[2] == 6) && (ident[3] == 1))

1135 
	}
}

1148 
u8_t


1149 
	$snmp_iso_prefix_expand
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
snmp_obj_id
 *
oidret
)

1151 const 
s32_t
 *
prefix_ptr
;

1152 
s32_t
 *
ret_ptr
;

1153 
u8_t
 
i
;

1155 
i
 = 0;

1156 
prefix_ptr
 = &
prefix
[0];

1157 
ret_ptr
 = &
oidret
->
id
[0];

1158 
ident_len
 = ((ident_len < 4)?ident_len:4);

1159 while ((
i
 < 
ident_len
) && ((*
ident
) <= (*
prefix_ptr
)))

1161 *
ret_ptr
++ = *
prefix_ptr
++;

1162 
ident
++;

1163 
i
++;

1165 if (
i
 == 
ident_len
)

1168 while (
i
 < 4)

1170 *
ret_ptr
++ = *
prefix_ptr
++;

1171 
i
++;

1173 
oidret
->
len
 = 
i
;

1181 
	}
}

	@/root/Robux/net/lwip/core/snmp/msg_in.c

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_SNMP


39 #include 
	~"lwip/ip_addr.h
"

40 #include 
	~"lwip/mem.h
"

41 #include 
	~"lwip/udp.h
"

42 #include 
	~"lwip/stats.h
"

43 #include 
	~"lwip/snmp.h
"

44 #include 
	~"lwip/snmp_asn1.h
"

45 #include 
	~"lwip/snmp_msg.h
"

46 #include 
	~"lwip/snmp_structs.h
"

48 #include 
	~<string.h
>

52 const 
s32_t
 
	gsnmp_version
 = 0;

54 const char 
	gsnmp_publiccommunity
[7] = "public";

57 struct 
snmp_msg_pstat
 
	gmsg_input_list
[
SNMP_CONCURRENT_REQUESTS
];

59 struct 
udp_pcb
 *
	gsnmp1_pcb
;

61 static void 
snmp_recv
(void *
arg
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
);

62 static 
err_t
 
snmp_pdu_header_check
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
pdu_len
, u16_t *
ofs_ret
, struct 
snmp_msg_pstat
 *
m_stat
);

63 static 
err_t
 
snmp_pdu_dec_varbindlist
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t *
ofs_ret
, struct 
snmp_msg_pstat
 *
m_stat
);

71 
	$snmp_init
(void)

73 struct 
snmp_msg_pstat
 *
msg_ps
;

74 
u8_t
 
i
;

76 
snmp1_pcb
 = 
	`udp_new
();

77 if (
snmp1_pcb
 != 
NULL
)

79 
	`udp_recv
(
snmp1_pcb
, 
snmp_recv
, (void *)
SNMP_IN_PORT
);

80 
	`udp_bind
(
snmp1_pcb
, 
IP_ADDR_ANY
, 
SNMP_IN_PORT
);

82 
msg_ps
 = &
msg_input_list
[0];

83 for (
i
=0; i<
SNMP_CONCURRENT_REQUESTS
; i++)

85 
msg_ps
->
state
 = 
SNMP_MSG_EMPTY
;

86 
msg_ps
->
error_index
 = 0;

87 
msg_ps
->
error_status
 = 
SNMP_ES_NOERROR
;

88 
msg_ps
++;

90 
trap_msg
.
pcb
 = 
snmp1_pcb
;

93 
	`snmp_coldstart_trap
();

94 
	}
}

97 
	$snmp_error_response
(struct 
snmp_msg_pstat
 *
msg_ps
, 
u8_t
 
error
)

99 
	`snmp_varbind_list_free
(&
msg_ps
->
outvb
);

100 
msg_ps
->
outvb
 = msg_ps->
invb
;

101 
msg_ps
->
invb
.
head
 = 
NULL
;

102 
msg_ps
->
invb
.
tail
 = 
NULL
;

103 
msg_ps
->
invb
.
count
 = 0;

104 
msg_ps
->
error_status
 = 
error
;

105 
msg_ps
->
error_index
 = 1 + msg_ps->
vb_idx
;

106 
	`snmp_send_response
(
msg_ps
);

107 
	`snmp_varbind_list_free
(&
msg_ps
->
outvb
);

108 
msg_ps
->
state
 = 
SNMP_MSG_EMPTY
;

109 
	}
}

112 
	$snmp_ok_response
(struct 
snmp_msg_pstat
 *
msg_ps
)

114 
err_t
 
err_ret
;

116 
err_ret
 = 
	`snmp_send_response
(
msg_ps
);

117 if (
err_ret
 == 
ERR_MEM
)

123 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_event = %"
S32_F
"\n",
msg_ps
->
error_status
));

126 
	`snmp_varbind_list_free
(&
msg_ps
->
invb
);

127 
	`snmp_varbind_list_free
(&
msg_ps
->
outvb
);

128 
msg_ps
->
state
 = 
SNMP_MSG_EMPTY
;

129 
	}
}

138 
	$snmp_msg_get_event
(
u8_t
 
request_id
, struct 
snmp_msg_pstat
 *
msg_ps
)

140 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_get_event: msg_ps->state==%"
U16_F
"\n",(
u16_t
)
msg_ps
->
state
));

142 if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_GET_OBJDEF
)

144 struct 
mib_external_node
 *
en
;

145 struct 
snmp_name_ptr
 
np
;

148 
en
 = 
msg_ps
->
ext_mib_node
;

149 
np
 = 
msg_ps
->
ext_name_ptr
;

152 
en
->
	`get_object_def_a
(
request_id
, 
np
.
ident_len
, np.
ident
, &
msg_ps
->
ext_object_def
);

153 if (
msg_ps
->
ext_object_def
.
instance
 != 
MIB_OBJECT_NONE
)

155 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_GET_VALUE
;

156 
en
->
	`get_value_q
(
request_id
, &
msg_ps
->
ext_object_def
);

160 
en
->
	`get_object_def_pc
(
request_id
, 
np
.
ident_len
, np.
ident
);

162 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

165 else if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_GET_VALUE
)

167 struct 
mib_external_node
 *
en
;

168 struct 
snmp_varbind
 *
vb
;

171 
en
 = 
msg_ps
->
ext_mib_node
;

174 
vb
 = (struct 
snmp_varbind
 *)
	`mem_malloc
(sizeof(struct snmp_varbind));

175 
	`LWIP_ASSERT
("vb != NULL",
vb
 != 
NULL
);

176 if (
vb
 != 
NULL
)

178 
vb
->
next
 = 
NULL
;

179 
vb
->
prev
 = 
NULL
;

182 
vb
->
ident
 = 
msg_ps
->
vb_ptr
->ident;

183 
vb
->
ident_len
 = 
msg_ps
->
vb_ptr
->ident_len;

185 
msg_ps
->
vb_ptr
->
ident
 = 
NULL
;

186 
msg_ps
->
vb_ptr
->
ident_len
 = 0;

188 
vb
->
value_type
 = 
msg_ps
->
ext_object_def
.
asn_type
;

189 
vb
->
value_len
 = 
msg_ps
->
ext_object_def
.
v_len
;

190 if (
vb
->
value_len
 > 0)

192 
vb
->
value
 = 
	`mem_malloc
(vb->
value_len
);

193 
	`LWIP_ASSERT
("vb->value != NULL",
vb
->
value
 != 
NULL
);

194 if (
vb
->
value
 != 
NULL
)

196 
en
->
	`get_value_a
(
request_id
, &
msg_ps
->
ext_object_def
, 
vb
->
value_len
, vb->
value
);

197 
	`snmp_varbind_tail_add
(&
msg_ps
->
outvb
, 
vb
);

199 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

200 
msg_ps
->
vb_idx
 += 1;

204 
en
->
	`get_value_pc
(
request_id
, &
msg_ps
->
ext_object_def
);

205 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_event: no variable space\n"));

206 
msg_ps
->
vb_ptr
->
ident
 = 
vb
->ident;

207 
msg_ps
->
vb_ptr
->
ident_len
 = 
vb
->ident_len;

208 
	`mem_free
(
vb
);

209 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_TOOBIG
);

215 
en
->
	`get_value_a
(
request_id
, &
msg_ps
->
ext_object_def
, 0, 
NULL
);

216 
vb
->
value
 = 
NULL
;

217 
	`snmp_varbind_tail_add
(&
msg_ps
->
outvb
, 
vb
);

219 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

220 
msg_ps
->
vb_idx
 += 1;

225 
en
->
	`get_value_pc
(
request_id
, &
msg_ps
->
ext_object_def
);

226 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_event: no outvb space\n"));

227 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_TOOBIG
);

231 while ((
msg_ps
->
state
 == 
SNMP_MSG_SEARCH_OBJ
) &&

232 (
msg_ps
->
vb_idx
 < msg_ps->
invb
.
count
))

234 struct 
mib_node
 *
mn
;

235 struct 
snmp_name_ptr
 
np
;

237 if (
msg_ps
->
vb_idx
 == 0)

239 
msg_ps
->
vb_ptr
 = msg_ps->
invb
.
head
;

243 
msg_ps
->
vb_ptr
 = msg_ps->vb_ptr->
next
;

246 if (
	`snmp_iso_prefix_tst
(
msg_ps
->
vb_ptr
->
ident_len
, msg_ps->vb_ptr->
ident
))

248 
mn
 = 
	`snmp_search_tree
((struct 
mib_node
*)&
internet
, 
msg_ps
->
vb_ptr
->
ident_len
 - 4,

249 
msg_ps
->
vb_ptr
->
ident
 + 4, &
np
);

250 if (
mn
 != 
NULL
)

252 if (
mn
->
node_type
 == 
MIB_NODE_EX
)

255 struct 
mib_external_node
 *
en
 = (struct mib_external_node*)
mn
;

257 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_GET_OBJDEF
;

259 
msg_ps
->
ext_mib_node
 = 
en
;

260 
msg_ps
->
ext_name_ptr
 = 
np
;

262 
en
->
	`get_object_def_q
(en->
addr_inf
, 
request_id
, 
np
.
ident_len
, np.
ident
);

267 struct 
obj_def
 
object_def
;

269 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_GET_OBJDEF
;

270 
mn
->
	`get_object_def
(
np
.
ident_len
, np.
ident
, &
object_def
);

271 if (
object_def
.
instance
 != 
MIB_OBJECT_NONE
)

273 
mn
 = mn;

278 
mn
 = 
NULL
;

280 if (
mn
 != 
NULL
)

282 struct 
snmp_varbind
 *
vb
;

284 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_GET_VALUE
;

286 
vb
 = (struct 
snmp_varbind
 *)
	`mem_malloc
(sizeof(struct snmp_varbind));

287 
	`LWIP_ASSERT
("vb != NULL",
vb
 != 
NULL
);

288 if (
vb
 != 
NULL
)

290 
vb
->
next
 = 
NULL
;

291 
vb
->
prev
 = 
NULL
;

294 
vb
->
ident
 = 
msg_ps
->
vb_ptr
->ident;

295 
vb
->
ident_len
 = 
msg_ps
->
vb_ptr
->ident_len;

297 
msg_ps
->
vb_ptr
->
ident
 = 
NULL
;

298 
msg_ps
->
vb_ptr
->
ident_len
 = 0;

300 
vb
->
value_type
 = 
object_def
.
asn_type
;

301 
vb
->
value_len
 = 
object_def
.
v_len
;

302 if (
vb
->
value_len
 > 0)

304 
vb
->
value
 = 
	`mem_malloc
(vb->
value_len
);

305 
	`LWIP_ASSERT
("vb->value != NULL",
vb
->
value
 != 
NULL
);

306 if (
vb
->
value
 != 
NULL
)

308 
mn
->
	`get_value
(&
object_def
, 
vb
->
value_len
, vb->
value
);

309 
	`snmp_varbind_tail_add
(&
msg_ps
->
outvb
, 
vb
);

310 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

311 
msg_ps
->
vb_idx
 += 1;

315 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_event: couldn't allocate variable space\n"));

316 
msg_ps
->
vb_ptr
->
ident
 = 
vb
->ident;

317 
msg_ps
->
vb_ptr
->
ident_len
 = 
vb
->ident_len;

318 
	`mem_free
(
vb
);

319 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_TOOBIG
);

325 
vb
->
value
 = 
NULL
;

326 
	`snmp_varbind_tail_add
(&
msg_ps
->
outvb
, 
vb
);

327 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

328 
msg_ps
->
vb_idx
 += 1;

333 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_event: couldn't allocate outvb space\n"));

334 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_TOOBIG
);

342 
mn
 = 
NULL
;

344 if (
mn
 == 
NULL
)

347 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

350 if ((
msg_ps
->
state
 == 
SNMP_MSG_SEARCH_OBJ
) &&

351 (
msg_ps
->
vb_idx
 == msg_ps->
invb
.
count
))

353 
	`snmp_ok_response
(
msg_ps
);

355 
	}
}

364 
	$snmp_msg_getnext_event
(
u8_t
 
request_id
, struct 
snmp_msg_pstat
 *
msg_ps
)

366 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_getnext_event: msg_ps->state==%"
U16_F
"\n",(
u16_t
)
msg_ps
->
state
));

368 if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_GET_OBJDEF
)

370 struct 
mib_external_node
 *
en
;

373 
en
 = 
msg_ps
->
ext_mib_node
;

376 
en
->
	`get_object_def_a
(
request_id
, 1, &
msg_ps
->
ext_oid
.
id
[msg_ps->ext_oid.
len
 - 1], &msg_ps->
ext_object_def
);

377 if (
msg_ps
->
ext_object_def
.
instance
 != 
MIB_OBJECT_NONE
)

379 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_GET_VALUE
;

380 
en
->
	`get_value_q
(
request_id
, &
msg_ps
->
ext_object_def
);

384 
en
->
	`get_object_def_pc
(
request_id
, 1, &
msg_ps
->
ext_oid
.
id
[msg_ps->ext_oid.
len
 - 1]);

386 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

389 else if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_GET_VALUE
)

391 struct 
mib_external_node
 *
en
;

392 struct 
snmp_varbind
 *
vb
;

395 
en
 = 
msg_ps
->
ext_mib_node
;

397 
vb
 = 
	`snmp_varbind_alloc
(&
msg_ps
->
ext_oid
,

398 
msg_ps
->
ext_object_def
.
asn_type
,

399 
msg_ps
->
ext_object_def
.
v_len
);

400 if (
vb
 != 
NULL
)

402 
en
->
	`get_value_a
(
request_id
, &
msg_ps
->
ext_object_def
, 
vb
->
value_len
, vb->
value
);

403 
	`snmp_varbind_tail_add
(&
msg_ps
->
outvb
, 
vb
);

404 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

405 
msg_ps
->
vb_idx
 += 1;

409 
en
->
	`get_value_pc
(
request_id
, &
msg_ps
->
ext_object_def
);

410 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_getnext_event: couldn't allocate outvb space\n"));

411 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_TOOBIG
);

415 while ((
msg_ps
->
state
 == 
SNMP_MSG_SEARCH_OBJ
) &&

416 (
msg_ps
->
vb_idx
 < msg_ps->
invb
.
count
))

418 struct 
mib_node
 *
mn
;

419 struct 
snmp_obj_id
 
oid
;

421 if (
msg_ps
->
vb_idx
 == 0)

423 
msg_ps
->
vb_ptr
 = msg_ps->
invb
.
head
;

427 
msg_ps
->
vb_ptr
 = msg_ps->vb_ptr->
next
;

429 if (
	`snmp_iso_prefix_expand
(
msg_ps
->
vb_ptr
->
ident_len
, msg_ps->vb_ptr->
ident
, &
oid
))

431 if (
msg_ps
->
vb_ptr
->
ident_len
 > 3)

434 
mn
 = 
	`snmp_expand_tree
((struct 
mib_node
*)&
internet
,

435 
msg_ps
->
vb_ptr
->
ident_len
 - 4,

436 
msg_ps
->
vb_ptr
->
ident
 + 4, &
oid
);

441 
mn
 = 
	`snmp_expand_tree
((struct 
mib_node
*)&
internet
, 0, 
NULL
, &
oid
);

446 
mn
 = 
NULL
;

448 if (
mn
 != 
NULL
)

450 if (
mn
->
node_type
 == 
MIB_NODE_EX
)

453 struct 
mib_external_node
 *
en
 = (struct mib_external_node*)
mn
;

455 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_GET_OBJDEF
;

457 
msg_ps
->
ext_mib_node
 = 
en
;

458 
msg_ps
->
ext_oid
 = 
oid
;

460 
en
->
	`get_object_def_q
(en->
addr_inf
, 
request_id
, 1, &
oid
.
id
[oid.
len
 - 1]);

465 struct 
obj_def
 
object_def
;

466 struct 
snmp_varbind
 *
vb
;

468 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_GET_OBJDEF
;

469 
mn
->
	`get_object_def
(1, &
oid
.
id
[oid.
len
 - 1], &
object_def
);

471 
vb
 = 
	`snmp_varbind_alloc
(&
oid
, 
object_def
.
asn_type
, object_def.
v_len
);

472 if (
vb
 != 
NULL
)

474 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_GET_VALUE
;

475 
mn
->
	`get_value
(&
object_def
, object_def.
v_len
, 
vb
->
value
);

476 
	`snmp_varbind_tail_add
(&
msg_ps
->
outvb
, 
vb
);

477 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

478 
msg_ps
->
vb_idx
 += 1;

482 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_recv couldn't allocate outvb space\n"));

483 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_TOOBIG
);

487 if (
mn
 == 
NULL
)

490 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

493 if ((
msg_ps
->
state
 == 
SNMP_MSG_SEARCH_OBJ
) &&

494 (
msg_ps
->
vb_idx
 == msg_ps->
invb
.
count
))

496 
	`snmp_ok_response
(
msg_ps
);

498 
	}
}

507 
	$snmp_msg_set_event
(
u8_t
 
request_id
, struct 
snmp_msg_pstat
 *
msg_ps
)

509 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_msg_set_event: msg_ps->state==%"
U16_F
"\n",(
u16_t
)
msg_ps
->
state
));

511 if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_GET_OBJDEF
)

513 struct 
mib_external_node
 *
en
;

514 struct 
snmp_name_ptr
 
np
;

517 
en
 = 
msg_ps
->
ext_mib_node
;

518 
np
 = 
msg_ps
->
ext_name_ptr
;

521 
en
->
	`get_object_def_a
(
request_id
, 
np
.
ident_len
, np.
ident
, &
msg_ps
->
ext_object_def
);

522 if (
msg_ps
->
ext_object_def
.
instance
 != 
MIB_OBJECT_NONE
)

524 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_SET_TEST
;

525 
en
->
	`set_test_q
(
request_id
, &
msg_ps
->
ext_object_def
);

529 
en
->
	`get_object_def_pc
(
request_id
, 
np
.
ident_len
, np.
ident
);

531 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

534 else if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_SET_TEST
)

536 struct 
mib_external_node
 *
en
;

539 
en
 = 
msg_ps
->
ext_mib_node
;

541 if (
msg_ps
->
ext_object_def
.
access
 == 
MIB_OBJECT_READ_WRITE
)

543 if ((
msg_ps
->
ext_object_def
.
asn_type
 == msg_ps->
vb_ptr
->
value_type
) &&

544 (
en
->
	`set_test_a
(
request_id
,&
msg_ps
->
ext_object_def
,

545 
msg_ps
->
vb_ptr
->
value_len
,msg_ps->vb_ptr->
value
) != 0))

547 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

548 
msg_ps
->
vb_idx
 += 1;

552 
en
->
	`set_test_pc
(
request_id
,&
msg_ps
->
ext_object_def
);

554 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_BADVALUE
);

559 
en
->
	`set_test_pc
(
request_id
,&
msg_ps
->
ext_object_def
);

561 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

564 else if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_GET_OBJDEF_S
)

566 struct 
mib_external_node
 *
en
;

567 struct 
snmp_name_ptr
 
np
;

570 
en
 = 
msg_ps
->
ext_mib_node
;

571 
np
 = 
msg_ps
->
ext_name_ptr
;

574 
en
->
	`get_object_def_a
(
request_id
, 
np
.
ident_len
, np.
ident
, &
msg_ps
->
ext_object_def
);

575 if (
msg_ps
->
ext_object_def
.
instance
 != 
MIB_OBJECT_NONE
)

577 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_SET_VALUE
;

578 
en
->
	`set_value_q
(
request_id
, &
msg_ps
->
ext_object_def
,

579 
msg_ps
->
vb_ptr
->
value_len
,msg_ps->vb_ptr->
value
);

583 
en
->
	`get_object_def_pc
(
request_id
, 
np
.
ident_len
, np.
ident
);

585 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_GENERROR
);

588 else if (
msg_ps
->
state
 == 
SNMP_MSG_EXTERNAL_SET_VALUE
)

590 struct 
mib_external_node
 *
en
;

593 
en
 = 
msg_ps
->
ext_mib_node
;

594 
en
->
	`set_value_a
(
request_id
, &
msg_ps
->
ext_object_def
, 0, 
NULL
);

597 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_SET_VALUE
;

598 
msg_ps
->
vb_idx
 += 1;

602 while ((
msg_ps
->
state
 == 
SNMP_MSG_SEARCH_OBJ
) &&

603 (
msg_ps
->
vb_idx
 < msg_ps->
invb
.
count
))

605 struct 
mib_node
 *
mn
;

606 struct 
snmp_name_ptr
 
np
;

608 if (
msg_ps
->
vb_idx
 == 0)

610 
msg_ps
->
vb_ptr
 = msg_ps->
invb
.
head
;

614 
msg_ps
->
vb_ptr
 = msg_ps->vb_ptr->
next
;

617 if (
	`snmp_iso_prefix_tst
(
msg_ps
->
vb_ptr
->
ident_len
, msg_ps->vb_ptr->
ident
))

619 
mn
 = 
	`snmp_search_tree
((struct 
mib_node
*)&
internet
, 
msg_ps
->
vb_ptr
->
ident_len
 - 4,

620 
msg_ps
->
vb_ptr
->
ident
 + 4, &
np
);

621 if (
mn
 != 
NULL
)

623 if (
mn
->
node_type
 == 
MIB_NODE_EX
)

626 struct 
mib_external_node
 *
en
 = (struct mib_external_node*)
mn
;

628 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_GET_OBJDEF
;

630 
msg_ps
->
ext_mib_node
 = 
en
;

631 
msg_ps
->
ext_name_ptr
 = 
np
;

633 
en
->
	`get_object_def_q
(en->
addr_inf
, 
request_id
, 
np
.
ident_len
, np.
ident
);

638 struct 
obj_def
 
object_def
;

640 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_GET_OBJDEF
;

641 
mn
->
	`get_object_def
(
np
.
ident_len
, np.
ident
, &
object_def
);

642 if (
object_def
.
instance
 != 
MIB_OBJECT_NONE
)

644 
mn
 = mn;

649 
mn
 = 
NULL
;

651 if (
mn
 != 
NULL
)

653 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_SET_TEST
;

655 if (
object_def
.
access
 == 
MIB_OBJECT_READ_WRITE
)

657 if ((
object_def
.
asn_type
 == 
msg_ps
->
vb_ptr
->
value_type
) &&

658 (
mn
->
	`set_test
(&
object_def
,
msg_ps
->
vb_ptr
->
value_len
,msg_ps->vb_ptr->
value
) != 0))

660 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

661 
msg_ps
->
vb_idx
 += 1;

666 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_BADVALUE
);

672 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

680 
mn
 = 
NULL
;

682 if (
mn
 == 
NULL
)

685 
	`snmp_error_response
(
msg_ps
,
SNMP_ES_NOSUCHNAME
);

689 if ((
msg_ps
->
state
 == 
SNMP_MSG_SEARCH_OBJ
) &&

690 (
msg_ps
->
vb_idx
 == msg_ps->
invb
.
count
))

692 
msg_ps
->
vb_idx
 = 0;

693 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_SET_VALUE
;

697 while ((
msg_ps
->
state
 == 
SNMP_MSG_INTERNAL_SET_VALUE
) &&

698 (
msg_ps
->
vb_idx
 < msg_ps->
invb
.
count
))

700 struct 
mib_node
 *
mn
;

701 struct 
snmp_name_ptr
 
np
;

703 if (
msg_ps
->
vb_idx
 == 0)

705 
msg_ps
->
vb_ptr
 = msg_ps->
invb
.
head
;

709 
msg_ps
->
vb_ptr
 = msg_ps->vb_ptr->
next
;

712 
mn
 = 
	`snmp_search_tree
((struct 
mib_node
*)&
internet
, 
msg_ps
->
vb_ptr
->
ident_len
 - 4,

713 
msg_ps
->
vb_ptr
->
ident
 + 4, &
np
);

716 if (
mn
 != 
NULL
)

718 if (
mn
->
node_type
 == 
MIB_NODE_EX
)

721 struct 
mib_external_node
 *
en
 = (struct mib_external_node*)
mn
;

723 
msg_ps
->
state
 = 
SNMP_MSG_EXTERNAL_GET_OBJDEF_S
;

725 
msg_ps
->
ext_mib_node
 = 
en
;

726 
msg_ps
->
ext_name_ptr
 = 
np
;

728 
en
->
	`get_object_def_q
(en->
addr_inf
, 
request_id
, 
np
.
ident_len
, np.
ident
);

733 struct 
obj_def
 
object_def
;

735 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_GET_OBJDEF_S
;

736 
mn
->
	`get_object_def
(
np
.
ident_len
, np.
ident
, &
object_def
);

737 
msg_ps
->
state
 = 
SNMP_MSG_INTERNAL_SET_VALUE
;

738 
mn
->
	`set_value
(&
object_def
,
msg_ps
->
vb_ptr
->
value_len
,msg_ps->vb_ptr->
value
);

739 
msg_ps
->
vb_idx
 += 1;

743 if ((
msg_ps
->
state
 == 
SNMP_MSG_INTERNAL_SET_VALUE
) &&

744 (
msg_ps
->
vb_idx
 == msg_ps->
invb
.
count
))

749 
msg_ps
->
outvb
 = msg_ps->
invb
;

750 
msg_ps
->
invb
.
head
 = 
NULL
;

751 
msg_ps
->
invb
.
tail
 = 
NULL
;

752 
msg_ps
->
invb
.
count
 = 0;

753 
	`snmp_ok_response
(
msg_ps
);

755 
	}
}

765 
	$snmp_msg_event
(
u8_t
 
request_id
)

767 struct 
snmp_msg_pstat
 *
msg_ps
;

769 if (
request_id
 < 
SNMP_CONCURRENT_REQUESTS
)

771 
msg_ps
 = &
msg_input_list
[
request_id
];

772 if (
msg_ps
->
rt
 == 
SNMP_ASN1_PDU_GET_NEXT_REQ
)

774 
	`snmp_msg_getnext_event
(
request_id
, 
msg_ps
);

776 else if (
msg_ps
->
rt
 == 
SNMP_ASN1_PDU_GET_REQ
)

778 
	`snmp_msg_get_event
(
request_id
, 
msg_ps
);

780 else if(
msg_ps
->
rt
 == 
SNMP_ASN1_PDU_SET_REQ
)

782 
	`snmp_msg_set_event
(
request_id
, 
msg_ps
);

785 
	}
}

790 
	$snmp_recv
(void *
arg
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
)

792 struct 
udp_hdr
 *
udphdr
;

795 
	`LWIP_UNUSED_ARG
(
arg
);

797 if(
	`pbuf_header
(
p
, 
UDP_HLEN
)){

798 
	`LWIP_ASSERT
("Can't move to UDP header", 0);

799 
	`pbuf_free
(
p
);

802 
udphdr
 = 
p
->
payload
;

805 if ((
pcb
 == 
snmp1_pcb
) && (
	`ntohs
(
udphdr
->
dest
) == 
SNMP_IN_PORT
))

807 struct 
snmp_msg_pstat
 *
msg_ps
;

808 
u8_t
 
req_idx
;

811 
msg_ps
 = &
msg_input_list
[0];

812 
req_idx
 = 0;

813 while ((
req_idx
<
SNMP_CONCURRENT_REQUESTS
) && (
msg_ps
->
state
 != 
SNMP_MSG_EMPTY
))

815 
req_idx
++;

816 
msg_ps
++;

818 if (
req_idx
 != 
SNMP_CONCURRENT_REQUESTS
)

820 
err_t
 
err_ret
;

821 
u16_t
 
payload_len
;

822 
u16_t
 
payload_ofs
;

823 
u16_t
 
varbind_ofs
 = 0;

826 
	`snmp_inc_snmpinpkts
();

828 
msg_ps
->
pcb
 = pcb;

830 
msg_ps
->
sip
 = *
addr
;

832 
msg_ps
->
sp
 = 
port
;

834 
payload_len
 = 
	`ntohs
(
udphdr
->
len
) - 
UDP_HLEN
;

837 
payload_ofs
 = 
UDP_HLEN
;

840 
err_ret
 = 
	`snmp_pdu_header_check
(
p
, 
payload_ofs
, 
payload_len
, &
varbind_ofs
, 
msg_ps
);

841 if (((
msg_ps
->
rt
 == 
SNMP_ASN1_PDU_GET_REQ
) ||

842 (
msg_ps
->
rt
 == 
SNMP_ASN1_PDU_GET_NEXT_REQ
) ||

843 (
msg_ps
->
rt
 == 
SNMP_ASN1_PDU_SET_REQ
)) &&

844 ((
msg_ps
->
error_status
 == 
SNMP_ES_NOERROR
) &&

845 (
msg_ps
->
error_index
 == 0)) )

848 
err_ret
 = err_ret;

853 
err_ret
 = 
ERR_ARG
;

855 if (
err_ret
 == 
ERR_OK
)

857 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_recv ok, community %s\n", 
msg_ps
->
community
));

861 
err_ret
 = 
	`snmp_pdu_dec_varbindlist
(
p
, 
varbind_ofs
, &varbind_ofs, 
msg_ps
);

862 if ((
err_ret
 == 
ERR_OK
) && (
msg_ps
->
invb
.
count
 > 0))

865 
	`pbuf_free
(
p
);

867 
msg_ps
->
error_status
 = 
SNMP_ES_NOERROR
;

868 
msg_ps
->
error_index
 = 0;

870 
msg_ps
->
state
 = 
SNMP_MSG_SEARCH_OBJ
;

872 
msg_ps
->
vb_idx
 = 0;

874 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_recv varbind cnt=%"
U16_F
"\n",(
u16_t
)
msg_ps
->
invb
.
count
));

877 
	`snmp_msg_event
(
req_idx
);

884 
	`pbuf_free
(
p
);

885 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_pdu_dec_varbindlist() failed\n"));

892 
	`pbuf_free
(
p
);

893 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_pdu_header_check() failed\n"));

899 
	`pbuf_free
(
p
);

905 
	`pbuf_free
(
p
);

907 
	}
}

921 static 
err_t


922 
	$snmp_pdu_header_check
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
pdu_len
, u16_t *
ofs_ret
, struct 
snmp_msg_pstat
 *
m_stat
)

924 
err_t
 
derr
;

925 
u16_t
 
len
, 
ofs_base
;

926 
u8_t
 
len_octets
;

927 
u8_t
 
type
;

928 
s32_t
 
version
;

930 
ofs_base
 = 
ofs
;

931 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

932 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

933 if ((
derr
 != 
ERR_OK
) ||

934 (
pdu_len
 != (1 + 
len_octets
 + 
len
)) ||

935 (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_SEQ
)))

937 
	`snmp_inc_snmpinasnparseerrs
();

938 return 
ERR_ARG
;

940 
ofs
 += (1 + 
len_octets
);

941 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

942 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

943 if ((
derr
 != 
ERR_OK
) || (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
)))

946 
	`snmp_inc_snmpinasnparseerrs
();

947 return 
ERR_ARG
;

949 
derr
 = 
	`snmp_asn1_dec_s32t
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, &
version
);

950 if (
derr
 != 
ERR_OK
)

953 
	`snmp_inc_snmpinasnparseerrs
();

954 return 
ERR_ARG
;

956 if (
version
 != 0)

959 
	`snmp_inc_snmpinbadversions
();

960 return 
ERR_ARG
;

962 
ofs
 += (1 + 
len_octets
 + 
len
);

963 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

964 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

965 if ((
derr
 != 
ERR_OK
) || (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
)))

968 
	`snmp_inc_snmpinasnparseerrs
();

969 return 
ERR_ARG
;

971 
derr
 = 
	`snmp_asn1_dec_raw
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, 
SNMP_COMMUNITY_STR_LEN
, 
m_stat
->
community
);

972 if (
derr
 != 
ERR_OK
)

974 
	`snmp_inc_snmpinasnparseerrs
();

975 return 
ERR_ARG
;

978 
len
 = ((len < (
SNMP_COMMUNITY_STR_LEN
))?(len):(SNMP_COMMUNITY_STR_LEN));

979 
m_stat
->
community
[
len
] = 0;

980 
m_stat
->
com_strlen
 = 
len
;

981 if (
	`strncmp
(
snmp_publiccommunity
, (const char*)
m_stat
->
community
, 
SNMP_COMMUNITY_STR_LEN
) != 0)

984 
	`snmp_inc_snmpinbadcommunitynames
();

985 
	`snmp_authfail_trap
();

986 return 
ERR_ARG
;

988 
ofs
 += (1 + 
len_octets
 + 
len
);

989 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

990 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

991 if (
derr
 != 
ERR_OK
)

993 
	`snmp_inc_snmpinasnparseerrs
();

994 return 
ERR_ARG
;

996 switch(
type
)

998 case (
SNMP_ASN1_CONTXT
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_PDU_GET_REQ
):

1000 
	`snmp_inc_snmpingetrequests
();

1001 
derr
 = 
ERR_OK
;

1003 case (
SNMP_ASN1_CONTXT
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_PDU_GET_NEXT_REQ
):

1005 
	`snmp_inc_snmpingetnexts
();

1006 
derr
 = 
ERR_OK
;

1008 case (
SNMP_ASN1_CONTXT
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_PDU_GET_RESP
):

1010 
	`snmp_inc_snmpingetresponses
();

1011 
derr
 = 
ERR_ARG
;

1013 case (
SNMP_ASN1_CONTXT
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_PDU_SET_REQ
):

1015 
	`snmp_inc_snmpinsetrequests
();

1016 
derr
 = 
ERR_OK
;

1018 case (
SNMP_ASN1_CONTXT
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_PDU_TRAP
):

1020 
	`snmp_inc_snmpintraps
();

1021 
derr
 = 
ERR_ARG
;

1024 
	`snmp_inc_snmpinasnparseerrs
();

1025 
derr
 = 
ERR_ARG
;

1028 if (
derr
 != 
ERR_OK
)

1031 return 
ERR_ARG
;

1033 
m_stat
->
rt
 = 
type
 & 0x1F;

1034 
ofs
 += (1 + 
len_octets
);

1035 if (
len
 != (
pdu_len
 - (
ofs
 - 
ofs_base
)))

1038 
	`snmp_inc_snmpinasnparseerrs
();

1039 return 
ERR_ARG
;

1041 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

1042 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

1043 if ((
derr
 != 
ERR_OK
) || (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
)))

1046 
	`snmp_inc_snmpinasnparseerrs
();

1047 return 
ERR_ARG
;

1049 
derr
 = 
	`snmp_asn1_dec_s32t
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, &
m_stat
->
rid
);

1050 if (
derr
 != 
ERR_OK
)

1053 
	`snmp_inc_snmpinasnparseerrs
();

1054 return 
ERR_ARG
;

1056 
ofs
 += (1 + 
len_octets
 + 
len
);

1057 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

1058 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

1059 if ((
derr
 != 
ERR_OK
) || (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
)))

1062 
	`snmp_inc_snmpinasnparseerrs
();

1063 return 
ERR_ARG
;

1067 
derr
 = 
	`snmp_asn1_dec_s32t
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, &
m_stat
->
error_status
);

1068 if (
derr
 != 
ERR_OK
)

1071 
	`snmp_inc_snmpinasnparseerrs
();

1072 return 
ERR_ARG
;

1074 switch (
m_stat
->
error_status
)

1076 case 
SNMP_ES_TOOBIG
:

1077 
	`snmp_inc_snmpintoobigs
();

1079 case 
SNMP_ES_NOSUCHNAME
:

1080 
	`snmp_inc_snmpinnosuchnames
();

1082 case 
SNMP_ES_BADVALUE
:

1083 
	`snmp_inc_snmpinbadvalues
();

1085 case 
SNMP_ES_READONLY
:

1086 
	`snmp_inc_snmpinreadonlys
();

1088 case 
SNMP_ES_GENERROR
:

1089 
	`snmp_inc_snmpingenerrs
();

1092 
ofs
 += (1 + 
len_octets
 + 
len
);

1093 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

1094 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

1095 if ((
derr
 != 
ERR_OK
) || (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
)))

1098 
	`snmp_inc_snmpinasnparseerrs
();

1099 return 
ERR_ARG
;

1103 
derr
 = 
	`snmp_asn1_dec_s32t
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, &
m_stat
->
error_index
);

1104 if (
derr
 != 
ERR_OK
)

1107 
	`snmp_inc_snmpinasnparseerrs
();

1108 return 
ERR_ARG
;

1110 
ofs
 += (1 + 
len_octets
 + 
len
);

1111 *
ofs_ret
 = 
ofs
;

1112 return 
ERR_OK
;

1113 
	}
}

1115 static 
err_t


1116 
	$snmp_pdu_dec_varbindlist
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t *
ofs_ret
, struct 
snmp_msg_pstat
 *
m_stat
)

1118 
err_t
 
derr
;

1119 
u16_t
 
len
, 
vb_len
;

1120 
u8_t
 
len_octets
;

1121 
u8_t
 
type
;

1124 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

1125 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
vb_len
);

1126 if ((
derr
 != 
ERR_OK
) ||

1127 (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_SEQ
)))

1129 
	`snmp_inc_snmpinasnparseerrs
();

1130 return 
ERR_ARG
;

1132 
ofs
 += (1 + 
len_octets
);

1135 
m_stat
->
invb
.
count
 = 0;

1136 
m_stat
->
invb
.
head
 = 
NULL
;

1137 
m_stat
->
invb
.
tail
 = 
NULL
;

1139 while (
vb_len
 > 0)

1141 struct 
snmp_obj_id
 
oid
, 
oid_value
;

1142 struct 
snmp_varbind
 *
vb
;

1144 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

1145 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

1146 if ((
derr
 != 
ERR_OK
) ||

1147 (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_SEQ
)) ||

1148 (
len
 == 0) || (len > 
vb_len
))

1150 
	`snmp_inc_snmpinasnparseerrs
();

1152 
	`snmp_varbind_list_free
(&
m_stat
->
invb
);

1153 return 
ERR_ARG
;

1155 
ofs
 += (1 + 
len_octets
);

1156 
vb_len
 -= (1 + 
len_octets
);

1158 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

1159 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

1160 if ((
derr
 != 
ERR_OK
) || (
type
 != (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
)))

1163 
	`snmp_inc_snmpinasnparseerrs
();

1165 
	`snmp_varbind_list_free
(&
m_stat
->
invb
);

1166 return 
ERR_ARG
;

1168 
derr
 = 
	`snmp_asn1_dec_oid
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, &
oid
);

1169 if (
derr
 != 
ERR_OK
)

1172 
	`snmp_inc_snmpinasnparseerrs
();

1174 
	`snmp_varbind_list_free
(&
m_stat
->
invb
);

1175 return 
ERR_ARG
;

1177 
ofs
 += (1 + 
len_octets
 + 
len
);

1178 
vb_len
 -= (1 + 
len_octets
 + 
len
);

1180 
	`snmp_asn1_dec_type
(
p
, 
ofs
, &
type
);

1181 
derr
 = 
	`snmp_asn1_dec_length
(
p
, 
ofs
+1, &
len_octets
, &
len
);

1182 if (
derr
 != 
ERR_OK
)

1185 
	`snmp_inc_snmpinasnparseerrs
();

1187 
	`snmp_varbind_list_free
(&
m_stat
->
invb
);

1188 return 
ERR_ARG
;

1191 switch (
type
)

1193 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
):

1194 
vb
 = 
	`snmp_varbind_alloc
(&
oid
, 
type
, sizeof(
s32_t
));

1195 if (
vb
 != 
NULL
)

1197 
s32_t
 *
vptr
 = 
vb
->
value
;

1199 
derr
 = 
	`snmp_asn1_dec_s32t
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, 
vptr
);

1200 
	`snmp_varbind_tail_add
(&
m_stat
->
invb
, 
vb
);

1204 
derr
 = 
ERR_ARG
;

1207 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
):

1208 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_GAUGE
):

1209 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_TIMETICKS
):

1210 
vb
 = 
	`snmp_varbind_alloc
(&
oid
, 
type
, sizeof(
u32_t
));

1211 if (
vb
 != 
NULL
)

1213 
u32_t
 *
vptr
 = 
vb
->
value
;

1215 
derr
 = 
	`snmp_asn1_dec_u32t
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, 
vptr
);

1216 
	`snmp_varbind_tail_add
(&
m_stat
->
invb
, 
vb
);

1220 
derr
 = 
ERR_ARG
;

1223 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
):

1224 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OPAQUE
):

1225 
vb
 = 
	`snmp_varbind_alloc
(&
oid
, 
type
, 
len
);

1226 if (
vb
 != 
NULL
)

1228 
derr
 = 
	`snmp_asn1_dec_raw
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, 
vb
->
value_len
, vb->
value
);

1229 
	`snmp_varbind_tail_add
(&
m_stat
->
invb
, 
vb
);

1233 
derr
 = 
ERR_ARG
;

1236 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_NUL
):

1237 
vb
 = 
	`snmp_varbind_alloc
(&
oid
, 
type
, 0);

1238 if (
vb
 != 
NULL
)

1240 
	`snmp_varbind_tail_add
(&
m_stat
->
invb
, 
vb
);

1241 
derr
 = 
ERR_OK
;

1245 
derr
 = 
ERR_ARG
;

1248 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
):

1249 
derr
 = 
	`snmp_asn1_dec_oid
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, &
oid_value
);

1250 if (
derr
 == 
ERR_OK
)

1252 
vb
 = 
	`snmp_varbind_alloc
(&
oid
, 
type
, 
oid_value
.
len
 * sizeof(
s32_t
));

1253 if (
vb
 != 
NULL
)

1255 
u8_t
 
i
 = 
oid_value
.
len
;

1256 
s32_t
 *
vptr
 = 
vb
->
value
;

1258 while(
i
 > 0)

1260 
i
--;

1261 
vptr
[
i
] = 
oid_value
.
id
[i];

1263 
	`snmp_varbind_tail_add
(&
m_stat
->
invb
, 
vb
);

1264 
derr
 = 
ERR_OK
;

1268 
derr
 = 
ERR_ARG
;

1272 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
):

1273 if (
len
 == 4)

1276 
vb
 = 
	`snmp_varbind_alloc
(&
oid
, 
type
, 4);

1277 if (
vb
 != 
NULL
)

1279 
derr
 = 
	`snmp_asn1_dec_raw
(
p
, 
ofs
 + 1 + 
len_octets
, 
len
, 
vb
->
value_len
, vb->
value
);

1280 
	`snmp_varbind_tail_add
(&
m_stat
->
invb
, 
vb
);

1284 
derr
 = 
ERR_ARG
;

1289 
derr
 = 
ERR_ARG
;

1293 
derr
 = 
ERR_ARG
;

1296 if (
derr
 != 
ERR_OK
)

1298 
	`snmp_inc_snmpinasnparseerrs
();

1300 
	`snmp_varbind_list_free
(&
m_stat
->
invb
);

1301 return 
ERR_ARG
;

1303 
ofs
 += (1 + 
len_octets
 + 
len
);

1304 
vb_len
 -= (1 + 
len_octets
 + 
len
);

1307 if (
m_stat
->
rt
 == 
SNMP_ASN1_PDU_SET_REQ
)

1309 
	`snmp_add_snmpintotalsetvars
(
m_stat
->
invb
.
count
);

1313 
	`snmp_add_snmpintotalreqvars
(
m_stat
->
invb
.
count
);

1316 *
ofs_ret
 = 
ofs
;

1317 return 
ERR_OK
;

1318 
	}
}

1320 struct 
snmp_varbind
*

1321 
	$snmp_varbind_alloc
(struct 
snmp_obj_id
 *
oid
, 
u8_t
 
type
, u8_t 
len
)

1323 struct 
snmp_varbind
 *
vb
;

1325 
vb
 = (struct 
snmp_varbind
 *)
	`mem_malloc
(sizeof(struct snmp_varbind));

1326 
	`LWIP_ASSERT
("vb != NULL",
vb
 != 
NULL
);

1327 if (
vb
 != 
NULL
)

1329 
u8_t
 
i
;

1331 
vb
->
next
 = 
NULL
;

1332 
vb
->
prev
 = 
NULL
;

1333 
i
 = 
oid
->
len
;

1334 
vb
->
ident_len
 = 
i
;

1335 if (
i
 > 0)

1338 
vb
->
ident
 = (
s32_t
*)
	`mem_malloc
(sizeof(s32_t) * 
i
);

1339 
	`LWIP_ASSERT
("vb->ident != NULL",
vb
->
ident
 != 
NULL
);

1340 if (
vb
->
ident
 == 
NULL
)

1342 
	`mem_free
(
vb
);

1343 return 
NULL
;

1345 while(
i
 > 0)

1347 
i
--;

1348 
vb
->
ident
[
i
] = 
oid
->
id
[i];

1354 
vb
->
ident
 = 
NULL
;

1356 
vb
->
value_type
 = 
type
;

1357 
vb
->
value_len
 = 
len
;

1358 if (
len
 > 0)

1361 
vb
->
value
 = 
	`mem_malloc
(
len
);

1362 
	`LWIP_ASSERT
("vb->value != NULL",
vb
->
value
 != 
NULL
);

1363 if (
vb
->
value
 == 
NULL
)

1365 if (
vb
->
ident
 != 
NULL
)

1367 
	`mem_free
(
vb
->
ident
);

1369 
	`mem_free
(
vb
);

1370 return 
NULL
;

1376 
vb
->
value
 = 
NULL
;

1379 return 
vb
;

1380 
	}
}

1383 
	$snmp_varbind_free
(struct 
snmp_varbind
 *
vb
)

1385 if (
vb
->
value
 != 
NULL
 )

1387 
	`mem_free
(
vb
->
value
);

1389 if (
vb
->
ident
 != 
NULL
 )

1391 
	`mem_free
(
vb
->
ident
);

1393 
	`mem_free
(
vb
);

1394 
	}
}

1397 
	$snmp_varbind_list_free
(struct 
snmp_varbind_root
 *
root
)

1399 struct 
snmp_varbind
 *
vb
, *
prev
;

1401 
vb
 = 
root
->
tail
;

1402 while ( 
vb
 != 
NULL
 )

1404 
prev
 = 
vb
->prev;

1405 
	`snmp_varbind_free
(
vb
);

1406 
vb
 = 
prev
;

1408 
root
->
count
 = 0;

1409 
root
->
head
 = 
NULL
;

1410 
root
->
tail
 = 
NULL
;

1411 
	}
}

1414 
	$snmp_varbind_tail_add
(struct 
snmp_varbind_root
 *
root
, struct 
snmp_varbind
 *
vb
)

1416 if (
root
->
count
 == 0)

1419 
root
->
head
 = 
vb
;

1420 
root
->
tail
 = 
vb
;

1425 
root
->
tail
->
next
 = 
vb
;

1426 
vb
->
prev
 = 
root
->
tail
;

1427 
root
->
tail
 = 
vb
;

1429 
root
->
count
 += 1;

1430 
	}
}

1432 struct 
snmp_varbind
*

1433 
	$snmp_varbind_tail_remove
(struct 
snmp_varbind_root
 *
root
)

1435 struct 
snmp_varbind
* 
vb
;

1437 if (
root
->
count
 > 0)

1440 
vb
 = 
root
->
tail
;

1441 
root
->
tail
 = 
vb
->
prev
;

1442 
vb
->
prev
->
next
 = 
NULL
;

1443 
root
->
count
 -= 1;

1448 
vb
 = 
NULL
;

1450 return 
vb
;

1451 
	}
}

	@/root/Robux/net/lwip/core/snmp/msg_out.c

45 #include 
	~"lwip/opt.h
"

47 #if 
LWIP_SNMP


49 #include 
	~"lwip/udp.h
"

50 #include 
	~"lwip/netif.h
"

51 #include 
	~"lwip/snmp.h
"

52 #include 
	~"lwip/snmp_asn1.h
"

53 #include 
	~"lwip/snmp_msg.h
"

55 struct 
	ssnmp_trap_dst


58 struct 
ip_addr
 
	mdip
;

60 
u8_t
 
	menable
;

62 struct 
snmp_trap_dst
 
	gtrap_dst
[
SNMP_TRAP_DESTINATIONS
];

65 struct 
snmp_msg_trap
 
	gtrap_msg
;

67 static 
u16_t
 
snmp_resp_header_sum
(struct 
snmp_msg_pstat
 *
m_stat
, u16_t 
vb_len
);

68 static 
u16_t
 
snmp_trap_header_sum
(struct 
snmp_msg_trap
 *
m_trap
, u16_t 
vb_len
);

69 static 
u16_t
 
snmp_varbind_list_sum
(struct 
snmp_varbind_root
 *
root
);

71 static 
u16_t
 
snmp_resp_header_enc
(struct 
snmp_msg_pstat
 *
m_stat
, struct 
pbuf
 *
p
);

72 static 
u16_t
 
snmp_trap_header_enc
(struct 
snmp_msg_trap
 *
m_trap
, struct 
pbuf
 *
p
);

73 static 
u16_t
 
snmp_varbind_list_enc
(struct 
snmp_varbind_root
 *
root
, struct 
pbuf
 *
p
, u16_t 
ofs
);

81 
	$snmp_trap_dst_enable
(
u8_t
 
dst_idx
, u8_t 
enable
)

83 if (
dst_idx
 < 
SNMP_TRAP_DESTINATIONS
)

85 
trap_dst
[
dst_idx
].
enable
 = enable;

87 
	}
}

95 
	$snmp_trap_dst_ip_set
(
u8_t
 
dst_idx
, struct 
ip_addr
 *
dst
)

97 if (
dst_idx
 < 
SNMP_TRAP_DESTINATIONS
)

99 
trap_dst
[
dst_idx
].
dip
.
addr
 = 
	`htonl
(
dst
->addr);

101 
	}
}

112 
err_t


113 
	$snmp_send_response
(struct 
snmp_msg_pstat
 *
m_stat
)

115 struct 
snmp_varbind_root
 
emptyvb
 = {
NULL
, NULL, 0, 0, 0};

116 struct 
pbuf
 *
p
;

117 
u16_t
 
tot_len
;

118 
err_t
 
err
;

121 
tot_len
 = 
	`snmp_varbind_list_sum
(&
m_stat
->
outvb
);

122 
tot_len
 = 
	`snmp_resp_header_sum
(
m_stat
, tot_len);

125 
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
tot_len
, 
PBUF_POOL
);

126 if (
p
 == 
NULL
)

128 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_snd_response() tooBig\n"));

131 
m_stat
->
error_status
 = 
SNMP_ES_TOOBIG
;

132 
m_stat
->
error_index
 = 0;

134 
tot_len
 = 
	`snmp_varbind_list_sum
(&
emptyvb
);

135 
tot_len
 = 
	`snmp_resp_header_sum
(
m_stat
, tot_len);

137 
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
tot_len
, 
PBUF_POOL
);

139 if (
p
 != 
NULL
)

142 
u16_t
 
ofs
;

144 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_snd_response() p != NULL\n"));

147 
ofs
 = 
	`snmp_resp_header_enc
(
m_stat
, 
p
);

148 if (
m_stat
->
error_status
 == 
SNMP_ES_TOOBIG
)

150 
	`snmp_varbind_list_enc
(&
emptyvb
, 
p
, 
ofs
);

154 
	`snmp_varbind_list_enc
(&
m_stat
->
outvb
, 
p
, 
ofs
);

157 switch (
m_stat
->
error_status
)

159 case 
SNMP_ES_TOOBIG
:

160 
	`snmp_inc_snmpouttoobigs
();

162 case 
SNMP_ES_NOSUCHNAME
:

163 
	`snmp_inc_snmpoutnosuchnames
();

165 case 
SNMP_ES_BADVALUE
:

166 
	`snmp_inc_snmpoutbadvalues
();

168 case 
SNMP_ES_GENERROR
:

169 
	`snmp_inc_snmpoutgenerrs
();

172 
	`snmp_inc_snmpoutgetresponses
();

173 
	`snmp_inc_snmpoutpkts
();

177 
	`udp_connect
(
m_stat
->
pcb
, &m_stat->
sip
, m_stat->
sp
);

178 
err
 = 
	`udp_send
(
m_stat
->
pcb
, 
p
);

179 if (
err
 == 
ERR_MEM
)

182 
err
 = 
ERR_MEM
;

186 
err
 = 
ERR_OK
;

189 
	`udp_disconnect
(
m_stat
->
pcb
);

191 
	`pbuf_free
(
p
);

192 
	`LWIP_DEBUGF
(
SNMP_MSG_DEBUG
, ("snmp_snd_response() done\n"));

193 return 
err
;

199 return 
ERR_MEM
;

201 
	}
}

219 
err_t


220 
	$snmp_send_trap
(
s8_t
 
generic_trap
, struct 
snmp_obj_id
 *
eoid
, 
s32_t
 
specific_trap
)

222 struct 
snmp_trap_dst
 *
td
;

223 struct 
netif
 *
dst_if
;

224 struct 
ip_addr
 
dst_ip
;

225 struct 
pbuf
 *
p
;

226 
u16_t
 
i
,
tot_len
;

228 for (
i
=0, 
td
 = &
trap_dst
[0]; i<
SNMP_TRAP_DESTINATIONS
; i++, td++)

230 if ((
td
->
enable
 != 0) && (td->
dip
.
addr
 != 0))

233 
trap_msg
.
dip
.
addr
 = 
td
->dip.addr;

235 
dst_if
 = 
	`ip_route
(&
td
->
dip
);

236 
dst_ip
.
addr
 = 
	`ntohl
(
dst_if
->
ip_addr
.addr);

237 
trap_msg
.
sip_raw
[0] = 
dst_ip
.
addr
 >> 24;

238 
trap_msg
.
sip_raw
[1] = 
dst_ip
.
addr
 >> 16;

239 
trap_msg
.
sip_raw
[2] = 
dst_ip
.
addr
 >> 8;

240 
trap_msg
.
sip_raw
[3] = 
dst_ip
.
addr
;

241 
trap_msg
.
gen_trap
 = 
generic_trap
;

242 
trap_msg
.
spc_trap
 = 
specific_trap
;

243 if (
generic_trap
 == 
SNMP_GENTRAP_ENTERPRISESPC
)

246 
trap_msg
.
enterprise
 = 
eoid
;

251 
	`snmp_get_snmpgrpid_ptr
(&
trap_msg
.
enterprise
);

253 
	`snmp_get_sysuptime
(&
trap_msg
.
ts
);

256 
tot_len
 = 
	`snmp_varbind_list_sum
(&
trap_msg
.
outvb
);

257 
tot_len
 = 
	`snmp_trap_header_sum
(&
trap_msg
, tot_len);

260 
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
tot_len
, 
PBUF_POOL
);

261 if (
p
 != 
NULL
)

263 
u16_t
 
ofs
;

266 
ofs
 = 
	`snmp_trap_header_enc
(&
trap_msg
, 
p
);

267 
	`snmp_varbind_list_enc
(&
trap_msg
.
outvb
, 
p
, 
ofs
);

269 
	`snmp_inc_snmpouttraps
();

270 
	`snmp_inc_snmpoutpkts
();

273 
	`udp_connect
(
trap_msg
.
pcb
, &trap_msg.
dip
, 
SNMP_TRAP_PORT
);

274 
	`udp_send
(
trap_msg
.
pcb
, 
p
);

276 
	`udp_disconnect
(
trap_msg
.
pcb
);

278 
	`pbuf_free
(
p
);

282 return 
ERR_MEM
;

286 return 
ERR_OK
;

287 
	}
}

290 
	$snmp_coldstart_trap
(void)

292 
trap_msg
.
outvb
.
head
 = 
NULL
;

293 
trap_msg
.
outvb
.
tail
 = 
NULL
;

294 
trap_msg
.
outvb
.
count
 = 0;

295 
	`snmp_send_trap
(
SNMP_GENTRAP_COLDSTART
, 
NULL
, 0);

296 
	}
}

299 
	$snmp_authfail_trap
(void)

301 
u8_t
 
enable
;

302 
	`snmp_get_snmpenableauthentraps
(&
enable
);

303 if (
enable
 == 1)

305 
trap_msg
.
outvb
.
head
 = 
NULL
;

306 
trap_msg
.
outvb
.
tail
 = 
NULL
;

307 
trap_msg
.
outvb
.
count
 = 0;

308 
	`snmp_send_trap
(
SNMP_GENTRAP_AUTHFAIL
, 
NULL
, 0);

310 
	}
}

320 static 
u16_t


321 
	$snmp_resp_header_sum
(struct 
snmp_msg_pstat
 *
m_stat
, 
u16_t
 
vb_len
)

323 
u16_t
 
tot_len
;

324 struct 
snmp_resp_header_lengths
 *
rhl
;

326 
rhl
 = &
m_stat
->rhl;

327 
tot_len
 = 
vb_len
;

328 
	`snmp_asn1_enc_s32t_cnt
(
m_stat
->
error_index
, &
rhl
->
erridxlen
);

329 
	`snmp_asn1_enc_length_cnt
(
rhl
->
erridxlen
, &rhl->
erridxlenlen
);

330 
tot_len
 += 1 + 
rhl
->
erridxlenlen
 + rhl->
erridxlen
;

332 
	`snmp_asn1_enc_s32t_cnt
(
m_stat
->
error_status
, &
rhl
->
errstatlen
);

333 
	`snmp_asn1_enc_length_cnt
(
rhl
->
errstatlen
, &rhl->
errstatlenlen
);

334 
tot_len
 += 1 + 
rhl
->
errstatlenlen
 + rhl->
errstatlen
;

336 
	`snmp_asn1_enc_s32t_cnt
(
m_stat
->
rid
, &
rhl
->
ridlen
);

337 
	`snmp_asn1_enc_length_cnt
(
rhl
->
ridlen
, &rhl->
ridlenlen
);

338 
tot_len
 += 1 + 
rhl
->
ridlenlen
 + rhl->
ridlen
;

340 
rhl
->
pdulen
 = 
tot_len
;

341 
	`snmp_asn1_enc_length_cnt
(
rhl
->
pdulen
, &rhl->
pdulenlen
);

342 
tot_len
 += 1 + 
rhl
->
pdulenlen
;

344 
rhl
->
comlen
 = 
m_stat
->
com_strlen
;

345 
	`snmp_asn1_enc_length_cnt
(
rhl
->
comlen
, &rhl->
comlenlen
);

346 
tot_len
 += 1 + 
rhl
->
comlenlen
 + rhl->
comlen
;

348 
	`snmp_asn1_enc_s32t_cnt
(
snmp_version
, &
rhl
->
verlen
);

349 
	`snmp_asn1_enc_length_cnt
(
rhl
->
verlen
, &rhl->
verlenlen
);

350 
tot_len
 += 1 + 
rhl
->
verlen
 + rhl->
verlenlen
;

352 
rhl
->
seqlen
 = 
tot_len
;

353 
	`snmp_asn1_enc_length_cnt
(
rhl
->
seqlen
, &rhl->
seqlenlen
);

354 
tot_len
 += 1 + 
rhl
->
seqlenlen
;

356 return 
tot_len
;

357 
	}
}

367 static 
u16_t


368 
	$snmp_trap_header_sum
(struct 
snmp_msg_trap
 *
m_trap
, 
u16_t
 
vb_len
)

370 
u16_t
 
tot_len
;

371 struct 
snmp_trap_header_lengths
 *
thl
;

373 
thl
 = &
m_trap
->thl;

374 
tot_len
 = 
vb_len
;

376 
	`snmp_asn1_enc_u32t_cnt
(
m_trap
->
ts
, &
thl
->
tslen
);

377 
	`snmp_asn1_enc_length_cnt
(
thl
->
tslen
, &thl->
tslenlen
);

378 
tot_len
 += 1 + 
thl
->
tslen
 + thl->
tslenlen
;

380 
	`snmp_asn1_enc_s32t_cnt
(
m_trap
->
spc_trap
, &
thl
->
strplen
);

381 
	`snmp_asn1_enc_length_cnt
(
thl
->
strplen
, &thl->
strplenlen
);

382 
tot_len
 += 1 + 
thl
->
strplen
 + thl->
strplenlen
;

384 
	`snmp_asn1_enc_s32t_cnt
(
m_trap
->
gen_trap
, &
thl
->
gtrplen
);

385 
	`snmp_asn1_enc_length_cnt
(
thl
->
gtrplen
, &thl->
gtrplenlen
);

386 
tot_len
 += 1 + 
thl
->
gtrplen
 + thl->
gtrplenlen
;

388 
thl
->
aaddrlen
 = 4;

389 
	`snmp_asn1_enc_length_cnt
(
thl
->
aaddrlen
, &thl->
aaddrlenlen
);

390 
tot_len
 += 1 + 
thl
->
aaddrlen
 + thl->
aaddrlenlen
;

392 
	`snmp_asn1_enc_oid_cnt
(
m_trap
->
enterprise
->
len
, &m_trap->enterprise->
id
[0], &
thl
->
eidlen
);

393 
	`snmp_asn1_enc_length_cnt
(
thl
->
eidlen
, &thl->
eidlenlen
);

394 
tot_len
 += 1 + 
thl
->
eidlen
 + thl->
eidlenlen
;

396 
thl
->
pdulen
 = 
tot_len
;

397 
	`snmp_asn1_enc_length_cnt
(
thl
->
pdulen
, &thl->
pdulenlen
);

398 
tot_len
 += 1 + 
thl
->
pdulenlen
;

400 
thl
->
comlen
 = sizeof(
snmp_publiccommunity
) - 1;

401 
	`snmp_asn1_enc_length_cnt
(
thl
->
comlen
, &thl->
comlenlen
);

402 
tot_len
 += 1 + 
thl
->
comlenlen
 + thl->
comlen
;

404 
	`snmp_asn1_enc_s32t_cnt
(
snmp_version
, &
thl
->
verlen
);

405 
	`snmp_asn1_enc_length_cnt
(
thl
->
verlen
, &thl->
verlenlen
);

406 
tot_len
 += 1 + 
thl
->
verlen
 + thl->
verlenlen
;

408 
thl
->
seqlen
 = 
tot_len
;

409 
	`snmp_asn1_enc_length_cnt
(
thl
->
seqlen
, &thl->
seqlenlen
);

410 
tot_len
 += 1 + 
thl
->
seqlenlen
;

412 return 
tot_len
;

413 
	}
}

422 static 
u16_t


423 
	$snmp_varbind_list_sum
(struct 
snmp_varbind_root
 *
root
)

425 struct 
snmp_varbind
 *
vb
;

426 
u32_t
 *
uint_ptr
;

427 
s32_t
 *
sint_ptr
;

428 
u16_t
 
tot_len
;

430 
tot_len
 = 0;

431 
vb
 = 
root
->
tail
;

432 while ( 
vb
 != 
NULL
 )

435 switch (
vb
->
value_type
)

437 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
):

438 
sint_ptr
 = 
vb
->
value
;

439 
	`snmp_asn1_enc_s32t_cnt
(*
sint_ptr
, &
vb
->
vlen
);

441 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
):

442 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_GAUGE
):

443 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_TIMETICKS
):

444 
uint_ptr
 = 
vb
->
value
;

445 
	`snmp_asn1_enc_u32t_cnt
(*
uint_ptr
, &
vb
->
vlen
);

447 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
):

448 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_NUL
):

449 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
):

450 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OPAQUE
):

451 
vb
->
vlen
 = vb->
value_len
;

453 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
):

454 
sint_ptr
 = 
vb
->
value
;

455 
	`snmp_asn1_enc_oid_cnt
(
vb
->
value_len
 / sizeof(
s32_t
), 
sint_ptr
, &vb->
vlen
);

459 
vb
->
vlen
 = 0;

463 
	`snmp_asn1_enc_length_cnt
(
vb
->
vlen
, &vb->
vlenlen
);

464 
	`snmp_asn1_enc_oid_cnt
(
vb
->
ident_len
, vb->
ident
, &vb->
olen
);

465 
	`snmp_asn1_enc_length_cnt
(
vb
->
olen
, &vb->
olenlen
);

467 
vb
->
seqlen
 = 1 + vb->
vlenlen
 + vb->
vlen
;

468 
vb
->
seqlen
 += 1 + vb->
olenlen
 + vb->
olen
;

469 
	`snmp_asn1_enc_length_cnt
(
vb
->
seqlen
, &vb->
seqlenlen
);

472 
tot_len
 += 1 + 
vb
->
seqlenlen
 + vb->
seqlen
;

474 
vb
 = vb->
prev
;

478 
root
->
seqlen
 = 
tot_len
;

479 
	`snmp_asn1_enc_length_cnt
(
root
->
seqlen
, &root->
seqlenlen
);

480 
tot_len
 += 1 + 
root
->
seqlenlen
;

482 return 
tot_len
;

483 
	}
}

488 static 
u16_t


489 
	$snmp_resp_header_enc
(struct 
snmp_msg_pstat
 *
m_stat
, struct 
pbuf
 *
p
)

491 
u16_t
 
ofs
;

493 
ofs
 = 0;

494 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_SEQ
));

495 
ofs
 += 1;

496 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_stat
->
rhl
.
seqlen
);

497 
ofs
 += 
m_stat
->
rhl
.
seqlenlen
;

499 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
));

500 
ofs
 += 1;

501 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_stat
->
rhl
.
verlen
);

502 
ofs
 += 
m_stat
->
rhl
.
verlenlen
;

503 
	`snmp_asn1_enc_s32t
(
p
, 
ofs
, 
m_stat
->
rhl
.
verlen
, 
snmp_version
);

504 
ofs
 += 
m_stat
->
rhl
.
verlen
;

506 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
));

507 
ofs
 += 1;

508 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_stat
->
rhl
.
comlen
);

509 
ofs
 += 
m_stat
->
rhl
.
comlenlen
;

510 
	`snmp_asn1_enc_raw
(
p
, 
ofs
, 
m_stat
->
rhl
.
comlen
, m_stat->
community
);

511 
ofs
 += 
m_stat
->
rhl
.
comlen
;

513 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_CONTXT
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_PDU_GET_RESP
));

514 
ofs
 += 1;

515 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_stat
->
rhl
.
pdulen
);

516 
ofs
 += 
m_stat
->
rhl
.
pdulenlen
;

518 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
));

519 
ofs
 += 1;

520 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_stat
->
rhl
.
ridlen
);

521 
ofs
 += 
m_stat
->
rhl
.
ridlenlen
;

522 
	`snmp_asn1_enc_s32t
(
p
, 
ofs
, 
m_stat
->
rhl
.
ridlen
, m_stat->
rid
);

523 
ofs
 += 
m_stat
->
rhl
.
ridlen
;

525 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
));

526 
ofs
 += 1;

527 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_stat
->
rhl
.
errstatlen
);

528 
ofs
 += 
m_stat
->
rhl
.
errstatlenlen
;

529 
	`snmp_asn1_enc_s32t
(
p
, 
ofs
, 
m_stat
->
rhl
.
errstatlen
, m_stat->
error_status
);

530 
ofs
 += 
m_stat
->
rhl
.
errstatlen
;

532 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
));

533 
ofs
 += 1;

534 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_stat
->
rhl
.
erridxlen
);

535 
ofs
 += 
m_stat
->
rhl
.
erridxlenlen
;

536 
	`snmp_asn1_enc_s32t
(
p
, 
ofs
, 
m_stat
->
rhl
.
erridxlen
, m_stat->
error_index
);

537 
ofs
 += 
m_stat
->
rhl
.
erridxlen
;

539 return 
ofs
;

540 
	}
}

545 static 
u16_t


546 
	$snmp_trap_header_enc
(struct 
snmp_msg_trap
 *
m_trap
, struct 
pbuf
 *
p
)

548 
u16_t
 
ofs
;

550 
ofs
 = 0;

551 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_SEQ
));

552 
ofs
 += 1;

553 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
seqlen
);

554 
ofs
 += 
m_trap
->
thl
.
seqlenlen
;

556 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
));

557 
ofs
 += 1;

558 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
verlen
);

559 
ofs
 += 
m_trap
->
thl
.
verlenlen
;

560 
	`snmp_asn1_enc_s32t
(
p
, 
ofs
, 
m_trap
->
thl
.
verlen
, 
snmp_version
);

561 
ofs
 += 
m_trap
->
thl
.
verlen
;

563 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
));

564 
ofs
 += 1;

565 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
comlen
);

566 
ofs
 += 
m_trap
->
thl
.
comlenlen
;

567 
	`snmp_asn1_enc_raw
(
p
, 
ofs
, 
m_trap
->
thl
.
comlen
, (
u8_t
 *)&
snmp_publiccommunity
[0]);

568 
ofs
 += 
m_trap
->
thl
.
comlen
;

570 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_CONTXT
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_PDU_TRAP
));

571 
ofs
 += 1;

572 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
pdulen
);

573 
ofs
 += 
m_trap
->
thl
.
pdulenlen
;

575 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
));

576 
ofs
 += 1;

577 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
eidlen
);

578 
ofs
 += 
m_trap
->
thl
.
eidlenlen
;

579 
	`snmp_asn1_enc_oid
(
p
, 
ofs
, 
m_trap
->
enterprise
->
len
, &m_trap->enterprise->
id
[0]);

580 
ofs
 += 
m_trap
->
thl
.
eidlen
;

582 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
));

583 
ofs
 += 1;

584 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
aaddrlen
);

585 
ofs
 += 
m_trap
->
thl
.
aaddrlenlen
;

586 
	`snmp_asn1_enc_raw
(
p
, 
ofs
, 
m_trap
->
thl
.
aaddrlen
, &m_trap->
sip_raw
[0]);

587 
ofs
 += 
m_trap
->
thl
.
aaddrlen
;

589 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
));

590 
ofs
 += 1;

591 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
gtrplen
);

592 
ofs
 += 
m_trap
->
thl
.
gtrplenlen
;

593 
	`snmp_asn1_enc_u32t
(
p
, 
ofs
, 
m_trap
->
thl
.
gtrplen
, m_trap->
gen_trap
);

594 
ofs
 += 
m_trap
->
thl
.
gtrplen
;

596 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
));

597 
ofs
 += 1;

598 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
strplen
);

599 
ofs
 += 
m_trap
->
thl
.
strplenlen
;

600 
	`snmp_asn1_enc_u32t
(
p
, 
ofs
, 
m_trap
->
thl
.
strplen
, m_trap->
spc_trap
);

601 
ofs
 += 
m_trap
->
thl
.
strplen
;

603 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_TIMETICKS
));

604 
ofs
 += 1;

605 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
m_trap
->
thl
.
tslen
);

606 
ofs
 += 
m_trap
->
thl
.
tslenlen
;

607 
	`snmp_asn1_enc_u32t
(
p
, 
ofs
, 
m_trap
->
thl
.
tslen
, m_trap->
ts
);

608 
ofs
 += 
m_trap
->
thl
.
tslen
;

610 return 
ofs
;

611 
	}
}

616 static 
u16_t


617 
	$snmp_varbind_list_enc
(struct 
snmp_varbind_root
 *
root
, struct 
pbuf
 *
p
, 
u16_t
 
ofs
)

619 struct 
snmp_varbind
 *
vb
;

620 
s32_t
 *
sint_ptr
;

621 
u32_t
 *
uint_ptr
;

622 
u8_t
 *
raw_ptr
;

624 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_SEQ
));

625 
ofs
 += 1;

626 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
root
->
seqlen
);

627 
ofs
 += 
root
->
seqlenlen
;

629 
vb
 = 
root
->
head
;

630 while ( 
vb
 != 
NULL
 )

632 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_CONSTR
 | 
SNMP_ASN1_SEQ
));

633 
ofs
 += 1;

634 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
vb
->
seqlen
);

635 
ofs
 += 
vb
->
seqlenlen
;

637 
	`snmp_asn1_enc_type
(
p
, 
ofs
, (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
));

638 
ofs
 += 1;

639 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
vb
->
olen
);

640 
ofs
 += 
vb
->
olenlen
;

641 
	`snmp_asn1_enc_oid
(
p
, 
ofs
, 
vb
->
ident_len
, &vb->
ident
[0]);

642 
ofs
 += 
vb
->
olen
;

644 
	`snmp_asn1_enc_type
(
p
, 
ofs
, 
vb
->
value_type
);

645 
ofs
 += 1;

646 
	`snmp_asn1_enc_length
(
p
, 
ofs
, 
vb
->
vlen
);

647 
ofs
 += 
vb
->
vlenlen
;

649 switch (
vb
->
value_type
)

651 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_INTEG
):

652 
sint_ptr
 = 
vb
->
value
;

653 
	`snmp_asn1_enc_s32t
(
p
, 
ofs
, 
vb
->
vlen
, *
sint_ptr
);

655 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_COUNTER
):

656 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_GAUGE
):

657 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_TIMETICKS
):

658 
uint_ptr
 = 
vb
->
value
;

659 
	`snmp_asn1_enc_u32t
(
p
, 
ofs
, 
vb
->
vlen
, *
uint_ptr
);

661 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OC_STR
):

662 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_IPADDR
):

663 case (
SNMP_ASN1_APPLIC
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OPAQUE
):

664 
raw_ptr
 = 
vb
->
value
;

665 
	`snmp_asn1_enc_raw
(
p
, 
ofs
, 
vb
->
vlen
, 
raw_ptr
);

667 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_NUL
):

669 case (
SNMP_ASN1_UNIV
 | 
SNMP_ASN1_PRIMIT
 | 
SNMP_ASN1_OBJ_ID
):

670 
sint_ptr
 = 
vb
->
value
;

671 
	`snmp_asn1_enc_oid
(
p
, 
ofs
, 
vb
->
value_len
 / sizeof(
s32_t
), 
sint_ptr
);

677 
ofs
 += 
vb
->
vlen
;

678 
vb
 = vb->
next
;

680 return 
ofs
;

681 
	}
}

	@/root/Robux/net/lwip/core/stats.c

39 #include 
	~"lwip/opt.h
"

41 #if 
LWIP_STATS


43 #include 
	~"lwip/def.h
"

44 #include 
	~"lwip/stats.h
"

45 #include 
	~"lwip/mem.h
"

47 #include 
	~<string.h
>

49 struct 
stats_
 
	glwip_stats
;

51 #if 
LWIP_STATS_DISPLAY


53 
	$stats_display_proto
(struct 
stats_proto
 *
proto
, char *
name
)

55 
	`LWIP_PLATFORM_DIAG
(("\n%s\n\t", 
name
));

56 
	`LWIP_PLATFORM_DIAG
(("xmit: %"
STAT_COUNTER_F
"\n\t", 
proto
->
xmit
));

57 
	`LWIP_PLATFORM_DIAG
(("recv: %"
STAT_COUNTER_F
"\n\t", 
proto
->
recv
));

58 
	`LWIP_PLATFORM_DIAG
(("fw: %"
STAT_COUNTER_F
"\n\t", 
proto
->
fw
));

59 
	`LWIP_PLATFORM_DIAG
(("drop: %"
STAT_COUNTER_F
"\n\t", 
proto
->
drop
));

60 
	`LWIP_PLATFORM_DIAG
(("chkerr: %"
STAT_COUNTER_F
"\n\t", 
proto
->
chkerr
));

61 
	`LWIP_PLATFORM_DIAG
(("lenerr: %"
STAT_COUNTER_F
"\n\t", 
proto
->
lenerr
));

62 
	`LWIP_PLATFORM_DIAG
(("memerr: %"
STAT_COUNTER_F
"\n\t", 
proto
->
memerr
));

63 
	`LWIP_PLATFORM_DIAG
(("rterr: %"
STAT_COUNTER_F
"\n\t", 
proto
->
rterr
));

64 
	`LWIP_PLATFORM_DIAG
(("proterr: %"
STAT_COUNTER_F
"\n\t", 
proto
->
proterr
));

65 
	`LWIP_PLATFORM_DIAG
(("opterr: %"
STAT_COUNTER_F
"\n\t", 
proto
->
opterr
));

66 
	`LWIP_PLATFORM_DIAG
(("err: %"
STAT_COUNTER_F
"\n\t", 
proto
->
err
));

67 
	`LWIP_PLATFORM_DIAG
(("cachehit: %"
STAT_COUNTER_F
"\n", 
proto
->
cachehit
));

68 
	}
}

70 #if 
IGMP_STATS


72 
	$stats_display_igmp
(struct 
stats_igmp
 *
igmp
)

74 
	`LWIP_PLATFORM_DIAG
(("\nIGMP\n\t"));

75 
	`LWIP_PLATFORM_DIAG
(("lenerr: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
lenerr
));

76 
	`LWIP_PLATFORM_DIAG
(("chkerr: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
chkerr
));

77 
	`LWIP_PLATFORM_DIAG
(("v1_rxed: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
v1_rxed
));

78 
	`LWIP_PLATFORM_DIAG
(("join_sent: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
join_sent
));

79 
	`LWIP_PLATFORM_DIAG
(("leave_sent: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
leave_sent
));

80 
	`LWIP_PLATFORM_DIAG
(("unicast_query: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
unicast_query
));

81 
	`LWIP_PLATFORM_DIAG
(("report_sent: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
report_sent
));

82 
	`LWIP_PLATFORM_DIAG
(("report_rxed: %"
STAT_COUNTER_F
"\n\t", 
igmp
->
report_rxed
));

83 
	`LWIP_PLATFORM_DIAG
(("group_query_rxed: %"
STAT_COUNTER_F
"\n", 
igmp
->
group_query_rxed
));

84 
	}
}

87 #if 
MEM_STATS
 || 
MEMP_STATS


89 
	$stats_display_mem
(struct 
stats_mem
 *
mem
, char *
name
)

91 
	`LWIP_PLATFORM_DIAG
(("\nMEM %s\n\t", 
name
));

92 
	`LWIP_PLATFORM_DIAG
(("avail: %"
U32_F
"\n\t", (
u32_t
)
mem
->
avail
));

93 
	`LWIP_PLATFORM_DIAG
(("used: %"
U32_F
"\n\t", (
u32_t
)
mem
->
used
));

94 
	`LWIP_PLATFORM_DIAG
(("max: %"
U32_F
"\n\t", (
u32_t
)
mem
->
max
));

95 
	`LWIP_PLATFORM_DIAG
(("err: %"
U32_F
"\n", (
u32_t
)
mem
->
err
));

96 
	}
}

98 #if 
MEMP_STATS


100 
	$stats_display_memp
(struct 
stats_mem
 *
mem
, int 
index
)

102 char * 
memp_names
[] = {

103 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
) desc,

	)

104 #include 
	~"lwip/memp_std.h
"

106 if(
index
 < 
MEMP_MAX
) {

107 
	`stats_display_mem
(
mem
, 
memp_names
[
index
]);

109 
	}
}

113 #if 
SYS_STATS


115 
	$stats_display_sys
(struct 
stats_sys
 *
sys
)

117 
	`LWIP_PLATFORM_DIAG
(("\nSYS\n\t"));

118 
	`LWIP_PLATFORM_DIAG
(("sem.used: %"
U32_F
"\n\t", (
u32_t
)
sys
->
sem
.
used
));

119 
	`LWIP_PLATFORM_DIAG
(("sem.max: %"
U32_F
"\n\t", (
u32_t
)
sys
->
sem
.
max
));

120 
	`LWIP_PLATFORM_DIAG
(("sem.err: %"
U32_F
"\n\t", (
u32_t
)
sys
->
sem
.
err
));

121 
	`LWIP_PLATFORM_DIAG
(("mbox.used: %"
U32_F
"\n\t", (
u32_t
)
sys
->
mbox
.
used
));

122 
	`LWIP_PLATFORM_DIAG
(("mbox.max: %"
U32_F
"\n\t", (
u32_t
)
sys
->
mbox
.
max
));

123 
	`LWIP_PLATFORM_DIAG
(("mbox.err: %"
U32_F
"\n\t", (
u32_t
)
sys
->
mbox
.
err
));

124 
	}
}

128 
	$stats_display
(void)

130 
s16_t
 
i
;

132 
	`LINK_STATS_DISPLAY
();

133 
	`ETHARP_STATS_DISPLAY
();

134 
	`IPFRAG_STATS_DISPLAY
();

135 
	`IP_STATS_DISPLAY
();

136 
	`IGMP_STATS_DISPLAY
();

137 
	`ICMP_STATS_DISPLAY
();

138 
	`UDP_STATS_DISPLAY
();

139 
	`TCP_STATS_DISPLAY
();

140 
	`MEM_STATS_DISPLAY
();

141 for (
i
 = 0; i < 
MEMP_MAX
; i++) {

142 
	`MEMP_STATS_DISPLAY
(
i
);

144 
	`SYS_STATS_DISPLAY
();

145 
	}
}

	@/root/Robux/net/lwip/core/sys.c

39 #include 
	~"lwip/opt.h
"

41 #if (
NO_SYS
 == 0)

43 #include 
	~"lwip/sys.h
"

44 #include 
	~"lwip/def.h
"

45 #include 
	~"lwip/memp.h
"

46 #include 
	~"lwip/tcpip.h
"

52 struct 
	ssswt_cb


54 
s16_t
 
	mtimeflag
;

55 
sys_sem_t
 *
	mpsem
;

66 
	$sys_mbox_fetch
(
sys_mbox_t
 
mbox
, void **
msg
)

68 
u32_t
 
time_needed
;

69 struct 
sys_timeouts
 *
timeouts
;

70 struct 
sys_timeo
 *
tmptimeout
;

71 
sys_timeout_handler
 
h
;

72 void *
arg
;

74 
again
:

75 
timeouts
 = 
	`sys_arch_timeouts
();

77 if (!
timeouts
 || !timeouts->
next
) {

78 
	`UNLOCK_TCPIP_CORE
();

79 
time_needed
 = 
	`sys_arch_mbox_fetch
(
mbox
, 
msg
, 0);

80 
	`LOCK_TCPIP_CORE
();

82 if (
timeouts
->
next
->
time
 > 0) {

83 
	`UNLOCK_TCPIP_CORE
();

84 
time_needed
 = 
	`sys_arch_mbox_fetch
(
mbox
, 
msg
, 
timeouts
->
next
->
time
);

85 
	`LOCK_TCPIP_CORE
();

87 
time_needed
 = 
SYS_ARCH_TIMEOUT
;

90 if (
time_needed
 == 
SYS_ARCH_TIMEOUT
) {

94 
tmptimeout
 = 
timeouts
->
next
;

95 
timeouts
->
next
 = 
tmptimeout
->next;

96 
h
 = 
tmptimeout
->h;

97 
arg
 = 
tmptimeout
->arg;

98 
	`memp_free
(
MEMP_SYS_TIMEOUT
, 
tmptimeout
);

99 if (
h
 != 
NULL
) {

100 
	`LWIP_DEBUGF
(
SYS_DEBUG
, ("smf calling h=%p(%p)\n", (void*)&
h
, 
arg
));

101 
	`h
(
arg
);

105 goto 
again
;

110 if (
time_needed
 < 
timeouts
->
next
->
time
) {

111 
timeouts
->
next
->
time
 -= 
time_needed
;

113 
timeouts
->
next
->
time
 = 0;

117 
	}
}

126 
	$sys_sem_wait
(
sys_sem_t
 
sem
)

128 
u32_t
 
time_needed
;

129 struct 
sys_timeouts
 *
timeouts
;

130 struct 
sys_timeo
 *
tmptimeout
;

131 
sys_timeout_handler
 
h
;

132 void *
arg
;

134 
again
:

136 
timeouts
 = 
	`sys_arch_timeouts
();

138 if (!
timeouts
 || !timeouts->
next
) {

139 
	`sys_arch_sem_wait
(
sem
, 0);

141 if (
timeouts
->
next
->
time
 > 0) {

142 
time_needed
 = 
	`sys_arch_sem_wait
(
sem
, 
timeouts
->
next
->
time
);

144 
time_needed
 = 
SYS_ARCH_TIMEOUT
;

147 if (
time_needed
 == 
SYS_ARCH_TIMEOUT
) {

151 
tmptimeout
 = 
timeouts
->
next
;

152 
timeouts
->
next
 = 
tmptimeout
->next;

153 
h
 = 
tmptimeout
->h;

154 
arg
 = 
tmptimeout
->arg;

155 
	`memp_free
(
MEMP_SYS_TIMEOUT
, 
tmptimeout
);

156 if (
h
 != 
NULL
) {

157 
	`LWIP_DEBUGF
(
SYS_DEBUG
, ("ssw h=%p(%p)\n", (void*)&
h
, (void *)
arg
));

158 
	`h
(
arg
);

162 goto 
again
;

167 if (
time_needed
 < 
timeouts
->
next
->
time
) {

168 
timeouts
->
next
->
time
 -= 
time_needed
;

170 
timeouts
->
next
->
time
 = 0;

174 
	}
}

188 
	$sys_timeout
(
u32_t
 
msecs
, 
sys_timeout_handler
 
h
, void *
arg
)

190 struct 
sys_timeouts
 *
timeouts
;

191 struct 
sys_timeo
 *
timeout
, *
t
;

193 
timeout
 = 
	`memp_malloc
(
MEMP_SYS_TIMEOUT
);

194 if (
timeout
 == 
NULL
) {

195 
	`LWIP_ASSERT
("sys_timeout: timeout != NULL", 
timeout
 != 
NULL
);

198 
timeout
->
next
 = 
NULL
;

199 
timeout
->
h
 = h;

200 
timeout
->
arg
 = arg;

201 
timeout
->
time
 = 
msecs
;

203 
timeouts
 = 
	`sys_arch_timeouts
();

205 
	`LWIP_DEBUGF
(
SYS_DEBUG
, ("sys_timeout: %p msecs=%"
U32_F
" h=%p arg=%p\n",

206 (void *)
timeout
, 
msecs
, (void*)&
h
, (void *)
arg
));

208 if (
timeouts
 == 
NULL
) {

209 
	`LWIP_ASSERT
("sys_timeout: timeouts != NULL", 
timeouts
 != 
NULL
);

213 if (
timeouts
->
next
 == 
NULL
) {

214 
timeouts
->
next
 = 
timeout
;

218 if (
timeouts
->
next
->
time
 > 
msecs
) {

219 
timeouts
->
next
->
time
 -= 
msecs
;

220 
timeout
->
next
 = 
timeouts
->next;

221 
timeouts
->
next
 = 
timeout
;

223 for(
t
 = 
timeouts
->
next
; t != 
NULL
; t = t->next) {

224 
timeout
->
time
 -= 
t
->time;

225 if (
t
->
next
 == 
NULL
 || t->next->
time
 > 
timeout
->time) {

226 if (
t
->
next
 != 
NULL
) {

227 
t
->
next
->
time
 -= 
timeout
->time;

229 
timeout
->
next
 = 
t
->next;

230 
t
->
next
 = 
timeout
;

235 
	}
}

248 
	$sys_untimeout
(
sys_timeout_handler
 
h
, void *
arg
)

250 struct 
sys_timeouts
 *
timeouts
;

251 struct 
sys_timeo
 *
prev_t
, *
t
;

253 
timeouts
 = 
	`sys_arch_timeouts
();

255 if (
timeouts
 == 
NULL
) {

256 
	`LWIP_ASSERT
("sys_untimeout: timeouts != NULL", 
timeouts
 != 
NULL
);

259 if (
timeouts
->
next
 == 
NULL
) {

263 for (
t
 = 
timeouts
->
next
, 
prev_t
 = 
NULL
; t != NULL; prev_t = t, t = t->next) {

264 if ((
t
->
h
 == h) && (t->
arg
 == arg)) {

267 if (
prev_t
 == 
NULL
)

268 
timeouts
->
next
 = 
t
->next;

270 
prev_t
->
next
 = 
t
->next;

272 if (
t
->
next
 != 
NULL
)

273 
t
->
next
->
time
 += t->time;

274 
	`memp_free
(
MEMP_SYS_TIMEOUT
, 
t
);

279 
	}
}

287 
	$sswt_handler
(void *
arg
)

289 struct 
sswt_cb
 *sswt_cb = (struct sswt_cb *) 
arg
;

292 
sswt_cb
->
timeflag
 = 1;

293 
	`sys_sem_signal
(*(
sswt_cb
->
psem
));

294 
	}
}

304 
	$sys_sem_wait_timeout
(
sys_sem_t
 
sem
, 
u32_t
 
timeout
)

306 struct 
sswt_cb
 sswt_cb;

308 
sswt_cb
.
psem
 = &
sem
;

309 
sswt_cb
.
timeflag
 = 0;

312 if (
timeout
 > 0) {

314 
	`sys_timeout
(
timeout
, 
sswt_handler
, &
sswt_cb
);

316 
	`sys_sem_wait
(
sem
);

318 if (
sswt_cb
.
timeflag
) {

323 
	`sys_untimeout
(
sswt_handler
, &
sswt_cb
);

326 
	}
}

334 
	$sys_msleep
(
u32_t
 
ms
)

336 
sys_sem_t
 
delaysem
 = 
	`sys_sem_new
(0);

338 
	`sys_sem_wait_timeout
(
delaysem
, 
ms
);

340 
	`sys_sem_free
(
delaysem
);

341 
	}
}

	@/root/Robux/net/lwip/core/tcp.c

43 #include 
	~"lwip/opt.h
"

45 #if 
LWIP_TCP


47 #include 
	~"lwip/def.h
"

48 #include 
	~"lwip/mem.h
"

49 #include 
	~"lwip/memp.h
"

50 #include 
	~"lwip/snmp.h
"

51 #include 
	~"lwip/tcp.h
"

53 #include 
	~<string.h
>

56 
u32_t
 
	gtcp_ticks
;

57 const 
u8_t
 
	gtcp_backoff
[13] =

60 const 
u8_t
 
	gtcp_persist_backoff
[7] = { 3, 6, 12, 24, 48, 96, 120 };

65 struct 
tcp_pcb
 *
	gtcp_bound_pcbs
;

67 union 
tcp_listen_pcbs_t
 
	gtcp_listen_pcbs
;

70 struct 
tcp_pcb
 *
	gtcp_active_pcbs
;

72 struct 
tcp_pcb
 *
	gtcp_tw_pcbs
;

74 struct 
tcp_pcb
 *
	gtcp_tmp_pcb
;

76 static 
u8_t
 
	gtcp_timer
;

77 static 
u16_t
 
tcp_new_port
(void);

84 
	$tcp_tmr
(void)

87 
	`tcp_fasttmr
();

89 if (++
tcp_timer
 & 1) {

92 
	`tcp_slowtmr
();

94 
	}
}

110 
err_t


111 
	$tcp_close
(struct 
tcp_pcb
 *
pcb
)

113 
err_t
 
err
;

115 #if 
TCP_DEBUG


116 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_close: closing in "));

117 
	`tcp_debug_print_state
(
pcb
->
state
);

120 switch (
pcb
->
state
) {

121 case 
CLOSED
:

129 
err
 = 
ERR_OK
;

130 
	`TCP_RMV
(&
tcp_bound_pcbs
, 
pcb
);

131 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

132 
pcb
 = 
NULL
;

134 case 
LISTEN
:

135 
err
 = 
ERR_OK
;

136 
	`tcp_pcb_remove
((struct 
tcp_pcb
 **)&
tcp_listen_pcbs
.
pcbs
, 
pcb
);

137 
	`memp_free
(
MEMP_TCP_PCB_LISTEN
, 
pcb
);

138 
pcb
 = 
NULL
;

140 case 
SYN_SENT
:

141 
err
 = 
ERR_OK
;

142 
	`tcp_pcb_remove
(&
tcp_active_pcbs
, 
pcb
);

143 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

144 
pcb
 = 
NULL
;

145 
	`snmp_inc_tcpattemptfails
();

147 case 
SYN_RCVD
:

148 
err
 = 
	`tcp_send_ctrl
(
pcb
, 
TCP_FIN
);

149 if (
err
 == 
ERR_OK
) {

150 
	`snmp_inc_tcpattemptfails
();

151 
pcb
->
state
 = 
FIN_WAIT_1
;

154 case 
ESTABLISHED
:

155 
err
 = 
	`tcp_send_ctrl
(
pcb
, 
TCP_FIN
);

156 if (
err
 == 
ERR_OK
) {

157 
	`snmp_inc_tcpestabresets
();

158 
pcb
->
state
 = 
FIN_WAIT_1
;

161 case 
CLOSE_WAIT
:

162 
err
 = 
	`tcp_send_ctrl
(
pcb
, 
TCP_FIN
);

163 if (
err
 == 
ERR_OK
) {

164 
	`snmp_inc_tcpestabresets
();

165 
pcb
->
state
 = 
LAST_ACK
;

170 
err
 = 
ERR_OK
;

171 
pcb
 = 
NULL
;

175 if (
pcb
 != 
NULL
 && 
err
 == 
ERR_OK
) {

183 
	`tcp_output
(
pcb
);

185 return 
err
;

186 
	}
}

196 
	$tcp_abort
(struct 
tcp_pcb
 *
pcb
)

198 
u32_t
 
seqno
, 
ackno
;

199 
u16_t
 
remote_port
, 
local_port
;

200 struct 
ip_addr
 
remote_ip
, 
local_ip
;

201 #if 
LWIP_CALLBACK_API


202 void (* 
errf
)(void *
arg
, 
err_t
 
err
);

204 void *
errf_arg
;

210 if (
pcb
->
state
 == 
TIME_WAIT
) {

211 
	`tcp_pcb_remove
(&
tcp_tw_pcbs
, 
pcb
);

212 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

214 
seqno
 = 
pcb
->
snd_nxt
;

215 
ackno
 = 
pcb
->
rcv_nxt
;

216 
	`ip_addr_set
(&
local_ip
, &(
pcb
->local_ip));

217 
	`ip_addr_set
(&
remote_ip
, &(
pcb
->remote_ip));

218 
local_port
 = 
pcb
->local_port;

219 
remote_port
 = 
pcb
->remote_port;

220 #if 
LWIP_CALLBACK_API


221 
errf
 = 
pcb
->errf;

223 
errf_arg
 = 
pcb
->
callback_arg
;

224 
	`tcp_pcb_remove
(&
tcp_active_pcbs
, 
pcb
);

225 if (
pcb
->
unacked
 != 
NULL
) {

226 
	`tcp_segs_free
(
pcb
->
unacked
);

228 if (
pcb
->
unsent
 != 
NULL
) {

229 
	`tcp_segs_free
(
pcb
->
unsent
);

231 #if 
TCP_QUEUE_OOSEQ


232 if (
pcb
->
ooseq
 != 
NULL
) {

233 
	`tcp_segs_free
(
pcb
->
ooseq
);

236 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

237 
	`TCP_EVENT_ERR
(
errf
, 
errf_arg
, 
ERR_ABRT
);

238 
	`LWIP_DEBUGF
(
TCP_RST_DEBUG
, ("tcp_abort: sending RST\n"));

239 
	`tcp_rst
(
seqno
, 
ackno
, &
local_ip
, &
remote_ip
, 
local_port
, 
remote_port
);

241 
	}
}

256 
err_t


257 
	$tcp_bind
(struct 
tcp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
, 
u16_t
 
port
)

259 struct 
tcp_pcb
 *
cpcb
;

261 
	`LWIP_ERROR
("tcp_connect: can only bind in state CLOSED", 
pcb
->
state
 == 
CLOSED
, return 
ERR_ISCONN
);

263 if (
port
 == 0) {

264 
port
 = 
	`tcp_new_port
();

268 for(
cpcb
 = (struct 
tcp_pcb
 *)
tcp_listen_pcbs
.
pcbs
;

269 
cpcb
 != 
NULL
; cpcb = cpcb->
next
) {

270 if (
cpcb
->
local_port
 == 
port
) {

271 if (
	`ip_addr_isany
(&(
cpcb
->
local_ip
)) ||

272 
	`ip_addr_isany
(
ipaddr
) ||

273 
	`ip_addr_cmp
(&(
cpcb
->
local_ip
), 
ipaddr
)) {

274 return 
ERR_USE
;

279 for(
cpcb
 = 
tcp_active_pcbs
;

280 
cpcb
 != 
NULL
; cpcb = cpcb->
next
) {

281 if (
cpcb
->
local_port
 == 
port
) {

282 if (
	`ip_addr_isany
(&(
cpcb
->
local_ip
)) ||

283 
	`ip_addr_isany
(
ipaddr
) ||

284 
	`ip_addr_cmp
(&(
cpcb
->
local_ip
), 
ipaddr
)) {

285 return 
ERR_USE
;

290 for(
cpcb
 = 
tcp_bound_pcbs
; cpcb != 
NULL
; cpcb = cpcb->
next
) {

291 if (
cpcb
->
local_port
 == 
port
) {

292 if (
	`ip_addr_isany
(&(
cpcb
->
local_ip
)) ||

293 
	`ip_addr_isany
(
ipaddr
) ||

294 
	`ip_addr_cmp
(&(
cpcb
->
local_ip
), 
ipaddr
)) {

295 return 
ERR_USE
;

301 for(
cpcb
 = 
tcp_tw_pcbs
; cpcb != 
NULL
; cpcb = cpcb->
next
) {

302 if (
cpcb
->
local_port
 == 
port
) {

303 if (
	`ip_addr_cmp
(&(
cpcb
->
local_ip
), 
ipaddr
)) {

304 return 
ERR_USE
;

309 if (!
	`ip_addr_isany
(
ipaddr
)) {

310 
pcb
->
local_ip
 = *
ipaddr
;

312 
pcb
->
local_port
 = 
port
;

313 
	`TCP_REG
(&
tcp_bound_pcbs
, 
pcb
);

314 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_bind: bind to port %"
U16_F
"\n", 
port
));

315 return 
ERR_OK
;

316 
	}
}

317 #if 
LWIP_CALLBACK_API


321 static 
err_t


322 
	$tcp_accept_null
(void *
arg
, struct 
tcp_pcb
 *
pcb
, 
err_t
 
err
)

324 
	`LWIP_UNUSED_ARG
(
arg
);

325 
	`LWIP_UNUSED_ARG
(
pcb
);

326 
	`LWIP_UNUSED_ARG
(
err
);

328 return 
ERR_ABRT
;

329 
	}
}

346 struct 
tcp_pcb
 *

347 
	$tcp_listen_with_backlog
(struct 
tcp_pcb
 *
pcb
, 
u8_t
 
backlog
)

349 struct 
tcp_pcb_listen
 *
lpcb
;

351 
	`LWIP_UNUSED_ARG
(
backlog
);

352 
	`LWIP_ERROR
("tcp_listen: pcb already connected", 
pcb
->
state
 == 
CLOSED
, return 
NULL
);

355 if (
pcb
->
state
 == 
LISTEN
) {

356 return 
pcb
;

358 
lpcb
 = 
	`memp_malloc
(
MEMP_TCP_PCB_LISTEN
);

359 if (
lpcb
 == 
NULL
) {

360 return 
NULL
;

362 
lpcb
->
callback_arg
 = 
pcb
->callback_arg;

363 
lpcb
->
local_port
 = 
pcb
->local_port;

364 
lpcb
->
state
 = 
LISTEN
;

365 
lpcb
->
so_options
 = 
pcb
->so_options;

366 
lpcb
->
so_options
 |= 
SOF_ACCEPTCONN
;

367 
lpcb
->
ttl
 = 
pcb
->ttl;

368 
lpcb
->
tos
 = 
pcb
->tos;

369 
	`ip_addr_set
(&
lpcb
->
local_ip
, &
pcb
->local_ip);

370 
	`TCP_RMV
(&
tcp_bound_pcbs
, 
pcb
);

371 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

372 #if 
LWIP_CALLBACK_API


373 
lpcb
->
accept
 = 
tcp_accept_null
;

375 #if 
TCP_LISTEN_BACKLOG


376 
lpcb
->
accepts_pending
 = 0;

377 
lpcb
->
backlog
 = (backlog ? backlog : 1);

379 
	`TCP_REG
(&
tcp_listen_pcbs
.
listen_pcbs
, 
lpcb
);

380 return (struct 
tcp_pcb
 *)
lpcb
;

381 
	}
}

392 
	$tcp_recved
(struct 
tcp_pcb
 *
pcb
, 
u16_t
 
len
)

394 if ((
u32_t
)
pcb
->
rcv_wnd
 + 
len
 > 
TCP_WND
) {

395 
pcb
->
rcv_wnd
 = 
TCP_WND
;

396 
pcb
->
rcv_ann_wnd
 = 
TCP_WND
;

398 
pcb
->
rcv_wnd
 += 
len
;

399 if (
pcb
->
rcv_wnd
 >= pcb->
mss
) {

400 
pcb
->
rcv_ann_wnd
 = pcb->
rcv_wnd
;

404 if (!(
pcb
->
flags
 & 
TF_ACK_DELAY
) &&

405 !(
pcb
->
flags
 & 
TF_ACK_NOW
)) {

416 
	`tcp_ack
(
pcb
);

418 else if (
pcb
->
flags
 & 
TF_ACK_DELAY
 && pcb->
rcv_wnd
 >= 
TCP_WND
/2) {

426 
	`tcp_ack_now
(
pcb
);

429 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_recved: recveived %"
U16_F
" bytes, wnd %"U16_F" (%"U16_F").\n",

430 
len
, 
pcb
->
rcv_wnd
, 
TCP_WND
 - pcb->rcv_wnd));

431 
	}
}

439 static 
u16_t


440 
	$tcp_new_port
(void)

442 struct 
tcp_pcb
 *
pcb
;

443 #ifndef 
TCP_LOCAL_PORT_RANGE_START


444 #define 
	#TCP_LOCAL_PORT_RANGE_START
 4096

	)

445 #define 
	#TCP_LOCAL_PORT_RANGE_END
 0x7fff

	)

447 static 
u16_t
 
port
 = 
TCP_LOCAL_PORT_RANGE_START
;

449 
again
:

450 if (++
port
 > 
TCP_LOCAL_PORT_RANGE_END
) {

451 
port
 = 
TCP_LOCAL_PORT_RANGE_START
;

454 for(
pcb
 = 
tcp_active_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

455 if (
pcb
->
local_port
 == 
port
) {

456 goto 
again
;

459 for(
pcb
 = 
tcp_tw_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

460 if (
pcb
->
local_port
 == 
port
) {

461 goto 
again
;

464 for(
pcb
 = (struct 
tcp_pcb
 *)
tcp_listen_pcbs
.
pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

465 if (
pcb
->
local_port
 == 
port
) {

466 goto 
again
;

469 return 
port
;

470 
	}
}

484 
err_t


485 
tcp_connect
(struct 
tcp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
, 
u16_t
 
port
,

486 
	$err_t
 (* 
connected
)(void *
arg
, struct 
tcp_pcb
 *
tpcb
, 
err_t
 
err
))

488 
u32_t
 
optdata
;

489 
err_t
 
ret
;

490 
u32_t
 
iss
;

492 
	`LWIP_ERROR
("tcp_connect: can only connected from state CLOSED", 
pcb
->
state
 == 
CLOSED
, return 
ERR_ISCONN
);

494 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_connect to port %"
U16_F
"\n", 
port
));

495 if (
ipaddr
 != 
NULL
) {

496 
pcb
->
remote_ip
 = *
ipaddr
;

498 return 
ERR_VAL
;

500 
pcb
->
remote_port
 = 
port
;

501 if (
pcb
->
local_port
 == 0) {

502 
pcb
->
local_port
 = 
	`tcp_new_port
();

504 
iss
 = 
	`tcp_next_iss
();

505 
pcb
->
rcv_nxt
 = 0;

506 
pcb
->
snd_nxt
 = 
iss
;

507 
pcb
->
lastack
 = 
iss
 - 1;

508 
pcb
->
snd_lbb
 = 
iss
 - 1;

509 
pcb
->
rcv_wnd
 = 
TCP_WND
;

510 
pcb
->
rcv_ann_wnd
 = 
TCP_WND
;

511 
pcb
->
snd_wnd
 = 
TCP_WND
;

514 
pcb
->
mss
 = (
TCP_MSS
 > 536) ? 536 : TCP_MSS;

515 #if 
TCP_CALCULATE_EFF_SEND_MSS


516 
pcb
->
mss
 = 
	`tcp_eff_send_mss
(pcb->mss, 
ipaddr
);

518 
pcb
->
cwnd
 = 1;

519 
pcb
->
ssthresh
 = pcb->
mss
 * 10;

520 
pcb
->
state
 = 
SYN_SENT
;

521 #if 
LWIP_CALLBACK_API


522 
pcb
->
connected
 = connected;

524 
	`TCP_RMV
(&
tcp_bound_pcbs
, 
pcb
);

525 
	`TCP_REG
(&
tcp_active_pcbs
, 
pcb
);

527 
	`snmp_inc_tcpactiveopens
();

530 
optdata
 = 
	`TCP_BUILD_MSS_OPTION
();

532 
ret
 = 
	`tcp_enqueue
(
pcb
, 
NULL
, 0, 
TCP_SYN
, 0, (
u8_t
 *)&
optdata
, 4);

533 if (
ret
 == 
ERR_OK
) {

534 
	`tcp_output
(
pcb
);

536 return 
ret
;

537 
	}
}

547 
	$tcp_slowtmr
(void)

549 struct 
tcp_pcb
 *
pcb
, *
pcb2
, *
prev
;

550 
u16_t
 
eff_wnd
;

551 
u8_t
 
pcb_remove
;

552 
err_t
 
err
;

554 
err
 = 
ERR_OK
;

556 ++
tcp_ticks
;

559 
prev
 = 
NULL
;

560 
pcb
 = 
tcp_active_pcbs
;

561 if (
pcb
 == 
NULL
) {

562 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: no active pcbs\n"));

564 while (
pcb
 != 
NULL
) {

565 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: processing active pcb\n"));

566 
	`LWIP_ASSERT
("tcp_slowtmr: active pcb->state != CLOSED\n", 
pcb
->
state
 != 
CLOSED
);

567 
	`LWIP_ASSERT
("tcp_slowtmr: active pcb->state != LISTEN\n", 
pcb
->
state
 != 
LISTEN
);

568 
	`LWIP_ASSERT
("tcp_slowtmr: active pcb->state != TIME-WAIT\n", 
pcb
->
state
 != 
TIME_WAIT
);

570 
pcb_remove
 = 0;

572 if (
pcb
->
state
 == 
SYN_SENT
 && pcb->
nrtx
 == 
TCP_SYNMAXRTX
) {

573 ++
pcb_remove
;

574 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: max SYN retries reached\n"));

576 else if (
pcb
->
nrtx
 == 
TCP_MAXRTX
) {

577 ++
pcb_remove
;

578 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: max DATA retries reached\n"));

580 if (
pcb
->
persist_backoff
 > 0) {

583 
pcb
->
persist_cnt
++;

584 if (
pcb
->
persist_cnt
 >= 
tcp_persist_backoff
[pcb->
persist_backoff
-1]) {

585 
pcb
->
persist_cnt
 = 0;

586 if (
pcb
->
persist_backoff
 < sizeof(
tcp_persist_backoff
)) {

587 
pcb
->
persist_backoff
++;

589 
	`tcp_zero_window_probe
(
pcb
);

593 if(
pcb
->
rtime
 >= 0)

594 ++
pcb
->
rtime
;

596 if (
pcb
->
unacked
 != 
NULL
 && pcb->
rtime
 >= pcb->
rto
) {

598 
	`LWIP_DEBUGF
(
TCP_RTO_DEBUG
, ("tcp_slowtmr: rtime %"
S16_F


599 " pcb->rto %"
S16_F
"\n",

600 
pcb
->
rtime
, pcb->
rto
));

604 if (
pcb
->
state
 != 
SYN_SENT
) {

605 
pcb
->
rto
 = ((pcb->
sa
 >> 3) + pcb->
sv
) << 
tcp_backoff
[pcb->
nrtx
];

609 
pcb
->
rtime
 = 0;

612 
eff_wnd
 = 
	`LWIP_MIN
(
pcb
->
cwnd
, pcb->
snd_wnd
);

613 
pcb
->
ssthresh
 = 
eff_wnd
 >> 1;

614 if (
pcb
->
ssthresh
 < pcb->
mss
) {

615 
pcb
->
ssthresh
 = pcb->
mss
 * 2;

617 
pcb
->
cwnd
 = pcb->
mss
;

618 
	`LWIP_DEBUGF
(
TCP_CWND_DEBUG
, ("tcp_slowtmr: cwnd %"
U16_F


619 " ssthresh %"
U16_F
"\n",

620 
pcb
->
cwnd
, pcb->
ssthresh
));

624 
	`tcp_rexmit_rto
(
pcb
);

629 if (
pcb
->
state
 == 
FIN_WAIT_2
) {

630 if ((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >

631 
TCP_FIN_WAIT_TIMEOUT
 / 
TCP_SLOW_INTERVAL
) {

632 ++
pcb_remove
;

633 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));

638 if((
pcb
->
so_options
 & 
SOF_KEEPALIVE
) &&

639 ((
pcb
->
state
 == 
ESTABLISHED
) ||

640 (
pcb
->
state
 == 
CLOSE_WAIT
))) {

641 #if 
LWIP_TCP_KEEPALIVE


642 if((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >

643 (
pcb
->
keep_idle
 + (pcb->
keep_cnt
*pcb->
keep_intvl
))

644 / 
TCP_SLOW_INTERVAL
)

646 if((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >

647 (
pcb
->
keep_idle
 + 
TCP_MAXIDLE
) / 
TCP_SLOW_INTERVAL
)

650 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"
U16_F
".%"U16_F".%"U16_F".%"U16_F".\n",

651 
	`ip4_addr1
(&
pcb
->
remote_ip
), 
	`ip4_addr2
(&pcb->remote_ip),

652 
	`ip4_addr3
(&
pcb
->
remote_ip
), 
	`ip4_addr4
(&pcb->remote_ip)));

654 
	`tcp_abort
(
pcb
);

656 #if 
LWIP_TCP_KEEPALIVE


657 else if((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >

658 (
pcb
->
keep_idle
 + pcb->
keep_cnt_sent
 * pcb->
keep_intvl
)

659 / 
TCP_SLOW_INTERVAL
)

661 else if((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >

662 (
pcb
->
keep_idle
 + pcb->
keep_cnt_sent
 * 
TCP_KEEPINTVL_DEFAULT
)

663 / 
TCP_SLOW_INTERVAL
)

666 
	`tcp_keepalive
(
pcb
);

667 
pcb
->
keep_cnt_sent
++;

674 #if 
TCP_QUEUE_OOSEQ


675 if (
pcb
->
ooseq
 != 
NULL
 &&

676 (
u32_t
)
tcp_ticks
 - 
pcb
->
tmr
 >= pcb->
rto
 * 
TCP_OOSEQ_TIMEOUT
) {

677 
	`tcp_segs_free
(
pcb
->
ooseq
);

678 
pcb
->
ooseq
 = 
NULL
;

679 
	`LWIP_DEBUGF
(
TCP_CWND_DEBUG
, ("tcp_slowtmr: dropping OOSEQ queued data\n"));

684 if (
pcb
->
state
 == 
SYN_RCVD
) {

685 if ((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >

686 
TCP_SYN_RCVD_TIMEOUT
 / 
TCP_SLOW_INTERVAL
) {

687 ++
pcb_remove
;

688 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));

693 if (
pcb
->
state
 == 
LAST_ACK
) {

694 if ((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) > 2 * 
TCP_MSL
 / 
TCP_SLOW_INTERVAL
) {

695 ++
pcb_remove
;

696 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));

701 if (
pcb_remove
) {

702 
	`tcp_pcb_purge
(
pcb
);

704 if (
prev
 != 
NULL
) {

705 
	`LWIP_ASSERT
("tcp_slowtmr: middle tcp != tcp_active_pcbs", 
pcb
 != 
tcp_active_pcbs
);

706 
prev
->
next
 = 
pcb
->next;

709 
	`LWIP_ASSERT
("tcp_slowtmr: first pcb == tcp_active_pcbs", 
tcp_active_pcbs
 == 
pcb
);

710 
tcp_active_pcbs
 = 
pcb
->
next
;

713 
	`TCP_EVENT_ERR
(
pcb
->
errf
, pcb->
callback_arg
, 
ERR_ABRT
);

715 
pcb2
 = 
pcb
->
next
;

716 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

717 
pcb
 = 
pcb2
;

721 ++
pcb
->
polltmr
;

722 if (
pcb
->
polltmr
 >= pcb->
pollinterval
) {

723 
pcb
->
polltmr
 = 0;

724 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_slowtmr: polling application\n"));

725 
	`TCP_EVENT_POLL
(
pcb
, 
err
);

726 if (
err
 == 
ERR_OK
) {

727 
	`tcp_output
(
pcb
);

731 
prev
 = 
pcb
;

732 
pcb
 = pcb->
next
;

738 
prev
 = 
NULL
;

739 
pcb
 = 
tcp_tw_pcbs
;

740 while (
pcb
 != 
NULL
) {

741 
	`LWIP_ASSERT
("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", 
pcb
->
state
 == 
TIME_WAIT
);

742 
pcb_remove
 = 0;

745 if ((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) > 2 * 
TCP_MSL
 / 
TCP_SLOW_INTERVAL
) {

746 ++
pcb_remove
;

752 if (
pcb_remove
) {

753 
	`tcp_pcb_purge
(
pcb
);

755 if (
prev
 != 
NULL
) {

756 
	`LWIP_ASSERT
("tcp_slowtmr: middle tcp != tcp_tw_pcbs", 
pcb
 != 
tcp_tw_pcbs
);

757 
prev
->
next
 = 
pcb
->next;

760 
	`LWIP_ASSERT
("tcp_slowtmr: first pcb == tcp_tw_pcbs", 
tcp_tw_pcbs
 == 
pcb
);

761 
tcp_tw_pcbs
 = 
pcb
->
next
;

763 
pcb2
 = 
pcb
->
next
;

764 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

765 
pcb
 = 
pcb2
;

767 
prev
 = 
pcb
;

768 
pcb
 = pcb->
next
;

771 
	}
}

780 
	$tcp_fasttmr
(void)

782 struct 
tcp_pcb
 *
pcb
;

784 for(
pcb
 = 
tcp_active_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

786 if (
pcb
->
refused_data
 != 
NULL
) {

788 
err_t
 
err
;

789 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_fasttmr: notify kept packet\n"));

790 
	`TCP_EVENT_RECV
(
pcb
, pcb->
refused_data
, 
ERR_OK
, 
err
);

791 if (
err
 == 
ERR_OK
) {

792 
pcb
->
refused_data
 = 
NULL
;

797 if (
pcb
->
flags
 & 
TF_ACK_DELAY
) {

798 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_fasttmr: delayed ACK\n"));

799 
	`tcp_ack_now
(
pcb
);

800 
pcb
->
flags
 &= ~(
TF_ACK_DELAY
 | 
TF_ACK_NOW
);

803 
	}
}

811 
u8_t


812 
	$tcp_segs_free
(struct 
tcp_seg
 *
seg
)

814 
u8_t
 
count
 = 0;

815 struct 
tcp_seg
 *
next
;

816 while (
seg
 != 
NULL
) {

817 
next
 = 
seg
->next;

818 
count
 += 
	`tcp_seg_free
(
seg
);

819 
seg
 = 
next
;

821 return 
count
;

822 
	}
}

830 
u8_t


831 
	$tcp_seg_free
(struct 
tcp_seg
 *
seg
)

833 
u8_t
 
count
 = 0;

835 if (
seg
 != 
NULL
) {

836 if (
seg
->
p
 != 
NULL
) {

837 
count
 = 
	`pbuf_free
(
seg
->
p
);

838 #if 
TCP_DEBUG


839 
seg
->
p
 = 
NULL
;

842 
	`memp_free
(
MEMP_TCP_SEG
, 
seg
);

844 return 
count
;

845 
	}
}

854 
	$tcp_setprio
(struct 
tcp_pcb
 *
pcb
, 
u8_t
 
prio
)

856 
pcb
->
prio
 = prio;

857 
	}
}

858 #if 
TCP_QUEUE_OOSEQ


867 struct 
tcp_seg
 *

868 
	$tcp_seg_copy
(struct 
tcp_seg
 *
seg
)

870 struct 
tcp_seg
 *
cseg
;

872 
cseg
 = 
	`memp_malloc
(
MEMP_TCP_SEG
);

873 if (
cseg
 == 
NULL
) {

874 return 
NULL
;

876 
	`SMEMCPY
((
u8_t
 *)
cseg
, (const u8_t *)
seg
, sizeof(struct 
tcp_seg
));

877 
	`pbuf_ref
(
cseg
->
p
);

878 return 
cseg
;

879 
	}
}

882 #if 
LWIP_CALLBACK_API


887 static 
err_t


888 
	$tcp_recv_null
(void *
arg
, struct 
tcp_pcb
 *
pcb
, struct 
pbuf
 *
p
, 
err_t
 
err
)

890 
arg
 = arg;

891 if (
p
 != 
NULL
) {

892 
	`pbuf_free
(
p
);

893 } else if (
err
 == 
ERR_OK
) {

894 return 
	`tcp_close
(
pcb
);

896 return 
ERR_OK
;

897 
	}
}

906 
	$tcp_kill_prio
(
u8_t
 
prio
)

908 struct 
tcp_pcb
 *
pcb
, *
inactive
;

909 
u32_t
 
inactivity
;

910 
u8_t
 
mprio
;

913 
mprio
 = 
TCP_PRIO_MAX
;

916 
inactivity
 = 0;

917 
inactive
 = 
NULL
;

918 for(
pcb
 = 
tcp_active_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

919 if (
pcb
->
prio
 <= prio &&

920 
pcb
->
prio
 <= 
mprio
 &&

921 (
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >= 
inactivity
) {

922 
inactivity
 = 
tcp_ticks
 - 
pcb
->
tmr
;

923 
inactive
 = 
pcb
;

924 
mprio
 = 
pcb
->
prio
;

927 if (
inactive
 != 
NULL
) {

928 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_kill_prio: killing oldest PCB %p (%"
S32_F
")\n",

929 (void *)
inactive
, 
inactivity
));

930 
	`tcp_abort
(
inactive
);

932 
	}
}

939 
	$tcp_kill_timewait
(void)

941 struct 
tcp_pcb
 *
pcb
, *
inactive
;

942 
u32_t
 
inactivity
;

944 
inactivity
 = 0;

945 
inactive
 = 
NULL
;

947 for(
pcb
 = 
tcp_tw_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

948 if ((
u32_t
)(
tcp_ticks
 - 
pcb
->
tmr
) >= 
inactivity
) {

949 
inactivity
 = 
tcp_ticks
 - 
pcb
->
tmr
;

950 
inactive
 = 
pcb
;

953 if (
inactive
 != 
NULL
) {

954 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"
S32_F
")\n",

955 (void *)
inactive
, 
inactivity
));

956 
	`tcp_abort
(
inactive
);

958 
	}
}

966 struct 
tcp_pcb
 *

967 
	$tcp_alloc
(
u8_t
 
prio
)

969 struct 
tcp_pcb
 *
pcb
;

970 
u32_t
 
iss
;

972 
pcb
 = 
	`memp_malloc
(
MEMP_TCP_PCB
);

973 if (
pcb
 == 
NULL
) {

975 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));

976 
	`tcp_kill_timewait
();

978 
pcb
 = 
	`memp_malloc
(
MEMP_TCP_PCB
);

979 if (
pcb
 == 
NULL
) {

981 
	`tcp_kill_prio
(
prio
);

983 
pcb
 = 
	`memp_malloc
(
MEMP_TCP_PCB
);

986 if (
pcb
 != 
NULL
) {

987 
	`memset
(
pcb
, 0, sizeof(struct 
tcp_pcb
));

988 
pcb
->
prio
 = 
TCP_PRIO_NORMAL
;

989 
pcb
->
snd_buf
 = 
TCP_SND_BUF
;

990 
pcb
->
snd_queuelen
 = 0;

991 
pcb
->
rcv_wnd
 = 
TCP_WND
;

992 
pcb
->
rcv_ann_wnd
 = 
TCP_WND
;

993 
pcb
->
tos
 = 0;

994 
pcb
->
ttl
 = 
TCP_TTL
;

997 
pcb
->
mss
 = (
TCP_MSS
 > 536) ? 536 : TCP_MSS;

998 
pcb
->
rto
 = 3000 / 
TCP_SLOW_INTERVAL
;

999 
pcb
->
sa
 = 0;

1000 
pcb
->
sv
 = 3000 / 
TCP_SLOW_INTERVAL
;

1001 
pcb
->
rtime
 = -1;

1002 
pcb
->
cwnd
 = 1;

1003 
iss
 = 
	`tcp_next_iss
();

1004 
pcb
->
snd_wl2
 = 
iss
;

1005 
pcb
->
snd_nxt
 = 
iss
;

1006 
pcb
->
snd_max
 = 
iss
;

1007 
pcb
->
lastack
 = 
iss
;

1008 
pcb
->
snd_lbb
 = 
iss
;

1009 
pcb
->
tmr
 = 
tcp_ticks
;

1011 
pcb
->
polltmr
 = 0;

1013 #if 
LWIP_CALLBACK_API


1014 
pcb
->
recv
 = 
tcp_recv_null
;

1018 
pcb
->
keep_idle
 = 
TCP_KEEPIDLE_DEFAULT
;

1020 #if 
LWIP_TCP_KEEPALIVE


1021 
pcb
->
keep_intvl
 = 
TCP_KEEPINTVL_DEFAULT
;

1022 
pcb
->
keep_cnt
 = 
TCP_KEEPCNT_DEFAULT
;

1025 
pcb
->
keep_cnt_sent
 = 0;

1027 return 
pcb
;

1028 
	}
}

1042 struct 
tcp_pcb
 *

1043 
	$tcp_new
(void)

1045 return 
	`tcp_alloc
(
TCP_PRIO_NORMAL
);

1046 
	}
}

1056 
	$tcp_arg
(struct 
tcp_pcb
 *
pcb
, void *
arg
)

1058 
pcb
->
callback_arg
 = 
arg
;

1059 
	}
}

1060 #if 
LWIP_CALLBACK_API


1070 
tcp_recv
(struct 
tcp_pcb
 *
pcb
,

1071 
	$err_t
 (* 
recv
)(void *
arg
, struct 
tcp_pcb
 *
tpcb
, struct 
pbuf
 *
p
, 
err_t
 
err
))

1073 
pcb
->
recv
 = recv;

1074 
	}
}

1084 
tcp_sent
(struct 
tcp_pcb
 *
pcb
,

1085 
	$err_t
 (* 
sent
)(void *
arg
, struct 
tcp_pcb
 *
tpcb
, 
u16_t
 
len
))

1087 
pcb
->
sent
 = sent;

1088 
	}
}

1099 
tcp_err
(struct 
tcp_pcb
 *
pcb
,

1100 void (* 
errf
)(void *
arg
, 
err_t
 
err
))

1102 
pcb
->
errf
 = errf;

1103 
	}
}

1114 
tcp_accept
(struct 
tcp_pcb
 *
pcb
,

1115 
	$err_t
 (* 
accept
)(void *
arg
, struct 
tcp_pcb
 *
newpcb
, 
err_t
 
err
))

1117 ((struct 
tcp_pcb_listen
 *)
pcb
)->
accept
 = accept;

1118 
	}
}

1129 
tcp_poll
(struct 
tcp_pcb
 *
pcb
,

1130 
	$err_t
 (* 
poll
)(void *
arg
, struct 
tcp_pcb
 *
tpcb
), 
u8_t
 
interval
)

1132 #if 
LWIP_CALLBACK_API


1133 
pcb
->
poll
 = poll;

1135 
pcb
->
pollinterval
 = 
interval
;

1136 
	}
}

1145 
	$tcp_pcb_purge
(struct 
tcp_pcb
 *
pcb
)

1147 if (
pcb
->
state
 != 
CLOSED
 &&

1148 
pcb
->
state
 != 
TIME_WAIT
 &&

1149 
pcb
->
state
 != 
LISTEN
) {

1151 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_pcb_purge\n"));

1153 if (
pcb
->
refused_data
 != 
NULL
) {

1154 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_pcb_purge: data left on ->refused_data\n"));

1155 
	`pbuf_free
(
pcb
->
refused_data
);

1156 
pcb
->
refused_data
 = 
NULL
;

1158 if (
pcb
->
unsent
 != 
NULL
) {

1159 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_pcb_purge: not all data sent\n"));

1161 if (
pcb
->
unacked
 != 
NULL
) {

1162 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_pcb_purge: data left on ->unacked\n"));

1164 #if 
TCP_QUEUE_OOSEQ


1165 if (
pcb
->
ooseq
 != 
NULL
) {

1166 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_pcb_purge: data left on ->ooseq\n"));

1171 
pcb
->
rtime
 = -1;

1173 
	`tcp_segs_free
(
pcb
->
ooseq
);

1174 
pcb
->
ooseq
 = 
NULL
;

1176 
	`tcp_segs_free
(
pcb
->
unsent
);

1177 
	`tcp_segs_free
(
pcb
->
unacked
);

1178 
pcb
->
unacked
 = pcb->
unsent
 = 
NULL
;

1180 
	}
}

1189 
	$tcp_pcb_remove
(struct 
tcp_pcb
 **
pcblist
, struct tcp_pcb *
pcb
)

1191 
	`TCP_RMV
(
pcblist
, 
pcb
);

1193 
	`tcp_pcb_purge
(
pcb
);

1196 if (
pcb
->
state
 != 
TIME_WAIT
 &&

1197 
pcb
->
state
 != 
LISTEN
 &&

1198 
pcb
->
flags
 & 
TF_ACK_DELAY
) {

1199 
pcb
->
flags
 |= 
TF_ACK_NOW
;

1200 
	`tcp_output
(
pcb
);

1203 if (
pcb
->
state
 != 
LISTEN
) {

1204 
	`LWIP_ASSERT
("unsent segments leaking", 
pcb
->
unsent
 == 
NULL
);

1205 
	`LWIP_ASSERT
("unacked segments leaking", 
pcb
->
unacked
 == 
NULL
);

1206 #if 
TCP_QUEUE_OOSEQ


1207 
	`LWIP_ASSERT
("ooseq segments leaking", 
pcb
->
ooseq
 == 
NULL
);

1211 
pcb
->
state
 = 
CLOSED
;

1213 
	`LWIP_ASSERT
("tcp_pcb_remove: tcp_pcbs_sane()", 
	`tcp_pcbs_sane
());

1214 
	}
}

1221 
u32_t


1222 
	$tcp_next_iss
(void)

1224 static 
u32_t
 
iss
 = 6510;

1226 
iss
 += 
tcp_ticks
;

1227 return 
iss
;

1228 
	}
}

1230 #if 
TCP_CALCULATE_EFF_SEND_MSS


1236 
u16_t


1237 
	$tcp_eff_send_mss
(
u16_t
 
sendmss
, struct 
ip_addr
 *
addr
)

1239 
u16_t
 
mss_s
;

1240 struct 
netif
 *
outif
;

1242 
outif
 = 
	`ip_route
(
addr
);

1243 if ((
outif
 != 
NULL
) && (outif->
mtu
 != 0)) {

1244 
mss_s
 = 
outif
->
mtu
 - 
IP_HLEN
 - 
TCP_HLEN
;

1248 
sendmss
 = 
	`LWIP_MIN
(sendmss, 
mss_s
);

1250 return 
sendmss
;

1251 
	}
}

1254 #if 
TCP_DEBUG
 || 
TCP_INPUT_DEBUG
 || 
TCP_OUTPUT_DEBUG


1261 
	$tcp_debug_print
(struct 
tcp_hdr
 *
tcphdr
)

1263 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP header:\n"));

1264 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("+-------------------------------+\n"));

1265 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("| %5"
U16_F
" | %5"U16_F" | (src port, dest port)\n",

1266 
	`ntohs
(
tcphdr
->
src
), ntohs(tcphdr->
dest
)));

1267 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("+-------------------------------+\n"));

1268 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("| %010"
U32_F
" | (seq no)\n",

1269 
	`ntohl
(
tcphdr
->
seqno
)));

1270 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("+-------------------------------+\n"));

1271 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("| %010"
U32_F
" | (ack no)\n",

1272 
	`ntohl
(
tcphdr
->
ackno
)));

1273 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("+-------------------------------+\n"));

1274 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("| %2"
U16_F
" | |%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"| %5"U16_F" | (hdrlen, flags (",

1275 
	`TCPH_HDRLEN
(
tcphdr
),

1276 
	`TCPH_FLAGS
(
tcphdr
) >> 5 & 1,

1277 
	`TCPH_FLAGS
(
tcphdr
) >> 4 & 1,

1278 
	`TCPH_FLAGS
(
tcphdr
) >> 3 & 1,

1279 
	`TCPH_FLAGS
(
tcphdr
) >> 2 & 1,

1280 
	`TCPH_FLAGS
(
tcphdr
) >> 1 & 1,

1281 
	`TCPH_FLAGS
(
tcphdr
) & 1,

1282 
	`ntohs
(
tcphdr
->
wnd
)));

1283 
	`tcp_debug_print_flags
(
	`TCPH_FLAGS
(
tcphdr
));

1284 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("), win)\n"));

1285 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("+-------------------------------+\n"));

1286 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("| 0x%04"
X16_F
" | %5"
U16_F
" | (chksum, urgp)\n",

1287 
	`ntohs
(
tcphdr
->
chksum
), ntohs(tcphdr->
urgp
)));

1288 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("+-------------------------------+\n"));

1289 
	}
}

1297 
	$tcp_debug_print_state
(enum 
tcp_state
 
s
)

1299 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("State: "));

1300 switch (
s
) {

1301 case 
CLOSED
:

1302 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("CLOSED\n"));

1304 case 
LISTEN
:

1305 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("LISTEN\n"));

1307 case 
SYN_SENT
:

1308 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("SYN_SENT\n"));

1310 case 
SYN_RCVD
:

1311 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("SYN_RCVD\n"));

1313 case 
ESTABLISHED
:

1314 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("ESTABLISHED\n"));

1316 case 
FIN_WAIT_1
:

1317 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("FIN_WAIT_1\n"));

1319 case 
FIN_WAIT_2
:

1320 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("FIN_WAIT_2\n"));

1322 case 
CLOSE_WAIT
:

1323 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("CLOSE_WAIT\n"));

1325 case 
CLOSING
:

1326 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("CLOSING\n"));

1328 case 
LAST_ACK
:

1329 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("LAST_ACK\n"));

1331 case 
TIME_WAIT
:

1332 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TIME_WAIT\n"));

1335 
	}
}

1343 
	$tcp_debug_print_flags
(
u8_t
 
flags
)

1345 if (
flags
 & 
TCP_FIN
) {

1346 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("FIN "));

1348 if (
flags
 & 
TCP_SYN
) {

1349 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("SYN "));

1351 if (
flags
 & 
TCP_RST
) {

1352 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("RST "));

1354 if (
flags
 & 
TCP_PSH
) {

1355 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("PSH "));

1357 if (
flags
 & 
TCP_ACK
) {

1358 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("ACK "));

1360 if (
flags
 & 
TCP_URG
) {

1361 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("URG "));

1363 if (
flags
 & 
TCP_ECE
) {

1364 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("ECE "));

1366 if (
flags
 & 
TCP_CWR
) {

1367 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("CWR "));

1369 
	}
}

1375 
	$tcp_debug_print_pcbs
(void)

1377 struct 
tcp_pcb
 *
pcb
;

1378 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("Active PCB states:\n"));

1379 for(
pcb
 = 
tcp_active_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

1380 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("Local port %"
U16_F
", foreign port %"U16_F" snd_nxt %"
U32_F
" rcv_nxt %"U32_F" ",

1381 
pcb
->
local_port
, pcb->
remote_port
,

1382 
pcb
->
snd_nxt
, pcb->
rcv_nxt
));

1383 
	`tcp_debug_print_state
(
pcb
->
state
);

1385 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("Listen PCB states:\n"));

1386 for(
pcb
 = (struct 
tcp_pcb
 *)
tcp_listen_pcbs
.
pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

1387 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("Local port %"
U16_F
", foreign port %"U16_F" snd_nxt %"
U32_F
" rcv_nxt %"U32_F" ",

1388 
pcb
->
local_port
, pcb->
remote_port
,

1389 
pcb
->
snd_nxt
, pcb->
rcv_nxt
));

1390 
	`tcp_debug_print_state
(
pcb
->
state
);

1392 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TIME-WAIT PCB states:\n"));

1393 for(
pcb
 = 
tcp_tw_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

1394 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("Local port %"
U16_F
", foreign port %"U16_F" snd_nxt %"
U32_F
" rcv_nxt %"U32_F" ",

1395 
pcb
->
local_port
, pcb->
remote_port
,

1396 
pcb
->
snd_nxt
, pcb->
rcv_nxt
));

1397 
	`tcp_debug_print_state
(
pcb
->
state
);

1399 
	}
}

1404 
s16_t


1405 
	$tcp_pcbs_sane
(void)

1407 struct 
tcp_pcb
 *
pcb
;

1408 for(
pcb
 = 
tcp_active_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

1409 
	`LWIP_ASSERT
("tcp_pcbs_sane: active pcb->state != CLOSED", 
pcb
->
state
 != 
CLOSED
);

1410 
	`LWIP_ASSERT
("tcp_pcbs_sane: active pcb->state != LISTEN", 
pcb
->
state
 != 
LISTEN
);

1411 
	`LWIP_ASSERT
("tcp_pcbs_sane: active pcb->state != TIME-WAIT", 
pcb
->
state
 != 
TIME_WAIT
);

1413 for(
pcb
 = 
tcp_tw_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

1414 
	`LWIP_ASSERT
("tcp_pcbs_sane: tw pcb->state == TIME-WAIT", 
pcb
->
state
 == 
TIME_WAIT
);

1417 
	}
}

	@/root/Robux/net/lwip/core/tcp_in.c

44 #include 
	~"lwip/opt.h
"

46 #if 
LWIP_TCP


48 #include 
	~"lwip/tcp.h
"

49 #include 
	~"lwip/def.h
"

50 #include 
	~"lwip/ip_addr.h
"

51 #include 
	~"lwip/netif.h
"

52 #include 
	~"lwip/mem.h
"

53 #include 
	~"lwip/memp.h
"

54 #include 
	~"lwip/inet.h
"

55 #include 
	~"lwip/inet_chksum.h
"

56 #include 
	~"lwip/stats.h
"

57 #include 
	~"lwip/snmp.h
"

58 #include 
	~"arch/perf.h
"

63 static struct 
tcp_seg
 
	ginseg
;

64 static struct 
tcp_hdr
 *
	gtcphdr
;

65 static struct 
ip_hdr
 *
	giphdr
;

66 static 
u32_t
 
	gseqno
, 
	gackno
;

67 static 
u8_t
 
	gflags
;

68 static 
u16_t
 
	gtcplen
;

70 static 
u8_t
 
	grecv_flags
;

71 static struct 
pbuf
 *
	grecv_data
;

73 struct 
tcp_pcb
 *
	gtcp_input_pcb
;

76 static 
err_t
 
tcp_process
(struct 
tcp_pcb
 *
pcb
);

77 static 
u8_t
 
tcp_receive
(struct 
tcp_pcb
 *
pcb
);

78 static void 
tcp_parseopt
(struct 
tcp_pcb
 *
pcb
);

80 static 
err_t
 
tcp_listen_input
(struct 
tcp_pcb_listen
 *
pcb
);

81 static 
err_t
 
tcp_timewait_input
(struct 
tcp_pcb
 *
pcb
);

93 
	$tcp_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
)

95 struct 
tcp_pcb
 *
pcb
, *
prev
;

96 struct 
tcp_pcb_listen
 *
lpcb
;

97 
u8_t
 
hdrlen
;

98 
err_t
 
err
;

100 
PERF_START
;

102 
	`TCP_STATS_INC
(
tcp
.
recv
);

103 
	`snmp_inc_tcpinsegs
();

105 
iphdr
 = 
p
->
payload
;

106 
tcphdr
 = (struct 
tcp_hdr
 *)((
u8_t
 *)
p
->
payload
 + 
	`IPH_HL
(
iphdr
) * 4);

108 #if 
TCP_INPUT_DEBUG


109 
	`tcp_debug_print
(
tcphdr
);

113 if (
	`pbuf_header
(
p
, -((
s16_t
)(
	`IPH_HL
(
iphdr
) * 4))) || (p->
tot_len
 < sizeof(struct 
tcp_hdr
))) {

115 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: short packet (%"
U16_F
" bytes) discarded\n", 
p
->
tot_len
));

116 
	`TCP_STATS_INC
(
tcp
.
lenerr
);

117 
	`TCP_STATS_INC
(
tcp
.
drop
);

118 
	`snmp_inc_tcpinerrs
();

119 
	`pbuf_free
(
p
);

124 if (
	`ip_addr_isbroadcast
(&(
iphdr
->
dest
), 
inp
) ||

125 
	`ip_addr_ismulticast
(&(
iphdr
->
dest
))) {

126 
	`TCP_STATS_INC
(
tcp
.
proterr
);

127 
	`TCP_STATS_INC
(
tcp
.
drop
);

128 
	`snmp_inc_tcpinerrs
();

129 
	`pbuf_free
(
p
);

133 #if 
CHECKSUM_CHECK_TCP


135 if (
	`inet_chksum_pseudo
(
p
, (struct 
ip_addr
 *)&(
iphdr
->
src
),

136 (struct 
ip_addr
 *)&(
iphdr
->
dest
),

137 
IP_PROTO_TCP
, 
p
->
tot_len
) != 0) {

138 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: packet discarded due to failing checksum 0x%04"
X16_F
"\n",

139 
	`inet_chksum_pseudo
(
p
, (struct 
ip_addr
 *)&(
iphdr
->
src
), (struct ip_addr *)&(iphdr->
dest
),

140 
IP_PROTO_TCP
, 
p
->
tot_len
)));

141 #if 
TCP_DEBUG


142 
	`tcp_debug_print
(
tcphdr
);

144 
	`TCP_STATS_INC
(
tcp
.
chkerr
);

145 
	`TCP_STATS_INC
(
tcp
.
drop
);

146 
	`snmp_inc_tcpinerrs
();

147 
	`pbuf_free
(
p
);

154 
hdrlen
 = 
	`TCPH_HDRLEN
(
tcphdr
);

155 if(
	`pbuf_header
(
p
, -(
hdrlen
 * 4))){

157 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: short packet\n"));

158 
	`TCP_STATS_INC
(
tcp
.
lenerr
);

159 
	`TCP_STATS_INC
(
tcp
.
drop
);

160 
	`snmp_inc_tcpinerrs
();

161 
	`pbuf_free
(
p
);

166 
tcphdr
->
src
 = 
	`ntohs
(tcphdr->src);

167 
tcphdr
->
dest
 = 
	`ntohs
(tcphdr->dest);

168 
seqno
 = 
tcphdr
->seqno = 
	`ntohl
(tcphdr->seqno);

169 
ackno
 = 
tcphdr
->ackno = 
	`ntohl
(tcphdr->ackno);

170 
tcphdr
->
wnd
 = 
	`ntohs
(tcphdr->wnd);

172 
flags
 = 
	`TCPH_FLAGS
(
tcphdr
) & 
TCP_FLAGS
;

173 
tcplen
 = 
p
->
tot_len
 + ((
flags
 & 
TCP_FIN
 || flags & 
TCP_SYN
)? 1: 0);

177 
prev
 = 
NULL
;

180 for(
pcb
 = 
tcp_active_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

181 
	`LWIP_ASSERT
("tcp_input: active pcb->state != CLOSED", 
pcb
->
state
 != 
CLOSED
);

182 
	`LWIP_ASSERT
("tcp_input: active pcb->state != TIME-WAIT", 
pcb
->
state
 != 
TIME_WAIT
);

183 
	`LWIP_ASSERT
("tcp_input: active pcb->state != LISTEN", 
pcb
->
state
 != 
LISTEN
);

184 if (
pcb
->
remote_port
 == 
tcphdr
->
src
 &&

185 
pcb
->
local_port
 == 
tcphdr
->
dest
 &&

186 
	`ip_addr_cmp
(&(
pcb
->
remote_ip
), &(
iphdr
->
src
)) &&

187 
	`ip_addr_cmp
(&(
pcb
->
local_ip
), &(
iphdr
->
dest
))) {

192 
	`LWIP_ASSERT
("tcp_input: pcb->next != pcb (before cache)", 
pcb
->
next
 != pcb);

193 if (
prev
 != 
NULL
) {

194 
prev
->
next
 = 
pcb
->next;

195 
pcb
->
next
 = 
tcp_active_pcbs
;

196 
tcp_active_pcbs
 = 
pcb
;

198 
	`LWIP_ASSERT
("tcp_input: pcb->next != pcb (after cache)", 
pcb
->
next
 != pcb);

201 
prev
 = 
pcb
;

204 if (
pcb
 == 
NULL
) {

207 for(
pcb
 = 
tcp_tw_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

208 
	`LWIP_ASSERT
("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", 
pcb
->
state
 == 
TIME_WAIT
);

209 if (
pcb
->
remote_port
 == 
tcphdr
->
src
 &&

210 
pcb
->
local_port
 == 
tcphdr
->
dest
 &&

211 
	`ip_addr_cmp
(&(
pcb
->
remote_ip
), &(
iphdr
->
src
)) &&

212 
	`ip_addr_cmp
(&(
pcb
->
local_ip
), &(
iphdr
->
dest
))) {

216 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: packed for TIME_WAITing connection.\n"));

217 
	`tcp_timewait_input
(
pcb
);

218 
	`pbuf_free
(
p
);

225 
prev
 = 
NULL
;

226 for(
lpcb
 = 
tcp_listen_pcbs
.
listen_pcbs
; lpcb != 
NULL
; lpcb = lpcb->
next
) {

227 if ((
	`ip_addr_isany
(&(
lpcb
->
local_ip
)) ||

228 
	`ip_addr_cmp
(&(
lpcb
->
local_ip
), &(
iphdr
->
dest
))) &&

229 
lpcb
->
local_port
 == 
tcphdr
->
dest
) {

233 if (
prev
 != 
NULL
) {

234 ((struct 
tcp_pcb_listen
 *)
prev
)->
next
 = 
lpcb
->next;

236 
lpcb
->
next
 = 
tcp_listen_pcbs
.
listen_pcbs
;

238 
tcp_listen_pcbs
.
listen_pcbs
 = 
lpcb
;

241 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: packed for LISTENing connection.\n"));

242 
	`tcp_listen_input
(
lpcb
);

243 
	`pbuf_free
(
p
);

246 
prev
 = (struct 
tcp_pcb
 *)
lpcb
;

250 #if 
TCP_INPUT_DEBUG


251 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));

252 
	`tcp_debug_print_flags
(
	`TCPH_FLAGS
(
tcphdr
));

253 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));

257 if (
pcb
 != 
NULL
) {

259 #if 
TCP_INPUT_DEBUG


260 #if 
TCP_DEBUG


261 
	`tcp_debug_print_state
(
pcb
->
state
);

266 
inseg
.
next
 = 
NULL
;

267 
inseg
.
len
 = 
p
->
tot_len
;

268 
inseg
.
dataptr
 = 
p
->
payload
;

269 
inseg
.
p
 = p;

270 
inseg
.
tcphdr
 = tcphdr;

272 
recv_data
 = 
NULL
;

273 
recv_flags
 = 0;

276 if (
pcb
->
refused_data
 != 
NULL
) {

278 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: notify kept packet\n"));

279 
	`TCP_EVENT_RECV
(
pcb
, pcb->
refused_data
, 
ERR_OK
, 
err
);

280 if (
err
 == 
ERR_OK
) {

281 
pcb
->
refused_data
 = 
NULL
;

284 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));

285 
	`TCP_STATS_INC
(
tcp
.
drop
);

286 
	`snmp_inc_tcpinerrs
();

287 
	`pbuf_free
(
p
);

292 
tcp_input_pcb
 = 
pcb
;

293 
err
 = 
	`tcp_process
(
pcb
);

294 
tcp_input_pcb
 = 
NULL
;

297 if (
err
 != 
ERR_ABRT
) {

298 if (
recv_flags
 & 
TF_RESET
) {

303 
	`TCP_EVENT_ERR
(
pcb
->
errf
, pcb->
callback_arg
, 
ERR_RST
);

304 
	`tcp_pcb_remove
(&
tcp_active_pcbs
, 
pcb
);

305 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

306 } else if (
recv_flags
 & 
TF_CLOSED
) {

309 
	`tcp_pcb_remove
(&
tcp_active_pcbs
, 
pcb
);

310 
	`memp_free
(
MEMP_TCP_PCB
, 
pcb
);

312 
err
 = 
ERR_OK
;

316 if (
pcb
->
acked
 > 0) {

317 
	`TCP_EVENT_SENT
(
pcb
, pcb->
acked
, 
err
);

320 if (
recv_data
 != 
NULL
) {

321 if(
flags
 & 
TCP_PSH
) {

322 
recv_data
->
flags
 |= 
PBUF_FLAG_PUSH
;

326 
	`TCP_EVENT_RECV
(
pcb
, 
recv_data
, 
ERR_OK
, 
err
);

329 if (
err
 != 
ERR_OK
) {

330 
pcb
->
refused_data
 = 
recv_data
;

331 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));

337 if (
recv_flags
 & 
TF_GOT_FIN
) {

338 
	`TCP_EVENT_RECV
(
pcb
, 
NULL
, 
ERR_OK
, 
err
);

342 if (
err
 == 
ERR_OK
) {

343 
	`tcp_output
(
pcb
);

350 if (
inseg
.
p
 != 
NULL
)

352 
	`pbuf_free
(
inseg
.
p
);

353 
inseg
.
p
 = 
NULL
;

355 #if 
TCP_INPUT_DEBUG


356 #if 
TCP_DEBUG


357 
	`tcp_debug_print_state
(
pcb
->
state
);

365 
	`LWIP_DEBUGF
(
TCP_RST_DEBUG
, ("tcp_input: no PCB match found, resetting.\n"));

366 if (!(
	`TCPH_FLAGS
(
tcphdr
) & 
TCP_RST
)) {

367 
	`TCP_STATS_INC
(
tcp
.
proterr
);

368 
	`TCP_STATS_INC
(
tcp
.
drop
);

369 
	`tcp_rst
(
ackno
, 
seqno
 + 
tcplen
,

370 &(
iphdr
->
dest
), &(iphdr->
src
),

371 
tcphdr
->
dest
, tcphdr->
src
);

373 
	`pbuf_free
(
p
);

376 
	`LWIP_ASSERT
("tcp_input: tcp_pcbs_sane()", 
	`tcp_pcbs_sane
());

377 
	`PERF_STOP
("tcp_input");

378 
	}
}

392 static 
err_t


393 
	$tcp_listen_input
(struct 
tcp_pcb_listen
 *
pcb
)

395 struct 
tcp_pcb
 *
npcb
;

396 
u32_t
 
optdata
;

400 if (
flags
 & 
TCP_ACK
) {

403 
	`LWIP_DEBUGF
(
TCP_RST_DEBUG
, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));

404 
	`tcp_rst
(
ackno
 + 1, 
seqno
 + 
tcplen
,

405 &(
iphdr
->
dest
), &(iphdr->
src
),

406 
tcphdr
->
dest
, tcphdr->
src
);

407 } else if (
flags
 & 
TCP_SYN
) {

408 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP connection request %"
U16_F
" -> %"U16_F".\n", 
tcphdr
->
src
, tcphdr->
dest
));

409 #if 
TCP_LISTEN_BACKLOG


410 if (
pcb
->
accepts_pending
 >= pcb->
backlog
) {

411 return 
ERR_ABRT
;

414 
npcb
 = 
	`tcp_alloc
(
pcb
->
prio
);

418 if (
npcb
 == 
NULL
) {

419 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_listen_input: could not allocate PCB\n"));

420 
	`TCP_STATS_INC
(
tcp
.
memerr
);

421 return 
ERR_MEM
;

423 #if 
TCP_LISTEN_BACKLOG


424 
pcb
->
accepts_pending
++;

427 
	`ip_addr_set
(&(
npcb
->
local_ip
), &(
iphdr
->
dest
));

428 
npcb
->
local_port
 = 
pcb
->local_port;

429 
	`ip_addr_set
(&(
npcb
->
remote_ip
), &(
iphdr
->
src
));

430 
npcb
->
remote_port
 = 
tcphdr
->
src
;

431 
npcb
->
state
 = 
SYN_RCVD
;

432 
npcb
->
rcv_nxt
 = 
seqno
 + 1;

433 
npcb
->
snd_wnd
 = 
tcphdr
->
wnd
;

434 
npcb
->
ssthresh
 = npcb->
snd_wnd
;

435 
npcb
->
snd_wl1
 = 
seqno
 - 1;

436 
npcb
->
callback_arg
 = 
pcb
->callback_arg;

437 #if 
LWIP_CALLBACK_API


438 
npcb
->
accept
 = 
pcb
->accept;

441 
npcb
->
so_options
 = 
pcb
->so_options & (
SOF_DEBUG
|
SOF_DONTROUTE
|
SOF_KEEPALIVE
|
SOF_OOBINLINE
|
SOF_LINGER
);

444 
	`TCP_REG
(&
tcp_active_pcbs
, 
npcb
);

447 
	`tcp_parseopt
(
npcb
);

448 #if 
TCP_CALCULATE_EFF_SEND_MSS


449 
npcb
->
mss
 = 
	`tcp_eff_send_mss
(npcb->mss, &(npcb->
remote_ip
));

452 
	`snmp_inc_tcppassiveopens
();

455 
optdata
 = 
	`TCP_BUILD_MSS_OPTION
();

457 
	`tcp_enqueue
(
npcb
, 
NULL
, 0, 
TCP_SYN
 | 
TCP_ACK
, 0, (
u8_t
 *)&
optdata
, 4);

458 return 
	`tcp_output
(
npcb
);

460 return 
ERR_OK
;

461 
	}
}

472 static 
err_t


473 
	$tcp_timewait_input
(struct 
tcp_pcb
 *
pcb
)

475 if (
	`TCP_SEQ_GT
(
seqno
 + 
tcplen
, 
pcb
->
rcv_nxt
)) {

476 
pcb
->
rcv_nxt
 = 
seqno
 + 
tcplen
;

478 if (
tcplen
 > 0) {

479 
	`tcp_ack_now
(
pcb
);

481 return 
	`tcp_output
(
pcb
);

482 
	}
}

495 static 
err_t


496 
	$tcp_process
(struct 
tcp_pcb
 *
pcb
)

498 struct 
tcp_seg
 *
rseg
;

499 
u8_t
 
acceptable
 = 0;

500 
err_t
 
err
;

501 
u8_t
 
accepted_inseq
;

503 
err
 = 
ERR_OK
;

506 if (
flags
 & 
TCP_RST
) {

508 if (
pcb
->
state
 == 
SYN_SENT
) {

509 if (
ackno
 == 
pcb
->
snd_nxt
) {

510 
acceptable
 = 1;

513 if (
	`TCP_SEQ_BETWEEN
(
seqno
, 
pcb
->
rcv_nxt
,

514 
pcb
->
rcv_nxt
+pcb->
rcv_wnd
)) {

515 
acceptable
 = 1;

519 if (
acceptable
) {

520 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_process: Connection RESET\n"));

521 
	`LWIP_ASSERT
("tcp_input: pcb->state != CLOSED", 
pcb
->
state
 != 
CLOSED
);

522 
recv_flags
 = 
TF_RESET
;

523 
pcb
->
flags
 &= ~
TF_ACK_DELAY
;

524 return 
ERR_RST
;

526 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_process: unacceptable reset seqno %"
U32_F
" rcv_nxt %"U32_F"\n",

527 
seqno
, 
pcb
->
rcv_nxt
));

528 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_process: unacceptable reset seqno %"
U32_F
" rcv_nxt %"U32_F"\n",

529 
seqno
, 
pcb
->
rcv_nxt
));

530 return 
ERR_OK
;

535 
pcb
->
tmr
 = 
tcp_ticks
;

536 
pcb
->
keep_cnt_sent
 = 0;

539 switch (
pcb
->
state
) {

540 case 
SYN_SENT
:

541 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("SYN-SENT: ackno %"
U32_F
" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", 
ackno
,

542 
pcb
->
snd_nxt
, 
	`ntohl
(pcb->
unacked
->
tcphdr
->
seqno
)));

544 if ((
flags
 & 
TCP_ACK
) && (flags & 
TCP_SYN
)

545 && 
ackno
 == 
	`ntohl
(
pcb
->
unacked
->
tcphdr
->
seqno
) + 1) {

546 
pcb
->
snd_buf
++;

547 
pcb
->
rcv_nxt
 = 
seqno
 + 1;

548 
pcb
->
lastack
 = 
ackno
;

549 
pcb
->
snd_wnd
 = 
tcphdr
->
wnd
;

550 
pcb
->
snd_wl1
 = 
seqno
 - 1;

551 
pcb
->
state
 = 
ESTABLISHED
;

555 
	`tcp_parseopt
(
pcb
);

556 #if 
TCP_CALCULATE_EFF_SEND_MSS


557 
pcb
->
mss
 = 
	`tcp_eff_send_mss
(pcb->mss, &(pcb->
remote_ip
));

562 
pcb
->
ssthresh
 = pcb->
mss
 * 10;

564 
pcb
->
cwnd
 = ((pcb->cwnd == 1) ? (pcb->
mss
 * 2) : pcb->mss);

565 
	`LWIP_ASSERT
("pcb->snd_queuelen > 0", (
pcb
->
snd_queuelen
 > 0));

566 --
pcb
->
snd_queuelen
;

567 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
, ("tcp_process: SYN-SENT --queuelen %"
U16_F
"\n", (
u16_t
)
pcb
->
snd_queuelen
));

568 
rseg
 = 
pcb
->
unacked
;

569 
pcb
->
unacked
 = 
rseg
->
next
;

573 if(
pcb
->
unacked
 == 
NULL
)

574 
pcb
->
rtime
 = -1;

576 
pcb
->
rtime
 = 0;

577 
pcb
->
nrtx
 = 0;

580 
	`tcp_seg_free
(
rseg
);

584 
	`TCP_EVENT_CONNECTED
(
pcb
, 
ERR_OK
, 
err
);

585 
	`tcp_ack_now
(
pcb
);

588 else if (
flags
 & 
TCP_ACK
) {

590 
	`tcp_rst
(
ackno
, 
seqno
 + 
tcplen
, &(
iphdr
->
dest
), &(iphdr->
src
),

591 
tcphdr
->
dest
, tcphdr->
src
);

594 case 
SYN_RCVD
:

595 if (
flags
 & 
TCP_ACK
 &&

596 !(
flags
 & 
TCP_RST
)) {

598 if (
	`TCP_SEQ_BETWEEN
(
ackno
, 
pcb
->
lastack
+1, pcb->
snd_nxt
)) {

599 
u16_t
 
old_cwnd
;

600 
pcb
->
state
 = 
ESTABLISHED
;

601 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP connection established %"
U16_F
" -> %"U16_F".\n", 
inseg
.
tcphdr
->
src
, inseg.tcphdr->
dest
));

602 #if 
LWIP_CALLBACK_API


603 
	`LWIP_ASSERT
("pcb->accept != NULL", 
pcb
->
accept
 != 
NULL
);

606 
	`TCP_EVENT_ACCEPT
(
pcb
, 
ERR_OK
, 
err
);

607 if (
err
 != 
ERR_OK
) {

610 
	`tcp_abort
(
pcb
);

611 return 
ERR_ABRT
;

613 
old_cwnd
 = 
pcb
->
cwnd
;

616 
accepted_inseq
 = 
	`tcp_receive
(
pcb
);

618 
pcb
->
cwnd
 = ((
old_cwnd
 == 1) ? (pcb->
mss
 * 2) : pcb->mss);

620 if ((
flags
 & 
TCP_FIN
) && 
accepted_inseq
) {

621 
	`tcp_ack_now
(
pcb
);

622 
pcb
->
state
 = 
CLOSE_WAIT
;

628 
	`tcp_rst
(
ackno
, 
seqno
 + 
tcplen
, &(
iphdr
->
dest
), &(iphdr->
src
),

629 
tcphdr
->
dest
, tcphdr->
src
);

633 case 
CLOSE_WAIT
:

635 case 
ESTABLISHED
:

636 
accepted_inseq
 = 
	`tcp_receive
(
pcb
);

637 if ((
flags
 & 
TCP_FIN
) && 
accepted_inseq
) {

638 
	`tcp_ack_now
(
pcb
);

639 
pcb
->
state
 = 
CLOSE_WAIT
;

642 case 
FIN_WAIT_1
:

643 
	`tcp_receive
(
pcb
);

644 if (
flags
 & 
TCP_FIN
) {

645 if (
flags
 & 
TCP_ACK
 && 
ackno
 == 
pcb
->
snd_nxt
) {

646 
	`LWIP_DEBUGF
(
TCP_DEBUG
,

647 ("TCP connection closed %"
U16_F
" -> %"U16_F".\n", 
inseg
.
tcphdr
->
src
, inseg.tcphdr->
dest
));

648 
	`tcp_ack_now
(
pcb
);

649 
	`tcp_pcb_purge
(
pcb
);

650 
	`TCP_RMV
(&
tcp_active_pcbs
, 
pcb
);

651 
pcb
->
state
 = 
TIME_WAIT
;

652 
	`TCP_REG
(&
tcp_tw_pcbs
, 
pcb
);

654 
	`tcp_ack_now
(
pcb
);

655 
pcb
->
state
 = 
CLOSING
;

657 } else if (
flags
 & 
TCP_ACK
 && 
ackno
 == 
pcb
->
snd_nxt
) {

658 
pcb
->
state
 = 
FIN_WAIT_2
;

661 case 
FIN_WAIT_2
:

662 
	`tcp_receive
(
pcb
);

663 if (
flags
 & 
TCP_FIN
) {

664 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP connection closed %"
U16_F
" -> %"U16_F".\n", 
inseg
.
tcphdr
->
src
, inseg.tcphdr->
dest
));

665 
	`tcp_ack_now
(
pcb
);

666 
	`tcp_pcb_purge
(
pcb
);

667 
	`TCP_RMV
(&
tcp_active_pcbs
, 
pcb
);

668 
pcb
->
state
 = 
TIME_WAIT
;

669 
	`TCP_REG
(&
tcp_tw_pcbs
, 
pcb
);

672 case 
CLOSING
:

673 
	`tcp_receive
(
pcb
);

674 if (
flags
 & 
TCP_ACK
 && 
ackno
 == 
pcb
->
snd_nxt
) {

675 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP connection closed %"
U16_F
" -> %"U16_F".\n", 
inseg
.
tcphdr
->
src
, inseg.tcphdr->
dest
));

676 
	`tcp_ack_now
(
pcb
);

677 
	`tcp_pcb_purge
(
pcb
);

678 
	`TCP_RMV
(&
tcp_active_pcbs
, 
pcb
);

679 
pcb
->
state
 = 
TIME_WAIT
;

680 
	`TCP_REG
(&
tcp_tw_pcbs
, 
pcb
);

683 case 
LAST_ACK
:

684 
	`tcp_receive
(
pcb
);

685 if (
flags
 & 
TCP_ACK
 && 
ackno
 == 
pcb
->
snd_nxt
) {

686 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP connection closed %"
U16_F
" -> %"U16_F".\n", 
inseg
.
tcphdr
->
src
, inseg.tcphdr->
dest
));

688 
recv_flags
 = 
TF_CLOSED
;

694 return 
ERR_OK
;

695 
	}
}

711 static 
u8_t


712 
	$tcp_receive
(struct 
tcp_pcb
 *
pcb
)

714 struct 
tcp_seg
 *
next
;

715 #if 
TCP_QUEUE_OOSEQ


716 struct 
tcp_seg
 *
prev
, *
cseg
;

718 struct 
pbuf
 *
p
;

719 
s32_t
 
off
;

720 
s16_t
 
m
;

721 
u32_t
 
right_wnd_edge
;

722 
u16_t
 
new_tot_len
;

723 
u8_t
 
accepted_inseq
 = 0;

725 if (
flags
 & 
TCP_ACK
) {

726 
right_wnd_edge
 = 
pcb
->
snd_wnd
 + pcb->
snd_wl1
;

729 if (
	`TCP_SEQ_LT
(
pcb
->
snd_wl1
, 
seqno
) ||

730 (
pcb
->
snd_wl1
 == 
seqno
 && 
	`TCP_SEQ_LT
(pcb->
snd_wl2
, 
ackno
)) ||

731 (
pcb
->
snd_wl2
 == 
ackno
 && 
tcphdr
->
wnd
 > pcb->
snd_wnd
)) {

732 
pcb
->
snd_wnd
 = 
tcphdr
->
wnd
;

733 
pcb
->
snd_wl1
 = 
seqno
;

734 
pcb
->
snd_wl2
 = 
ackno
;

735 if (
pcb
->
snd_wnd
 > 0 && pcb->
persist_backoff
 > 0) {

736 
pcb
->
persist_backoff
 = 0;

738 
	`LWIP_DEBUGF
(
TCP_WND_DEBUG
, ("tcp_receive: window update %"
U16_F
"\n", 
pcb
->
snd_wnd
));

739 #if 
TCP_WND_DEBUG


741 if (
pcb
->
snd_wnd
 != 
tcphdr
->
wnd
) {

742 
	`LWIP_DEBUGF
(
TCP_WND_DEBUG
, ("tcp_receive: no window update lastack %"
U32_F
" snd_max %"U32_F" ackno %"U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",

743 
pcb
->
lastack
, pcb->
snd_max
, 
ackno
, pcb->
snd_wl1
, 
seqno
, pcb->
snd_wl2
));

748 if (
pcb
->
lastack
 == 
ackno
) {

749 
pcb
->
acked
 = 0;

751 if (
pcb
->
snd_wl1
 + pcb->
snd_wnd
 == 
right_wnd_edge
){

752 ++
pcb
->
dupacks
;

753 if (
pcb
->
dupacks
 >= 3 && pcb->
unacked
 != 
NULL
) {

754 if (!(
pcb
->
flags
 & 
TF_INFR
)) {

756 
	`LWIP_DEBUGF
(
TCP_FR_DEBUG
, ("tcp_receive: dupacks %"
U16_F
" (%"
U32_F
"), fast retransmit %"U32_F"\n",

757 (
u16_t
)
pcb
->
dupacks
, pcb->
lastack
,

758 
	`ntohl
(
pcb
->
unacked
->
tcphdr
->
seqno
)));

759 
	`tcp_rexmit
(
pcb
);

765 if (
pcb
->
cwnd
 > pcb->
snd_wnd
)

766 
pcb
->
ssthresh
 = pcb->
snd_wnd
 / 2;

768 
pcb
->
ssthresh
 = pcb->
cwnd
 / 2;

771 if (
pcb
->
ssthresh
 < 2*pcb->
mss
) {

772 
	`LWIP_DEBUGF
(
TCP_FR_DEBUG
, ("tcp_receive: The minimum value for ssthresh %"
U16_F
" should be min 2 mss %"U16_F"...\n", 
pcb
->
ssthresh
, 2*pcb->
mss
));

773 
pcb
->
ssthresh
 = 2*pcb->
mss
;

776 
pcb
->
cwnd
 = pcb->
ssthresh
 + 3 * pcb->
mss
;

777 
pcb
->
flags
 |= 
TF_INFR
;

781 if ((
u16_t
)(
pcb
->
cwnd
 + pcb->
mss
) > pcb->cwnd) {

782 
pcb
->
cwnd
 += pcb->
mss
;

787 
	`LWIP_DEBUGF
(
TCP_FR_DEBUG
, ("tcp_receive: dupack averted %"
U32_F
" %"U32_F"\n",

788 
pcb
->
snd_wl1
 + pcb->
snd_wnd
, 
right_wnd_edge
));

790 } else if (
	`TCP_SEQ_BETWEEN
(
ackno
, 
pcb
->
lastack
+1, pcb->
snd_max
)){

796 if (
pcb
->
flags
 & 
TF_INFR
) {

797 
pcb
->
flags
 &= ~
TF_INFR
;

798 
pcb
->
cwnd
 = pcb->
ssthresh
;

802 
pcb
->
nrtx
 = 0;

805 
pcb
->
rto
 = (pcb->
sa
 >> 3) + pcb->
sv
;

808 
pcb
->
acked
 = (
u16_t
)(
ackno
 - pcb->
lastack
);

810 
pcb
->
snd_buf
 += pcb->
acked
;

813 
pcb
->
dupacks
 = 0;

814 
pcb
->
lastack
 = 
ackno
;

818 if (
pcb
->
state
 >= 
ESTABLISHED
) {

819 if (
pcb
->
cwnd
 < pcb->
ssthresh
) {

820 if ((
u16_t
)(
pcb
->
cwnd
 + pcb->
mss
) > pcb->cwnd) {

821 
pcb
->
cwnd
 += pcb->
mss
;

823 
	`LWIP_DEBUGF
(
TCP_CWND_DEBUG
, ("tcp_receive: slow start cwnd %"
U16_F
"\n", 
pcb
->
cwnd
));

825 
u16_t
 
new_cwnd
 = (
pcb
->
cwnd
 + pcb->
mss
 * pcb->mss / pcb->cwnd);

826 if (
new_cwnd
 > 
pcb
->
cwnd
) {

827 
pcb
->
cwnd
 = 
new_cwnd
;

829 
	`LWIP_DEBUGF
(
TCP_CWND_DEBUG
, ("tcp_receive: congestion avoidance cwnd %"
U16_F
"\n", 
pcb
->
cwnd
));

832 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_receive: ACK for %"
U32_F
", unacked->seqno %"U32_F":%"U32_F"\n",

833 
ackno
,

834 
pcb
->
unacked
 != 
NULL
?

835 
	`ntohl
(
pcb
->
unacked
->
tcphdr
->
seqno
): 0,

836 
pcb
->
unacked
 != 
NULL
?

837 
	`ntohl
(
pcb
->
unacked
->
tcphdr
->
seqno
) + 
	`TCP_TCPLEN
(pcb->unacked): 0));

841 while (
pcb
->
unacked
 != 
NULL
 &&

842 
	`TCP_SEQ_LEQ
(
	`ntohl
(
pcb
->
unacked
->
tcphdr
->
seqno
) +

843 
	`TCP_TCPLEN
(
pcb
->
unacked
), 
ackno
)) {

844 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_receive: removing %"
U32_F
":%"U32_F" from pcb->unacked\n",

845 
	`ntohl
(
pcb
->
unacked
->
tcphdr
->
seqno
),

846 
	`ntohl
(
pcb
->
unacked
->
tcphdr
->
seqno
) +

847 
	`TCP_TCPLEN
(
pcb
->
unacked
)));

849 
next
 = 
pcb
->
unacked
;

850 
pcb
->
unacked
 = pcb->unacked->
next
;

852 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
, ("tcp_receive: queuelen %"
U16_F
" ... ", (
u16_t
)
pcb
->
snd_queuelen
));

853 
	`LWIP_ASSERT
("pcb->snd_queuelen >= pbuf_clen(next->p)", (
pcb
->
snd_queuelen
 >= 
	`pbuf_clen
(
next
->
p
)));

854 
pcb
->
snd_queuelen
 -= 
	`pbuf_clen
(
next
->
p
);

855 
	`tcp_seg_free
(
next
);

857 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
, ("%"
U16_F
" (after freeing unacked)\n", (
u16_t
)
pcb
->
snd_queuelen
));

858 if (
pcb
->
snd_queuelen
 != 0) {

859 
	`LWIP_ASSERT
("tcp_receive: valid queue length", 
pcb
->
unacked
 != 
NULL
 ||

860 
pcb
->
unsent
 != 
NULL
);

866 if(
pcb
->
unacked
 == 
NULL
)

867 
pcb
->
rtime
 = -1;

869 
pcb
->
rtime
 = 0;

871 
pcb
->
polltmr
 = 0;

874 
pcb
->
acked
 = 0;

883 while (
pcb
->
unsent
 != 
NULL
 &&

886 
	`TCP_SEQ_BETWEEN
(
ackno
, 
	`ntohl
(
pcb
->
unsent
->
tcphdr
->
seqno
) + 
	`TCP_TCPLEN
(pcb->unsent), pcb->
snd_max
)

888 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_receive: removing %"
U32_F
":%"U32_F" from pcb->unsent\n",

889 
	`ntohl
(
pcb
->
unsent
->
tcphdr
->
seqno
), ntohl(pcb->unsent->tcphdr->seqno) +

890 
	`TCP_TCPLEN
(
pcb
->
unsent
)));

892 
next
 = 
pcb
->
unsent
;

893 
pcb
->
unsent
 = pcb->unsent->
next
;

894 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
, ("tcp_receive: queuelen %"
U16_F
" ... ", (
u16_t
)
pcb
->
snd_queuelen
));

895 
	`LWIP_ASSERT
("pcb->snd_queuelen >= pbuf_clen(next->p)", (
pcb
->
snd_queuelen
 >= 
	`pbuf_clen
(
next
->
p
)));

896 
pcb
->
snd_queuelen
 -= 
	`pbuf_clen
(
next
->
p
);

897 
	`tcp_seg_free
(
next
);

898 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
, ("%"
U16_F
" (after freeing unsent)\n", (
u16_t
)
pcb
->
snd_queuelen
));

899 if (
pcb
->
snd_queuelen
 != 0) {

900 
	`LWIP_ASSERT
("tcp_receive: valid queue length",

901 
pcb
->
unacked
 != 
NULL
 || pcb->
unsent
 != NULL);

904 if (
pcb
->
unsent
 != 
NULL
) {

905 
pcb
->
snd_nxt
 = 
	`htonl
(pcb->
unsent
->
tcphdr
->
seqno
);

910 
	`LWIP_DEBUGF
(
TCP_RTO_DEBUG
, ("tcp_receive: pcb->rttest %"
U32_F
" rtseq %"U32_F" ackno %"U32_F"\n",

911 
pcb
->
rttest
, pcb->
rtseq
, 
ackno
));

916 if (
pcb
->
rttest
 && 
	`TCP_SEQ_LT
(pcb->
rtseq
, 
ackno
)) {

919 
m
 = (
s16_t
)(
tcp_ticks
 - 
pcb
->
rttest
);

921 
	`LWIP_DEBUGF
(
TCP_RTO_DEBUG
, ("tcp_receive: experienced rtt %"
U16_F
" ticks (%"U16_F" msec).\n",

922 
m
, m * 
TCP_SLOW_INTERVAL
));

925 
m
 = m - (
pcb
->
sa
 >> 3);

926 
pcb
->
sa
 += 
m
;

927 if (
m
 < 0) {

928 
m
 = -m;

930 
m
 = m - (
pcb
->
sv
 >> 2);

931 
pcb
->
sv
 += 
m
;

932 
pcb
->
rto
 = (pcb->
sa
 >> 3) + pcb->
sv
;

934 
	`LWIP_DEBUGF
(
TCP_RTO_DEBUG
, ("tcp_receive: RTO %"
U16_F
" (%"U16_F" milliseconds)\n",

935 
pcb
->
rto
, pcb->rto * 
TCP_SLOW_INTERVAL
));

937 
pcb
->
rttest
 = 0;

943 if (
tcplen
 > 0) {

974 if (
	`TCP_SEQ_BETWEEN
(
pcb
->
rcv_nxt
, 
seqno
 + 1, seqno + 
tcplen
 - 1)){

995 
off
 = 
pcb
->
rcv_nxt
 - 
seqno
;

996 
p
 = 
inseg
.p;

997 
	`LWIP_ASSERT
("inseg.p != NULL", 
inseg
.
p
);

998 
	`LWIP_ASSERT
("insane offset!", (
off
 < 0x7fff));

999 if (
inseg
.
p
->
len
 < 
off
) {

1000 
	`LWIP_ASSERT
("pbuf too short!", (((
s32_t
)
inseg
.
p
->
tot_len
) >= 
off
));

1001 
new_tot_len
 = (
u16_t
)(
inseg
.
p
->
tot_len
 - 
off
);

1002 while (
p
->
len
 < 
off
) {

1003 
off
 -= 
p
->
len
;

1007 
p
->
tot_len
 = 
new_tot_len
;

1008 
p
->
len
 = 0;

1009 
p
 = p->
next
;

1011 if(
	`pbuf_header
(
p
, (
s16_t
)-
off
)) {

1013 
	`LWIP_ASSERT
("pbuf_header failed", 0);

1016 if(
	`pbuf_header
(
inseg
.
p
, (
s16_t
)-
off
)) {

1018 
	`LWIP_ASSERT
("pbuf_header failed", 0);

1023 
inseg
.
dataptr
 = 
p
->
payload
;

1024 
inseg
.
len
 -= (
u16_t
)(
pcb
->
rcv_nxt
 - 
seqno
);

1025 
inseg
.
tcphdr
->
seqno
 = seqno = 
pcb
->
rcv_nxt
;

1028 if (
	`TCP_SEQ_LT
(
seqno
, 
pcb
->
rcv_nxt
)){

1032 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_receive: duplicate seqno %"
U32_F
"\n", 
seqno
));

1033 
	`tcp_ack_now
(
pcb
);

1040 if (
	`TCP_SEQ_BETWEEN
(
seqno
, 
pcb
->
rcv_nxt
,

1041 
pcb
->
rcv_nxt
 + pcb->
rcv_wnd
 - 1)){

1042 if (
pcb
->
rcv_nxt
 == 
seqno
) {

1043 
accepted_inseq
 = 1;

1047 #if 
TCP_QUEUE_OOSEQ


1048 if (
pcb
->
ooseq
 != 
NULL
 &&

1049 
	`TCP_SEQ_LEQ
(
pcb
->
ooseq
->
tcphdr
->
seqno
, seqno + 
inseg
.
len
)) {

1050 if (
pcb
->
ooseq
->
len
 > 0) {

1053 
inseg
.
len
 = (
u16_t
)(
pcb
->
ooseq
->
tcphdr
->
seqno
 - seqno);

1054 
	`pbuf_realloc
(
inseg
.
p
, inseg.
len
);

1057 if ((
	`TCPH_FLAGS
(
inseg
.
tcphdr
) & (
TCP_FIN
|
TCP_SYN
)) ==

1058 (
	`TCPH_FLAGS
(
pcb
->
ooseq
->
tcphdr
) & (
TCP_FIN
|
TCP_SYN
))) {

1059 struct 
tcp_seg
 *
old_ooseq
 = 
pcb
->
ooseq
;

1060 
pcb
->
ooseq
 = pcb->ooseq->
next
;

1061 
	`memp_free
(
MEMP_TCP_SEG
, 
old_ooseq
);

1067 
tcplen
 = 
	`TCP_TCPLEN
(&
inseg
);

1072 if (
pcb
->
state
 != 
CLOSE_WAIT
) {

1073 
pcb
->
rcv_nxt
 += 
tcplen
;

1077 if (
pcb
->
rcv_wnd
 < 
tcplen
) {

1078 
pcb
->
rcv_wnd
 = 0;

1080 
pcb
->
rcv_wnd
 -= 
tcplen
;

1083 if (
pcb
->
rcv_ann_wnd
 < 
tcplen
) {

1084 
pcb
->
rcv_ann_wnd
 = 0;

1086 
pcb
->
rcv_ann_wnd
 -= 
tcplen
;

1098 if (
inseg
.
p
->
tot_len
 > 0) {

1099 
recv_data
 = 
inseg
.
p
;

1103 
inseg
.
p
 = 
NULL
;

1105 if (
	`TCPH_FLAGS
(
inseg
.
tcphdr
) & 
TCP_FIN
) {

1106 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_receive: received FIN.\n"));

1107 
recv_flags
 = 
TF_GOT_FIN
;

1110 #if 
TCP_QUEUE_OOSEQ


1113 while (
pcb
->
ooseq
 != 
NULL
 &&

1114 
pcb
->
ooseq
->
tcphdr
->
seqno
 == pcb->
rcv_nxt
) {

1116 
cseg
 = 
pcb
->
ooseq
;

1117 
seqno
 = 
pcb
->
ooseq
->
tcphdr
->seqno;

1119 
pcb
->
rcv_nxt
 += 
	`TCP_TCPLEN
(
cseg
);

1120 if (
pcb
->
rcv_wnd
 < 
	`TCP_TCPLEN
(
cseg
)) {

1121 
pcb
->
rcv_wnd
 = 0;

1123 
pcb
->
rcv_wnd
 -= 
	`TCP_TCPLEN
(
cseg
);

1125 if (
pcb
->
rcv_ann_wnd
 < 
	`TCP_TCPLEN
(
cseg
)) {

1126 
pcb
->
rcv_ann_wnd
 = 0;

1128 
pcb
->
rcv_ann_wnd
 -= 
	`TCP_TCPLEN
(
cseg
);

1131 if (
cseg
->
p
->
tot_len
 > 0) {

1134 if (
recv_data
) {

1135 
	`pbuf_cat
(
recv_data
, 
cseg
->
p
);

1137 
recv_data
 = 
cseg
->
p
;

1139 
cseg
->
p
 = 
NULL
;

1141 if (
	`TCPH_FLAGS
(
cseg
->
tcphdr
) & 
TCP_FIN
) {

1142 
	`LWIP_DEBUGF
(
TCP_INPUT_DEBUG
, ("tcp_receive: dequeued FIN.\n"));

1143 
recv_flags
 = 
TF_GOT_FIN
;

1144 if (
pcb
->
state
 == 
ESTABLISHED
) {

1145 
pcb
->
state
 = 
CLOSE_WAIT
;

1150 
pcb
->
ooseq
 = 
cseg
->
next
;

1151 
	`tcp_seg_free
(
cseg
);

1157 
	`tcp_ack
(
pcb
);

1161 
	`tcp_ack_now
(
pcb
);

1162 #if 
TCP_QUEUE_OOSEQ


1164 if (
pcb
->
ooseq
 == 
NULL
) {

1165 
pcb
->
ooseq
 = 
	`tcp_seg_copy
(&
inseg
);

1179 
prev
 = 
NULL
;

1180 for(
next
 = 
pcb
->
ooseq
; next != 
NULL
; next = next->next) {

1181 if (
seqno
 == 
next
->
tcphdr
->seqno) {

1186 if (
inseg
.
len
 > 
next
->len) {

1190 
cseg
 = 
	`tcp_seg_copy
(&
inseg
);

1191 if (
cseg
 != 
NULL
) {

1192 
cseg
->
next
 = next->next;

1193 if (
prev
 != 
NULL
) {

1194 
prev
->
next
 = 
cseg
;

1196 
pcb
->
ooseq
 = 
cseg
;

1198 
	`tcp_seg_free
(
next
);

1199 if (
cseg
->
next
 != 
NULL
) {

1200 
next
 = 
cseg
->next;

1201 if (
	`TCP_SEQ_GT
(
seqno
 + 
cseg
->
len
, 
next
->
tcphdr
->seqno)) {

1203 
cseg
->
len
 = (
u16_t
)(
next
->
tcphdr
->
seqno
 - seqno);

1204 
	`pbuf_realloc
(
cseg
->
p
, cseg->
len
);

1216 if (
prev
 == 
NULL
) {

1217 if (
	`TCP_SEQ_LT
(
seqno
, 
next
->
tcphdr
->seqno)) {

1223 if (
	`TCP_SEQ_GT
(
seqno
 + 
inseg
.
len
, 
next
->
tcphdr
->seqno)) {

1225 
inseg
.
len
 = (
u16_t
)(
next
->
tcphdr
->
seqno
 - seqno);

1226 
	`pbuf_realloc
(
inseg
.
p
, inseg.
len
);

1228 
cseg
 = 
	`tcp_seg_copy
(&
inseg
);

1229 if (
cseg
 != 
NULL
) {

1230 
cseg
->
next
 = next;

1231 
pcb
->
ooseq
 = 
cseg
;

1238 if(
	`TCP_SEQ_BETWEEN
(
seqno
, 
prev
->
tcphdr
->seqno+1, 
next
->tcphdr->seqno-1)){

1244 if (
	`TCP_SEQ_GT
(
seqno
 + 
inseg
.
len
, 
next
->
tcphdr
->seqno)) {

1246 
inseg
.
len
 = (
u16_t
)(
next
->
tcphdr
->
seqno
 - seqno);

1247 
	`pbuf_realloc
(
inseg
.
p
, inseg.
len
);

1250 
cseg
 = 
	`tcp_seg_copy
(&
inseg
);

1251 if (
cseg
 != 
NULL
) {

1252 
cseg
->
next
 = next;

1253 
prev
->
next
 = 
cseg
;

1254 if (
	`TCP_SEQ_GT
(
prev
->
tcphdr
->
seqno
 + prev->
len
, seqno)) {

1256 
prev
->
len
 = (
u16_t
)(
seqno
 - prev->
tcphdr
->seqno);

1257 
	`pbuf_realloc
(
prev
->
p
, prev->
len
);

1265 if (
next
->next == 
NULL
 &&

1266 
	`TCP_SEQ_GT
(
seqno
, 
next
->
tcphdr
->seqno)) {

1267 
next
->next = 
	`tcp_seg_copy
(&
inseg
);

1268 if (
next
->next != 
NULL
) {

1269 if (
	`TCP_SEQ_GT
(
next
->
tcphdr
->
seqno
 + next->
len
, seqno)) {

1271 
next
->
len
 = (
u16_t
)(
seqno
 - next->
tcphdr
->seqno);

1272 
	`pbuf_realloc
(
next
->
p
, next->
len
);

1278 
prev
 = 
next
;

1285 
	`tcp_ack_now
(
pcb
);

1292 if(!
	`TCP_SEQ_BETWEEN
(
seqno
, 
pcb
->
rcv_nxt
, pcb->rcv_nxt + pcb->
rcv_wnd
-1)){

1293 
	`tcp_ack_now
(
pcb
);

1296 return 
accepted_inseq
;

1297 
	}
}

1309 
	$tcp_parseopt
(struct 
tcp_pcb
 *
pcb
)

1311 
u8_t
 
c
;

1312 
u8_t
 *
opts
, 
opt
;

1313 
u16_t
 
mss
;

1315 
opts
 = (
u8_t
 *)
tcphdr
 + 
TCP_HLEN
;

1318 if(
	`TCPH_HDRLEN
(
tcphdr
) > 0x5) {

1319 for(
c
 = 0; c < (
	`TCPH_HDRLEN
(
tcphdr
) - 5) << 2 ;) {

1320 
opt
 = 
opts
[
c
];

1321 if (
opt
 == 0x00) {

1324 } else if (
opt
 == 0x01) {

1325 ++
c
;

1327 } else if (
opt
 == 0x02 &&

1328 
opts
[
c
 + 1] == 0x04) {

1330 
mss
 = (
opts
[
c
 + 2] << 8) | opts[c + 3];

1332 
pcb
->
mss
 = ((mss > 
TCP_MSS
) || (mss == 0)) ? TCP_MSS : mss;

1337 if (
opts
[
c
 + 1] == 0) {

1344 
c
 += 
opts
[c + 1];

1348 
	}
}

	@/root/Robux/net/lwip/core/tcp_out.c

41 #include 
	~"lwip/opt.h
"

43 #if 
LWIP_TCP


45 #include 
	~"lwip/tcp.h
"

46 #include 
	~"lwip/def.h
"

47 #include 
	~"lwip/mem.h
"

48 #include 
	~"lwip/memp.h
"

49 #include 
	~"lwip/sys.h
"

50 #include 
	~"lwip/ip_addr.h
"

51 #include 
	~"lwip/netif.h
"

52 #include 
	~"lwip/inet.h
"

53 #include 
	~"lwip/inet_chksum.h
"

54 #include 
	~"lwip/stats.h
"

55 #include 
	~"lwip/snmp.h
"

57 #include 
	~<string.h
>

60 static void 
tcp_output_segment
(struct 
tcp_seg
 *
seg
, struct 
tcp_pcb
 *
pcb
);

69 
err_t


70 
	$tcp_send_ctrl
(struct 
tcp_pcb
 *
pcb
, 
u8_t
 
flags
)

73 return 
	`tcp_enqueue
(
pcb
, 
NULL
, 0, 
flags
, 
TCP_WRITE_FLAG_COPY
, NULL, 0);

74 
	}
}

94 
err_t


95 
	$tcp_write
(struct 
tcp_pcb
 *
pcb
, const void *
data
, 
u16_t
 
len
, 
u8_t
 
apiflags
)

97 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
, ("tcp_write(pcb=%p, data=%p, len=%"
U16_F
", apiflags=%"U16_F")\n", (void *)
pcb
,

98 
data
, 
len
, (
u16_t
)
apiflags
));

100 if (
pcb
->
state
 == 
ESTABLISHED
 ||

101 
pcb
->
state
 == 
CLOSE_WAIT
 ||

102 
pcb
->
state
 == 
SYN_SENT
 ||

103 
pcb
->
state
 == 
SYN_RCVD
) {

104 if (
len
 > 0) {

105 return 
	`tcp_enqueue
(
pcb
, (void *)
data
, 
len
, 0, 
apiflags
, 
NULL
, 0);

107 return 
ERR_OK
;

109 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 
LWIP_DBG_STATE
 | 3, ("tcp_write() called in invalid state\n"));

110 return 
ERR_CONN
;

112 
	}
}

129 
err_t


130 
	$tcp_enqueue
(struct 
tcp_pcb
 *
pcb
, void *
arg
, 
u16_t
 
len
,

131 
u8_t
 
flags
, u8_t 
apiflags
,

132 
u8_t
 *
optdata
, u8_t 
optlen
)

134 struct 
pbuf
 *
p
;

135 struct 
tcp_seg
 *
seg
, *
useg
, *
queue
;

136 
u32_t
 
seqno
;

137 
u16_t
 
left
, 
seglen
;

138 void *
ptr
;

139 
u16_t
 
queuelen
;

141 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
, ("tcp_enqueue(pcb=%p, arg=%p, len=%"
U16_F
", flags=%"
X16_F
", apiflags=%"U16_F")\n",

142 (void *)
pcb
, 
arg
, 
len
, (
u16_t
)
flags
, (u16_t)
apiflags
));

143 
	`LWIP_ERROR
("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",

144 ((
len
 == 0) || (
optlen
 == 0)), return 
ERR_ARG
;);

145 
	`LWIP_ERROR
("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",

146 ((
arg
 == 
NULL
) || (
optdata
 == NULL)), return 
ERR_ARG
;);

148 if (
len
 > 
pcb
->
snd_buf
) {

149 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 3, ("tcp_enqueue: too much data (len=%"
U16_F
" > snd_buf=%"U16_F")\n", 
len
, 
pcb
->
snd_buf
));

150 
pcb
->
flags
 |= 
TF_NAGLEMEMERR
;

151 return 
ERR_MEM
;

153 
left
 = 
len
;

154 
ptr
 = 
arg
;

158 
seqno
 = 
pcb
->
snd_lbb
;

160 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
, ("tcp_enqueue: queuelen: %"
U16_F
"\n", (
u16_t
)
pcb
->
snd_queuelen
));

164 
queuelen
 = 
pcb
->
snd_queuelen
;

166 if ((
queuelen
 >= 
TCP_SND_QUEUELEN
) || (queuelen > 
TCP_SNDQUEUELEN_OVERFLOW
)) {

167 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 3, ("tcp_enqueue: too long queue %"
U16_F
" (max %"U16_F")\n", 
queuelen
, 
TCP_SND_QUEUELEN
));

168 
	`TCP_STATS_INC
(
tcp
.
memerr
);

169 
pcb
->
flags
 |= 
TF_NAGLEMEMERR
;

170 return 
ERR_MEM
;

172 if (
queuelen
 != 0) {

173 
	`LWIP_ASSERT
("tcp_enqueue: pbufs on queue => at least one queue non-empty",

174 
pcb
->
unacked
 != 
NULL
 || pcb->
unsent
 != NULL);

176 
	`LWIP_ASSERT
("tcp_enqueue: no pbufs on queue => both queues empty",

177 
pcb
->
unacked
 == 
NULL
 && pcb->
unsent
 == NULL);

182 
useg
 = 
queue
 = 
seg
 = 
NULL
;

183 
seglen
 = 0;

184 while (
queue
 == 
NULL
 || 
left
 > 0) {

188 
seglen
 = 
left
 > 
pcb
->
mss
? pcb->mss: left;

191 
seg
 = 
	`memp_malloc
(
MEMP_TCP_SEG
);

192 if (
seg
 == 
NULL
) {

193 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));

194 goto 
memerr
;

196 
seg
->
next
 = 
NULL
;

197 
seg
->
p
 = 
NULL
;

200 if (
queue
 == 
NULL
) {

201 
queue
 = 
seg
;

206 
	`LWIP_ASSERT
("useg != NULL", 
useg
 != 
NULL
);

207 
useg
->
next
 = 
seg
;

210 
useg
 = 
seg
;

218 if (
optdata
 != 
NULL
) {

219 if ((
seg
->
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
optlen
, 
PBUF_RAM
)) == 
NULL
) {

220 goto 
memerr
;

222 
	`LWIP_ASSERT
("check that first pbuf can hold optlen",

223 (
seg
->
p
->
len
 >= 
optlen
));

224 
queuelen
 += 
	`pbuf_clen
(
seg
->
p
);

225 
seg
->
dataptr
 = seg->
p
->
payload
;

228 else if (
apiflags
 & 
TCP_WRITE_FLAG_COPY
) {

229 if ((
seg
->
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
seglen
, 
PBUF_RAM
)) == 
NULL
) {

230 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"
U16_F
"\n", 
seglen
));

231 goto 
memerr
;

233 
	`LWIP_ASSERT
("check that first pbuf can hold the complete seglen",

234 (
seg
->
p
->
len
 >= 
seglen
));

235 
queuelen
 += 
	`pbuf_clen
(
seg
->
p
);

236 if (
arg
 != 
NULL
) {

237 
	`MEMCPY
(
seg
->
p
->
payload
, 
ptr
, 
seglen
);

239 
seg
->
dataptr
 = seg->
p
->
payload
;

248 if ((
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 
seglen
, 
PBUF_ROM
)) == 
NULL
) {

249 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));

250 goto 
memerr
;

252 ++
queuelen
;

254 
p
->
payload
 = 
ptr
;

255 
seg
->
dataptr
 = 
ptr
;

258 if ((
seg
->
p
 = 
	`pbuf_alloc
(
PBUF_TRANSPORT
, 0, 
PBUF_RAM
)) == 
NULL
) {

261 
	`pbuf_free
(
p
);

262 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));

263 goto 
memerr
;

265 
queuelen
 += 
	`pbuf_clen
(
seg
->
p
);

268 
	`pbuf_cat
(
seg
->
p
 , p );

269 
p
 = 
NULL
;

274 if ((
queuelen
 > 
TCP_SND_QUEUELEN
) || (queuelen > 
TCP_SNDQUEUELEN_OVERFLOW
)) {

275 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 2, ("tcp_enqueue: queue too long %"
U16_F
" (%"U16_F")\n", 
queuelen
, 
TCP_SND_QUEUELEN
));

276 goto 
memerr
;

279 
seg
->
len
 = 
seglen
;

282 if (
	`pbuf_header
(
seg
->
p
, 
TCP_HLEN
)) {

283 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));

284 
	`TCP_STATS_INC
(
tcp
.
err
);

285 goto 
memerr
;

287 
seg
->
tcphdr
 = seg->
p
->
payload
;

288 
seg
->
tcphdr
->
src
 = 
	`htons
(
pcb
->
local_port
);

289 
seg
->
tcphdr
->
dest
 = 
	`htons
(
pcb
->
remote_port
);

290 
seg
->
tcphdr
->
seqno
 = 
	`htonl
(seqno);

291 
seg
->
tcphdr
->
urgp
 = 0;

292 
	`TCPH_FLAGS_SET
(
seg
->
tcphdr
, 
flags
);

296 if (
optdata
 == 
NULL
) {

297 
	`TCPH_HDRLEN_SET
(
seg
->
tcphdr
, 5);

300 
	`TCPH_HDRLEN_SET
(
seg
->
tcphdr
, (5 + 
optlen
 / 4));

304 
	`SMEMCPY
(
seg
->
dataptr
, 
optdata
, 
optlen
);

306 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 
LWIP_DBG_TRACE
, ("tcp_enqueue: queueing %"
U32_F
":%"U32_F" (0x%"
X16_F
")\n",

307 
	`ntohl
(
seg
->
tcphdr
->
seqno
),

308 
	`ntohl
(
seg
->
tcphdr
->
seqno
) + 
	`TCP_TCPLEN
(seg),

309 (
u16_t
)
flags
));

311 
left
 -= 
seglen
;

312 
seqno
 += 
seglen
;

313 
ptr
 = (void *)((
u8_t
 *)ptr + 
seglen
);

319 if (
pcb
->
unsent
 == 
NULL
) {

320 
useg
 = 
NULL
;

323 for (
useg
 = 
pcb
->
unsent
; useg->
next
 != 
NULL
; useg = useg->next);

329 if (
useg
 != 
NULL
 &&

330 
	`TCP_TCPLEN
(
useg
) != 0 &&

331 !(
	`TCPH_FLAGS
(
useg
->
tcphdr
) & (
TCP_SYN
 | 
TCP_FIN
)) &&

332 !(
flags
 & (
TCP_SYN
 | 
TCP_FIN
)) &&

334 
useg
->
len
 + 
queue
->len <= 
pcb
->
mss
) {

336 if(
	`pbuf_header
(
queue
->
p
, -
TCP_HLEN
)) {

338 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

339 
	`TCP_STATS_INC
(
tcp
.
err
);

340 goto 
memerr
;

342 
	`pbuf_cat
(
useg
->
p
, 
queue
->p);

343 
useg
->
len
 += 
queue
->len;

344 
useg
->
next
 = 
queue
->next;

346 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
, ("tcp_enqueue: chaining segments, new len %"
U16_F
"\n", 
useg
->
len
));

347 if (
seg
 == 
queue
) {

348 
seg
 = 
NULL
;

350 
	`memp_free
(
MEMP_TCP_SEG
, 
queue
);

354 if (
useg
 == 
NULL
) {

356 
pcb
->
unsent
 = 
queue
;

360 
useg
->
next
 = 
queue
;

363 if ((
flags
 & 
TCP_SYN
) || (flags & 
TCP_FIN
)) {

364 ++
len
;

366 if (
flags
 & 
TCP_FIN
) {

367 
pcb
->
flags
 |= 
TF_FIN
;

369 
pcb
->
snd_lbb
 += 
len
;

371 
pcb
->
snd_buf
 -= 
len
;

374 
pcb
->
snd_queuelen
 = 
queuelen
;

375 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
, ("tcp_enqueue: %"
S16_F
" (after enqueued)\n", 
pcb
->
snd_queuelen
));

376 if (
pcb
->
snd_queuelen
 != 0) {

377 
	`LWIP_ASSERT
("tcp_enqueue: valid queue length",

378 
pcb
->
unacked
 != 
NULL
 || pcb->
unsent
 != NULL);

383 if (
seg
 != 
NULL
 && 
seglen
 > 0 && seg->
tcphdr
 != NULL && ((
apiflags
 & 
TCP_WRITE_FLAG_MORE
)==0)) {

384 
	`TCPH_SET_FLAG
(
seg
->
tcphdr
, 
TCP_PSH
);

387 return 
ERR_OK
;

388 
memerr
:

389 
pcb
->
flags
 |= 
TF_NAGLEMEMERR
;

390 
	`TCP_STATS_INC
(
tcp
.
memerr
);

392 if (
queue
 != 
NULL
) {

393 
	`tcp_segs_free
(
queue
);

395 if (
pcb
->
snd_queuelen
 != 0) {

396 
	`LWIP_ASSERT
("tcp_enqueue: valid queue length", 
pcb
->
unacked
 != 
NULL
 ||

397 
pcb
->
unsent
 != 
NULL
);

399 
	`LWIP_DEBUGF
(
TCP_QLEN_DEBUG
 | 
LWIP_DBG_STATE
, ("tcp_enqueue: %"
S16_F
" (with mem err)\n", 
pcb
->
snd_queuelen
));

400 return 
ERR_MEM
;

401 
	}
}

410 
err_t


411 
	$tcp_output
(struct 
tcp_pcb
 *
pcb
)

413 struct 
pbuf
 *
p
;

414 struct 
tcp_hdr
 *
tcphdr
;

415 struct 
tcp_seg
 *
seg
, *
useg
;

416 
u32_t
 
wnd
;

417 #if 
TCP_CWND_DEBUG


418 
s16_t
 
i
 = 0;

425 if (
tcp_input_pcb
 == 
pcb
) {

426 return 
ERR_OK
;

429 
wnd
 = 
	`LWIP_MIN
(
pcb
->
snd_wnd
, pcb->
cwnd
);

431 
seg
 = 
pcb
->
unsent
;

434 
useg
 = 
pcb
->
unacked
;

435 if (
useg
 != 
NULL
) {

436 for (; 
useg
->
next
 != 
NULL
; useg = useg->next);

445 if (
pcb
->
flags
 & 
TF_ACK_NOW
 &&

446 (
seg
 == 
NULL
 ||

447 
	`ntohl
(
seg
->
tcphdr
->
seqno
) - 
pcb
->
lastack
 + seg->
len
 > 
wnd
)) {

448 
p
 = 
	`pbuf_alloc
(
PBUF_IP
, 
TCP_HLEN
, 
PBUF_RAM
);

449 if (
p
 == 
NULL
) {

450 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
, ("tcp_output: (ACK) could not allocate pbuf\n"));

451 return 
ERR_BUF
;

453 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
, ("tcp_output: sending ACK for %"
U32_F
"\n", 
pcb
->
rcv_nxt
));

455 
pcb
->
flags
 &= ~(
TF_ACK_DELAY
 | 
TF_ACK_NOW
);

457 
tcphdr
 = 
p
->
payload
;

458 
tcphdr
->
src
 = 
	`htons
(
pcb
->
local_port
);

459 
tcphdr
->
dest
 = 
	`htons
(
pcb
->
remote_port
);

460 
tcphdr
->
seqno
 = 
	`htonl
(
pcb
->
snd_nxt
);

461 
tcphdr
->
ackno
 = 
	`htonl
(
pcb
->
rcv_nxt
);

462 
	`TCPH_FLAGS_SET
(
tcphdr
, 
TCP_ACK
);

463 
tcphdr
->
wnd
 = 
	`htons
(
pcb
->
rcv_ann_wnd
);

464 
tcphdr
->
urgp
 = 0;

465 
	`TCPH_HDRLEN_SET
(
tcphdr
, 5);

467 
tcphdr
->
chksum
 = 0;

468 #if 
CHECKSUM_GEN_TCP


469 
tcphdr
->
chksum
 = 
	`inet_chksum_pseudo
(
p
, &(
pcb
->
local_ip
), &(pcb->
remote_ip
),

470 
IP_PROTO_TCP
, 
p
->
tot_len
);

472 #if 
LWIP_NETIF_HWADDRHINT


474 struct 
netif
 *netif;

475 
netif
 = 
	`ip_route
(&
pcb
->
remote_ip
);

476 if(
netif
 != 
NULL
){

477 
netif
->
addr_hint
 = &(
pcb
->addr_hint);

478 
	`ip_output_if
(
p
, &(
pcb
->
local_ip
), &(pcb->
remote_ip
), pcb->
ttl
,

479 
pcb
->
tos
, 
IP_PROTO_TCP
, 
netif
);

480 
netif
->
addr_hint
 = 
NULL
;

484 
	`ip_output
(
p
, &(
pcb
->
local_ip
), &(pcb->
remote_ip
), pcb->
ttl
, pcb->
tos
,

485 
IP_PROTO_TCP
);

487 
	`pbuf_free
(
p
);

489 return 
ERR_OK
;

492 #if 
TCP_OUTPUT_DEBUG


493 if (
seg
 == 
NULL
) {

494 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
, ("tcp_output: nothing to send (%p)\n",

495 (void*)
pcb
->
unsent
));

498 #if 
TCP_CWND_DEBUG


499 if (
seg
 == 
NULL
) {

500 
	`LWIP_DEBUGF
(
TCP_CWND_DEBUG
, ("tcp_output: snd_wnd %"
U16_F


501 ", cwnd %"
U16_F
", wnd %"
U32_F


502 ", seg == NULL, ack %"
U32_F
"\n",

503 
pcb
->
snd_wnd
, pcb->
cwnd
, 
wnd
, pcb->
lastack
));

505 
	`LWIP_DEBUGF
(
TCP_CWND_DEBUG
,

506 ("tcp_output: snd_wnd %"
U16_F
", cwnd %"U16_F", wnd %"
U32_F


507 ", effwnd %"
U32_F
", seq %"U32_F", ack %"U32_F"\n",

508 
pcb
->
snd_wnd
, pcb->
cwnd
, 
wnd
,

509 
	`ntohl
(
seg
->
tcphdr
->
seqno
) - 
pcb
->
lastack
 + seg->
len
,

510 
	`ntohl
(
seg
->
tcphdr
->
seqno
), 
pcb
->
lastack
));

514 while (
seg
 != 
NULL
 &&

515 
	`ntohl
(
seg
->
tcphdr
->
seqno
) - 
pcb
->
lastack
 + seg->
len
 <= 
wnd
) {

516 
	`LWIP_ASSERT
("RST not expected here!",

517 (
	`TCPH_FLAGS
(
seg
->
tcphdr
) & 
TCP_RST
) == 0);

525 if((
	`tcp_do_output_nagle
(
pcb
) == 0) &&

526 ((
pcb
->
flags
 & (
TF_NAGLEMEMERR
 | 
TF_FIN
)) == 0)){

529 #if 
TCP_CWND_DEBUG


530 
	`LWIP_DEBUGF
(
TCP_CWND_DEBUG
, ("tcp_output: snd_wnd %"
U16_F
", cwnd %"U16_F", wnd %"
U32_F
", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"
S16_F
"\n",

531 
pcb
->
snd_wnd
, pcb->
cwnd
, 
wnd
,

532 
	`ntohl
(
seg
->
tcphdr
->
seqno
) + seg->
len
 -

533 
pcb
->
lastack
,

534 
	`ntohl
(
seg
->
tcphdr
->
seqno
), 
pcb
->
lastack
, 
i
));

535 ++
i
;

538 
pcb
->
unsent
 = 
seg
->
next
;

540 if (
pcb
->
state
 != 
SYN_SENT
) {

541 
	`TCPH_SET_FLAG
(
seg
->
tcphdr
, 
TCP_ACK
);

542 
pcb
->
flags
 &= ~(
TF_ACK_DELAY
 | 
TF_ACK_NOW
);

545 
	`tcp_output_segment
(
seg
, 
pcb
);

546 
pcb
->
snd_nxt
 = 
	`ntohl
(
seg
->
tcphdr
->
seqno
) + 
	`TCP_TCPLEN
(seg);

547 if (
	`TCP_SEQ_LT
(
pcb
->
snd_max
, pcb->
snd_nxt
)) {

548 
pcb
->
snd_max
 = pcb->
snd_nxt
;

551 if (
	`TCP_TCPLEN
(
seg
) > 0) {

552 
seg
->
next
 = 
NULL
;

554 if (
pcb
->
unacked
 == 
NULL
) {

555 
pcb
->
unacked
 = 
seg
;

556 
useg
 = 
seg
;

562 if (
	`TCP_SEQ_LT
(
	`ntohl
(
seg
->
tcphdr
->
seqno
), ntohl(
useg
->tcphdr->seqno))){

564 
seg
->
next
 = 
pcb
->
unacked
;

565 
pcb
->
unacked
 = 
seg
;

568 
useg
->
next
 = 
seg
;

569 
useg
 = useg->
next
;

574 
	`tcp_seg_free
(
seg
);

576 
seg
 = 
pcb
->
unsent
;

579 if (
seg
 != 
NULL
 && 
pcb
->
persist_backoff
 == 0 &&

580 
	`ntohl
(
seg
->
tcphdr
->
seqno
) - 
pcb
->
lastack
 + seg->
len
 > pcb->
snd_wnd
) {

582 
pcb
->
persist_cnt
 = 0;

583 
pcb
->
persist_backoff
 = 1;

586 
pcb
->
flags
 &= ~
TF_NAGLEMEMERR
;

587 return 
ERR_OK
;

588 
	}
}

597 
	$tcp_output_segment
(struct 
tcp_seg
 *
seg
, struct 
tcp_pcb
 *
pcb
)

599 
u16_t
 
len
;

600 struct 
netif
 *netif;

603 
	`snmp_inc_tcpoutsegs
();

607 
seg
->
tcphdr
->
ackno
 = 
	`htonl
(
pcb
->
rcv_nxt
);

610 
seg
->
tcphdr
->
wnd
 = 
	`htons
(
pcb
->
rcv_ann_wnd
);

614 if (
	`ip_addr_isany
(&(
pcb
->
local_ip
))) {

615 
netif
 = 
	`ip_route
(&(
pcb
->
remote_ip
));

616 if (
netif
 == 
NULL
) {

619 
	`ip_addr_set
(&(
pcb
->
local_ip
), &(
netif
->
ip_addr
));

623 if(
pcb
->
rtime
 == -1)

624 
pcb
->
rtime
 = 0;

626 if (
pcb
->
rttest
 == 0) {

627 
pcb
->
rttest
 = 
tcp_ticks
;

628 
pcb
->
rtseq
 = 
	`ntohl
(
seg
->
tcphdr
->
seqno
);

630 
	`LWIP_DEBUGF
(
TCP_RTO_DEBUG
, ("tcp_output_segment: rtseq %"
U32_F
"\n", 
pcb
->
rtseq
));

632 
	`LWIP_DEBUGF
(
TCP_OUTPUT_DEBUG
, ("tcp_output_segment: %"
U32_F
":%"U32_F"\n",

633 
	`htonl
(
seg
->
tcphdr
->
seqno
), htonl(seg->tcphdr->seqno) +

634 
seg
->
len
));

636 
len
 = (
u16_t
)((
u8_t
 *)
seg
->
tcphdr
 - (u8_t *)seg->
p
->
payload
);

638 
seg
->
p
->
len
 -= len;

639 
seg
->
p
->
tot_len
 -= 
len
;

641 
seg
->
p
->
payload
 = seg->
tcphdr
;

643 
seg
->
tcphdr
->
chksum
 = 0;

644 #if 
CHECKSUM_GEN_TCP


645 
seg
->
tcphdr
->
chksum
 = 
	`inet_chksum_pseudo
(seg->
p
,

646 &(
pcb
->
local_ip
),

647 &(
pcb
->
remote_ip
),

648 
IP_PROTO_TCP
, 
seg
->
p
->
tot_len
);

650 
	`TCP_STATS_INC
(
tcp
.
xmit
);

652 #if 
LWIP_NETIF_HWADDRHINT


654 struct 
netif
 *netif;

655 
netif
 = 
	`ip_route
(&
pcb
->
remote_ip
);

656 if(
netif
 != 
NULL
){

657 
netif
->
addr_hint
 = &(
pcb
->addr_hint);

658 
	`ip_output_if
(
seg
->
p
, &(
pcb
->
local_ip
), &(pcb->
remote_ip
), pcb->
ttl
,

659 
pcb
->
tos
, 
IP_PROTO_TCP
, 
netif
);

660 
netif
->
addr_hint
 = 
NULL
;

664 
	`ip_output
(
seg
->
p
, &(
pcb
->
local_ip
), &(pcb->
remote_ip
), pcb->
ttl
, pcb->
tos
,

665 
IP_PROTO_TCP
);

667 
	}
}

690 
	$tcp_rst
(
u32_t
 
seqno
, u32_t 
ackno
,

691 struct 
ip_addr
 *
local_ip
, struct ip_addr *
remote_ip
,

692 
u16_t
 
local_port
, u16_t 
remote_port
)

694 struct 
pbuf
 *
p
;

695 struct 
tcp_hdr
 *
tcphdr
;

696 
p
 = 
	`pbuf_alloc
(
PBUF_IP
, 
TCP_HLEN
, 
PBUF_RAM
);

697 if (
p
 == 
NULL
) {

698 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_rst: could not allocate memory for pbuf\n"));

701 
	`LWIP_ASSERT
("check that first pbuf can hold struct tcp_hdr",

702 (
p
->
len
 >= sizeof(struct 
tcp_hdr
)));

704 
tcphdr
 = 
p
->
payload
;

705 
tcphdr
->
src
 = 
	`htons
(
local_port
);

706 
tcphdr
->
dest
 = 
	`htons
(
remote_port
);

707 
tcphdr
->
seqno
 = 
	`htonl
(seqno);

708 
tcphdr
->
ackno
 = 
	`htonl
(ackno);

709 
	`TCPH_FLAGS_SET
(
tcphdr
, 
TCP_RST
 | 
TCP_ACK
);

710 
tcphdr
->
wnd
 = 
	`htons
(
TCP_WND
);

711 
tcphdr
->
urgp
 = 0;

712 
	`TCPH_HDRLEN_SET
(
tcphdr
, 5);

714 
tcphdr
->
chksum
 = 0;

715 #if 
CHECKSUM_GEN_TCP


716 
tcphdr
->
chksum
 = 
	`inet_chksum_pseudo
(
p
, 
local_ip
, 
remote_ip
,

717 
IP_PROTO_TCP
, 
p
->
tot_len
);

719 
	`TCP_STATS_INC
(
tcp
.
xmit
);

720 
	`snmp_inc_tcpoutrsts
();

722 
	`ip_output
(
p
, 
local_ip
, 
remote_ip
, 
TCP_TTL
, 0, 
IP_PROTO_TCP
);

723 
	`pbuf_free
(
p
);

724 
	`LWIP_DEBUGF
(
TCP_RST_DEBUG
, ("tcp_rst: seqno %"
U32_F
" ackno %"U32_F".\n", 
seqno
, 
ackno
));

725 
	}
}

735 
	$tcp_rexmit_rto
(struct 
tcp_pcb
 *
pcb
)

737 struct 
tcp_seg
 *
seg
;

739 if (
pcb
->
unacked
 == 
NULL
) {

744 for (
seg
 = 
pcb
->
unacked
; seg->
next
 != 
NULL
; seg = seg->next);

746 
seg
->
next
 = 
pcb
->
unsent
;

748 
pcb
->
unsent
 = pcb->
unacked
;

750 
pcb
->
unacked
 = 
NULL
;

752 
pcb
->
snd_nxt
 = 
	`ntohl
(pcb->
unsent
->
tcphdr
->
seqno
);

754 ++
pcb
->
nrtx
;

757 
pcb
->
rttest
 = 0;

760 
	`tcp_output
(
pcb
);

761 
	}
}

771 
	$tcp_rexmit
(struct 
tcp_pcb
 *
pcb
)

773 struct 
tcp_seg
 *
seg
;

775 if (
pcb
->
unacked
 == 
NULL
) {

780 
seg
 = 
pcb
->
unacked
->
next
;

781 
pcb
->
unacked
->
next
 = pcb->
unsent
;

782 
pcb
->
unsent
 = pcb->
unacked
;

783 
pcb
->
unacked
 = 
seg
;

785 
pcb
->
snd_nxt
 = 
	`ntohl
(pcb->
unsent
->
tcphdr
->
seqno
);

787 ++
pcb
->
nrtx
;

790 
pcb
->
rttest
 = 0;

793 
	`snmp_inc_tcpretranssegs
();

794 
	`tcp_output
(
pcb
);

795 
	}
}

806 
	$tcp_keepalive
(struct 
tcp_pcb
 *
pcb
)

808 struct 
pbuf
 *
p
;

809 struct 
tcp_hdr
 *
tcphdr
;

811 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_keepalive: sending KEEPALIVE probe to %"
U16_F
".%"U16_F".%"U16_F".%"U16_F"\n",

812 
	`ip4_addr1
(&
pcb
->
remote_ip
), 
	`ip4_addr2
(&pcb->remote_ip),

813 
	`ip4_addr3
(&
pcb
->
remote_ip
), 
	`ip4_addr4
(&pcb->remote_ip)));

815 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_keepalive: tcp_ticks %"
U32_F
" pcb->tmr %"U32_F" pcb->keep_cnt_sent %"
U16_F
"\n",

816 
tcp_ticks
, 
pcb
->
tmr
, pcb->
keep_cnt_sent
));

818 
p
 = 
	`pbuf_alloc
(
PBUF_IP
, 
TCP_HLEN
, 
PBUF_RAM
);

820 if(
p
 == 
NULL
) {

821 
	`LWIP_DEBUGF
(
TCP_DEBUG
,

825 
	`LWIP_ASSERT
("check that first pbuf can hold struct tcp_hdr",

826 (
p
->
len
 >= sizeof(struct 
tcp_hdr
)));

828 
tcphdr
 = 
p
->
payload
;

829 
tcphdr
->
src
 = 
	`htons
(
pcb
->
local_port
);

830 
tcphdr
->
dest
 = 
	`htons
(
pcb
->
remote_port
);

831 
tcphdr
->
seqno
 = 
	`htonl
(
pcb
->
snd_nxt
 - 1);

832 
tcphdr
->
ackno
 = 
	`htonl
(
pcb
->
rcv_nxt
);

833 
	`TCPH_FLAGS_SET
(
tcphdr
, 0);

834 
tcphdr
->
wnd
 = 
	`htons
(
pcb
->
rcv_ann_wnd
);

835 
tcphdr
->
urgp
 = 0;

836 
	`TCPH_HDRLEN_SET
(
tcphdr
, 5);

838 
tcphdr
->
chksum
 = 0;

839 #if 
CHECKSUM_GEN_TCP


840 
tcphdr
->
chksum
 = 
	`inet_chksum_pseudo
(
p
, &
pcb
->
local_ip
, &pcb->
remote_ip
,

841 
IP_PROTO_TCP
, 
p
->
tot_len
);

843 
	`TCP_STATS_INC
(
tcp
.
xmit
);

846 #if 
LWIP_NETIF_HWADDRHINT


848 struct 
netif
 *netif;

849 
netif
 = 
	`ip_route
(&
pcb
->
remote_ip
);

850 if(
netif
 != 
NULL
){

851 
netif
->
addr_hint
 = &(
pcb
->addr_hint);

852 
	`ip_output_if
(
p
, &(
pcb
->
local_ip
), &(pcb->
remote_ip
), pcb->
ttl
,

853 0, 
IP_PROTO_TCP
, 
netif
);

854 
netif
->
addr_hint
 = 
NULL
;

858 
	`ip_output
(
p
, &
pcb
->
local_ip
, &pcb->
remote_ip
, pcb->
ttl
, 0, 
IP_PROTO_TCP
);

861 
	`pbuf_free
(
p
);

863 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_keepalive: seqno %"
U32_F
" ackno %"U32_F".\n",

864 
pcb
->
snd_nxt
 - 1, pcb->
rcv_nxt
));

865 
	}
}

877 
	$tcp_zero_window_probe
(struct 
tcp_pcb
 *
pcb
)

879 struct 
pbuf
 *
p
;

880 struct 
tcp_hdr
 *
tcphdr
;

881 struct 
tcp_seg
 *
seg
;

883 
	`LWIP_DEBUGF
(
TCP_DEBUG
,

885 
U16_F
".%"U16_F".%"U16_F".%"U16_F"\n",

886 
	`ip4_addr1
(&
pcb
->
remote_ip
), 
	`ip4_addr2
(&pcb->remote_ip),

887 
	`ip4_addr3
(&
pcb
->
remote_ip
), 
	`ip4_addr4
(&pcb->remote_ip)));

889 
	`LWIP_DEBUGF
(
TCP_DEBUG
,

890 ("tcp_zero_window_probe: tcp_ticks %"
U32_F


891 " pcb->tmr %"
U32_F
" pcb->keep_cnt_sent %"
U16_F
"\n",

892 
tcp_ticks
, 
pcb
->
tmr
, pcb->
keep_cnt_sent
));

894 
seg
 = 
pcb
->
unacked
;

896 if(
seg
 == 
NULL
)

897 
seg
 = 
pcb
->
unsent
;

899 if(
seg
 == 
NULL
)

902 
p
 = 
	`pbuf_alloc
(
PBUF_IP
, 
TCP_HLEN
 + 1, 
PBUF_RAM
);

904 if(
p
 == 
NULL
) {

905 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_zero_window_probe: no memory for pbuf\n"));

908 
	`LWIP_ASSERT
("check that first pbuf can hold struct tcp_hdr",

909 (
p
->
len
 >= sizeof(struct 
tcp_hdr
)));

911 
tcphdr
 = 
p
->
payload
;

912 
tcphdr
->
src
 = 
	`htons
(
pcb
->
local_port
);

913 
tcphdr
->
dest
 = 
	`htons
(
pcb
->
remote_port
);

914 
tcphdr
->
seqno
 = 
seg
->tcphdr->seqno;

915 
tcphdr
->
ackno
 = 
	`htonl
(
pcb
->
rcv_nxt
);

916 
	`TCPH_FLAGS_SET
(
tcphdr
, 0);

917 
tcphdr
->
wnd
 = 
	`htons
(
pcb
->
rcv_ann_wnd
);

918 
tcphdr
->
urgp
 = 0;

919 
	`TCPH_HDRLEN_SET
(
tcphdr
, 5);

922 *((char *)
p
->
payload
 + sizeof(struct 
tcp_hdr
)) = *(char *)
seg
->
dataptr
;

924 
tcphdr
->
chksum
 = 0;

925 #if 
CHECKSUM_GEN_TCP


926 
tcphdr
->
chksum
 = 
	`inet_chksum_pseudo
(
p
, &
pcb
->
local_ip
, &pcb->
remote_ip
,

927 
IP_PROTO_TCP
, 
p
->
tot_len
);

929 
	`TCP_STATS_INC
(
tcp
.
xmit
);

932 #if 
LWIP_NETIF_HWADDRHINT


934 struct 
netif
 *netif;

935 
netif
 = 
	`ip_route
(&
pcb
->
remote_ip
);

936 if(
netif
 != 
NULL
){

937 
netif
->
addr_hint
 = &(
pcb
->addr_hint);

938 
	`ip_output_if
(
p
, &(
pcb
->
local_ip
), &(pcb->
remote_ip
), pcb->
ttl
,

939 0, 
IP_PROTO_TCP
, 
netif
);

940 
netif
->
addr_hint
 = 
NULL
;

944 
	`ip_output
(
p
, &
pcb
->
local_ip
, &pcb->
remote_ip
, pcb->
ttl
, 0, 
IP_PROTO_TCP
);

947 
	`pbuf_free
(
p
);

949 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("tcp_zero_window_probe: seqno %"
U32_F


950 " ackno %"
U32_F
".\n",

951 
pcb
->
snd_nxt
 - 1, pcb->
rcv_nxt
));

952 
	}
}

	@/root/Robux/net/lwip/core/udp.c

49 #include 
	~"lwip/opt.h
"

51 #if 
LWIP_UDP


53 #include 
	~"lwip/udp.h
"

54 #include 
	~"lwip/def.h
"

55 #include 
	~"lwip/memp.h
"

56 #include 
	~"lwip/inet.h
"

57 #include 
	~"lwip/inet_chksum.h
"

58 #include 
	~"lwip/ip_addr.h
"

59 #include 
	~"lwip/netif.h
"

60 #include 
	~"lwip/icmp.h
"

61 #include 
	~"lwip/stats.h
"

62 #include 
	~"lwip/snmp.h
"

63 #include 
	~"arch/perf.h
"

64 #include 
	~"lwip/dhcp.h
"

66 #include 
	~<string.h
>

70 struct 
udp_pcb
 *
	gudp_pcbs
;

85 
	$udp_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
)

87 struct 
udp_hdr
 *
udphdr
;

88 struct 
udp_pcb
 *
pcb
, *
prev
;

89 struct 
udp_pcb
 *
uncon_pcb
;

90 struct 
ip_hdr
 *
iphdr
;

91 
u16_t
 
src
, 
dest
;

92 
u8_t
 
local_match
;

94 
PERF_START
;

96 
	`UDP_STATS_INC
(
udp
.
recv
);

98 
iphdr
 = 
p
->
payload
;

102 if (
p
->
tot_len
 < (
	`IPH_HL
(
iphdr
) * 4 + 
UDP_HLEN
) || 
	`pbuf_header
(p, -(
s16_t
)(IPH_HL(iphdr) * 4))) {

104 
	`LWIP_DEBUGF
(
UDP_DEBUG
,

105 ("udp_input: short UDP datagram (%"
U16_F
" bytes) discarded\n", 
p
->
tot_len
));

106 
	`UDP_STATS_INC
(
udp
.
lenerr
);

107 
	`UDP_STATS_INC
(
udp
.
drop
);

108 
	`snmp_inc_udpinerrors
();

109 
	`pbuf_free
(
p
);

110 goto 
end
;

113 
udphdr
 = (struct 
udp_hdr
 *)
p
->
payload
;

115 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_input: received datagram of length %"
U16_F
"\n", 
p
->
tot_len
));

118 
src
 = 
	`ntohs
(
udphdr
->src);

119 
dest
 = 
	`ntohs
(
udphdr
->dest);

121 
	`udp_debug_print
(
udphdr
);

124 
	`LWIP_DEBUGF
(
UDP_DEBUG
,

125 ("udp (%"
U16_F
".%"U16_F".%"U16_F".%"U16_F", %"U16_F") <-- "

126 "(%"
U16_F
".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",

127 
	`ip4_addr1
(&
iphdr
->
dest
), 
	`ip4_addr2
(&iphdr->dest),

128 
	`ip4_addr3
(&
iphdr
->
dest
), 
	`ip4_addr4
(&iphdr->dest), 
	`ntohs
(
udphdr
->dest),

129 
	`ip4_addr1
(&
iphdr
->
src
), 
	`ip4_addr2
(&iphdr->src),

130 
	`ip4_addr3
(&
iphdr
->
src
), 
	`ip4_addr4
(&iphdr->src), 
	`ntohs
(
udphdr
->src)));

132 #if 
LWIP_DHCP


133 
pcb
 = 
NULL
;

136 if (
dest
 == 
DHCP_CLIENT_PORT
) {

138 if (
src
 == 
DHCP_SERVER_PORT
) {

139 if ((
inp
->
dhcp
 != 
NULL
) && (inp->dhcp->
pcb
 != NULL)) {

143 if ((
	`ip_addr_isany
(&
inp
->
dhcp
->
pcb
->
remote_ip
) ||

144 
	`ip_addr_cmp
(&(
inp
->
dhcp
->
pcb
->
remote_ip
), &(
iphdr
->
src
)))) {

145 
pcb
 = 
inp
->
dhcp
->pcb;

152 
prev
 = 
NULL
;

153 
local_match
 = 0;

154 
uncon_pcb
 = 
NULL
;

159 for (
pcb
 = 
udp_pcbs
; pcb != 
NULL
; pcb = pcb->
next
) {

160 
local_match
 = 0;

162 
	`LWIP_DEBUGF
(
UDP_DEBUG
,

163 ("pcb (%"
U16_F
".%"U16_F".%"U16_F".%"U16_F", %"U16_F") --- "

164 "(%"
U16_F
".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",

165 
	`ip4_addr1
(&
pcb
->
local_ip
), 
	`ip4_addr2
(&pcb->local_ip),

166 
	`ip4_addr3
(&
pcb
->
local_ip
), 
	`ip4_addr4
(&pcb->local_ip), pcb->
local_port
,

167 
	`ip4_addr1
(&
pcb
->
remote_ip
), 
	`ip4_addr2
(&pcb->remote_ip),

168 
	`ip4_addr3
(&
pcb
->
remote_ip
), 
	`ip4_addr4
(&pcb->remote_ip), pcb->
remote_port
));

171 if ((
pcb
->
local_port
 == 
dest
) &&

172 (
	`ip_addr_isany
(&
pcb
->
local_ip
) ||

173 
	`ip_addr_cmp
(&(
pcb
->
local_ip
), &(
iphdr
->
dest
)) ||

174 #if 
LWIP_IGMP


175 
	`ip_addr_ismulticast
(&(
iphdr
->
dest
)) ||

177 
	`ip_addr_isbroadcast
(&(
iphdr
->
dest
), 
inp
))) {

178 
local_match
 = 1;

179 if ((
uncon_pcb
 == 
NULL
) &&

180 ((
pcb
->
flags
 & 
UDP_FLAGS_CONNECTED
) == 0)) {

182 
uncon_pcb
 = 
pcb
;

186 if ((
local_match
 != 0) &&

187 (
pcb
->
remote_port
 == 
src
) &&

188 (
	`ip_addr_isany
(&
pcb
->
remote_ip
) ||

189 
	`ip_addr_cmp
(&(
pcb
->
remote_ip
), &(
iphdr
->
src
)))) {

191 if (
prev
 != 
NULL
) {

194 
prev
->
next
 = 
pcb
->next;

195 
pcb
->
next
 = 
udp_pcbs
;

196 
udp_pcbs
 = 
pcb
;

198 
	`UDP_STATS_INC
(
udp
.
cachehit
);

202 
prev
 = 
pcb
;

205 if (
pcb
 == 
NULL
) {

206 
pcb
 = 
uncon_pcb
;

211 if (
pcb
 != 
NULL
 || 
	`ip_addr_cmp
(&
inp
->
ip_addr
, &
iphdr
->
dest
)) {

212 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
, ("udp_input: calculating checksum\n"));

213 #if 
LWIP_UDPLITE


214 if (
	`IPH_PROTO
(
iphdr
) == 
IP_PROTO_UDPLITE
) {

216 #if 
CHECKSUM_CHECK_UDP


217 
u16_t
 
chklen
 = 
	`ntohs
(
udphdr
->
len
);

218 if (
chklen
 < sizeof(struct 
udp_hdr
)) {

219 if (
chklen
 == 0) {

222 
chklen
 = 
p
->
tot_len
;

226 
	`UDP_STATS_INC
(
udp
.
chkerr
);

227 
	`UDP_STATS_INC
(
udp
.
drop
);

228 
	`snmp_inc_udpinerrors
();

229 
	`pbuf_free
(
p
);

230 goto 
end
;

233 if (
	`inet_chksum_pseudo_partial
(
p
, (struct 
ip_addr
 *)&(
iphdr
->
src
),

234 (struct 
ip_addr
 *)&(
iphdr
->
dest
),

235 
IP_PROTO_UDPLITE
, 
p
->
tot_len
, 
chklen
) != 0) {

236 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 2,

238 
	`UDP_STATS_INC
(
udp
.
chkerr
);

239 
	`UDP_STATS_INC
(
udp
.
drop
);

240 
	`snmp_inc_udpinerrors
();

241 
	`pbuf_free
(
p
);

242 goto 
end
;

248 #if 
CHECKSUM_CHECK_UDP


249 if (
udphdr
->
chksum
 != 0) {

250 if (
	`inet_chksum_pseudo
(
p
, (struct 
ip_addr
 *)&(
iphdr
->
src
),

251 (struct 
ip_addr
 *)&(
iphdr
->
dest
),

252 
IP_PROTO_UDP
, 
p
->
tot_len
) != 0) {

253 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 2,

255 
	`UDP_STATS_INC
(
udp
.
chkerr
);

256 
	`UDP_STATS_INC
(
udp
.
drop
);

257 
	`snmp_inc_udpinerrors
();

258 
	`pbuf_free
(
p
);

259 goto 
end
;

264 if(
	`pbuf_header
(
p
, -
UDP_HLEN
)) {

266 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

267 
	`UDP_STATS_INC
(
udp
.
drop
);

268 
	`snmp_inc_udpinerrors
();

269 
	`pbuf_free
(
p
);

270 goto 
end
;

272 if (
pcb
 != 
NULL
) {

273 
	`snmp_inc_udpindatagrams
();

275 if (
pcb
->
recv
 != 
NULL
) {

277 
pcb
->
	`recv
(pcb->
recv_arg
, pcb, 
p
, &(
iphdr
->
src
), src);

280 
	`pbuf_free
(
p
);

281 goto 
end
;

284 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
, ("udp_input: not for us.\n"));

286 #if 
LWIP_ICMP


289 if (!
	`ip_addr_isbroadcast
(&
iphdr
->
dest
, 
inp
) &&

290 !
	`ip_addr_ismulticast
(&
iphdr
->
dest
)) {

292 
	`pbuf_header
(
p
, (
	`IPH_HL
(
iphdr
) * 4) + 
UDP_HLEN
);

293 
	`LWIP_ASSERT
("p->payload == iphdr", (
p
->
payload
 == 
iphdr
));

294 
	`icmp_dest_unreach
(
p
, 
ICMP_DUR_PORT
);

297 
	`UDP_STATS_INC
(
udp
.
proterr
);

298 
	`UDP_STATS_INC
(
udp
.
drop
);

299 
	`snmp_inc_udpnoports
();

300 
	`pbuf_free
(
p
);

303 
	`pbuf_free
(
p
);

305 
end
:

306 
	`PERF_STOP
("udp_input");

307 
	}
}

327 
err_t


328 
	$udp_send
(struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
)

331 return 
	`udp_sendto
(
pcb
, 
p
, &pcb->
remote_ip
, pcb->
remote_port
);

332 
	}
}

351 
err_t


352 
	$udp_sendto
(struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
,

353 struct 
ip_addr
 *
dst_ip
, 
u16_t
 
dst_port
)

355 struct 
netif
 *netif;

357 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("udp_send\n"));

360 #if 
LWIP_IGMP


361 
netif
 = 
	`ip_route
((
	`ip_addr_ismulticast
(
dst_ip
))?(&(
pcb
->
multicast_ip
)):(dst_ip));

363 
netif
 = 
	`ip_route
(
dst_ip
);

367 if (
netif
 == 
NULL
) {

368 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 1, ("udp_send: No route to 0x%"
X32_F
"\n", 
dst_ip
->
addr
));

369 
	`UDP_STATS_INC
(
udp
.
rterr
);

370 return 
ERR_RTE
;

372 return 
	`udp_sendto_if
(
pcb
, 
p
, 
dst_ip
, 
dst_port
, 
netif
);

373 
	}
}

394 
err_t


395 
	$udp_sendto_if
(struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
,

396 struct 
ip_addr
 *
dst_ip
, 
u16_t
 
dst_port
, struct 
netif
 *netif)

398 struct 
udp_hdr
 *
udphdr
;

399 struct 
ip_addr
 *
src_ip
;

400 
err_t
 
err
;

401 struct 
pbuf
 *
q
;

404 if (
pcb
->
local_port
 == 0) {

405 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("udp_send: not yet bound to a port, binding now\n"));

406 
err
 = 
	`udp_bind
(
pcb
, &pcb->
local_ip
, pcb->
local_port
);

407 if (
err
 != 
ERR_OK
) {

408 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("udp_send: forced port bind failed\n"));

409 return 
err
;

414 if (
	`pbuf_header
(
p
, 
UDP_HLEN
)) {

416 
q
 = 
	`pbuf_alloc
(
PBUF_IP
, 
UDP_HLEN
, 
PBUF_RAM
);

418 if (
q
 == 
NULL
) {

419 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("udp_send: could not allocate header\n"));

420 return 
ERR_MEM
;

423 
	`pbuf_chain
(
q
, 
p
);

425 
	`LWIP_DEBUGF
(
UDP_DEBUG
,

426 ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)
q
, (void *)
p
));

430 
q
 = 
p
;

431 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: added header in given pbuf %p\n", (void *)
p
));

433 
	`LWIP_ASSERT
("check that first pbuf can hold struct udp_hdr",

434 (
q
->
len
 >= sizeof(struct 
udp_hdr
)));

436 
udphdr
 = 
q
->
payload
;

437 
udphdr
->
src
 = 
	`htons
(
pcb
->
local_port
);

438 
udphdr
->
dest
 = 
	`htons
(
dst_port
);

440 
udphdr
->
chksum
 = 0x0000;

443 if (
	`ip_addr_isany
(&
pcb
->
local_ip
)) {

445 
src_ip
 = &(
netif
->
ip_addr
);

449 if (!
	`ip_addr_cmp
(&(
pcb
->
local_ip
), &(
netif
->
ip_addr
))) {

451 if (
q
 != 
p
) {

453 
	`pbuf_free
(
q
);

454 
q
 = 
NULL
;

457 return 
ERR_VAL
;

460 
src_ip
 = &(
pcb
->
local_ip
);

463 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: sending datagram of length %"
U16_F
"\n", 
q
->
tot_len
));

465 #if 
LWIP_UDPLITE


467 if (
pcb
->
flags
 & 
UDP_FLAGS_UDPLITE
) {

468 
u16_t
 
chklen
, 
chklen_hdr
;

469 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: UDP LITE packet length %"
U16_F
"\n", 
q
->
tot_len
));

471 
chklen_hdr
 = 
chklen
 = 
pcb
->
chksum_len_tx
;

472 if ((
chklen
 < sizeof(struct 
udp_hdr
)) || (chklen > 
q
->
tot_len
)) {

473 if (
chklen
 != 0) {

474 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"
U16_F
"\n", 
chklen
));

482 
chklen_hdr
 = 0;

483 
chklen
 = 
q
->
tot_len
;

485 
udphdr
->
len
 = 
	`htons
(
chklen_hdr
);

487 #if 
CHECKSUM_GEN_UDP


488 
udphdr
->
chksum
 = 
	`inet_chksum_pseudo_partial
(
q
, 
src_ip
, 
dst_ip
,

489 
IP_PROTO_UDPLITE
, 
q
->
tot_len
, 
chklen
);

491 if (
udphdr
->
chksum
 == 0x0000)

492 
udphdr
->
chksum
 = 0xffff;

495 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));

496 #if 
LWIP_NETIF_HWADDRHINT


497 
netif
->
addr_hint
 = &(
pcb
->addr_hint);

499 
err
 = 
	`ip_output_if
(
q
, 
src_ip
, 
dst_ip
, 
pcb
->
ttl
, pcb->
tos
, 
IP_PROTO_UDPLITE
, 
netif
);

500 #if 
LWIP_NETIF_HWADDRHINT


501 
netif
->
addr_hint
 = 
NULL
;

506 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: UDP packet length %"
U16_F
"\n", 
q
->
tot_len
));

507 
udphdr
->
len
 = 
	`htons
(
q
->
tot_len
);

509 #if 
CHECKSUM_GEN_UDP


510 if ((
pcb
->
flags
 & 
UDP_FLAGS_NOCHKSUM
) == 0) {

511 
udphdr
->
chksum
 = 
	`inet_chksum_pseudo
(
q
, 
src_ip
, 
dst_ip
, 
IP_PROTO_UDP
, q->
tot_len
);

513 if (
udphdr
->
chksum
 == 0x0000) udphdr->chksum = 0xffff;

516 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: UDP checksum 0x%04"
X16_F
"\n", 
udphdr
->
chksum
));

517 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));

519 #if 
LWIP_NETIF_HWADDRHINT


520 
netif
->
addr_hint
 = &(
pcb
->addr_hint);

522 
err
 = 
	`ip_output_if
(
q
, 
src_ip
, 
dst_ip
, 
pcb
->
ttl
, pcb->
tos
, 
IP_PROTO_UDP
, 
netif
);

523 #if 
LWIP_NETIF_HWADDRHINT


524 
netif
->
addr_hint
 = 
NULL
;

528 
	`snmp_inc_udpoutdatagrams
();

531 if (
q
 != 
p
) {

533 
	`pbuf_free
(
q
);

534 
q
 = 
NULL
;

538 
	`UDP_STATS_INC
(
udp
.
xmit
);

539 return 
err
;

540 
	}
}

561 
err_t


562 
	$udp_bind
(struct 
udp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
, 
u16_t
 
port
)

564 struct 
udp_pcb
 *
ipcb
;

565 
u8_t
 
rebind
;

567 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("udp_bind(ipaddr = "));

568 
	`ip_addr_debug_print
(
UDP_DEBUG
, 
ipaddr
);

569 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, (", port = %"
U16_F
")\n", 
port
));

571 
rebind
 = 0;

573 for (
ipcb
 = 
udp_pcbs
; ipcb != 
NULL
; ipcb = ipcb->
next
) {

575 if (
pcb
 == 
ipcb
) {

577 
	`LWIP_ASSERT
("rebind == 0", 
rebind
 == 0);

579 
rebind
 = 1;

586 #ifdef 
LWIP_UDP_TODO


589 if ((
ipcb
->
local_port
 == 
port
) &&

591 (
	`ip_addr_isany
(&(
ipcb
->
local_ip
)) ||

592 
	`ip_addr_isany
(
ipaddr
) ||

593 
	`ip_addr_cmp
(&(
ipcb
->
local_ip
), 
ipaddr
))) {

595 
	`LWIP_DEBUGF
(
UDP_DEBUG
,

596 ("udp_bind: local port %"
U16_F
" already bound by another pcb\n", 
port
));

597 return 
ERR_USE
;

602 
	`ip_addr_set
(&
pcb
->
local_ip
, 
ipaddr
);

605 if (
port
 == 0) {

606 #ifndef 
UDP_LOCAL_PORT_RANGE_START


607 #define 
	#UDP_LOCAL_PORT_RANGE_START
 4096

	)

608 #define 
	#UDP_LOCAL_PORT_RANGE_END
 0x7fff

	)

610 
port
 = 
UDP_LOCAL_PORT_RANGE_START
;

611 
ipcb
 = 
udp_pcbs
;

612 while ((
ipcb
 != 
NULL
) && (
port
 != 
UDP_LOCAL_PORT_RANGE_END
)) {

613 if (
ipcb
->
local_port
 == 
port
) {

615 
port
++;

617 
ipcb
 = 
udp_pcbs
;

620 
ipcb
 = ipcb->
next
;

622 if (
ipcb
 != 
NULL
) {

624 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_bind: out of free UDP ports\n"));

625 return 
ERR_USE
;

628 
pcb
->
local_port
 = 
port
;

629 
	`snmp_insert_udpidx_tree
(
pcb
);

631 if (
rebind
 == 0) {

633 
pcb
->
next
 = 
udp_pcbs
;

634 
udp_pcbs
 = 
pcb
;

636 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
,

637 ("udp_bind: bound to %"
U16_F
".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",

638 (
u16_t
)(
	`ntohl
(
pcb
->
local_ip
.
addr
) >> 24 & 0xff),

639 (
u16_t
)(
	`ntohl
(
pcb
->
local_ip
.
addr
) >> 16 & 0xff),

640 (
u16_t
)(
	`ntohl
(
pcb
->
local_ip
.
addr
) >> 8 & 0xff),

641 (
u16_t
)(
	`ntohl
(
pcb
->
local_ip
.
addr
) & 0xff), pcb->
local_port
));

642 return 
ERR_OK
;

643 
	}
}

661 
err_t


662 
	$udp_connect
(struct 
udp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
, 
u16_t
 
port
)

664 struct 
udp_pcb
 *
ipcb
;

666 if (
pcb
->
local_port
 == 0) {

667 
err_t
 
err
 = 
	`udp_bind
(
pcb
, &pcb->
local_ip
, pcb->
local_port
);

668 if (
err
 != 
ERR_OK
)

669 return 
err
;

672 
	`ip_addr_set
(&
pcb
->
remote_ip
, 
ipaddr
);

673 
pcb
->
remote_port
 = 
port
;

674 
pcb
->
flags
 |= 
UDP_FLAGS_CONNECTED
;

676 #ifdef 
LWIP_UDP_TODO


678 if (
	`ip_addr_isany
(&
pcb
->
local_ip
) && !ip_addr_isany(&pcb->
remote_ip
)) {

679 struct 
netif
 *netif;

681 if ((
netif
 = 
	`ip_route
(&(
pcb
->
remote_ip
))) == 
NULL
) {

682 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("udp_connect: No route to 0x%lx\n", 
pcb
->
remote_ip
.
addr
));

683 
	`UDP_STATS_INC
(
udp
.
rterr
);

684 return 
ERR_RTE
;

689 
pcb
->
local_ip
 = 
netif
->
ip_addr
;

690 } else if (
	`ip_addr_isany
(&
pcb
->
remote_ip
)) {

691 
pcb
->
local_ip
.
addr
 = 0;

694 
	`LWIP_DEBUGF
(
UDP_DEBUG
 | 
LWIP_DBG_TRACE
 | 
LWIP_DBG_STATE
,

695 ("udp_connect: connected to %"
U16_F
".%"U16_F".%"U16_F".%"U16_F",port %"U16_F"\n",

696 (
u16_t
)(
	`ntohl
(
pcb
->
remote_ip
.
addr
) >> 24 & 0xff),

697 (
u16_t
)(
	`ntohl
(
pcb
->
remote_ip
.
addr
) >> 16 & 0xff),

698 (
u16_t
)(
	`ntohl
(
pcb
->
remote_ip
.
addr
) >> 8 & 0xff),

699 (
u16_t
)(
	`ntohl
(
pcb
->
remote_ip
.
addr
) & 0xff), pcb->
remote_port
));

702 for (
ipcb
 = 
udp_pcbs
; ipcb != 
NULL
; ipcb = ipcb->
next
) {

703 if (
pcb
 == 
ipcb
) {

705 return 
ERR_OK
;

709 
pcb
->
next
 = 
udp_pcbs
;

710 
udp_pcbs
 = 
pcb
;

711 return 
ERR_OK
;

712 
	}
}

720 
	$udp_disconnect
(struct 
udp_pcb
 *
pcb
)

723 
	`ip_addr_set
(&
pcb
->
remote_ip
, 
IP_ADDR_ANY
);

724 
pcb
->
remote_port
 = 0;

726 
pcb
->
flags
 &= ~
UDP_FLAGS_CONNECTED
;

727 
	}
}

739 
udp_recv
(struct 
udp_pcb
 *
pcb
,

740 void (* 
recv
)(void *
arg
, struct 
udp_pcb
 *
upcb
, struct 
pbuf
 *
p
,

741 struct 
ip_addr
 *
addr
, 
u16_t
 
port
),

742 void *
recv_arg
)

745 
pcb
->
recv
 = recv;

746 
pcb
->
recv_arg
 = recv_arg;

747 
	}
}

758 
	$udp_remove
(struct 
udp_pcb
 *
pcb
)

760 struct 
udp_pcb
 *
pcb2
;

762 
	`snmp_delete_udpidx_tree
(
pcb
);

764 if (
udp_pcbs
 == 
pcb
) {

766 
udp_pcbs
 = udp_pcbs->
next
;

769 for (
pcb2
 = 
udp_pcbs
; pcb2 != 
NULL
; pcb2 = pcb2->
next
) {

771 if (
pcb2
->
next
 != 
NULL
 && pcb2->next == 
pcb
) {

773 
pcb2
->
next
 = 
pcb
->next;

776 
	`memp_free
(
MEMP_UDP_PCB
, 
pcb
);

777 
	}
}

787 struct 
udp_pcb
 *

788 
	$udp_new
(void)

790 struct 
udp_pcb
 *
pcb
;

791 
pcb
 = 
	`memp_malloc
(
MEMP_UDP_PCB
);

793 if (
pcb
 != 
NULL
) {

798 
	`memset
(
pcb
, 0, sizeof(struct 
udp_pcb
));

799 
pcb
->
ttl
 = 
UDP_TTL
;

801 return 
pcb
;

802 
	}
}

804 #if 
UDP_DEBUG


811 
	$udp_debug_print
(struct 
udp_hdr
 *
udphdr
)

813 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("UDP header:\n"));

814 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("+-------------------------------+\n"));

815 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("| %5"
U16_F
" | %5"U16_F" | (src port, dest port)\n",

816 
	`ntohs
(
udphdr
->
src
), ntohs(udphdr->
dest
)));

817 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("+-------------------------------+\n"));

818 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("| %5"
U16_F
" | 0x%04"
X16_F
" | (len, chksum)\n",

819 
	`ntohs
(
udphdr
->
len
), ntohs(udphdr->
chksum
)));

820 
	`LWIP_DEBUGF
(
UDP_DEBUG
, ("+-------------------------------+\n"));

821 
	}
}

	@/root/Robux/net/lwip/include/ipv4/lwip/autoip.h

44 #ifndef 
__LWIP_AUTOIP_H__


45 #define 
	#__LWIP_AUTOIP_H__


	)

47 #include 
	~"lwip/opt.h
"

49 #if 
LWIP_AUTOIP


51 #include 
	~"lwip/netif.h
"

52 #include 
	~"lwip/udp.h
"

53 #include 
	~"netif/etharp.h
"

56 #define 
	#AUTOIP_TMR_INTERVAL
 100

	)

57 #define 
	#AUTOIP_TICKS_PER_SECOND
 (1000 / 
AUTOIP_TMR_INTERVAL
)

	)

60 #define 
	#PROBE_WAIT
 1

	)

61 #define 
	#PROBE_MIN
 1

	)

62 #define 
	#PROBE_MAX
 2

	)

63 #define 
	#PROBE_NUM
 3

	)

64 #define 
	#ANNOUNCE_NUM
 2

	)

65 #define 
	#ANNOUNCE_INTERVAL
 2

	)

66 #define 
	#ANNOUNCE_WAIT
 2

	)

67 #define 
	#MAX_CONFLICTS
 10

	)

68 #define 
	#RATE_LIMIT_INTERVAL
 60

	)

69 #define 
	#DEFEND_INTERVAL
 10

	)

72 #define 
	#AUTOIP_STATE_OFF
 0

	)

73 #define 
	#AUTOIP_STATE_PROBING
 1

	)

74 #define 
	#AUTOIP_STATE_ANNOUNCING
 2

	)

75 #define 
	#AUTOIP_STATE_BOUND
 3

	)

77 struct 
	sautoip


79 struct 
ip_addr
 
	mllipaddr
;

80 
u8_t
 
	mstate
;

81 
u8_t
 
	msent_num
;

82 
u16_t
 
	mttw
;

83 
u8_t
 
	mlastconflict
;

84 
u8_t
 
	mtried_llipaddr
;

89 void 
autoip_init
(void);

92 
err_t
 
autoip_start
(struct 
netif
 *netif);

95 
err_t
 
autoip_stop
(struct 
netif
 *netif);

98 void 
autoip_arp_reply
(struct 
netif
 *netif, struct 
etharp_hdr
 *
hdr
);

101 void 
autoip_tmr
(void);

	@/root/Robux/net/lwip/include/ipv4/lwip/icmp.h

32 #ifndef 
__LWIP_ICMP_H__


33 #define 
	#__LWIP_ICMP_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_ICMP


39 #include 
	~"lwip/pbuf.h
"

40 #include 
	~"lwip/ip_addr.h
"

41 #include 
	~"lwip/netif.h
"

43 #ifdef 
__cplusplus


47 #define 
	#ICMP_ER
 0

	)

48 #define 
	#ICMP_DUR
 3

	)

49 #define 
	#ICMP_SQ
 4

	)

50 #define 
	#ICMP_RD
 5

	)

51 #define 
	#ICMP_ECHO
 8

	)

52 #define 
	#ICMP_TE
 11

	)

53 #define 
	#ICMP_PP
 12

	)

54 #define 
	#ICMP_TS
 13

	)

55 #define 
	#ICMP_TSR
 14

	)

56 #define 
	#ICMP_IRQ
 15

	)

57 #define 
	#ICMP_IR
 16

	)

59 enum 
	eicmp_dur_type
 {

60 
ICMP_DUR_NET
 = 0,

61 
ICMP_DUR_HOST
 = 1,

62 
ICMP_DUR_PROTO
 = 2,

63 
ICMP_DUR_PORT
 = 3,

64 
ICMP_DUR_FRAG
 = 4,

65 
ICMP_DUR_SR
 = 5

68 enum 
	eicmp_te_type
 {

69 
ICMP_TE_TTL
 = 0,

70 
ICMP_TE_FRAG
 = 1

73 void 
icmp_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

75 void 
icmp_dest_unreach
(struct 
pbuf
 *
p
, enum 
icmp_dur_type
 
t
);

76 void 
icmp_time_exceeded
(struct 
pbuf
 *
p
, enum 
icmp_te_type
 
t
);

78 #ifdef 
PACK_STRUCT_USE_INCLUDES


79 #include 
	~"arch/bpstruct.h
"

81 
PACK_STRUCT_BEGIN


82 struct 
	sicmp_echo_hdr
 {

83 
PACK_STRUCT_FIELD
(
u16_t
 
_type_code
);

84 
PACK_STRUCT_FIELD
(
u16_t
 
chksum
);

85 
PACK_STRUCT_FIELD
(
u16_t
 
id
);

86 
PACK_STRUCT_FIELD
(
u16_t
 
seqno
);

87 } 
PACK_STRUCT_STRUCT
;

88 
PACK_STRUCT_END


90 
PACK_STRUCT_BEGIN


91 struct 
	sicmp_dur_hdr
 {

92 
PACK_STRUCT_FIELD
(
u16_t
 
_type_code
);

93 
PACK_STRUCT_FIELD
(
u16_t
 
chksum
);

94 
PACK_STRUCT_FIELD
(
u32_t
 
unused
);

95 } 
PACK_STRUCT_STRUCT
;

96 
PACK_STRUCT_END


98 
PACK_STRUCT_BEGIN


99 struct 
	sicmp_te_hdr
 {

100 
PACK_STRUCT_FIELD
(
u16_t
 
_type_code
);

101 
PACK_STRUCT_FIELD
(
u16_t
 
chksum
);

102 
PACK_STRUCT_FIELD
(
u32_t
 
unused
);

103 } 
PACK_STRUCT_STRUCT
;

104 
PACK_STRUCT_END


105 #ifdef 
PACK_STRUCT_USE_INCLUDES


106 #include 
	~"arch/epstruct.h
"

109 #define 
	#ICMPH_TYPE
(
hdr
) (
	`ntohs
((hdr)->
_type_code
) >> 8)

	)

110 #define 
	#ICMPH_CODE
(
hdr
) (
	`ntohs
((hdr)->
_type_code
) & 0xff)

	)

112 #define 
	#ICMPH_TYPE_SET
(
hdr
, 
type
) ((hdr)->
_type_code
 = 
	`htons
(
	`ICMPH_CODE
(hdr) | ((type) << 8)))

	)

113 #define 
	#ICMPH_CODE_SET
(
hdr
, 
code
) ((hdr)->
_type_code
 = 
	`htons
((code) | (
	`ICMPH_TYPE
(hdr) << 8)))

	)

115 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv4/lwip/igmp.h

35 #ifndef 
__LWIP_IGMP_H__


36 #define 
	#__LWIP_IGMP_H__


	)

38 #include 
	~"lwip/opt.h
"

39 #include 
	~"lwip/ip_addr.h
"

40 #include 
	~"lwip/netif.h
"

41 #include 
	~"lwip/pbuf.h
"

43 #if 
LWIP_IGMP


45 #ifdef 
__cplusplus


52 #define 
	#IP_PROTO_IGMP
 2

	)

53 #define 
	#IGMP_TTL
 1

	)

54 #define 
	#IGMP_MINLEN
 8

	)

55 #define 
	#ROUTER_ALERT
 0x9404

	)

56 #define 
	#ROUTER_ALERTLEN
 4

	)

61 #define 
	#IGMP_MEMB_QUERY
 0x11

	)

62 #define 
	#IGMP_V1_MEMB_REPORT
 0x12

	)

63 #define 
	#IGMP_V2_MEMB_REPORT
 0x16

	)

64 #define 
	#IGMP_LEAVE_GROUP
 0x17

	)

67 #define 
	#IGMP_TMR_INTERVAL
 100

	)

68 #define 
	#IGMP_V1_DELAYING_MEMBER_TMR
 (1000/
IGMP_TMR_INTERVAL
)

	)

69 #define 
	#IGMP_JOIN_DELAYING_MEMBER_TMR
 (500 /
IGMP_TMR_INTERVAL
)

	)

72 #define 
	#IGMP_DEL_MAC_FILTER
 0

	)

73 #define 
	#IGMP_ADD_MAC_FILTER
 1

	)

76 #define 
	#IGMP_GROUP_NON_MEMBER
 0

	)

77 #define 
	#IGMP_GROUP_DELAYING_MEMBER
 1

	)

78 #define 
	#IGMP_GROUP_IDLE_MEMBER
 2

	)

83 #ifdef 
PACK_STRUCT_USE_INCLUDES


84 #include 
	~"arch/bpstruct.h
"

86 
PACK_STRUCT_BEGIN


87 struct 
	sigmp_msg
 {

88 
PACK_STRUCT_FIELD
(
u8_t
 
igmp_msgtype
);

89 
PACK_STRUCT_FIELD
(
u8_t
 
igmp_maxresp
);

90 
PACK_STRUCT_FIELD
(
u16_t
 
igmp_checksum
);

91 
PACK_STRUCT_FIELD
(struct 
ip_addr
 
igmp_group_address
);

92 } 
PACK_STRUCT_STRUCT
;

93 
PACK_STRUCT_END


94 #ifdef 
PACK_STRUCT_USE_INCLUDES


95 #include 
	~"arch/epstruct.h
"

110 struct 
	sigmp_group
 {

111 struct 
igmp_group
 *
next
;

112 struct 
netif
 *
interface
;

113 struct 
ip_addr
 
group_address
;

114 
u8_t
 
last_reporter_flag
;

115 
u8_t
 
group_state
;

116 
u16_t
 
timer
;

117 
u8_t
 
use
;

122 void 
igmp_init
(void);

124 
err_t
 
igmp_start
( struct 
netif
 *netif);

126 
err_t
 
igmp_stop
( struct 
netif
 *netif);

128 void 
igmp_report_groups
( struct 
netif
 *netif);

130 struct 
igmp_group
 *
igmp_lookfor_group
( struct 
netif
 *
ifp
, struct 
ip_addr
 *
addr
);

132 struct 
igmp_group
 *
igmp_lookup_group
( struct 
netif
 *
ifp
, struct 
ip_addr
 *
addr
);

134 
err_t
 
igmp_remove_group
( struct 
igmp_group
 *
group
);

136 void 
igmp_input
( struct 
pbuf
 *
p
, struct 
netif
 *
inp
, struct 
ip_addr
 *
dest
);

138 
err_t
 
igmp_joingroup
( struct 
ip_addr
 *
ifaddr
, struct ip_addr *
groupaddr
);

140 
err_t
 
igmp_leavegroup
( struct 
ip_addr
 *
ifaddr
, struct ip_addr *
groupaddr
);

142 void 
igmp_tmr
(void);

144 void 
igmp_timeout
( struct 
igmp_group
 *
group
);

146 void 
igmp_start_timer
( struct 
igmp_group
 *
group
, 
u8_t
 
max_time
);

148 void 
igmp_stop_timer
( struct 
igmp_group
 *
group
);

150 void 
igmp_delaying_member
( struct 
igmp_group
 *
group
, 
u8_t
 
maxresp
);

152 
err_t
 
igmp_ip_output_if
( struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
, 
u8_t
 
ttl
, u8_t 
proto
, struct 
netif
 *netif);

154 void 
igmp_send
( struct 
igmp_group
 *
group
, 
u8_t
 
type
);

156 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv4/lwip/inet.h

32 #ifndef 
__LWIP_INET_H__


33 #define 
	#__LWIP_INET_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #include 
	~"lwip/ip_addr.h
"

39 #ifdef 
__cplusplus


44 struct 
	sin_addr
 {

45 
u32_t
 
s_addr
;

48 
u32_t
 
inet_addr
(const char *
cp
);

49 int 
inet_aton
(const char *
cp
, struct 
in_addr
 *
addr
);

50 char *
inet_ntoa
(struct 
in_addr
 
addr
);

52 #ifdef 
htons


53 #undef 
htons


55 #ifdef 
htonl


56 #undef 
htonl


58 #ifdef 
ntohs


59 #undef 
ntohs


61 #ifdef 
ntohl


62 #undef 
ntohl


65 #ifndef 
LWIP_PLATFORM_BYTESWAP


66 #define 
	#LWIP_PLATFORM_BYTESWAP
 0

	)

69 #if 
BYTE_ORDER
 == 
BIG_ENDIAN


70 #define 
	#htons
(
x
) (x)

	)

71 #define 
	#ntohs
(
x
) (x)

	)

72 #define 
	#htonl
(
x
) (x)

	)

73 #define 
	#ntohl
(
x
) (x)

	)

75 #ifdef 
LWIP_PREFIX_BYTEORDER_FUNCS


77 #define 
	#htons
 
lwip_htons


	)

78 #define 
	#ntohs
 
lwip_ntohs


	)

79 #define 
	#htonl
 
lwip_htonl


	)

80 #define 
	#ntohl
 
lwip_ntohl


	)

82 #if 
LWIP_PLATFORM_BYTESWAP


83 #define 
	#htons
(
x
) 
	`LWIP_PLATFORM_HTONS
(x)

	)

84 #define 
	#ntohs
(
x
) 
	`LWIP_PLATFORM_HTONS
(x)

	)

85 #define 
	#htonl
(
x
) 
	`LWIP_PLATFORM_HTONL
(x)

	)

86 #define 
	#ntohl
(
x
) 
	`LWIP_PLATFORM_HTONL
(x)

	)

88 
u16_t
 
htons
(u16_t 
x
);

89 
u16_t
 
ntohs
(u16_t 
x
);

90 
u32_t
 
htonl
(u32_t 
x
);

91 
u32_t
 
ntohl
(u32_t 
x
);

96 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv4/lwip/inet_chksum.h

32 #ifndef 
__LWIP_INET_CHKSUM_H__


33 #define 
	#__LWIP_INET_CHKSUM_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #include 
	~"lwip/pbuf.h
"

38 #include 
	~"lwip/ip_addr.h
"

40 #ifdef 
__cplusplus


44 
u16_t
 
inet_chksum
(void *
dataptr
, u16_t 
len
);

45 
u16_t
 
inet_chksum_pbuf
(struct 
pbuf
 *
p
);

46 
u16_t
 
inet_chksum_pseudo
(struct 
pbuf
 *
p
,

47 struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

48 
u8_t
 
proto
, 
u16_t
 
proto_len
);

49 
u16_t
 
inet_chksum_pseudo_partial
(struct 
pbuf
 *
p
,

50 struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

51 
u8_t
 
proto
, 
u16_t
 
proto_len
, u16_t 
chksum_len
);

53 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv4/lwip/ip.h

32 #ifndef 
__LWIP_IP_H__


33 #define 
	#__LWIP_IP_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #include 
	~"lwip/def.h
"

38 #include 
	~"lwip/pbuf.h
"

39 #include 
	~"lwip/ip_addr.h
"

40 #include 
	~"lwip/err.h
"

42 #ifdef 
__cplusplus


46 #define 
	#ip_init
()

	)

47 struct 
netif
 *
ip_route
(struct 
ip_addr
 *
dest
);

48 
err_t
 
ip_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

49 
err_t
 
ip_output
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

50 
u8_t
 
ttl
, u8_t 
tos
, u8_t 
proto
);

51 
err_t
 
ip_output_if
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

52 
u8_t
 
ttl
, u8_t 
tos
, u8_t 
proto
,

53 struct 
netif
 *netif);

55 #define 
	#IP_HLEN
 20

	)

57 #define 
	#IP_PROTO_ICMP
 1

	)

58 #define 
	#IP_PROTO_UDP
 17

	)

59 #define 
	#IP_PROTO_UDPLITE
 136

	)

60 #define 
	#IP_PROTO_TCP
 6

	)

65 #ifdef 
IP_HDRINCL


66 #undef 
IP_HDRINCL


68 #define 
	#IP_HDRINCL
 
NULL


	)

70 #if 
LWIP_NETIF_HWADDRHINT


71 #define 
	#IP_PCB_ADDRHINT
 ;
u8_t
 
addr_hint


	)

73 #define 
	#IP_PCB_ADDRHINT


	)

80 #define 
	#IP_PCB
 \

82 struct 
ip_addr
 
local_ip
; \

83 struct 
ip_addr
 
remote_ip
; \

85 
u16_t
 
so_options
; \

87 
u8_t
 
tos
; \

89 
u8_t
 
ttl
 \

91 
IP_PCB_ADDRHINT


	)

93 struct 
	sip_pcb
 {

95 
IP_PCB
;

101 #define 
	#SOF_DEBUG
 (
u16_t
)0x0001U

	)

102 #define 
	#SOF_ACCEPTCONN
 (
u16_t
)0x0002U

	)

103 #define 
	#SOF_REUSEADDR
 (
u16_t
)0x0004U

	)

104 #define 
	#SOF_KEEPALIVE
 (
u16_t
)0x0008U

	)

105 #define 
	#SOF_DONTROUTE
 (
u16_t
)0x0010U

	)

106 #define 
	#SOF_BROADCAST
 (
u16_t
)0x0020U

	)

107 #define 
	#SOF_USELOOPBACK
 (
u16_t
)0x0040U

	)

108 #define 
	#SOF_LINGER
 (
u16_t
)0x0080U

	)

109 #define 
	#SOF_OOBINLINE
 (
u16_t
)0x0100U

	)

110 #define 
	#SOF_REUSEPORT
 (
u16_t
)0x0200U

	)

113 #ifdef 
PACK_STRUCT_USE_INCLUDES


114 #include 
	~"arch/bpstruct.h
"

116 
PACK_STRUCT_BEGIN


117 struct 
	sip_hdr
 {

119 
PACK_STRUCT_FIELD
(
u16_t
 
_v_hl_tos
);

121 
PACK_STRUCT_FIELD
(
u16_t
 
_len
);

123 
PACK_STRUCT_FIELD
(
u16_t
 
_id
);

125 
PACK_STRUCT_FIELD
(
u16_t
 
_offset
);

126 #define 
	#IP_RF
 0x8000

	)

127 #define 
	#IP_DF
 0x4000

	)

128 #define 
	#IP_MF
 0x2000

	)

129 #define 
	#IP_OFFMASK
 0x1fff

	)

131 
PACK_STRUCT_FIELD
(
u16_t
 
_ttl_proto
);

133 
PACK_STRUCT_FIELD
(
u16_t
 
_chksum
);

135 
PACK_STRUCT_FIELD
(struct 
ip_addr
 
src
);

136 
PACK_STRUCT_FIELD
(struct 
ip_addr
 
dest
);

137 } 
PACK_STRUCT_STRUCT
;

138 
PACK_STRUCT_END


139 #ifdef 
PACK_STRUCT_USE_INCLUDES


140 #include 
	~"arch/epstruct.h
"

143 #define 
	#IPH_V
(
hdr
) (
	`ntohs
((hdr)->
_v_hl_tos
) >> 12)

	)

144 #define 
	#IPH_HL
(
hdr
) ((
	`ntohs
((hdr)->
_v_hl_tos
) >> 8) & 0x0f)

	)

145 #define 
	#IPH_TOS
(
hdr
) (
	`ntohs
((hdr)->
_v_hl_tos
) & 0xff)

	)

146 #define 
	#IPH_LEN
(
hdr
) ((hdr)->
_len
)

	)

147 #define 
	#IPH_ID
(
hdr
) ((hdr)->
_id
)

	)

148 #define 
	#IPH_OFFSET
(
hdr
) ((hdr)->
_offset
)

	)

149 #define 
	#IPH_TTL
(
hdr
) (
	`ntohs
((hdr)->
_ttl_proto
) >> 8)

	)

150 #define 
	#IPH_PROTO
(
hdr
) (
	`ntohs
((hdr)->
_ttl_proto
) & 0xff)

	)

151 #define 
	#IPH_CHKSUM
(
hdr
) ((hdr)->
_chksum
)

	)

153 #define 
	#IPH_VHLTOS_SET
(
hdr
, 
v
, 
hl
, 
tos
) (hdr)->
_v_hl_tos
 = (
	`htons
(((v) << 12) | ((hl) << 8) | (tos)))

	)

154 #define 
	#IPH_LEN_SET
(
hdr
, 
len
) (hdr)->
_len
 = (len)

	)

155 #define 
	#IPH_ID_SET
(
hdr
, 
id
) (hdr)->
_id
 = (id)

	)

156 #define 
	#IPH_OFFSET_SET
(
hdr
, 
off
) (hdr)->
_offset
 = (off)

	)

157 #define 
	#IPH_TTL_SET
(
hdr
, 
ttl
) (hdr)->
_ttl_proto
 = (
	`htons
(
	`IPH_PROTO
(hdr) | ((
u16_t
)(ttl) << 8)))

	)

158 #define 
	#IPH_PROTO_SET
(
hdr
, 
proto
) (hdr)->
_ttl_proto
 = (
	`htons
((proto) | (
	`IPH_TTL
(hdr) << 8)))

	)

159 #define 
	#IPH_CHKSUM_SET
(
hdr
, 
chksum
) (hdr)->
_chksum
 = (chksum)

	)

161 #if 
IP_DEBUG


162 void 
ip_debug_print
(struct 
pbuf
 *
p
);

164 #define 
	#ip_debug_print
(
p
)

	)

167 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv4/lwip/ip_addr.h

32 #ifndef 
__LWIP_IP_ADDR_H__


33 #define 
	#__LWIP_IP_ADDR_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #ifdef 
__cplusplus


41 #ifdef 
PACK_STRUCT_USE_INCLUDES


42 #include 
	~"arch/bpstruct.h
"

44 
PACK_STRUCT_BEGIN


45 struct 
	sip_addr
 {

46 
PACK_STRUCT_FIELD
(
u32_t
 
addr
);

47 } 
PACK_STRUCT_STRUCT
;

48 
PACK_STRUCT_END


49 #ifdef 
PACK_STRUCT_USE_INCLUDES


50 #include 
	~"arch/epstruct.h
"

57 #ifdef 
PACK_STRUCT_USE_INCLUDES


58 #include 
	~"arch/bpstruct.h
"

60 
PACK_STRUCT_BEGIN


61 struct 
	sip_addr2
 {

62 
PACK_STRUCT_FIELD
(
u16_t
 
addrw
[2]);

63 } 
PACK_STRUCT_STRUCT
;

64 
PACK_STRUCT_END


65 #ifdef 
PACK_STRUCT_USE_INCLUDES


66 #include 
	~"arch/epstruct.h
"

69 struct 
netif
;

71 extern const struct 
ip_addr
 
ip_addr_any
;

72 extern const struct 
ip_addr
 
ip_addr_broadcast
;

77 #define 
	#IP_ADDR_ANY
 ((struct 
ip_addr
 *)&
ip_addr_any
)

	)

78 #define 
	#IP_ADDR_BROADCAST
 ((struct 
ip_addr
 *)&
ip_addr_broadcast
)

	)

80 #define 
	#INADDR_NONE
 ((
u32_t
)0xffffffffUL)

	)

81 #define 
	#INADDR_LOOPBACK
 ((
u32_t
)0x7f000001UL)

	)

88 #define 
	#IN_CLASSA
(
a
) ((((
u32_t
)(a)) & 0x80000000UL) == 0)

	)

89 #define 
	#IN_CLASSA_NET
 0xff000000

	)

90 #define 
	#IN_CLASSA_NSHIFT
 24

	)

91 #define 
	#IN_CLASSA_HOST
 (0xffffffff & ~
IN_CLASSA_NET
)

	)

92 #define 
	#IN_CLASSA_MAX
 128

	)

94 #define 
	#IN_CLASSB
(
a
) ((((
u32_t
)(a)) & 0xc0000000UL) == 0x80000000UL)

	)

95 #define 
	#IN_CLASSB_NET
 0xffff0000

	)

96 #define 
	#IN_CLASSB_NSHIFT
 16

	)

97 #define 
	#IN_CLASSB_HOST
 (0xffffffff & ~
IN_CLASSB_NET
)

	)

98 #define 
	#IN_CLASSB_MAX
 65536

	)

100 #define 
	#IN_CLASSC
(
a
) ((((
u32_t
)(a)) & 0xe0000000UL) == 0xc0000000UL)

	)

101 #define 
	#IN_CLASSC_NET
 0xffffff00

	)

102 #define 
	#IN_CLASSC_NSHIFT
 8

	)

103 #define 
	#IN_CLASSC_HOST
 (0xffffffff & ~
IN_CLASSC_NET
)

	)

105 #define 
	#IN_CLASSD
(
a
) (((
u32_t
)(a) & 0xf0000000UL) == 0xe0000000UL)

	)

106 #define 
	#IN_CLASSD_NET
 0xf0000000

	)

107 #define 
	#IN_CLASSD_NSHIFT
 28

	)

108 #define 
	#IN_CLASSD_HOST
 0x0fffffff

	)

109 #define 
	#IN_MULTICAST
(
a
) 
	`IN_CLASSD
(a)

	)

111 #define 
	#IN_EXPERIMENTAL
(
a
) (((
u32_t
)(a) & 0xf0000000UL) == 0xf0000000UL)

	)

112 #define 
	#IN_BADCLASS
(
a
) (((
u32_t
)(a) & 0xf0000000UL) == 0xf0000000UL)

	)

114 #define 
	#IN_LOOPBACKNET
 127

	)

116 #define 
	#IP4_ADDR
(
ipaddr
, 
a
,
b
,
c
,
d
) \

117 (
ipaddr
)->
addr
 = 
	`htonl
(((
u32_t
)((
a
) & 0xff) << 24) | \

118 ((
u32_t
)((
b
) & 0xff) << 16) | \

119 ((
u32_t
)((
c
) & 0xff) << 8) | \

120 (
u32_t
)((
d
) & 0xff))

	)

122 #define 
	#ip_addr_set
(
dest
, 
src
) (dest)->
addr
 = \

123 ((
src
) == 
NULL
? 0:\

124 (
src
)->
addr
)

	)

133 #define 
	#ip_addr_netcmp
(
addr1
, 
addr2
, 
mask
) (((addr1)->
addr
 & \

134 (
mask
)->
addr
) == \

135 ((
addr2
)->
addr
 & \

136 (
mask
)->
addr
))

	)

137 #define 
	#ip_addr_cmp
(
addr1
, 
addr2
) ((addr1)->
addr
 == (addr2)->addr)

	)

139 #define 
	#ip_addr_isany
(
addr1
) ((addr1) == 
NULL
 || (addr1)->
addr
 == 0)

	)

141 
u8_t
 
ip_addr_isbroadcast
(struct 
ip_addr
 *, struct 
netif
 *);

143 #define 
	#ip_addr_ismulticast
(
addr1
) (((addr1)->
addr
 & 
	`ntohl
(0xf0000000UL)) == ntohl(0xe0000000UL))

	)

145 #define 
	#ip_addr_islinklocal
(
addr1
) (((addr1)->
addr
 & 
	`ntohl
(0xffff0000UL)) == ntohl(0xa9fe0000UL))

	)

147 #define 
	#ip_addr_debug_print
(
debug
, 
ipaddr
) \

148 
	`LWIP_DEBUGF
(
debug
, ("%"
U16_F
".%"U16_F".%"U16_F".%"U16_F, \

149 
ipaddr
 ? (
u16_t
)(
	`ntohl
((ipaddr)->
addr
) >> 24) & 0xff : 0, \

150 
ipaddr
 ? (
u16_t
)(
	`ntohl
((ipaddr)->
addr
) >> 16) & 0xff : 0, \

151 
ipaddr
 ? (
u16_t
)(
	`ntohl
((ipaddr)->
addr
) >> 8) & 0xff : 0, \

152 
ipaddr
 ? (
u16_t
)
	`ntohl
((ipaddr)->
addr
) & 0xff : 0))

	)

156 #define 
	#ip4_addr1
(
ipaddr
) ((
u16_t
)(
	`ntohl
((ipaddr)->
addr
) >> 24) & 0xff)

	)

157 #define 
	#ip4_addr2
(
ipaddr
) ((
u16_t
)(
	`ntohl
((ipaddr)->
addr
) >> 16) & 0xff)

	)

158 #define 
	#ip4_addr3
(
ipaddr
) ((
u16_t
)(
	`ntohl
((ipaddr)->
addr
) >> 8) & 0xff)

	)

159 #define 
	#ip4_addr4
(
ipaddr
) ((
u16_t
)(
	`ntohl
((ipaddr)->
addr
)) & 0xff)

	)

161 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv4/lwip/ip_frag.h

33 #ifndef 
__LWIP_IP_FRAG_H__


34 #define 
	#__LWIP_IP_FRAG_H__


	)

36 #include 
	~"lwip/opt.h
"

37 #include 
	~"lwip/err.h
"

38 #include 
	~"lwip/pbuf.h
"

39 #include 
	~"lwip/netif.h
"

40 #include 
	~"lwip/ip_addr.h
"

41 #include 
	~"lwip/ip.h
"

43 #ifdef 
__cplusplus


47 #if 
IP_REASSEMBLY


49 #define 
	#IP_TMR_INTERVAL
 1000

	)

54 struct 
	sip_reassdata
 {

55 struct 
ip_reassdata
 *
next
;

56 struct 
pbuf
 *
p
;

57 struct 
ip_hdr
 
iphdr
;

58 
u16_t
 
datagram_len
;

59 
u8_t
 
flags
;

60 
u8_t
 
timer
;

63 void 
ip_reass_init
(void);

64 void 
ip_reass_tmr
(void);

65 struct 
pbuf
 * 
ip_reass
(struct pbuf *
p
);

68 #if 
IP_FRAG


69 
err_t
 
ip_frag
(struct 
pbuf
 *
p
, struct 
netif
 *netif, struct 
ip_addr
 *
dest
);

72 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv6/lwip/icmp.h

32 #ifndef 
__LWIP_ICMP_H__


33 #define 
	#__LWIP_ICMP_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_ICMP


39 #include 
	~"lwip/pbuf.h
"

40 #include 
	~"lwip/netif.h
"

42 #ifdef 
__cplusplus


46 #define 
	#ICMP6_DUR
 1

	)

47 #define 
	#ICMP6_TE
 3

	)

48 #define 
	#ICMP6_ECHO
 128

	)

49 #define 
	#ICMP6_ER
 129

	)

52 enum 
	eicmp_dur_type
 {

53 
ICMP_DUR_NET
 = 0,

54 
ICMP_DUR_HOST
 = 1,

55 
ICMP_DUR_PROTO
 = 2,

56 
ICMP_DUR_PORT
 = 3,

57 
ICMP_DUR_FRAG
 = 4,

58 
ICMP_DUR_SR
 = 5

61 enum 
	eicmp_te_type
 {

62 
ICMP_TE_TTL
 = 0,

63 
ICMP_TE_FRAG
 = 1

66 void 
icmp_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

68 void 
icmp_dest_unreach
(struct 
pbuf
 *
p
, enum 
icmp_dur_type
 
t
);

69 void 
icmp_time_exceeded
(struct 
pbuf
 *
p
, enum 
icmp_te_type
 
t
);

71 struct 
	sicmp_echo_hdr
 {

72 
u8_t
 
type
;

73 
u8_t
 
icode
;

74 
u16_t
 
chksum
;

75 
u16_t
 
id
;

76 
u16_t
 
seqno
;

79 struct 
	sicmp_dur_hdr
 {

80 
u8_t
 
type
;

81 
u8_t
 
icode
;

82 
u16_t
 
chksum
;

83 
u32_t
 
unused
;

86 struct 
	sicmp_te_hdr
 {

87 
u8_t
 
type
;

88 
u8_t
 
icode
;

89 
u16_t
 
chksum
;

90 
u32_t
 
unused
;

93 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv6/lwip/inet.h

32 #ifndef 
__LWIP_INET_H__


33 #define 
	#__LWIP_INET_H__


	)

35 #include 
	~"lwip/opt.h
"

36 #include 
	~"lwip/pbuf.h
"

37 #include 
	~"lwip/ip_addr.h
"

39 #ifdef 
__cplusplus


43 
u16_t
 
inet_chksum
(void *
data
, u16_t 
len
);

44 
u16_t
 
inet_chksum_pbuf
(struct 
pbuf
 *
p
);

45 
u16_t
 
inet_chksum_pseudo
(struct 
pbuf
 *
p
,

46 struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

47 
u8_t
 
proto
, 
u32_t
 
proto_len
);

49 
u32_t
 
inet_addr
(const char *
cp
);

50 
s8_t
 
inet_aton
(const char *
cp
, struct 
in_addr
 *
addr
);

52 #ifndef 
_MACHINE_ENDIAN_H_


53 #ifndef 
_NETINET_IN_H


54 #ifndef 
_LINUX_BYTEORDER_GENERIC_H


55 
u16_t
 
htons
(u16_t 
n
);

56 
u16_t
 
ntohs
(u16_t 
n
);

57 
u32_t
 
htonl
(u32_t 
n
);

58 
u32_t
 
ntohl
(u32_t 
n
);

63 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv6/lwip/ip.h

32 #ifndef 
__LWIP_IP_H__


33 #define 
	#__LWIP_IP_H__


	)

35 #include 
	~"lwip/opt.h
"

36 #include 
	~"lwip/def.h
"

37 #include 
	~"lwip/pbuf.h
"

38 #include 
	~"lwip/ip_addr.h
"

40 #include 
	~"lwip/err.h
"

42 #ifdef 
__cplusplus


46 #define 
	#IP_HLEN
 40

	)

48 #define 
	#IP_PROTO_ICMP
 58

	)

49 #define 
	#IP_PROTO_UDP
 17

	)

50 #define 
	#IP_PROTO_UDPLITE
 136

	)

51 #define 
	#IP_PROTO_TCP
 6

	)

56 #ifdef 
IP_HDRINCL


57 #undef 
IP_HDRINCL


59 #define 
	#IP_HDRINCL
 
NULL


	)

61 #if 
LWIP_NETIF_HWADDRHINT


62 #define 
	#IP_PCB_ADDRHINT
 ;
u8_t
 
addr_hint


	)

64 #define 
	#IP_PCB_ADDRHINT


	)

71 #define 
	#IP_PCB
 struct 
ip_addr
 
local_ip
; \

72 struct 
ip_addr
 
remote_ip
; \

74 
u16_t
 
so_options
; \

76 
u8_t
 
tos
; \

78 
u8_t
 
ttl
; \

80 
IP_PCB_ADDRHINT


	)

84 struct 
	sip_hdr
 {

85 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


86 
u8_t
 
tclass1
:4, 
v
:4;

87 
u8_t
 
flow1
:4, 
tclass2
:4;

89 
u8_t
 
v
:4, 
tclass1
:4;

90 
u8_t
 
tclass2
:8, 
flow1
:4;

92 
u16_t
 
flow2
;

93 
u16_t
 
len
;

94 
u8_t
 
nexthdr
;

95 
u8_t
 
hoplim
;

96 struct 
ip_addr
 
src
, 
dest
;

99 #define 
	#IPH_PROTO
(
hdr
) (
iphdr
->
nexthdr
)

	)

101 void 
ip_init
(void);

103 #include 
	~"lwip/netif.h
"

105 struct 
netif
 *
ip_route
(struct 
ip_addr
 *
dest
);

107 void 
ip_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

110 
err_t
 
ip_output
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

111 
u8_t
 
ttl
, u8_t 
proto
);

113 
err_t
 
ip_output_if
(struct 
pbuf
 *
p
, struct 
ip_addr
 *
src
, struct ip_addr *
dest
,

114 
u8_t
 
ttl
, u8_t 
proto
,

115 struct 
netif
 *netif);

117 #if 
IP_DEBUG


118 void 
ip_debug_print
(struct 
pbuf
 *
p
);

121 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/ipv6/lwip/ip_addr.h

32 #ifndef 
__LWIP_IP_ADDR_H__


33 #define 
	#__LWIP_IP_ADDR_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #ifdef 
__cplusplus


41 #define 
	#IP_ADDR_ANY
 0

	)

43 #ifdef 
PACK_STRUCT_USE_INCLUDES


44 #include 
	~"arch/bpstruct.h
"

46 
PACK_STRUCT_BEGIN


47 struct 
	sip_addr
 {

48 
PACK_STRUCT_FIELD
(
u32_t
 
addr
[4]);

49 } 
PACK_STRUCT_STRUCT
;

50 
PACK_STRUCT_END


51 #ifdef 
PACK_STRUCT_USE_INCLUDES


52 #include 
	~"arch/epstruct.h
"

59 #ifdef 
PACK_STRUCT_USE_INCLUDES


60 #include 
	~"arch/bpstruct.h
"

62 
PACK_STRUCT_BEGIN


63 struct 
	sip_addr2
 {

64 
PACK_STRUCT_FIELD
(
u16_t
 
addrw
[2]);

65 } 
PACK_STRUCT_STRUCT
;

66 
PACK_STRUCT_END


67 #ifdef 
PACK_STRUCT_USE_INCLUDES


68 #include 
	~"arch/epstruct.h
"

71 #define 
	#IP6_ADDR
(
ipaddr
, 
a
,
b
,
c
,
d
,
e
,
f
,
g
,
h
) do { (ipaddr)->
addr
[0] = 
	`htonl
((
u32_t
)((a & 0xffff) << 16) | (b & 0xffff)); \

72 (
ipaddr
)->
addr
[1] = 
	`htonl
(((
c
 & 0xffff) << 16) | (
d
 & 0xffff)); \

73 (
ipaddr
)->
addr
[2] = 
	`htonl
(((
e
 & 0xffff) << 16) | (
f
 & 0xffff)); \

74 (
ipaddr
)->
addr
[3] = 
	`htonl
(((
g
 & 0xffff) << 16) | (
h
 & 0xffff)); } while(0)

	)

76 
u8_t
 
ip_addr_netcmp
(struct 
ip_addr
 *
addr1
, struct ip_addr *
addr2
,

77 struct 
ip_addr
 *
mask
);

78 
u8_t
 
ip_addr_cmp
(struct 
ip_addr
 *
addr1
, struct ip_addr *
addr2
);

79 void 
ip_addr_set
(struct 
ip_addr
 *
dest
, struct ip_addr *
src
);

80 
u8_t
 
ip_addr_isany
(struct 
ip_addr
 *
addr
);

82 #define 
	#ip_addr_debug_print
(
debug
, 
ipaddr
) \

83 
	`LWIP_DEBUGF
(
debug
, ("%"
X32_F
":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F"\n", \

84 (
	`ntohl
(
ipaddr
->
addr
[0]) >> 16) & 0xffff, \

85 
	`ntohl
(
ipaddr
->
addr
[0]) & 0xffff, \

86 (
	`ntohl
(
ipaddr
->
addr
[1]) >> 16) & 0xffff, \

87 
	`ntohl
(
ipaddr
->
addr
[1]) & 0xffff, \

88 (
	`ntohl
(
ipaddr
->
addr
[2]) >> 16) & 0xffff, \

89 
	`ntohl
(
ipaddr
->
addr
[2]) & 0xffff, \

90 (
	`ntohl
(
ipaddr
->
addr
[3]) >> 16) & 0xffff, \

91 
	`ntohl
(
ipaddr
->
addr
[3]) & 0xffff));

	)

93 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/api.h

32 #ifndef 
__LWIP_API_H__


33 #define 
	#__LWIP_API_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_NETCONN


39 #include 
	~"lwip/netbuf.h
"

40 #include 
	~"lwip/sys.h
"

41 #include 
	~"lwip/ip_addr.h
"

42 #include 
	~"lwip/err.h
"

44 #ifdef 
__cplusplus


53 #define 
	#NETCONN_NOFLAG
 0x00

	)

54 #define 
	#NETCONN_NOCOPY
 0x00

	)

55 #define 
	#NETCONN_COPY
 0x01

	)

56 #define 
	#NETCONN_MORE
 0x02

	)

59 #define 
	#NETCONNTYPE_GROUP
(
t
) (t&0xF0)

	)

60 #define 
	#NETCONNTYPE_DATAGRAM
(
t
) (t&0xE0)

	)

62 enum 
	enetconn_type
 {

63 
NETCONN_INVALID
 = 0,

65 
NETCONN_TCP
 = 0x10,

67 
NETCONN_UDP
 = 0x20,

68 
NETCONN_UDPLITE
 = 0x21,

69 
NETCONN_UDPNOCHKSUM
= 0x22,

71 
NETCONN_RAW
 = 0x40

74 enum 
	enetconn_state
 {

75 
NETCONN_NONE
,

76 
NETCONN_WRITE
,

77 
NETCONN_LISTEN
,

78 
NETCONN_CONNECT
,

79 
NETCONN_CLOSE


82 enum 
	enetconn_evt
 {

83 
NETCONN_EVT_RCVPLUS
,

84 
NETCONN_EVT_RCVMINUS
,

85 
NETCONN_EVT_SENDPLUS
,

86 
NETCONN_EVT_SENDMINUS


89 #if 
LWIP_IGMP


90 enum 
	enetconn_igmp
 {

91 
NETCONN_JOIN
,

92 
NETCONN_LEAVE


97 struct 
ip_pcb
;

98 struct 
tcp_pcb
;

99 struct 
udp_pcb
;

100 struct 
raw_pcb
;

101 struct 
netconn
;

104 typedef void (* 
netconn_callback
)(struct 
	tnetconn
 *, enum 
	tnetconn_evt
, 
	tu16_t
 
	tlen
);

107 struct 
	snetconn
 {

109 enum 
netconn_type
 
type
;

111 enum 
netconn_state
 
state
;

114 struct 
ip_pcb
 *
ip
;

115 struct 
tcp_pcb
 *
tcp
;

116 struct 
udp_pcb
 *
udp
;

117 struct 
raw_pcb
 *
raw
;

118 } 
pcb
;

120 
err_t
 
err
;

122 
sys_sem_t
 
op_completed
;

125 
sys_mbox_t
 
recvmbox
;

128 
sys_mbox_t
 
acceptmbox
;

130 int 
socket
;

131 #if 
LWIP_SO_RCVTIMEO


134 int 
recv_timeout
;

136 #if 
LWIP_SO_RCVBUF


138 int 
recv_bufsize
;

140 
u16_t
 
recv_avail
;

143 struct 
api_msg_msg
 *
write_msg
;

146 int 
write_offset
;

147 #if 
LWIP_TCPIP_CORE_LOCKING


151 
u8_t
 
write_delayed
;

154 
netconn_callback
 
callback
;

158 #define 
	#API_EVENT
(
c
,
e
,
l
) if (c->
callback
) { \

159 (*
c
->
callback
)(c, 
e
, 
l
); \

160 }

	)

163 #define 
	#netconn_new
(
t
) 
	`netconn_new_with_proto_and_callback
(t, 0, 
NULL
)

	)

164 #define 
	#netconn_new_with_callback
(
t
, 
c
) 
	`netconn_new_with_proto_and_callback
(t, 0, c)

	)

166 
netconn
 *
netconn_new_with_proto_and_callback
(enum 
netconn_type
 
t
, 
u8_t
 
proto
,

167 
netconn_callback
 
callback
);

168 
err_t
 
netconn_delete
 (struct 
netconn
 *
conn
);

169 enum 
netconn_type
 netconn_type (struct 
netconn
 *
conn
);

171 
err_t
 
netconn_getaddr
 (struct 
netconn
 *
conn
,

172 struct 
ip_addr
 *
addr
,

173 
u16_t
 *
port
,

174 
u8_t
 
local
);

175 #define 
	#netconn_peer
(
c
,
i
,
p
) 
	`netconn_getaddr
(c,i,p,0)

	)

176 #define 
	#netconn_addr
(
c
,
i
,
p
) 
	`netconn_getaddr
(c,i,p,1)

	)

178 
err_t
 
netconn_bind
 (struct 
netconn
 *
conn
,

179 struct 
ip_addr
 *
addr
,

180 
u16_t
 
port
);

181 
err_t
 
netconn_connect
 (struct 
netconn
 *
conn
,

182 struct 
ip_addr
 *
addr
,

183 
u16_t
 
port
);

184 
err_t
 
netconn_disconnect
 (struct 
netconn
 *
conn
);

185 
err_t
 
netconn_listen_with_backlog
(struct 
netconn
 *
conn
, 
u8_t
 
backlog
);

186 #define 
	#netconn_listen
(
conn
) 
	`netconn_listen_with_backlog
(conn, 
TCP_DEFAULT_LISTEN_BACKLOG
)

	)

187 struct 
netconn
 * 
netconn_accept
 (struct netconn *
conn
);

188 struct 
netbuf
 * 
netconn_recv
 (struct 
netconn
 *
conn
);

189 
err_t
 
netconn_sendto
 (struct 
netconn
 *
conn
,

190 struct 
netbuf
 *
buf
, struct 
ip_addr
 *
addr
, 
u16_t
 
port
);

191 
err_t
 
netconn_send
 (struct 
netconn
 *
conn
,

192 struct 
netbuf
 *
buf
);

193 
err_t
 
netconn_write
 (struct 
netconn
 *
conn
,

194 const void *
dataptr
, int 
size
,

195 
u8_t
 
apiflags
);

196 
err_t
 
netconn_close
 (struct 
netconn
 *
conn
);

198 #if 
LWIP_IGMP


199 
err_t
 
netconn_join_leave_group
 (struct 
netconn
 *
conn
,

200 struct 
ip_addr
 *
multiaddr
,

201 struct 
ip_addr
 *
interface
,

202 enum 
netconn_igmp
 
join_or_leave
);

204 #if 
LWIP_DNS


205 
err_t
 
netconn_gethostbyname
(const char *
name
, struct 
ip_addr
 *
addr
);

208 #define 
	#netconn_err
(
conn
) ((conn)->
err
)

	)

209 #define 
	#netconn_recv_bufsize
(
conn
) ((conn)->
recv_bufsize
)

	)

211 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/api_msg.h

32 #ifndef 
__LWIP_API_MSG_H__


33 #define 
	#__LWIP_API_MSG_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_NETCONN


39 #include 
	~"lwip/ip_addr.h
"

40 #include 
	~"lwip/err.h
"

41 #include 
	~"lwip/sys.h
"

42 #include 
	~"lwip/igmp.h
"

43 #include 
	~"lwip/api.h
"

45 #ifdef 
__cplusplus


55 struct 
	sapi_msg_msg
 {

58 struct 
netconn
 *
conn
;

62 struct 
netbuf
 *
b
;

65 
u8_t
 
proto
;

66 } 
n
;

69 struct 
ip_addr
 *
ipaddr
;

70 
u16_t
 
port
;

71 } 
bc
;

74 struct 
ip_addr
 *
ipaddr
;

75 
u16_t
 *
port
;

76 
u8_t
 
local
;

77 } 
ad
;

80 const void *
dataptr
;

81 int 
len
;

82 
u8_t
 
apiflags
;

83 } 
w
;

86 
u16_t
 
len
;

87 } 
r
;

88 #if 
LWIP_IGMP


91 struct 
ip_addr
 *
multiaddr
;

92 struct 
ip_addr
 *
interface
;

93 enum 
netconn_igmp
 
join_or_leave
;

94 } 
jl
;

96 #if 
TCP_LISTEN_BACKLOG


98 
u8_t
 
backlog
;

99 } 
lb
;

101 } 
msg
;

107 struct 
	sapi_msg
 {

109 void (* 
function
)(struct 
api_msg_msg
 *
msg
);

111 struct 
api_msg_msg
 
msg
;

114 #if 
LWIP_DNS


119 struct 
	sdns_api_msg
 {

121 const char *
name
;

123 struct 
ip_addr
 *
addr
;

126 
sys_sem_t
 
sem
;

128 
err_t
 *
err
;

132 void 
do_newconn
 ( struct 
api_msg_msg
 *
msg
);

133 void 
do_delconn
 ( struct 
api_msg_msg
 *
msg
);

134 void 
do_bind
 ( struct 
api_msg_msg
 *
msg
);

135 void 
do_connect
 ( struct 
api_msg_msg
 *
msg
);

136 void 
do_disconnect
 ( struct 
api_msg_msg
 *
msg
);

137 void 
do_listen
 ( struct 
api_msg_msg
 *
msg
);

138 void 
do_send
 ( struct 
api_msg_msg
 *
msg
);

139 void 
do_recv
 ( struct 
api_msg_msg
 *
msg
);

140 void 
do_write
 ( struct 
api_msg_msg
 *
msg
);

141 void 
do_getaddr
 ( struct 
api_msg_msg
 *
msg
);

142 void 
do_close
 ( struct 
api_msg_msg
 *
msg
);

143 #if 
LWIP_IGMP


144 void 
do_join_leave_group
( struct 
api_msg_msg
 *
msg
);

147 #if 
LWIP_DNS


148 void 
do_gethostbyname
(void *
arg
);

151 struct 
netconn
* 
netconn_alloc
(enum 
netconn_type
 
t
, 
netconn_callback
 
callback
);

152 void 
netconn_free
(struct 
netconn
 *
conn
);

154 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/arch.h

32 #ifndef 
__LWIP_ARCH_H__


33 #define 
	#__LWIP_ARCH_H__


	)

35 #ifndef 
LITTLE_ENDIAN


36 #define 
	#LITTLE_ENDIAN
 1234

	)

39 #ifndef 
BIG_ENDIAN


40 #define 
	#BIG_ENDIAN
 4321

	)

43 #include 
	~"arch/cc.h
"

45 #ifdef 
__cplusplus


49 #ifndef 
PACK_STRUCT_BEGIN


50 #define 
	#PACK_STRUCT_BEGIN


	)

53 #ifndef 
PACK_STRUCT_END


54 #define 
	#PACK_STRUCT_END


	)

57 #ifndef 
PACK_STRUCT_FIELD


58 #define 
	#PACK_STRUCT_FIELD
(
x
) 
	)
x

62 #ifndef 
LWIP_UNUSED_ARG


63 #define 
	#LWIP_UNUSED_ARG
(
x
) (void)
	)
x

67 #ifdef 
LWIP_PROVIDE_ERRNO


69 #define 
	#EPERM
 1

	)

70 #define 
	#ENOENT
 2

	)

71 #define 
	#ESRCH
 3

	)

72 #define 
	#EINTR
 4

	)

73 #define 
	#EIO
 5

	)

74 #define 
	#ENXIO
 6

	)

75 #define 
	#E2BIG
 7

	)

76 #define 
	#ENOEXEC
 8

	)

77 #define 
	#EBADF
 9

	)

78 #define 
	#ECHILD
 10

	)

79 #define 
	#EAGAIN
 11

	)

80 #define 
	#ENOMEM
 12

	)

81 #define 
	#EACCES
 13

	)

82 #define 
	#EFAULT
 14

	)

83 #define 
	#ENOTBLK
 15

	)

84 #define 
	#EBUSY
 16

	)

85 #define 
	#EEXIST
 17

	)

86 #define 
	#EXDEV
 18

	)

87 #define 
	#ENODEV
 19

	)

88 #define 
	#ENOTDIR
 20

	)

89 #define 
	#EISDIR
 21

	)

90 #define 
	#EINVAL
 22

	)

91 #define 
	#ENFILE
 23

	)

92 #define 
	#EMFILE
 24

	)

93 #define 
	#ENOTTY
 25

	)

94 #define 
	#ETXTBSY
 26

	)

95 #define 
	#EFBIG
 27

	)

96 #define 
	#ENOSPC
 28

	)

97 #define 
	#ESPIPE
 29

	)

98 #define 
	#EROFS
 30

	)

99 #define 
	#EMLINK
 31

	)

100 #define 
	#EPIPE
 32

	)

101 #define 
	#EDOM
 33

	)

102 #define 
	#ERANGE
 34

	)

103 #define 
	#EDEADLK
 35

	)

104 #define 
	#ENAMETOOLONG
 36

	)

105 #define 
	#ENOLCK
 37

	)

106 #define 
	#ENOSYS
 38

	)

107 #define 
	#ENOTEMPTY
 39

	)

108 #define 
	#ELOOP
 40

	)

109 #define 
	#EWOULDBLOCK
 
EAGAIN


	)

110 #define 
	#ENOMSG
 42

	)

111 #define 
	#EIDRM
 43

	)

112 #define 
	#ECHRNG
 44

	)

113 #define 
	#EL2NSYNC
 45

	)

114 #define 
	#EL3HLT
 46

	)

115 #define 
	#EL3RST
 47

	)

116 #define 
	#ELNRNG
 48

	)

117 #define 
	#EUNATCH
 49

	)

118 #define 
	#ENOCSI
 50

	)

119 #define 
	#EL2HLT
 51

	)

120 #define 
	#EBADE
 52

	)

121 #define 
	#EBADR
 53

	)

122 #define 
	#EXFULL
 54

	)

123 #define 
	#ENOANO
 55

	)

124 #define 
	#EBADRQC
 56

	)

125 #define 
	#EBADSLT
 57

	)

127 #define 
	#EDEADLOCK
 
EDEADLK


	)

129 #define 
	#EBFONT
 59

	)

130 #define 
	#ENOSTR
 60

	)

131 #define 
	#ENODATA
 61

	)

132 #define 
	#ETIME
 62

	)

133 #define 
	#ENOSR
 63

	)

134 #define 
	#ENONET
 64

	)

135 #define 
	#ENOPKG
 65

	)

136 #define 
	#EREMOTE
 66

	)

137 #define 
	#ENOLINK
 67

	)

138 #define 
	#EADV
 68

	)

139 #define 
	#ESRMNT
 69

	)

140 #define 
	#ECOMM
 70

	)

141 #define 
	#EPROTO
 71

	)

142 #define 
	#EMULTIHOP
 72

	)

143 #define 
	#EDOTDOT
 73

	)

144 #define 
	#EBADMSG
 74

	)

145 #define 
	#EOVERFLOW
 75

	)

146 #define 
	#ENOTUNIQ
 76

	)

147 #define 
	#EBADFD
 77

	)

148 #define 
	#EREMCHG
 78

	)

149 #define 
	#ELIBACC
 79

	)

150 #define 
	#ELIBBAD
 80

	)

151 #define 
	#ELIBSCN
 81

	)

152 #define 
	#ELIBMAX
 82

	)

153 #define 
	#ELIBEXEC
 83

	)

154 #define 
	#EILSEQ
 84

	)

155 #define 
	#ERESTART
 85

	)

156 #define 
	#ESTRPIPE
 86

	)

157 #define 
	#EUSERS
 87

	)

158 #define 
	#ENOTSOCK
 88

	)

159 #define 
	#EDESTADDRREQ
 89

	)

160 #define 
	#EMSGSIZE
 90

	)

161 #define 
	#EPROTOTYPE
 91

	)

162 #define 
	#ENOPROTOOPT
 92

	)

163 #define 
	#EPROTONOSUPPORT
 93

	)

164 #define 
	#ESOCKTNOSUPPORT
 94

	)

165 #define 
	#EOPNOTSUPP
 95

	)

166 #define 
	#EPFNOSUPPORT
 96

	)

167 #define 
	#EAFNOSUPPORT
 97

	)

168 #define 
	#EADDRINUSE
 98

	)

169 #define 
	#EADDRNOTAVAIL
 99

	)

170 #define 
	#ENETDOWN
 100

	)

171 #define 
	#ENETUNREACH
 101

	)

172 #define 
	#ENETRESET
 102

	)

173 #define 
	#ECONNABORTED
 103

	)

174 #define 
	#ECONNRESET
 104

	)

175 #define 
	#ENOBUFS
 105

	)

176 #define 
	#EISCONN
 106

	)

177 #define 
	#ENOTCONN
 107

	)

178 #define 
	#ESHUTDOWN
 108

	)

179 #define 
	#ETOOMANYREFS
 109

	)

180 #define 
	#ETIMEDOUT
 110

	)

181 #define 
	#ECONNREFUSED
 111

	)

182 #define 
	#EHOSTDOWN
 112

	)

183 #define 
	#EHOSTUNREACH
 113

	)

184 #define 
	#EALREADY
 114

	)

185 #define 
	#EINPROGRESS
 115

	)

186 #define 
	#ESTALE
 116

	)

187 #define 
	#EUCLEAN
 117

	)

188 #define 
	#ENOTNAM
 118

	)

189 #define 
	#ENAVAIL
 119

	)

190 #define 
	#EISNAM
 120

	)

191 #define 
	#EREMOTEIO
 121

	)

192 #define 
	#EDQUOT
 122

	)

194 #define 
	#ENOMEDIUM
 123

	)

195 #define 
	#EMEDIUMTYPE
 124

	)

198 #define 
	#ENSROK
 0

	)

199 #define 
	#ENSRNODATA
 160

	)

200 #define 
	#ENSRFORMERR
 161

	)

201 #define 
	#ENSRSERVFAIL
 162

	)

202 #define 
	#ENSRNOTFOUND
 163

	)

203 #define 
	#ENSRNOTIMP
 164

	)

204 #define 
	#ENSRREFUSED
 165

	)

205 #define 
	#ENSRBADQUERY
 166

	)

206 #define 
	#ENSRBADNAME
 167

	)

207 #define 
	#ENSRBADFAMILY
 168

	)

208 #define 
	#ENSRBADRESP
 169

	)

209 #define 
	#ENSRCONNREFUSED
 170

	)

210 #define 
	#ENSRTIMEOUT
 171

	)

211 #define 
	#ENSROF
 172

	)

212 #define 
	#ENSRFILE
 173

	)

213 #define 
	#ENSRNOMEM
 174

	)

214 #define 
	#ENSRDESTRUCTION
 175

	)

215 #define 
	#ENSRQUERYDOMAINTOOLONG
 176

	)

216 #define 
	#ENSRCNAMELOOP
 177

	)

218 #ifndef 
errno


219 extern int 
errno
;

224 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/debug.h

32 #ifndef 
__LWIP_DEBUG_H__


33 #define 
	#__LWIP_DEBUG_H__


	)

35 #include 
	~"lwip/arch.h
"

43 #define 
	#LWIP_DBG_LEVEL_OFF
 0x00

	)

44 #define 
	#LWIP_DBG_LEVEL_WARNING
 0x01

	)

45 #define 
	#LWIP_DBG_LEVEL_SERIOUS
 0x02

	)

46 #define 
	#LWIP_DBG_LEVEL_SEVERE
 0x03

	)

47 #define 
	#LWIP_DBG_MASK_LEVEL
 0x03

	)

50 #define 
	#LWIP_DBG_ON
 0x80U

	)

52 #define 
	#LWIP_DBG_OFF
 0x00U

	)

55 #define 
	#LWIP_DBG_TRACE
 0x40U

	)

57 #define 
	#LWIP_DBG_STATE
 0x20U

	)

59 #define 
	#LWIP_DBG_FRESH
 0x10U

	)

61 #define 
	#LWIP_DBG_HALT
 0x08U

	)

63 #ifndef 
LWIP_NOASSERT


64 #define 
	#LWIP_ASSERT
(
message
, 
assertion
) do { if(!(assertion)) \

65 
	`LWIP_PLATFORM_ASSERT
(
message
); } while(0)

	)

67 #define 
	#LWIP_ASSERT
(
message
, 
assertion
)

	)

71 #ifndef 
LWIP_ERROR


72 #define 
	#LWIP_ERROR
(
message
, 
expression
, 
handler
) do { if (!(expression)) { \

73 
	`LWIP_PLATFORM_ASSERT
(
message
); 
handler
;}} while(0)

	)

76 #ifdef 
LWIP_DEBUG


80 #define 
	#LWIP_DEBUGF
(
debug
, 
message
) do { \

82 ((
debug
) & 
LWIP_DBG_ON
) && \

83 ((
debug
) & 
LWIP_DBG_TYPES_ON
) && \

84 ((
s16_t
)((
debug
) & 
LWIP_DBG_MASK_LEVEL
) >= 
LWIP_DBG_MIN_LEVEL
)) { \

85 
	`LWIP_PLATFORM_DIAG
(
message
); \

86 if ((
debug
) & 
LWIP_DBG_HALT
) { \

90 } while(0)

	)

93 #define 
	#LWIP_DEBUGF
(
debug
, 
message
)

	)

	@/root/Robux/net/lwip/include/lwip/def.h

32 #ifndef 
__LWIP_DEF_H__


33 #define 
	#__LWIP_DEF_H__


	)

36 #include 
	~"lwip/arch.h
"

38 #define 
	#LWIP_MAX
(
x
 , 
y
) (((x) > (y)) ? (x) : (y))

	)

39 #define 
	#LWIP_MIN
(
x
 , 
y
) (((x) < (y)) ? (x) : (y))

	)

41 #ifndef 
NULL


42 #define 
	#NULL
 ((void *)0)

	)

	@/root/Robux/net/lwip/include/lwip/dhcp.h

4 #ifndef 
__LWIP_DHCP_H__


5 #define 
	#__LWIP_DHCP_H__


	)

7 #include 
	~"lwip/opt.h
"

9 #if 
LWIP_DHCP


11 #include 
	~"lwip/netif.h
"

12 #include 
	~"lwip/udp.h
"

14 #ifdef 
__cplusplus


19 #define 
	#DHCP_COARSE_TIMER_SECS
 60

	)

21 #define 
	#DHCP_COARSE_TIMER_MSECS
 (
DHCP_COARSE_TIMER_SECS
*1000)

	)

23 #define 
	#DHCP_FINE_TIMER_MSECS
 500

	)

25 struct 
	sdhcp


28 
u8_t
 
state
;

30 
u8_t
 
tries
;

32 
u32_t
 
xid
;

34 struct 
udp_pcb
 *
pcb
;

36 struct 
pbuf
 *
p
;

38 struct 
dhcp_msg
 *
msg_in
;

40 struct 
dhcp_msg
 *
options_in
;

42 
u16_t
 
options_in_len
;

44 struct 
pbuf
 *
p_out
;

45 struct 
dhcp_msg
 *
msg_out
;

46 
u16_t
 
options_out_len
;

47 
u16_t
 
request_timeout
;

48 
u16_t
 
t1_timeout
;

49 
u16_t
 
t2_timeout
;

50 struct 
ip_addr
 
server_ip_addr
;

51 struct 
ip_addr
 
offered_ip_addr
;

52 struct 
ip_addr
 
offered_sn_mask
;

53 struct 
ip_addr
 
offered_gw_addr
;

54 struct 
ip_addr
 
offered_bc_addr
;

55 #define 
	#DHCP_MAX_DNS
 2

	)

56 
u32_t
 
dns_count
;

57 struct 
ip_addr
 
offered_dns_addr
[
DHCP_MAX_DNS
];

59 
u32_t
 
offered_t0_lease
;

60 
u32_t
 
offered_t1_renew
;

61 
u32_t
 
offered_t2_rebind
;

62 #if 
LWIP_DHCP_AUTOIP_COOP


63 
u8_t
 
autoip_coop_state
;

69 struct 
ip_addr
 
offered_si_addr
;

70 
u8_t
 *
boot_file_name
;

75 #ifdef 
PACK_STRUCT_USE_INCLUDES


76 #include 
	~"arch/bpstruct.h
"

78 
PACK_STRUCT_BEGIN


80 struct 
	sdhcp_msg


82 
PACK_STRUCT_FIELD
(
u8_t
 
op
);

83 
PACK_STRUCT_FIELD
(
u8_t
 
htype
);

84 
PACK_STRUCT_FIELD
(
u8_t
 
hlen
);

85 
PACK_STRUCT_FIELD
(
u8_t
 
hops
);

86 
PACK_STRUCT_FIELD
(
u32_t
 
xid
);

87 
PACK_STRUCT_FIELD
(
u16_t
 
secs
);

88 
PACK_STRUCT_FIELD
(
u16_t
 
flags
);

89 
PACK_STRUCT_FIELD
(struct 
ip_addr
 
ciaddr
);

90 
PACK_STRUCT_FIELD
(struct 
ip_addr
 
yiaddr
);

91 
PACK_STRUCT_FIELD
(struct 
ip_addr
 
siaddr
);

92 
PACK_STRUCT_FIELD
(struct 
ip_addr
 
giaddr
);

93 #define 
	#DHCP_CHADDR_LEN
 16U

	)

94 
PACK_STRUCT_FIELD
(
u8_t
 
chaddr
[
DHCP_CHADDR_LEN
]);

95 #define 
	#DHCP_SNAME_LEN
 64U

	)

96 
PACK_STRUCT_FIELD
(
u8_t
 
sname
[
DHCP_SNAME_LEN
]);

97 #define 
	#DHCP_FILE_LEN
 128U

	)

98 
PACK_STRUCT_FIELD
(
u8_t
 
file
[
DHCP_FILE_LEN
]);

99 
PACK_STRUCT_FIELD
(
u32_t
 
cookie
);

100 #define 
	#DHCP_MIN_OPTIONS_LEN
 68U

	)

102 #if ((
defined
(
DHCP_OPTIONS_LEN
)) && (DHCP_OPTIONS_LEN < 
DHCP_MIN_OPTIONS_LEN
))

103 #undef 
DHCP_OPTIONS_LEN


106 #if (!
defined
(
DHCP_OPTIONS_LEN
))

108 #define 
	#DHCP_OPTIONS_LEN
 
DHCP_MIN_OPTIONS_LEN


	)

110 
PACK_STRUCT_FIELD
(
u8_t
 
options
[
DHCP_OPTIONS_LEN
]);

111 } 
PACK_STRUCT_STRUCT
;

112 
PACK_STRUCT_END


113 #ifdef 
PACK_STRUCT_USE_INCLUDES


114 #include 
	~"arch/epstruct.h
"

118 
err_t
 
dhcp_start
(struct 
netif
 *netif);

120 
err_t
 
dhcp_renew
(struct 
netif
 *netif);

122 
err_t
 
dhcp_release
(struct 
netif
 *netif);

124 void 
dhcp_stop
(struct 
netif
 *netif);

126 void 
dhcp_inform
(struct 
netif
 *netif);

129 #if 
DHCP_DOES_ARP_CHECK


130 void 
dhcp_arp_reply
(struct 
netif
 *netif, struct 
ip_addr
 *
addr
);

134 void 
dhcp_coarse_tmr
(void);

136 void 
dhcp_fine_tmr
(void);

139 #define 
	#DHCP_MSG_OFS
 (
UDP_DATA_OFS
)

	)

140 #define 
	#DHCP_OP_OFS
 (
DHCP_MSG_OFS
 + 0)

	)

141 #define 
	#DHCP_HTYPE_OFS
 (
DHCP_MSG_OFS
 + 1)

	)

142 #define 
	#DHCP_HLEN_OFS
 (
DHCP_MSG_OFS
 + 2)

	)

143 #define 
	#DHCP_HOPS_OFS
 (
DHCP_MSG_OFS
 + 3)

	)

144 #define 
	#DHCP_XID_OFS
 (
DHCP_MSG_OFS
 + 4)

	)

145 #define 
	#DHCP_SECS_OFS
 (
DHCP_MSG_OFS
 + 8)

	)

146 #define 
	#DHCP_FLAGS_OFS
 (
DHCP_MSG_OFS
 + 10)

	)

147 #define 
	#DHCP_CIADDR_OFS
 (
DHCP_MSG_OFS
 + 12)

	)

148 #define 
	#DHCP_YIADDR_OFS
 (
DHCP_MSG_OFS
 + 16)

	)

149 #define 
	#DHCP_SIADDR_OFS
 (
DHCP_MSG_OFS
 + 20)

	)

150 #define 
	#DHCP_GIADDR_OFS
 (
DHCP_MSG_OFS
 + 24)

	)

151 #define 
	#DHCP_CHADDR_OFS
 (
DHCP_MSG_OFS
 + 28)

	)

152 #define 
	#DHCP_SNAME_OFS
 (
DHCP_MSG_OFS
 + 44)

	)

153 #define 
	#DHCP_FILE_OFS
 (
DHCP_MSG_OFS
 + 108)

	)

154 #define 
	#DHCP_MSG_LEN
 236

	)

156 #define 
	#DHCP_COOKIE_OFS
 (
DHCP_MSG_OFS
 + 
DHCP_MSG_LEN
)

	)

157 #define 
	#DHCP_OPTIONS_OFS
 (
DHCP_MSG_OFS
 + 
DHCP_MSG_LEN
 + 4)

	)

159 #define 
	#DHCP_CLIENT_PORT
 68

	)

160 #define 
	#DHCP_SERVER_PORT
 67

	)

163 #define 
	#DHCP_REQUESTING
 1

	)

164 #define 
	#DHCP_INIT
 2

	)

165 #define 
	#DHCP_REBOOTING
 3

	)

166 #define 
	#DHCP_REBINDING
 4

	)

167 #define 
	#DHCP_RENEWING
 5

	)

168 #define 
	#DHCP_SELECTING
 6

	)

169 #define 
	#DHCP_INFORMING
 7

	)

170 #define 
	#DHCP_CHECKING
 8

	)

171 #define 
	#DHCP_PERMANENT
 9

	)

172 #define 
	#DHCP_BOUND
 10

	)

174 #define 
	#DHCP_BACKING_OFF
 12

	)

175 #define 
	#DHCP_OFF
 13

	)

178 #define 
	#DHCP_AUTOIP_COOP_STATE_OFF
 0

	)

179 #define 
	#DHCP_AUTOIP_COOP_STATE_ON
 1

	)

181 #define 
	#DHCP_BOOTREQUEST
 1

	)

182 #define 
	#DHCP_BOOTREPLY
 2

	)

184 #define 
	#DHCP_DISCOVER
 1

	)

185 #define 
	#DHCP_OFFER
 2

	)

186 #define 
	#DHCP_REQUEST
 3

	)

187 #define 
	#DHCP_DECLINE
 4

	)

188 #define 
	#DHCP_ACK
 5

	)

189 #define 
	#DHCP_NAK
 6

	)

190 #define 
	#DHCP_RELEASE
 7

	)

191 #define 
	#DHCP_INFORM
 8

	)

193 #define 
	#DHCP_HTYPE_ETH
 1

	)

195 #define 
	#DHCP_HLEN_ETH
 6

	)

197 #define 
	#DHCP_BROADCAST_FLAG
 15

	)

198 #define 
	#DHCP_BROADCAST_MASK
 (1 << 
DHCP_FLAG_BROADCAST
)

	)

201 #define 
	#DHCP_OPTION_PAD
 0

	)

202 #define 
	#DHCP_OPTION_SUBNET_MASK
 1

	)

203 #define 
	#DHCP_OPTION_ROUTER
 3

	)

204 #define 
	#DHCP_OPTION_DNS_SERVER
 6

	)

205 #define 
	#DHCP_OPTION_HOSTNAME
 12

	)

206 #define 
	#DHCP_OPTION_IP_TTL
 23

	)

207 #define 
	#DHCP_OPTION_MTU
 26

	)

208 #define 
	#DHCP_OPTION_BROADCAST
 28

	)

209 #define 
	#DHCP_OPTION_TCP_TTL
 37

	)

210 #define 
	#DHCP_OPTION_END
 255

	)

213 #define 
	#DHCP_OPTION_REQUESTED_IP
 50

	)

214 #define 
	#DHCP_OPTION_LEASE_TIME
 51

	)

215 #define 
	#DHCP_OPTION_OVERLOAD
 52

	)

217 #define 
	#DHCP_OPTION_MESSAGE_TYPE
 53

	)

218 #define 
	#DHCP_OPTION_MESSAGE_TYPE_LEN
 1

	)

221 #define 
	#DHCP_OPTION_SERVER_ID
 54

	)

222 #define 
	#DHCP_OPTION_PARAMETER_REQUEST_LIST
 55

	)

224 #define 
	#DHCP_OPTION_MAX_MSG_SIZE
 57

	)

225 #define 
	#DHCP_OPTION_MAX_MSG_SIZE_LEN
 2

	)

227 #define 
	#DHCP_OPTION_T1
 58

	)

228 #define 
	#DHCP_OPTION_T2
 59

	)

229 #define 
	#DHCP_OPTION_US
 60

	)

230 #define 
	#DHCP_OPTION_CLIENT_ID
 61

	)

231 #define 
	#DHCP_OPTION_TFTP_SERVERNAME
 66

	)

232 #define 
	#DHCP_OPTION_BOOTFILE
 67

	)

235 #define 
	#DHCP_OVERLOAD_NONE
 0

	)

236 #define 
	#DHCP_OVERLOAD_FILE
 1

	)

237 #define 
	#DHCP_OVERLOAD_SNAME
 2

	)

238 #define 
	#DHCP_OVERLOAD_SNAME_FILE
 3

	)

240 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/dns.h

34 #ifndef 
__LWIP_DNS_H__


35 #define 
	#__LWIP_DNS_H__


	)

37 #include 
	~"lwip/opt.h
"

39 #if 
LWIP_DNS


42 #define 
	#DNS_TMR_INTERVAL
 1000

	)

45 #define 
	#DNS_RRTYPE_A
 1

	)

46 #define 
	#DNS_RRTYPE_NS
 2

	)

47 #define 
	#DNS_RRTYPE_MD
 3

	)

48 #define 
	#DNS_RRTYPE_MF
 4

	)

49 #define 
	#DNS_RRTYPE_CNAME
 5

	)

50 #define 
	#DNS_RRTYPE_SOA
 6

	)

51 #define 
	#DNS_RRTYPE_MB
 7

	)

52 #define 
	#DNS_RRTYPE_MG
 8

	)

53 #define 
	#DNS_RRTYPE_MR
 9

	)

54 #define 
	#DNS_RRTYPE_NULL
 10

	)

55 #define 
	#DNS_RRTYPE_WKS
 11

	)

56 #define 
	#DNS_RRTYPE_PTR
 12

	)

57 #define 
	#DNS_RRTYPE_HINFO
 13

	)

58 #define 
	#DNS_RRTYPE_MINFO
 14

	)

59 #define 
	#DNS_RRTYPE_MX
 15

	)

60 #define 
	#DNS_RRTYPE_TXT
 16

	)

63 #define 
	#DNS_RRCLASS_IN
 1

	)

64 #define 
	#DNS_RRCLASS_CS
 2

	)

65 #define 
	#DNS_RRCLASS_CH
 3

	)

66 #define 
	#DNS_RRCLASS_HS
 4

	)

67 #define 
	#DNS_RRCLASS_FLUSH
 0x800

	)

76 typedef void (*
	tdns_found_callback
)(const char *
	tname
, struct 
	tip_addr
 *
	tipaddr
, void *
	tcallback_arg
);

79 void 
	`dns_init
(void);

81 void 
	`dns_tmr
(void);

83 void 
	`dns_setserver
(
u8_t
 
numdns
, struct 
ip_addr
 *
dnsserver
);

85 struct 
ip_addr
 
	`dns_getserver
(
u8_t
 
numdns
);

87 
err_t
 
	`dns_gethostbyname
(const char *
hostname
, struct 
ip_addr
 *
addr
,

88 
dns_found_callback
 
found
, void *
callback_arg
);

	@/root/Robux/net/lwip/include/lwip/err.h

32 #ifndef 
__LWIP_ERR_H__


33 #define 
	#__LWIP_ERR_H__


	)

35 #include 
	~"lwip/opt.h
"

36 #include 
	~"lwip/arch.h
"

38 #ifdef 
__cplusplus


44 #ifdef 
LWIP_ERR_T


45 typedef 
LWIP_ERR_T
 
	terr_t
;

47 typedef 
s8_t
 
	terr_t
;

52 #define 
	#ERR_OK
 0

	)

53 #define 
	#ERR_MEM
 -1

	)

54 #define 
	#ERR_BUF
 -2

	)

55 #define 
	#ERR_TIMEOUT
 -3

	)

56 #define 
	#ERR_RTE
 -4

	)

58 #define 
	#ERR_IS_FATAL
(
e
) ((e) < 
ERR_RTE
)

	)

60 #define 
	#ERR_ABRT
 -5

	)

61 #define 
	#ERR_RST
 -6

	)

62 #define 
	#ERR_CLSD
 -7

	)

63 #define 
	#ERR_CONN
 -8

	)

65 #define 
	#ERR_VAL
 -9

	)

67 #define 
	#ERR_ARG
 -10

	)

69 #define 
	#ERR_USE
 -11

	)

71 #define 
	#ERR_IF
 -12

	)

72 #define 
	#ERR_ISCONN
 -13

	)

74 #define 
	#ERR_INPROGRESS
 -14

	)

77 #ifdef 
LWIP_DEBUG


78 extern const char *
lwip_strerr
(
err_t
 
err
);

80 #define 
	#lwip_strerr
(
x
) ""

	)

83 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/init.h

32 #ifndef 
__LWIP_INIT_H__


33 #define 
	#__LWIP_INIT_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #ifdef 
__cplusplus


42 void 
lwip_init
(void);

44 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/mem.h

32 #ifndef 
__LWIP_MEM_H__


33 #define 
	#__LWIP_MEM_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #ifdef 
__cplusplus


41 #if 
MEM_LIBC_MALLOC


43 #include 
	~<stddef.h
>

45 typedef 
size_t
 
	tmem_size_t
;

48 #define 
	#mem_init
()

	)

52 #ifndef 
mem_free


53 #define 
	#mem_free
 
free


	)

55 #ifndef 
mem_malloc


56 #define 
	#mem_malloc
 
malloc


	)

58 #ifndef 
mem_calloc


59 #define 
	#mem_calloc
 
calloc


	)

61 #ifndef 
mem_realloc


62 #define 
	#mem_realloc
 
realloc


	)

69 #if 
MEM_SIZE
 > 64000l

70 typedef 
u32_t
 
	tmem_size_t
;

72 typedef 
u16_t
 
	tmem_size_t
;

75 #if 
MEM_USE_POOLS


77 #define 
	#mem_init
()

	)

80 #define 
	#mem_realloc
(
mem
, 
size
) (mem)

	)

83 void 
mem_init
(void);

84 void *
mem_realloc
(void *
mem
, 
mem_size_t
 
size
);

86 void *
mem_malloc
(
mem_size_t
 
size
);

87 void *
mem_calloc
(
mem_size_t
 
count
, mem_size_t 
size
);

88 void 
mem_free
(void *
mem
);

91 #ifndef 
LWIP_MEM_ALIGN_SIZE


92 #define 
	#LWIP_MEM_ALIGN_SIZE
(
size
) (((size) + 
MEM_ALIGNMENT
 - 1) & ~(MEM_ALIGNMENT-1))

	)

95 #ifndef 
LWIP_MEM_ALIGN


96 #define 
	#LWIP_MEM_ALIGN
(
addr
) ((void *)(((
mem_ptr_t
)(addr) + 
MEM_ALIGNMENT
 - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))

	)

99 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/memp.h

33 #ifndef 
__LWIP_MEMP_H__


34 #define 
	#__LWIP_MEMP_H__


	)

36 #include 
	~"lwip/opt.h
"

38 #ifdef 
__cplusplus


44 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
) 
MEMP_
##name,

	)

45 #include 
	~"lwip/memp_std.h
"

46 
MEMP_MAX


47 } 
	tmemp_t
;

49 #if 
MEM_USE_POOLS


54 
MEMP_POOL_HELPER_FIRST
 = ((
u8_t
)

55 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
)

	)

56 #define 
	#LWIP_MALLOC_MEMPOOL_START
 1

	)

57 #define 
	#LWIP_MALLOC_MEMPOOL
(
num
, 
size
) * 
MEMP_POOL_
##size + 0

	)

58 #define 
	#LWIP_MALLOC_MEMPOOL_END


	)

59 #include 
	~"lwip/memp_std.h
"

63 
MEMP_POOL_HELPER_LAST
 = ((
u8_t
)

64 #define 
	#LWIP_MEMPOOL
(
name
,
num
,
size
,
desc
)

	)

65 #define 
	#LWIP_MALLOC_MEMPOOL_START


	)

66 #define 
	#LWIP_MALLOC_MEMPOOL
(
num
, 
size
) 0 + 
MEMP_POOL_
##size *

	)

67 #define 
	#LWIP_MALLOC_MEMPOOL_END
 1

	)

68 #include 
	~"lwip/memp_std.h
"

70 } 
	tmemp_pool_helper_t
;

74 #define 
	#MEMP_POOL_FIRST
 ((
memp_t
) 
MEMP_POOL_HELPER_FIRST
)

	)

75 #define 
	#MEMP_POOL_LAST
 ((
memp_t
) 
MEMP_POOL_HELPER_LAST
)

	)

77 extern const 
u16_t
 
memp_sizes
[
MEMP_MAX
];

80 void 
memp_init
(void);

82 #if 
MEMP_OVERFLOW_CHECK


83 void *
memp_malloc_fn
(
memp_t
 
type
, const char* 
file
, const int 
line
);

84 #define 
	#memp_malloc
(
t
) 
	`memp_malloc_fn
((t), 
__FILE__
, 
__LINE__
)

	)

86 void *
memp_malloc
(
memp_t
 
type
);

88 void 
memp_free
(
memp_t
 
type
, void *
mem
);

90 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/memp_std.h

12 #ifndef 
LWIP_MALLOC_MEMPOOL


14 #define 
	#LWIP_MALLOC_MEMPOOL
(
num
, 
size
) 
	`LWIP_MEMPOOL
(
POOL_
##size, num, size, "MALLOC_"#size)

	)

15 #define 
	#LWIP_MALLOC_MEMPOOL_START


	)

16 #define 
	#LWIP_MALLOC_MEMPOOL_END


	)

19 #ifndef 
LWIP_PBUF_MEMPOOL


22 #define 
	#LWIP_PBUF_MEMPOOL
(
name
, 
num
, 
payload
, 
desc
) 
	`LWIP_MEMPOOL
(name, num, (
	`MEMP_ALIGN_SIZE
(sizeof(struct 
pbuf
)) + MEMP_ALIGN_SIZE(payload)), desc)

	)

32 #if 
LWIP_RAW


33 
LWIP_MEMPOOL
(
RAW_PCB
, 
MEMP_NUM_RAW_PCB
, sizeof(struct 
raw_pcb
), "RAW_PCB")

36 #if 
LWIP_UDP


37 
LWIP_MEMPOOL
(
UDP_PCB
, 
MEMP_NUM_UDP_PCB
, sizeof(struct 
udp_pcb
), "UDP_PCB")

40 #if 
LWIP_TCP


41 
LWIP_MEMPOOL
(
TCP_PCB
, 
MEMP_NUM_TCP_PCB
, sizeof(struct 
tcp_pcb
), "TCP_PCB")

42 
LWIP_MEMPOOL
(
TCP_PCB_LISTEN
, 
MEMP_NUM_TCP_PCB_LISTEN
, sizeof(struct 
tcp_pcb_listen
), "TCP_PCB_LISTEN")

43 
LWIP_MEMPOOL
(
TCP_SEG
, 
MEMP_NUM_TCP_SEG
, sizeof(struct 
tcp_seg
), "TCP_SEG")

46 #if 
IP_REASSEMBLY


47 
LWIP_MEMPOOL
(
REASSDATA
, 
MEMP_NUM_REASSDATA
, sizeof(struct 
ip_reassdata
), "REASSDATA")

50 #if 
LWIP_NETCONN


51 
LWIP_MEMPOOL
(
NETBUF
, 
MEMP_NUM_NETBUF
, sizeof(struct 
netbuf
), "NETBUF")

52 
LWIP_MEMPOOL
(
NETCONN
, 
MEMP_NUM_NETCONN
, sizeof(struct 
netconn
), "NETCONN")

55 #if 
NO_SYS
==0

56 
LWIP_MEMPOOL
(
TCPIP_MSG_API
, 
MEMP_NUM_TCPIP_MSG_API
, sizeof(struct 
tcpip_msg
), "TCPIP_MSG_API")

57 
LWIP_MEMPOOL
(
TCPIP_MSG_INPKT
,
MEMP_NUM_TCPIP_MSG_INPKT
, sizeof(struct 
tcpip_msg
), "TCPIP_MSG_INPKT")

60 #if 
ARP_QUEUEING


61 
LWIP_MEMPOOL
(
ARP_QUEUE
, 
MEMP_NUM_ARP_QUEUE
, sizeof(struct 
etharp_q_entry
), "ARP_QUEUE")

64 #if 
LWIP_IGMP


65 
LWIP_MEMPOOL
(
IGMP_GROUP
, 
MEMP_NUM_IGMP_GROUP
, sizeof(struct 
igmp_group
), "IGMP_GROUP")

68 #if 
NO_SYS
==0

69 
LWIP_MEMPOOL
(
SYS_TIMEOUT
, 
MEMP_NUM_SYS_TIMEOUT
, sizeof(struct 
sys_timeo
), "SYS_TIMEOUT")

81 
LWIP_PBUF_MEMPOOL
(
PBUF
, 
MEMP_NUM_PBUF
, 0, "PBUF_REF/ROM")

82 
LWIP_PBUF_MEMPOOL
(
PBUF_POOL
, 
PBUF_POOL_SIZE
, 
PBUF_POOL_BUFSIZE
, "PBUF_POOL")

89 #if 
MEMP_USE_CUSTOM_POOLS


90 #include 
	~"lwippools.h
"

97 #undef 
LWIP_MEMPOOL


98 #undef 
LWIP_MALLOC_MEMPOOL


99 #undef 
LWIP_MALLOC_MEMPOOL_START


100 #undef 
LWIP_MALLOC_MEMPOOL_END


101 #undef 
LWIP_PBUF_MEMPOOL


	@/root/Robux/net/lwip/include/lwip/netbuf.h

32 #ifndef 
__LWIP_NETBUF_H__


33 #define 
	#__LWIP_NETBUF_H__


	)

35 #include 
	~"lwip/opt.h
"

36 #include 
	~"lwip/pbuf.h
"

38 #ifdef 
__cplusplus


42 struct 
	snetbuf
 {

43 struct 
pbuf
 *
p
, *
ptr
;

44 struct 
ip_addr
 *
addr
;

45 
u16_t
 
port
;

49 struct 
netbuf
 * 
netbuf_new
 (void);

50 void 
netbuf_delete
 (struct 
netbuf
 *
buf
);

51 void * 
netbuf_alloc
 (struct 
netbuf
 *
buf
, 
u16_t
 
size
);

52 void 
netbuf_free
 (struct 
netbuf
 *
buf
);

53 
err_t
 
netbuf_ref
 (struct 
netbuf
 *
buf
,

54 const void *
dataptr
, 
u16_t
 
size
);

55 void 
netbuf_chain
 (struct 
netbuf
 *
head
,

56 struct 
netbuf
 *
tail
);

58 
u16_t
 
netbuf_len
 (struct 
netbuf
 *
buf
);

59 
err_t
 
netbuf_data
 (struct 
netbuf
 *
buf
,

60 void **
dataptr
, 
u16_t
 *
len
);

61 
s8_t
 
netbuf_next
 (struct 
netbuf
 *
buf
);

62 void 
netbuf_first
 (struct 
netbuf
 *
buf
);

65 #define 
	#netbuf_copy_partial
(
buf
, 
dataptr
, 
len
, 
offset
) \

66 
	`pbuf_copy_partial
((
buf
)->
p
, (
dataptr
), (
len
), (
offset
))

	)

67 #define 
	#netbuf_copy
(
buf
,
dataptr
,
len
) 
	`netbuf_copy_partial
(buf, dataptr, len, 0)

	)

68 #define 
	#netbuf_len
(
buf
) ((buf)->
p
->
tot_len
)

	)

69 #define 
	#netbuf_fromaddr
(
buf
) ((buf)->
addr
)

	)

70 #define 
	#netbuf_fromport
(
buf
) ((buf)->
port
)

	)

72 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/netdb.h

30 #include 
	~"lwip/opt.h
"

32 #if 
LWIP_DNS
 && 
LWIP_SOCKET


34 #include 
	~"lwip/sockets.h
"

37 #ifndef 
LWIP_DNS_API_DECLARE_H_ERRNO


38 #define 
	#LWIP_DNS_API_DECLARE_H_ERRNO
 1

	)

41 #ifndef 
LWIP_DNS_API_DEFINE_ERRORS


42 #define 
	#LWIP_DNS_API_DEFINE_ERRORS
 1

	)

45 #ifndef 
LWIP_DNS_API_DECLARE_STRUCTS


46 #define 
	#LWIP_DNS_API_DECLARE_STRUCTS
 1

	)

49 #if 
LWIP_DNS_API_DEFINE_ERRORS


51 #define 
	#EAI_NONAME
 200

	)

52 #define 
	#EAI_SERVICE
 201

	)

53 #define 
	#EAI_FAIL
 202

	)

54 #define 
	#EAI_MEMORY
 203

	)

56 #define 
	#HOST_NOT_FOUND
 210

	)

57 #define 
	#NO_DATA
 211

	)

58 #define 
	#NO_RECOVERY
 212

	)

59 #define 
	#TRY_AGAIN
 213

	)

62 #if 
LWIP_DNS_API_DECLARE_STRUCTS


63 struct 
	shostent
 {

64 char *
	mh_name
;

65 char **
	mh_aliases
;

67 int 
	mh_addrtype
;

68 int 
	mh_length
;

69 char **
	mh_addr_list
;

71 #define 
	#h_addr
 
h_addr_list
[0]

	)

74 struct 
	saddrinfo
 {

75 int 
	mai_flags
;

76 int 
	mai_family
;

77 int 
	mai_socktype
;

78 int 
	mai_protocol
;

79 
socklen_t
 
	mai_addrlen
;

80 struct 
sockaddr
 *
	mai_addr
;

81 char *
	mai_canonname
;

82 struct 
addrinfo
 *
	mai_next
;

86 #if 
LWIP_DNS_API_DECLARE_H_ERRNO


88 extern int 
h_errno
;

91 struct 
hostent
 *
lwip_gethostbyname
(const char *
name
);

92 int 
lwip_gethostbyname_r
(const char *
name
, struct 
hostent
 *
ret
, char *
buf
,

93 
size_t
 
buflen
, struct 
hostent
 **
result
, int *
h_errnop
);

94 void 
lwip_freeaddrinfo
(struct 
addrinfo
 *
ai
);

95 int 
lwip_getaddrinfo
(const char *
nodename
,

96 const char *
servname
,

97 const struct 
addrinfo
 *
hints
,

98 struct 
addrinfo
 **
res
);

100 #if 
LWIP_COMPAT_SOCKETS


101 #define 
	#gethostbyname
(
name
) 
	`lwip_gethostbyname
(name)

	)

102 #define 
	#gethostbyname_r
(
name
, 
ret
, 
buf
, 
buflen
, 
result
, 
h_errnop
) \

103 
	`lwip_gethostbyname_r
(
name
, 
ret
, 
buf
, 
buflen
, 
result
, 
h_errnop
)

	)

104 #define 
	#freeaddrinfo
(
addrinfo
) 
	`lwip_freeaddrinfo
(
a
)

	)

105 #define 
	#getaddrinfo
(
nodname
, 
servname
, 
hints
, 
res
) \

106 
	`lwip_getaddrinfo
(
nodname
, 
servname
, 
hints
, 
res
)

	)

	@/root/Robux/net/lwip/include/lwip/netif.h

32 #ifndef 
__LWIP_NETIF_H__


33 #define 
	#__LWIP_NETIF_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #define 
	#ENABLE_LOOPBACK
 (
LWIP_NETIF_LOOPBACK
 || 
LWIP_HAVE_LOOPIF
)

	)

39 #include 
	~"lwip/err.h
"

41 #include 
	~"lwip/ip_addr.h
"

43 #include 
	~"lwip/inet.h
"

44 #include 
	~"lwip/pbuf.h
"

45 #if 
LWIP_DHCP


46 struct 
	gdhcp
;

48 #if 
LWIP_AUTOIP


49 struct 
	gautoip
;

52 #ifdef 
__cplusplus


61 #define 
	#NETIF_MAX_HWADDR_LEN
 6U

	)

69 #define 
	#NETIF_FLAG_UP
 0x01U

	)

71 #define 
	#NETIF_FLAG_BROADCAST
 0x02U

	)

73 #define 
	#NETIF_FLAG_POINTTOPOINT
 0x04U

	)

75 #define 
	#NETIF_FLAG_DHCP
 0x08U

	)

78 #define 
	#NETIF_FLAG_LINK_UP
 0x10U

	)

80 #define 
	#NETIF_FLAG_ETHARP
 0x20U

	)

82 #define 
	#NETIF_FLAG_IGMP
 0x40U

	)

88 struct 
	snetif
 {

90 struct 
netif
 *
next
;

93 struct 
ip_addr
 ip_addr;

94 struct 
ip_addr
 
netmask
;

95 struct 
ip_addr
 
gw
;

99 
err_t
 (* 
input
)(struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

103 
err_t
 (* 
output
)(struct 
netif
 *netif, struct 
pbuf
 *
p
,

104 struct 
ip_addr
 *
ipaddr
);

108 
err_t
 (* 
linkoutput
)(struct 
netif
 *netif, struct 
pbuf
 *
p
);

109 #if 
LWIP_NETIF_STATUS_CALLBACK


112 void (* 
status_callback
)(struct 
netif
 *netif);

114 #if 
LWIP_NETIF_LINK_CALLBACK


117 void (* 
link_callback
)(struct 
netif
 *netif);

121 void *
state
;

122 #if 
LWIP_DHCP


124 struct 
dhcp
 *dhcp;

126 #if 
LWIP_AUTOIP


128 struct 
autoip
 *autoip;

130 #if 
LWIP_NETIF_HOSTNAME


132 char* 
hostname
;

135 
u8_t
 
hwaddr_len
;

137 
u8_t
 
hwaddr
[
NETIF_MAX_HWADDR_LEN
];

139 
u16_t
 
mtu
;

141 
u8_t
 
flags
;

143 char 
name
[2];

145 
u8_t
 
num
;

146 #if 
LWIP_SNMP


148 
u8_t
 
link_type
;

150 
u32_t
 
link_speed
;

152 
u32_t
 
ts
;

154 
u32_t
 
ifinoctets
;

155 
u32_t
 
ifinucastpkts
;

156 
u32_t
 
ifinnucastpkts
;

157 
u32_t
 
ifindiscards
;

158 
u32_t
 
ifoutoctets
;

159 
u32_t
 
ifoutucastpkts
;

160 
u32_t
 
ifoutnucastpkts
;

161 
u32_t
 
ifoutdiscards
;

163 #if 
LWIP_IGMP


165 
err_t
 (*
igmp_mac_filter
)( struct 
netif
 *netif, struct 
ip_addr
 *
group
, 
u8_t
 
action
);

167 #if 
LWIP_NETIF_HWADDRHINT


168 
u8_t
 *
addr_hint
;

170 #if 
ENABLE_LOOPBACK


172 struct 
pbuf
 *
loop_first
;

173 struct 
pbuf
 *
loop_last
;

174 #if 
LWIP_LOOPBACK_MAX_PBUFS


175 
u16_t
 
loop_cnt_current
;

180 #if 
LWIP_SNMP


181 #define 
	#NETIF_INIT_SNMP
(
netif
, 
type
, 
speed
) \

183 
netif
->
link_type
 = 
type
; \

185 
netif
->
link_speed
 = 
speed
; \

186 
netif
->
ts
 = 0; \

187 
netif
->
ifinoctets
 = 0; \

188 
netif
->
ifinucastpkts
 = 0; \

189 
netif
->
ifinnucastpkts
 = 0; \

190 
netif
->
ifindiscards
 = 0; \

191 
netif
->
ifoutoctets
 = 0; \

192 
netif
->
ifoutucastpkts
 = 0; \

193 
netif
->
ifoutnucastpkts
 = 0; \

194 
netif
->
ifoutdiscards
 = 0

	)

196 #define 
	#NETIF_INIT_SNMP
(
netif
, 
type
, 
speed
)

	)

201 extern struct 
netif
 *
netif_list
;

203 extern struct 
netif
 *
netif_default
;

205 #define 
	#netif_init
()

	)

207 struct 
netif
 *
netif_add
(struct netif *netif, struct 
ip_addr
 *
ipaddr
, struct ip_addr *
netmask
,

208 struct 
ip_addr
 *
gw
,

209 void *
state
,

210 
err_t
 (* 
init
)(struct 
netif
 *netif),

211 
err_t
 (* 
input
)(struct 
pbuf
 *
p
, struct 
netif
 *netif));

214 
netif_set_addr
(struct 
netif
 *netif,struct 
ip_addr
 *
ipaddr
, struct ip_addr *
netmask
,

215 struct 
ip_addr
 *
gw
);

216 void 
netif_remove
(struct 
netif
 * netif);

222 struct 
netif
 *
netif_find
(char *
name
);

224 void 
netif_set_default
(struct 
netif
 *netif);

226 void 
netif_set_ipaddr
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
);

227 void 
netif_set_netmask
(struct 
netif
 *netif, struct 
ip_addr
 *
netmask
);

228 void 
netif_set_gw
(struct 
netif
 *netif, struct 
ip_addr
 *
gw
);

230 void 
netif_set_up
(struct 
netif
 *netif);

231 void 
netif_set_down
(struct 
netif
 *netif);

232 
u8_t
 
netif_is_up
(struct 
netif
 *netif);

234 #if 
LWIP_NETIF_STATUS_CALLBACK


238 void 
netif_set_status_callback
(struct 
netif
 *netif, void (* 
status_callback
)(struct netif *netif));

241 #if 
LWIP_NETIF_LINK_CALLBACK


242 void 
netif_set_link_up
(struct 
netif
 *netif);

243 void 
netif_set_link_down
(struct 
netif
 *netif);

244 
u8_t
 
netif_is_link_up
(struct 
netif
 *netif);

248 void 
netif_set_link_callback
(struct 
netif
 *netif, void (* 
link_callback
)(struct netif *netif));

251 #ifdef 
__cplusplus


255 #if 
ENABLE_LOOPBACK


256 
err_t
 
netif_loop_output
(struct 
netif
 *netif, struct 
pbuf
 *
p
, struct 
ip_addr
 *
dest_ip
);

257 void 
netif_poll
(struct 
netif
 *netif);

258 #if !
LWIP_NETIF_LOOPBACK_MULTITHREADING


259 void 
netif_poll_all
(void);

	@/root/Robux/net/lwip/include/lwip/netifapi.h

28 #ifndef 
__LWIP_NETIFAPI_H__


29 #define 
	#__LWIP_NETIFAPI_H__


	)

31 #include 
	~"lwip/opt.h
"

33 #if 
LWIP_NETIF_API


35 #include 
	~"lwip/sys.h
"

36 #include 
	~"lwip/netif.h
"

37 #include 
	~"lwip/dhcp.h
"

38 #include 
	~"lwip/autoip.h
"

40 #ifdef 
__cplusplus


44 struct 
	snetifapi_msg_msg
 {

45 #if !
LWIP_TCPIP_CORE_LOCKING


46 
sys_sem_t
 
sem
;

48 
err_t
 
err
;

49 struct 
netif
 *netif;

52 struct 
ip_addr
 *
ipaddr
;

53 struct 
ip_addr
 *
netmask
;

54 struct 
ip_addr
 *
gw
;

55 void *
state
;

56 
err_t
 (* 
init
) (struct 
netif
 *netif);

57 
err_t
 (* 
input
)(struct 
pbuf
 *
p
, struct 
netif
 *netif);

58 } 
add
;

60 void (* 
voidfunc
)(struct 
netif
 *netif);

61 
err_t
 (* 
errtfunc
)(struct 
netif
 *netif);

62 } 
common
;

63 } 
msg
;

66 struct 
	snetifapi_msg
 {

67 void (* 
function
)(struct 
netifapi_msg_msg
 *
msg
);

68 struct 
netifapi_msg_msg
 
msg
;

73 
err_t
 
netifapi_netif_add
 ( struct 
netif
 *netif,

74 struct 
ip_addr
 *
ipaddr
,

75 struct 
ip_addr
 *
netmask
,

76 struct 
ip_addr
 *
gw
,

77 void *
state
,

78 
err_t
 (* 
init
)(struct 
netif
 *netif),

79 
err_t
 (* 
input
)(struct 
pbuf
 *
p
, struct 
netif
 *netif) );

81 
err_t
 
netifapi_netif_common
 ( struct 
netif
 *netif,

82 void (* 
voidfunc
)(struct 
netif
 *netif),

83 
err_t
 (* 
errtfunc
)(struct 
netif
 *netif) );

85 #define 
	#netifapi_netif_remove
(
n
) 
	`netifapi_netif_common
(n, 
netif_remove
, 
NULL
)

	)

86 #define 
	#netifapi_netif_set_up
(
n
) 
	`netifapi_netif_common
(n, 
netif_set_up
, 
NULL
)

	)

87 #define 
	#netifapi_netif_set_down
(
n
) 
	`netifapi_netif_common
(n, 
netif_set_down
, 
NULL
)

	)

88 #define 
	#netifapi_netif_set_default
(
n
) 
	`netifapi_netif_common
(n, 
netif_set_default
, 
NULL
)

	)

89 #define 
	#netifapi_dhcp_start
(
n
) 
	`netifapi_netif_common
(n, 
NULL
, 
dhcp_start
)

	)

90 #define 
	#netifapi_dhcp_stop
(
n
) 
	`netifapi_netif_common
(n, 
dhcp_stop
, 
NULL
)

	)

91 #define 
	#netifapi_autoip_start
(
n
) 
	`netifapi_netif_common
(n, 
NULL
, 
autoip_start
)

	)

92 #define 
	#netifapi_autoip_stop
(
n
) 
	`netifapi_netif_common
(n, 
NULL
, 
autoip_stop
)

	)

94 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/opt.h

38 #ifndef 
__LWIP_OPT_H__


39 #define 
	#__LWIP_OPT_H__


	)

45 #include 
	~"lwipopts.h
"

46 #include 
	~"lwip/debug.h
"

59 #ifndef 
SYS_LIGHTWEIGHT_PROT


60 #define 
	#SYS_LIGHTWEIGHT_PROT
 0

	)

67 #ifndef 
NO_SYS


68 #define 
	#NO_SYS
 0

	)

75 #ifndef 
MEMCPY


76 #define 
	#MEMCPY
(
dst
,
src
,
len
) 
	`memcpy
(dst,src,len)

	)

83 #ifndef 
SMEMCPY


84 #define 
	#SMEMCPY
(
dst
,
src
,
len
) 
	`memcpy
(dst,src,len)

	)

97 #ifndef 
MEM_LIBC_MALLOC


98 #define 
	#MEM_LIBC_MALLOC
 0

	)

106 #ifndef 
MEM_ALIGNMENT


107 #define 
	#MEM_ALIGNMENT
 1

	)

114 #ifndef 
MEM_SIZE


115 #define 
	#MEM_SIZE
 1600

	)

127 #ifndef 
MEMP_OVERFLOW_CHECK


128 #define 
	#MEMP_OVERFLOW_CHECK
 0

	)

135 #ifndef 
MEMP_SANITY_CHECK


136 #define 
	#MEMP_SANITY_CHECK
 0

	)

144 #ifndef 
MEM_USE_POOLS


145 #define 
	#MEM_USE_POOLS
 0

	)

154 #ifndef 
MEMP_USE_CUSTOM_POOLS


155 #define 
	#MEMP_USE_CUSTOM_POOLS
 0

	)

176 #ifndef 
LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT


177 #define 
	#LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 0

	)

190 #ifndef 
MEMP_NUM_PBUF


191 #define 
	#MEMP_NUM_PBUF
 16

	)

198 #ifndef 
MEMP_NUM_RAW_PCB


199 #define 
	#MEMP_NUM_RAW_PCB
 4

	)

207 #ifndef 
MEMP_NUM_UDP_PCB


208 #define 
	#MEMP_NUM_UDP_PCB
 4

	)

215 #ifndef 
MEMP_NUM_TCP_PCB


216 #define 
	#MEMP_NUM_TCP_PCB
 5

	)

223 #ifndef 
MEMP_NUM_TCP_PCB_LISTEN


224 #define 
	#MEMP_NUM_TCP_PCB_LISTEN
 8

	)

231 #ifndef 
MEMP_NUM_TCP_SEG


232 #define 
	#MEMP_NUM_TCP_SEG
 16

	)

239 #ifndef 
MEMP_NUM_REASSDATA


240 #define 
	#MEMP_NUM_REASSDATA
 5

	)

249 #ifndef 
MEMP_NUM_ARP_QUEUE


250 #define 
	#MEMP_NUM_ARP_QUEUE
 30

	)

259 #ifndef 
MEMP_NUM_IGMP_GROUP


260 #define 
	#MEMP_NUM_IGMP_GROUP
 8

	)

267 #ifndef 
MEMP_NUM_SYS_TIMEOUT


268 #define 
	#MEMP_NUM_SYS_TIMEOUT
 3

	)

275 #ifndef 
MEMP_NUM_NETBUF


276 #define 
	#MEMP_NUM_NETBUF
 2

	)

283 #ifndef 
MEMP_NUM_NETCONN


284 #define 
	#MEMP_NUM_NETCONN
 4

	)

292 #ifndef 
MEMP_NUM_TCPIP_MSG_API


293 #define 
	#MEMP_NUM_TCPIP_MSG_API
 8

	)

301 #ifndef 
MEMP_NUM_TCPIP_MSG_INPKT


302 #define 
	#MEMP_NUM_TCPIP_MSG_INPKT
 8

	)

308 #ifndef 
PBUF_POOL_SIZE


309 #define 
	#PBUF_POOL_SIZE
 16

	)

320 #ifndef 
LWIP_ARP


321 #define 
	#LWIP_ARP
 1

	)

327 #ifndef 
ARP_TABLE_SIZE


328 #define 
	#ARP_TABLE_SIZE
 10

	)

335 #ifndef 
ARP_QUEUEING


336 #define 
	#ARP_QUEUEING
 1

	)

347 #ifndef 
ETHARP_TRUST_IP_MAC


348 #define 
	#ETHARP_TRUST_IP_MAC
 1

	)

361 #ifndef 
IP_FORWARD


362 #define 
	#IP_FORWARD
 0

	)

370 #ifndef 
IP_OPTIONS_ALLOWED


371 #define 
	#IP_OPTIONS_ALLOWED
 1

	)

379 #ifndef 
IP_REASSEMBLY


380 #define 
	#IP_REASSEMBLY
 1

	)

388 #ifndef 
IP_FRAG


389 #define 
	#IP_FRAG
 1

	)

397 #ifndef 
IP_REASS_MAXAGE


398 #define 
	#IP_REASS_MAXAGE
 3

	)

407 #ifndef 
IP_REASS_MAX_PBUFS


408 #define 
	#IP_REASS_MAX_PBUFS
 10

	)

416 #ifndef 
IP_FRAG_USES_STATIC_BUF


417 #define 
	#IP_FRAG_USES_STATIC_BUF
 1

	)

424 #if 
IP_FRAG_USES_STATIC_BUF
 && !
defined
(
IP_FRAG_MAX_MTU
)

425 #define 
	#IP_FRAG_MAX_MTU
 1500

	)

431 #ifndef 
IP_DEFAULT_TTL


432 #define 
	#IP_DEFAULT_TTL
 255

	)

444 #ifndef 
LWIP_ICMP


445 #define 
	#LWIP_ICMP
 1

	)

451 #ifndef 
ICMP_TTL


452 #define 
	#ICMP_TTL
 (
IP_DEFAULT_TTL
)

	)

463 #ifndef 
LWIP_RAW


464 #define 
	#LWIP_RAW
 1

	)

470 #ifndef 
RAW_TTL


471 #define 
	#RAW_TTL
 (
IP_DEFAULT_TTL
)

	)

482 #ifndef 
LWIP_DHCP


483 #define 
	#LWIP_DHCP
 0

	)

489 #ifndef 
DHCP_DOES_ARP_CHECK


490 #define 
	#DHCP_DOES_ARP_CHECK
 ((
LWIP_DHCP
) && (
LWIP_ARP
))

	)

501 #ifndef 
LWIP_AUTOIP


502 #define 
	#LWIP_AUTOIP
 0

	)

509 #ifndef 
LWIP_DHCP_AUTOIP_COOP


510 #define 
	#LWIP_DHCP_AUTOIP_COOP
 0

	)

522 #ifndef 
LWIP_SNMP


523 #define 
	#LWIP_SNMP
 0

	)

530 #ifndef 
SNMP_CONCURRENT_REQUESTS


531 #define 
	#SNMP_CONCURRENT_REQUESTS
 1

	)

538 #ifndef 
SNMP_TRAP_DESTINATIONS


539 #define 
	#SNMP_TRAP_DESTINATIONS
 1

	)

545 #ifndef 
SNMP_PRIVATE_MIB


546 #define 
	#SNMP_PRIVATE_MIB
 0

	)

554 #ifndef 
SNMP_SAFE_REQUESTS


555 #define 
	#SNMP_SAFE_REQUESTS
 1

	)

566 #ifndef 
LWIP_IGMP


567 #define 
	#LWIP_IGMP
 0

	)

579 #ifndef 
LWIP_DNS


580 #define 
	#LWIP_DNS
 0

	)

584 #ifndef 
DNS_TABLE_SIZE


585 #define 
	#DNS_TABLE_SIZE
 4

	)

589 #ifndef 
DNS_MAX_NAME_LENGTH


590 #define 
	#DNS_MAX_NAME_LENGTH
 256

	)

594 #ifndef 
DNS_MAX_SERVERS


595 #define 
	#DNS_MAX_SERVERS
 2

	)

599 #ifndef 
DNS_DOES_NAME_CHECK


600 #define 
	#DNS_DOES_NAME_CHECK
 1

	)

606 #ifndef 
DNS_USES_STATIC_BUF


607 #define 
	#DNS_USES_STATIC_BUF
 1

	)

611 #ifndef 
DNS_MSG_SIZE


612 #define 
	#DNS_MSG_SIZE
 512

	)

623 #ifndef 
LWIP_UDP


624 #define 
	#LWIP_UDP
 1

	)

630 #ifndef 
LWIP_UDPLITE


631 #define 
	#LWIP_UDPLITE
 0

	)

637 #ifndef 
UDP_TTL


638 #define 
	#UDP_TTL
 (
IP_DEFAULT_TTL
)

	)

649 #ifndef 
LWIP_TCP


650 #define 
	#LWIP_TCP
 1

	)

656 #ifndef 
TCP_TTL


657 #define 
	#TCP_TTL
 (
IP_DEFAULT_TTL
)

	)

663 #ifndef 
TCP_WND


664 #define 
	#TCP_WND
 2048

	)

670 #ifndef 
TCP_MAXRTX


671 #define 
	#TCP_MAXRTX
 12

	)

677 #ifndef 
TCP_SYNMAXRTX


678 #define 
	#TCP_SYNMAXRTX
 6

	)

685 #ifndef 
TCP_QUEUE_OOSEQ


686 #define 
	#TCP_QUEUE_OOSEQ
 1

	)

696 #ifndef 
TCP_MSS


697 #define 
	#TCP_MSS
 128

	)

708 #ifndef 
TCP_CALCULATE_EFF_SEND_MSS


709 #define 
	#TCP_CALCULATE_EFF_SEND_MSS
 1

	)

716 #ifndef 
TCP_SND_BUF


717 #define 
	#TCP_SND_BUF
 256

	)

724 #ifndef 
TCP_SND_QUEUELEN


725 #define 
	#TCP_SND_QUEUELEN
 (4 * (
TCP_SND_BUF
/
TCP_MSS
))

	)

733 #ifndef 
TCP_SNDLOWAT


734 #define 
	#TCP_SNDLOWAT
 (
TCP_SND_BUF
/2)

	)

740 #ifndef 
TCP_LISTEN_BACKLOG


741 #define 
	#TCP_LISTEN_BACKLOG
 0

	)

749 #ifndef 
TCP_DEFAULT_LISTEN_BACKLOG


750 #define 
	#TCP_DEFAULT_LISTEN_BACKLOG
 0xff

	)

760 #ifndef 
LWIP_EVENT_API


761 #define 
	#LWIP_EVENT_API
 0

	)

762 #define 
	#LWIP_CALLBACK_API
 1

	)

764 #define 
	#LWIP_EVENT_API
 1

	)

765 #define 
	#LWIP_CALLBACK_API
 0

	)

779 #ifndef 
PBUF_LINK_HLEN


780 #define 
	#PBUF_LINK_HLEN
 14

	)

788 #ifndef 
PBUF_POOL_BUFSIZE


789 #define 
	#PBUF_POOL_BUFSIZE
 
	`LWIP_MEM_ALIGN_SIZE
(
TCP_MSS
+40+
PBUF_LINK_HLEN
)

	)

801 #ifndef 
LWIP_NETIF_HOSTNAME


802 #define 
	#LWIP_NETIF_HOSTNAME
 0

	)

808 #ifndef 
LWIP_NETIF_API


809 #define 
	#LWIP_NETIF_API
 0

	)

816 #ifndef 
LWIP_NETIF_STATUS_CALLBACK


817 #define 
	#LWIP_NETIF_STATUS_CALLBACK
 0

	)

824 #ifndef 
LWIP_NETIF_LINK_CALLBACK


825 #define 
	#LWIP_NETIF_LINK_CALLBACK
 0

	)

835 #ifndef 
LWIP_NETIF_HWADDRHINT


836 #define 
	#LWIP_NETIF_HWADDRHINT
 0

	)

843 #ifndef 
LWIP_NETIF_LOOPBACK


844 #define 
	#LWIP_NETIF_LOOPBACK
 0

	)

851 #ifndef 
LWIP_LOOPBACK_MAX_PBUFS


852 #define 
	#LWIP_LOOPBACK_MAX_PBUFS
 0

	)

868 #ifndef 
LWIP_NETIF_LOOPBACK_MULTITHREADING


869 #define 
	#LWIP_NETIF_LOOPBACK_MULTITHREADING
 (!
NO_SYS
)

	)

880 #ifndef 
LWIP_HAVE_LOOPIF


881 #define 
	#LWIP_HAVE_LOOPIF
 0

	)

892 #ifndef 
LWIP_HAVE_SLIPIF


893 #define 
	#LWIP_HAVE_SLIPIF
 0

	)

904 #ifndef 
TCPIP_THREAD_NAME


905 #define 
	#TCPIP_THREAD_NAME
 "tcpip_thread"

	)

913 #ifndef 
TCPIP_THREAD_STACKSIZE


914 #define 
	#TCPIP_THREAD_STACKSIZE
 0

	)

922 #ifndef 
TCPIP_THREAD_PRIO


923 #define 
	#TCPIP_THREAD_PRIO
 1

	)

931 #ifndef 
TCPIP_MBOX_SIZE


932 #define 
	#TCPIP_MBOX_SIZE
 0

	)

938 #ifndef 
SLIPIF_THREAD_NAME


939 #define 
	#SLIPIF_THREAD_NAME
 "slipif_loop"

	)

947 #ifndef 
SLIPIF_THREAD_STACKSIZE


948 #define 
	#SLIPIF_THREAD_STACKSIZE
 0

	)

956 #ifndef 
SLIPIF_THREAD_PRIO


957 #define 
	#SLIPIF_THREAD_PRIO
 1

	)

963 #ifndef 
PPP_THREAD_NAME


964 #define 
	#PPP_THREAD_NAME
 "pppMain"

	)

972 #ifndef 
PPP_THREAD_STACKSIZE


973 #define 
	#PPP_THREAD_STACKSIZE
 0

	)

981 #ifndef 
PPP_THREAD_PRIO


982 #define 
	#PPP_THREAD_PRIO
 1

	)

988 #ifndef 
DEFAULT_THREAD_NAME


989 #define 
	#DEFAULT_THREAD_NAME
 "lwIP"

	)

997 #ifndef 
DEFAULT_THREAD_STACKSIZE


998 #define 
	#DEFAULT_THREAD_STACKSIZE
 0

	)

1006 #ifndef 
DEFAULT_THREAD_PRIO


1007 #define 
	#DEFAULT_THREAD_PRIO
 1

	)

1015 #ifndef 
DEFAULT_RAW_RECVMBOX_SIZE


1016 #define 
	#DEFAULT_RAW_RECVMBOX_SIZE
 0

	)

1024 #ifndef 
DEFAULT_UDP_RECVMBOX_SIZE


1025 #define 
	#DEFAULT_UDP_RECVMBOX_SIZE
 0

	)

1033 #ifndef 
DEFAULT_TCP_RECVMBOX_SIZE


1034 #define 
	#DEFAULT_TCP_RECVMBOX_SIZE
 0

	)

1042 #ifndef 
DEFAULT_ACCEPTMBOX_SIZE


1043 #define 
	#DEFAULT_ACCEPTMBOX_SIZE
 0

	)

1055 #ifndef 
LWIP_TCPIP_CORE_LOCKING


1056 #define 
	#LWIP_TCPIP_CORE_LOCKING
 0

	)

1062 #ifndef 
LWIP_NETCONN


1063 #define 
	#LWIP_NETCONN
 1

	)

1074 #ifndef 
LWIP_SOCKET


1075 #define 
	#LWIP_SOCKET
 1

	)

1082 #ifndef 
LWIP_COMPAT_SOCKETS


1083 #define 
	#LWIP_COMPAT_SOCKETS
 1

	)

1091 #ifndef 
LWIP_POSIX_SOCKETS_IO_NAMES


1092 #define 
	#LWIP_POSIX_SOCKETS_IO_NAMES
 1

	)

1100 #ifndef 
LWIP_TCP_KEEPALIVE


1101 #define 
	#LWIP_TCP_KEEPALIVE
 0

	)

1107 #ifndef 
LWIP_SO_RCVTIMEO


1108 #define 
	#LWIP_SO_RCVTIMEO
 0

	)

1114 #ifndef 
LWIP_SO_RCVBUF


1115 #define 
	#LWIP_SO_RCVBUF
 0

	)

1121 #ifndef 
SO_REUSE


1122 #define 
	#SO_REUSE
 0

	)

1133 #ifndef 
LWIP_STATS


1134 #define 
	#LWIP_STATS
 1

	)

1137 #if 
LWIP_STATS


1142 #ifndef 
LWIP_STATS_DISPLAY


1143 #define 
	#LWIP_STATS_DISPLAY
 0

	)

1149 #ifndef 
LINK_STATS


1150 #define 
	#LINK_STATS
 1

	)

1156 #ifndef 
ETHARP_STATS


1157 #define 
	#ETHARP_STATS
 (
LWIP_ARP
)

	)

1163 #ifndef 
IP_STATS


1164 #define 
	#IP_STATS
 1

	)

1171 #ifndef 
IPFRAG_STATS


1172 #define 
	#IPFRAG_STATS
 (
IP_REASSEMBLY
 || 
IP_FRAG
)

	)

1178 #ifndef 
ICMP_STATS


1179 #define 
	#ICMP_STATS
 1

	)

1185 #ifndef 
IGMP_STATS


1186 #define 
	#IGMP_STATS
 (
LWIP_IGMP
)

	)

1193 #ifndef 
UDP_STATS


1194 #define 
	#UDP_STATS
 (
LWIP_UDP
)

	)

1201 #ifndef 
TCP_STATS


1202 #define 
	#TCP_STATS
 (
LWIP_TCP
)

	)

1208 #ifndef 
MEM_STATS


1209 #define 
	#MEM_STATS
 1

	)

1215 #ifndef 
MEMP_STATS


1216 #define 
	#MEMP_STATS
 1

	)

1222 #ifndef 
SYS_STATS


1223 #define 
	#SYS_STATS
 1

	)

1228 #define 
	#LINK_STATS
 0

	)

1229 #define 
	#IP_STATS
 0

	)

1230 #define 
	#IPFRAG_STATS
 0

	)

1231 #define 
	#ICMP_STATS
 0

	)

1232 #define 
	#IGMP_STATS
 0

	)

1233 #define 
	#UDP_STATS
 0

	)

1234 #define 
	#TCP_STATS
 0

	)

1235 #define 
	#MEM_STATS
 0

	)

1236 #define 
	#MEMP_STATS
 0

	)

1237 #define 
	#SYS_STATS
 0

	)

1238 #define 
	#LWIP_STATS_DISPLAY
 0

	)

1250 #ifndef 
PPP_SUPPORT


1251 #define 
	#PPP_SUPPORT
 0

	)

1257 #ifndef 
PPPOE_SUPPORT


1258 #define 
	#PPPOE_SUPPORT
 0

	)

1264 #ifndef 
PPPOS_SUPPORT


1265 #define 
	#PPPOS_SUPPORT
 
PPP_SUPPORT


	)

1268 #if 
PPP_SUPPORT


1273 #ifndef 
NUM_PPP


1274 #define 
	#NUM_PPP
 1

	)

1280 #ifndef 
PAP_SUPPORT


1281 #define 
	#PAP_SUPPORT
 0

	)

1287 #ifndef 
CHAP_SUPPORT


1288 #define 
	#CHAP_SUPPORT
 0

	)

1294 #ifndef 
MSCHAP_SUPPORT


1295 #define 
	#MSCHAP_SUPPORT
 0

	)

1301 #ifndef 
CBCP_SUPPORT


1302 #define 
	#CBCP_SUPPORT
 0

	)

1308 #ifndef 
CCP_SUPPORT


1309 #define 
	#CCP_SUPPORT
 0

	)

1315 #ifndef 
VJ_SUPPORT


1316 #define 
	#VJ_SUPPORT
 0

	)

1322 #ifndef 
MD5_SUPPORT


1323 #define 
	#MD5_SUPPORT
 0

	)

1329 #ifndef 
FSM_DEFTIMEOUT


1330 #define 
	#FSM_DEFTIMEOUT
 6

	)

1333 #ifndef 
FSM_DEFMAXTERMREQS


1334 #define 
	#FSM_DEFMAXTERMREQS
 2

	)

1337 #ifndef 
FSM_DEFMAXCONFREQS


1338 #define 
	#FSM_DEFMAXCONFREQS
 10

	)

1341 #ifndef 
FSM_DEFMAXNAKLOOPS


1342 #define 
	#FSM_DEFMAXNAKLOOPS
 5

	)

1345 #ifndef 
UPAP_DEFTIMEOUT


1346 #define 
	#UPAP_DEFTIMEOUT
 6

	)

1349 #ifndef 
UPAP_DEFREQTIME


1350 #define 
	#UPAP_DEFREQTIME
 30

	)

1353 #ifndef 
CHAP_DEFTIMEOUT


1354 #define 
	#CHAP_DEFTIMEOUT
 6

	)

1357 #ifndef 
CHAP_DEFTRANSMITS


1358 #define 
	#CHAP_DEFTRANSMITS
 10

	)

1362 #ifndef 
LCP_ECHOINTERVAL


1363 #define 
	#LCP_ECHOINTERVAL
 0

	)

1367 #ifndef 
LCP_MAXECHOFAILS


1368 #define 
	#LCP_MAXECHOFAILS
 3

	)

1372 #ifndef 
PPP_MAXIDLEFLAG


1373 #define 
	#PPP_MAXIDLEFLAG
 100

	)

1384 #define 
	#PPP_MTU
 1500

	)

1385 #ifndef 
PPP_MAXMTU


1387 #define 
	#PPP_MAXMTU
 1500

	)

1389 #define 
	#PPP_MINMTU
 64

	)

1390 #define 
	#PPP_MRU
 1500

	)

1391 #define 
	#PPP_MAXMRU
 1500

	)

1392 #ifndef 
PPP_DEFMRU


1393 #define 
	#PPP_DEFMRU
 296

	)

1395 #define 
	#PPP_MINMRU
 128

	)

1398 #define 
	#MAXNAMELEN
 256

	)

1399 #define 
	#MAXSECRETLEN
 256

	)

1411 #ifndef 
CHECKSUM_GEN_IP


1412 #define 
	#CHECKSUM_GEN_IP
 1

	)

1418 #ifndef 
CHECKSUM_GEN_UDP


1419 #define 
	#CHECKSUM_GEN_UDP
 1

	)

1425 #ifndef 
CHECKSUM_GEN_TCP


1426 #define 
	#CHECKSUM_GEN_TCP
 1

	)

1432 #ifndef 
CHECKSUM_CHECK_IP


1433 #define 
	#CHECKSUM_CHECK_IP
 1

	)

1439 #ifndef 
CHECKSUM_CHECK_UDP


1440 #define 
	#CHECKSUM_CHECK_UDP
 1

	)

1446 #ifndef 
CHECKSUM_CHECK_TCP


1447 #define 
	#CHECKSUM_CHECK_TCP
 1

	)

1460 #ifndef 
LWIP_DBG_MIN_LEVEL


1461 #define 
	#LWIP_DBG_MIN_LEVEL
 
LWIP_DBG_LEVEL_OFF


	)

1468 #ifndef 
LWIP_DBG_TYPES_ON


1469 #define 
	#LWIP_DBG_TYPES_ON
 
LWIP_DBG_ON


	)

1475 #ifndef 
ETHARP_DEBUG


1476 #define 
	#ETHARP_DEBUG
 
LWIP_DBG_ON


	)

1482 #ifndef 
NETIF_DEBUG


1483 #define 
	#NETIF_DEBUG
 
LWIP_DBG_ON


	)

1489 #ifndef 
PBUF_DEBUG


1490 #define 
	#PBUF_DEBUG
 
LWIP_DBG_ON


	)

1496 #ifndef 
API_LIB_DEBUG


1497 #define 
	#API_LIB_DEBUG
 
LWIP_DBG_ON


	)

1503 #ifndef 
API_MSG_DEBUG


1504 #define 
	#API_MSG_DEBUG
 
LWIP_DBG_ON


	)

1510 #ifndef 
SOCKETS_DEBUG


1511 #define 
	#SOCKETS_DEBUG
 
LWIP_DBG_ON


	)

1517 #ifndef 
ICMP_DEBUG


1518 #define 
	#ICMP_DEBUG
 
LWIP_DBG_ON


	)

1524 #ifndef 
IGMP_DEBUG


1525 #define 
	#IGMP_DEBUG
 
LWIP_DBG_ON


	)

1531 #ifndef 
INET_DEBUG


1532 #define 
	#INET_DEBUG
 
LWIP_DBG_ON


	)

1538 #ifndef 
IP_DEBUG


1539 #define 
	#IP_DEBUG
 
LWIP_DBG_ON


	)

1545 #ifndef 
IP_REASS_DEBUG


1546 #define 
	#IP_REASS_DEBUG
 
LWIP_DBG_ON


	)

1552 #ifndef 
RAW_DEBUG


1553 #define 
	#RAW_DEBUG
 
LWIP_DBG_ON


	)

1559 #ifndef 
MEM_DEBUG


1560 #define 
	#MEM_DEBUG
 
LWIP_DBG_ON


	)

1566 #ifndef 
MEMP_DEBUG


1567 #define 
	#MEMP_DEBUG
 
LWIP_DBG_ON


	)

1573 #ifndef 
SYS_DEBUG


1574 #define 
	#SYS_DEBUG
 
LWIP_DBG_ON


	)

1580 #ifndef 
TCP_DEBUG


1581 #define 
	#TCP_DEBUG
 
LWIP_DBG_ON


	)

1587 #ifndef 
TCP_INPUT_DEBUG


1588 #define 
	#TCP_INPUT_DEBUG
 
LWIP_DBG_ON


	)

1594 #ifndef 
TCP_FR_DEBUG


1595 #define 
	#TCP_FR_DEBUG
 
LWIP_DBG_ON


	)

1602 #ifndef 
TCP_RTO_DEBUG


1603 #define 
	#TCP_RTO_DEBUG
 
LWIP_DBG_ON


	)

1609 #ifndef 
TCP_CWND_DEBUG


1610 #define 
	#TCP_CWND_DEBUG
 
LWIP_DBG_ON


	)

1616 #ifndef 
TCP_WND_DEBUG


1617 #define 
	#TCP_WND_DEBUG
 
LWIP_DBG_ON


	)

1623 #ifndef 
TCP_OUTPUT_DEBUG


1624 #define 
	#TCP_OUTPUT_DEBUG
 
LWIP_DBG_ON


	)

1630 #ifndef 
TCP_RST_DEBUG


1631 #define 
	#TCP_RST_DEBUG
 
LWIP_DBG_ON


	)

1637 #ifndef 
TCP_QLEN_DEBUG


1638 #define 
	#TCP_QLEN_DEBUG
 
LWIP_DBG_ON


	)

1644 #ifndef 
UDP_DEBUG


1645 #define 
	#UDP_DEBUG
 
LWIP_DBG_ON


	)

1651 #ifndef 
TCPIP_DEBUG


1652 #define 
	#TCPIP_DEBUG
 
LWIP_DBG_ON


	)

1658 #ifndef 
PPP_DEBUG


1659 #define 
	#PPP_DEBUG
 
LWIP_DBG_ON


	)

1665 #ifndef 
SLIP_DEBUG


1666 #define 
	#SLIP_DEBUG
 
LWIP_DBG_ON


	)

1672 #ifndef 
DHCP_DEBUG


1673 #define 
	#DHCP_DEBUG
 
LWIP_DBG_ON


	)

1679 #ifndef 
AUTOIP_DEBUG


1680 #define 
	#AUTOIP_DEBUG
 
LWIP_DBG_ON


	)

1686 #ifndef 
SNMP_MSG_DEBUG


1687 #define 
	#SNMP_MSG_DEBUG
 
LWIP_DBG_ON


	)

1693 #ifndef 
SNMP_MIB_DEBUG


1694 #define 
	#SNMP_MIB_DEBUG
 
LWIP_DBG_ON


	)

1700 #ifndef 
DNS_DEBUG


1701 #define 
	#DNS_DEBUG
 
LWIP_DBG_ON


	)

	@/root/Robux/net/lwip/include/lwip/pbuf.h

33 #ifndef 
__LWIP_PBUF_H__


34 #define 
	#__LWIP_PBUF_H__


	)

36 #include 
	~"lwip/opt.h
"

37 #include 
	~"lwip/err.h
"

39 #ifdef 
__cplusplus


43 #define 
	#PBUF_TRANSPORT_HLEN
 20

	)

44 #define 
	#PBUF_IP_HLEN
 20

	)

47 
PBUF_TRANSPORT
,

48 
PBUF_IP
,

49 
PBUF_LINK
,

50 
PBUF_RAW


51 } 
	tpbuf_layer
;

54 
PBUF_RAM
,

55 
PBUF_ROM
,

56 
PBUF_REF
,

57 
PBUF_POOL


58 } 
	tpbuf_type
;

62 #define 
	#PBUF_FLAG_PUSH
 0x01U

	)

64 struct 
	spbuf
 {

66 struct 
pbuf
 *
next
;

69 void *
payload
;

78 
u16_t
 
tot_len
;

81 
u16_t
 
len
;

84 
u8_t
 
type
;

87 
u8_t
 
flags
;

94 
u16_t
 
ref
;

99 #define 
	#pbuf_init
()

	)

101 struct 
pbuf
 *
pbuf_alloc
(
pbuf_layer
 
l
, 
u16_t
 
size
, 
pbuf_type
 
type
);

102 void 
pbuf_realloc
(struct 
pbuf
 *
p
, 
u16_t
 
size
);

103 
u8_t
 
pbuf_header
(struct 
pbuf
 *
p
, 
s16_t
 
header_size
);

104 void 
pbuf_ref
(struct 
pbuf
 *
p
);

105 void 
pbuf_ref_chain
(struct 
pbuf
 *
p
);

106 
u8_t
 
pbuf_free
(struct 
pbuf
 *
p
);

107 
u8_t
 
pbuf_clen
(struct 
pbuf
 *
p
);

108 void 
pbuf_cat
(struct 
pbuf
 *
head
, struct pbuf *
tail
);

109 void 
pbuf_chain
(struct 
pbuf
 *
head
, struct pbuf *
tail
);

110 struct 
pbuf
 *
pbuf_dechain
(struct pbuf *
p
);

111 
err_t
 
pbuf_copy
(struct 
pbuf
 *
p_to
, struct pbuf *
p_from
);

112 
u16_t
 
pbuf_copy_partial
(struct 
pbuf
 *
p
, void *
dataptr
, u16_t 
len
, u16_t 
offset
);

114 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/raw.h

32 #ifndef 
__LWIP_RAW_H__


33 #define 
	#__LWIP_RAW_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_RAW


39 #include 
	~"lwip/pbuf.h
"

40 #include 
	~"lwip/inet.h
"

41 #include 
	~"lwip/ip.h
"

42 #include 
	~"lwip/ip_addr.h
"

44 #ifdef 
__cplusplus


48 struct 
	sraw_pcb
 {

50 
IP_PCB
;

52 struct 
raw_pcb
 *
next
;

54 
u8_t
 
protocol
;

66 
u8_t
 (* 
recv
)(void *
arg
, struct 
raw_pcb
 *
pcb
, struct 
pbuf
 *
p
,

67 struct 
ip_addr
 *
addr
);

69 void *
recv_arg
;

74 struct 
raw_pcb
 * 
raw_new
 (
u8_t
 
proto
);

75 void 
raw_remove
 (struct 
raw_pcb
 *
pcb
);

76 
err_t
 
raw_bind
 (struct 
raw_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
);

77 
err_t
 
raw_connect
 (struct 
raw_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
);

79 void 
raw_recv
 (struct 
raw_pcb
 *
pcb
,

80 
u8_t
 (* 
recv
)(void *
arg
, struct 
raw_pcb
 *
pcb
,

81 struct 
pbuf
 *
p
,

82 struct 
ip_addr
 *
addr
),

83 void *
recv_arg
);

84 
err_t
 
raw_sendto
 (struct 
raw_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
ipaddr
);

85 
err_t
 
raw_send
 (struct 
raw_pcb
 *
pcb
, struct 
pbuf
 *
p
);

88 
u8_t
 
raw_input
 (struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

89 #define 
	#raw_init
()

	)

91 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/sio.h

35 #ifndef 
__SIO_H__


36 #define 
	#__SIO_H__


	)

38 #include 
	~"lwip/arch.h
"

40 #ifdef 
__cplusplus


46 #ifndef 
__sio_fd_t_defined


47 typedef void * 
	tsio_fd_t
;

53 #ifndef 
sio_open


54 
sio_fd_t
 
sio_open
(
u8_t
);

57 #ifndef 
sio_send


58 void 
sio_send
(
u8_t
, 
sio_fd_t
);

61 #ifndef 
sio_recv


62 
u8_t
 
sio_recv
(
sio_fd_t
);

65 #ifndef 
sio_read


66 
u32_t
 
sio_read
(
sio_fd_t
, 
u8_t
 *, u32_t);

69 #ifndef 
sio_write


70 
u32_t
 
sio_write
(
sio_fd_t
, 
u8_t
 *, u32_t);

73 #ifndef 
sio_read_abort


74 void 
sio_read_abort
(
sio_fd_t
);

77 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/snmp.h

33 #ifndef 
__LWIP_SNMP_H__


34 #define 
	#__LWIP_SNMP_H__


	)

36 #include 
	~"lwip/opt.h
"

37 #include 
	~"lwip/netif.h
"

38 #include 
	~"lwip/udp.h
"

40 #ifdef 
__cplusplus


47 enum 
	esnmp_ifType
 {

48 
snmp_ifType_other
=1,

49 
snmp_ifType_regular1822
,

50 
snmp_ifType_hdh1822
,

51 
snmp_ifType_ddn_x25
,

52 
snmp_ifType_rfc877_x25
,

53 
snmp_ifType_ethernet_csmacd
,

54 
snmp_ifType_iso88023_csmacd
,

55 
snmp_ifType_iso88024_tokenBus
,

56 
snmp_ifType_iso88025_tokenRing
,

57 
snmp_ifType_iso88026_man
,

58 
snmp_ifType_starLan
,

59 
snmp_ifType_proteon_10Mbit
,

60 
snmp_ifType_proteon_80Mbit
,

61 
snmp_ifType_hyperchannel
,

62 
snmp_ifType_fddi
,

63 
snmp_ifType_lapb
,

64 
snmp_ifType_sdlc
,

65 
snmp_ifType_ds1
,

66 
snmp_ifType_e1
,

67 
snmp_ifType_basicISDN
,

68 
snmp_ifType_primaryISDN
,

69 
snmp_ifType_propPointToPointSerial
,

70 
snmp_ifType_ppp
,

71 
snmp_ifType_softwareLoopback
,

72 
snmp_ifType_eon
,

73 
snmp_ifType_ethernet_3Mbit
,

74 
snmp_ifType_nsip
,

75 
snmp_ifType_slip
,

76 
snmp_ifType_ultra
,

77 
snmp_ifType_ds3
,

78 
snmp_ifType_sip
,

79 
snmp_ifType_frame_relay


82 #if 
LWIP_SNMP


85 #define 
	#SNMP_SYSUPTIME_INTERVAL
 10

	)

88 #define 
	#LWIP_SNMP_OBJ_ID_LEN
 32

	)

91 struct 
	ssnmp_obj_id


93 
u8_t
 
len
;

94 
s32_t
 
id
[
LWIP_SNMP_OBJ_ID_LEN
];

98 void 
snmp_set_sysdesr
(
u8_t
* 
str
, u8_t* 
len
);

99 void 
snmp_set_sysobjid
(struct 
snmp_obj_id
 *
oid
);

100 void 
snmp_get_sysobjid_ptr
(struct 
snmp_obj_id
 **
oid
);

101 void 
snmp_inc_sysuptime
(void);

102 void 
snmp_add_sysuptime
(
u32_t
 
value
);

103 void 
snmp_get_sysuptime
(
u32_t
 *
value
);

104 void 
snmp_set_syscontact
(
u8_t
 *
ocstr
, u8_t *
ocstrlen
);

105 void 
snmp_set_sysname
(
u8_t
 *
ocstr
, u8_t *
ocstrlen
);

106 void 
snmp_set_syslocation
(
u8_t
 *
ocstr
, u8_t *
ocstrlen
);

109 void 
snmp_add_ifinoctets
(struct 
netif
 *
ni
, 
u32_t
 
value
);

110 void 
snmp_inc_ifinucastpkts
(struct 
netif
 *
ni
);

111 void 
snmp_inc_ifinnucastpkts
(struct 
netif
 *
ni
);

112 void 
snmp_inc_ifindiscards
(struct 
netif
 *
ni
);

113 void 
snmp_add_ifoutoctets
(struct 
netif
 *
ni
, 
u32_t
 
value
);

114 void 
snmp_inc_ifoutucastpkts
(struct 
netif
 *
ni
);

115 void 
snmp_inc_ifoutnucastpkts
(struct 
netif
 *
ni
);

116 void 
snmp_inc_ifoutdiscards
(struct 
netif
 *
ni
);

117 void 
snmp_inc_iflist
(void);

118 void 
snmp_dec_iflist
(void);

121 void 
snmp_insert_arpidx_tree
(struct 
netif
 *
ni
, struct 
ip_addr
 *
ip
);

122 void 
snmp_delete_arpidx_tree
(struct 
netif
 *
ni
, struct 
ip_addr
 *
ip
);

125 void 
snmp_inc_ipinreceives
(void);

126 void 
snmp_inc_ipinhdrerrors
(void);

127 void 
snmp_inc_ipinaddrerrors
(void);

128 void 
snmp_inc_ipforwdatagrams
(void);

129 void 
snmp_inc_ipinunknownprotos
(void);

130 void 
snmp_inc_ipindiscards
(void);

131 void 
snmp_inc_ipindelivers
(void);

132 void 
snmp_inc_ipoutrequests
(void);

133 void 
snmp_inc_ipoutdiscards
(void);

134 void 
snmp_inc_ipoutnoroutes
(void);

135 void 
snmp_inc_ipreasmreqds
(void);

136 void 
snmp_inc_ipreasmoks
(void);

137 void 
snmp_inc_ipreasmfails
(void);

138 void 
snmp_inc_ipfragoks
(void);

139 void 
snmp_inc_ipfragfails
(void);

140 void 
snmp_inc_ipfragcreates
(void);

141 void 
snmp_inc_iproutingdiscards
(void);

142 void 
snmp_insert_ipaddridx_tree
(struct 
netif
 *
ni
);

143 void 
snmp_delete_ipaddridx_tree
(struct 
netif
 *
ni
);

144 void 
snmp_insert_iprteidx_tree
(
u8_t
 
dflt
, struct 
netif
 *
ni
);

145 void 
snmp_delete_iprteidx_tree
(
u8_t
 
dflt
, struct 
netif
 *
ni
);

148 void 
snmp_inc_icmpinmsgs
(void);

149 void 
snmp_inc_icmpinerrors
(void);

150 void 
snmp_inc_icmpindestunreachs
(void);

151 void 
snmp_inc_icmpintimeexcds
(void);

152 void 
snmp_inc_icmpinparmprobs
(void);

153 void 
snmp_inc_icmpinsrcquenchs
(void);

154 void 
snmp_inc_icmpinredirects
(void);

155 void 
snmp_inc_icmpinechos
(void);

156 void 
snmp_inc_icmpinechoreps
(void);

157 void 
snmp_inc_icmpintimestamps
(void);

158 void 
snmp_inc_icmpintimestampreps
(void);

159 void 
snmp_inc_icmpinaddrmasks
(void);

160 void 
snmp_inc_icmpinaddrmaskreps
(void);

161 void 
snmp_inc_icmpoutmsgs
(void);

162 void 
snmp_inc_icmpouterrors
(void);

163 void 
snmp_inc_icmpoutdestunreachs
(void);

164 void 
snmp_inc_icmpouttimeexcds
(void);

165 void 
snmp_inc_icmpoutparmprobs
(void);

166 void 
snmp_inc_icmpoutsrcquenchs
(void);

167 void 
snmp_inc_icmpoutredirects
(void);

168 void 
snmp_inc_icmpoutechos
(void);

169 void 
snmp_inc_icmpoutechoreps
(void);

170 void 
snmp_inc_icmpouttimestamps
(void);

171 void 
snmp_inc_icmpouttimestampreps
(void);

172 void 
snmp_inc_icmpoutaddrmasks
(void);

173 void 
snmp_inc_icmpoutaddrmaskreps
(void);

176 void 
snmp_inc_tcpactiveopens
(void);

177 void 
snmp_inc_tcppassiveopens
(void);

178 void 
snmp_inc_tcpattemptfails
(void);

179 void 
snmp_inc_tcpestabresets
(void);

180 void 
snmp_inc_tcpinsegs
(void);

181 void 
snmp_inc_tcpoutsegs
(void);

182 void 
snmp_inc_tcpretranssegs
(void);

183 void 
snmp_inc_tcpinerrs
(void);

184 void 
snmp_inc_tcpoutrsts
(void);

187 void 
snmp_inc_udpindatagrams
(void);

188 void 
snmp_inc_udpnoports
(void);

189 void 
snmp_inc_udpinerrors
(void);

190 void 
snmp_inc_udpoutdatagrams
(void);

191 void 
snmp_insert_udpidx_tree
(struct 
udp_pcb
 *
pcb
);

192 void 
snmp_delete_udpidx_tree
(struct 
udp_pcb
 *
pcb
);

195 void 
snmp_inc_snmpinpkts
(void);

196 void 
snmp_inc_snmpoutpkts
(void);

197 void 
snmp_inc_snmpinbadversions
(void);

198 void 
snmp_inc_snmpinbadcommunitynames
(void);

199 void 
snmp_inc_snmpinbadcommunityuses
(void);

200 void 
snmp_inc_snmpinasnparseerrs
(void);

201 void 
snmp_inc_snmpintoobigs
(void);

202 void 
snmp_inc_snmpinnosuchnames
(void);

203 void 
snmp_inc_snmpinbadvalues
(void);

204 void 
snmp_inc_snmpinreadonlys
(void);

205 void 
snmp_inc_snmpingenerrs
(void);

206 void 
snmp_add_snmpintotalreqvars
(
u8_t
 
value
);

207 void 
snmp_add_snmpintotalsetvars
(
u8_t
 
value
);

208 void 
snmp_inc_snmpingetrequests
(void);

209 void 
snmp_inc_snmpingetnexts
(void);

210 void 
snmp_inc_snmpinsetrequests
(void);

211 void 
snmp_inc_snmpingetresponses
(void);

212 void 
snmp_inc_snmpintraps
(void);

213 void 
snmp_inc_snmpouttoobigs
(void);

214 void 
snmp_inc_snmpoutnosuchnames
(void);

215 void 
snmp_inc_snmpoutbadvalues
(void);

216 void 
snmp_inc_snmpoutgenerrs
(void);

217 void 
snmp_inc_snmpoutgetrequests
(void);

218 void 
snmp_inc_snmpoutgetnexts
(void);

219 void 
snmp_inc_snmpoutsetrequests
(void);

220 void 
snmp_inc_snmpoutgetresponses
(void);

221 void 
snmp_inc_snmpouttraps
(void);

222 void 
snmp_get_snmpgrpid_ptr
(struct 
snmp_obj_id
 **
oid
);

223 void 
snmp_set_snmpenableauthentraps
(
u8_t
 *
value
);

224 void 
snmp_get_snmpenableauthentraps
(
u8_t
 *
value
);

231 #define 
	#snmp_set_sysdesr
(
str
, 
len
)

	)

232 #define 
	#snmp_set_sysobjid
(
oid
);

	)

233 #define 
	#snmp_get_sysobjid_ptr
(
oid
)

	)

234 #define 
	#snmp_inc_sysuptime
()

	)

235 #define 
	#snmp_add_sysuptime
(
value
)

	)

236 #define 
	#snmp_get_sysuptime
(
value
)

	)

237 #define 
	#snmp_set_syscontact
(
ocstr
, 
ocstrlen
);

	)

238 #define 
	#snmp_set_sysname
(
ocstr
, 
ocstrlen
);

	)

239 #define 
	#snmp_set_syslocation
(
ocstr
, 
ocstrlen
);

	)

242 #define 
	#snmp_add_ifinoctets
(
ni
,
value
)

	)

243 #define 
	#snmp_inc_ifinucastpkts
(
ni
)

	)

244 #define 
	#snmp_inc_ifinnucastpkts
(
ni
)

	)

245 #define 
	#snmp_inc_ifindiscards
(
ni
)

	)

246 #define 
	#snmp_add_ifoutoctets
(
ni
,
value
)

	)

247 #define 
	#snmp_inc_ifoutucastpkts
(
ni
)

	)

248 #define 
	#snmp_inc_ifoutnucastpkts
(
ni
)

	)

249 #define 
	#snmp_inc_ifoutdiscards
(
ni
)

	)

250 #define 
	#snmp_inc_iflist
()

	)

251 #define 
	#snmp_dec_iflist
()

	)

254 #define 
	#snmp_insert_arpidx_tree
(
ni
,
ip
)

	)

255 #define 
	#snmp_delete_arpidx_tree
(
ni
,
ip
)

	)

258 #define 
	#snmp_inc_ipinreceives
()

	)

259 #define 
	#snmp_inc_ipinhdrerrors
()

	)

260 #define 
	#snmp_inc_ipinaddrerrors
()

	)

261 #define 
	#snmp_inc_ipforwdatagrams
()

	)

262 #define 
	#snmp_inc_ipinunknownprotos
()

	)

263 #define 
	#snmp_inc_ipindiscards
()

	)

264 #define 
	#snmp_inc_ipindelivers
()

	)

265 #define 
	#snmp_inc_ipoutrequests
()

	)

266 #define 
	#snmp_inc_ipoutdiscards
()

	)

267 #define 
	#snmp_inc_ipoutnoroutes
()

	)

268 #define 
	#snmp_inc_ipreasmreqds
()

	)

269 #define 
	#snmp_inc_ipreasmoks
()

	)

270 #define 
	#snmp_inc_ipreasmfails
()

	)

271 #define 
	#snmp_inc_ipfragoks
()

	)

272 #define 
	#snmp_inc_ipfragfails
()

	)

273 #define 
	#snmp_inc_ipfragcreates
()

	)

274 #define 
	#snmp_inc_iproutingdiscards
()

	)

275 #define 
	#snmp_insert_ipaddridx_tree
(
ni
)

	)

276 #define 
	#snmp_delete_ipaddridx_tree
(
ni
)

	)

277 #define 
	#snmp_insert_iprteidx_tree
(
dflt
, 
ni
)

	)

278 #define 
	#snmp_delete_iprteidx_tree
(
dflt
, 
ni
)

	)

281 #define 
	#snmp_inc_icmpinmsgs
()

	)

282 #define 
	#snmp_inc_icmpinerrors
()

	)

283 #define 
	#snmp_inc_icmpindestunreachs
()

	)

284 #define 
	#snmp_inc_icmpintimeexcds
()

	)

285 #define 
	#snmp_inc_icmpinparmprobs
()

	)

286 #define 
	#snmp_inc_icmpinsrcquenchs
()

	)

287 #define 
	#snmp_inc_icmpinredirects
()

	)

288 #define 
	#snmp_inc_icmpinechos
()

	)

289 #define 
	#snmp_inc_icmpinechoreps
()

	)

290 #define 
	#snmp_inc_icmpintimestamps
()

	)

291 #define 
	#snmp_inc_icmpintimestampreps
()

	)

292 #define 
	#snmp_inc_icmpinaddrmasks
()

	)

293 #define 
	#snmp_inc_icmpinaddrmaskreps
()

	)

294 #define 
	#snmp_inc_icmpoutmsgs
()

	)

295 #define 
	#snmp_inc_icmpouterrors
()

	)

296 #define 
	#snmp_inc_icmpoutdestunreachs
()

	)

297 #define 
	#snmp_inc_icmpouttimeexcds
()

	)

298 #define 
	#snmp_inc_icmpoutparmprobs
()

	)

299 #define 
	#snmp_inc_icmpoutsrcquenchs
()

	)

300 #define 
	#snmp_inc_icmpoutredirects
()

	)

301 #define 
	#snmp_inc_icmpoutechos
()

	)

302 #define 
	#snmp_inc_icmpoutechoreps
()

	)

303 #define 
	#snmp_inc_icmpouttimestamps
()

	)

304 #define 
	#snmp_inc_icmpouttimestampreps
()

	)

305 #define 
	#snmp_inc_icmpoutaddrmasks
()

	)

306 #define 
	#snmp_inc_icmpoutaddrmaskreps
()

	)

308 #define 
	#snmp_inc_tcpactiveopens
()

	)

309 #define 
	#snmp_inc_tcppassiveopens
()

	)

310 #define 
	#snmp_inc_tcpattemptfails
()

	)

311 #define 
	#snmp_inc_tcpestabresets
()

	)

312 #define 
	#snmp_inc_tcpinsegs
()

	)

313 #define 
	#snmp_inc_tcpoutsegs
()

	)

314 #define 
	#snmp_inc_tcpretranssegs
()

	)

315 #define 
	#snmp_inc_tcpinerrs
()

	)

316 #define 
	#snmp_inc_tcpoutrsts
()

	)

319 #define 
	#snmp_inc_udpindatagrams
()

	)

320 #define 
	#snmp_inc_udpnoports
()

	)

321 #define 
	#snmp_inc_udpinerrors
()

	)

322 #define 
	#snmp_inc_udpoutdatagrams
()

	)

323 #define 
	#snmp_insert_udpidx_tree
(
pcb
)

	)

324 #define 
	#snmp_delete_udpidx_tree
(
pcb
)

	)

327 #define 
	#snmp_inc_snmpinpkts
()

	)

328 #define 
	#snmp_inc_snmpoutpkts
()

	)

329 #define 
	#snmp_inc_snmpinbadversions
()

	)

330 #define 
	#snmp_inc_snmpinbadcommunitynames
()

	)

331 #define 
	#snmp_inc_snmpinbadcommunityuses
()

	)

332 #define 
	#snmp_inc_snmpinasnparseerrs
()

	)

333 #define 
	#snmp_inc_snmpintoobigs
()

	)

334 #define 
	#snmp_inc_snmpinnosuchnames
()

	)

335 #define 
	#snmp_inc_snmpinbadvalues
()

	)

336 #define 
	#snmp_inc_snmpinreadonlys
()

	)

337 #define 
	#snmp_inc_snmpingenerrs
()

	)

338 #define 
	#snmp_add_snmpintotalreqvars
(
value
)

	)

339 #define 
	#snmp_add_snmpintotalsetvars
(
value
)

	)

340 #define 
	#snmp_inc_snmpingetrequests
()

	)

341 #define 
	#snmp_inc_snmpingetnexts
()

	)

342 #define 
	#snmp_inc_snmpinsetrequests
()

	)

343 #define 
	#snmp_inc_snmpingetresponses
()

	)

344 #define 
	#snmp_inc_snmpintraps
()

	)

345 #define 
	#snmp_inc_snmpouttoobigs
()

	)

346 #define 
	#snmp_inc_snmpoutnosuchnames
()

	)

347 #define 
	#snmp_inc_snmpoutbadvalues
()

	)

348 #define 
	#snmp_inc_snmpoutgenerrs
()

	)

349 #define 
	#snmp_inc_snmpoutgetrequests
()

	)

350 #define 
	#snmp_inc_snmpoutgetnexts
()

	)

351 #define 
	#snmp_inc_snmpoutsetrequests
()

	)

352 #define 
	#snmp_inc_snmpoutgetresponses
()

	)

353 #define 
	#snmp_inc_snmpouttraps
()

	)

354 #define 
	#snmp_get_snmpgrpid_ptr
(
oid
)

	)

355 #define 
	#snmp_set_snmpenableauthentraps
(
value
)

	)

356 #define 
	#snmp_get_snmpenableauthentraps
(
value
)

	)

360 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/snmp_asn1.h

35 #ifndef 
__LWIP_SNMP_ASN1_H__


36 #define 
	#__LWIP_SNMP_ASN1_H__


	)

38 #include 
	~"lwip/opt.h
"

39 #include 
	~"lwip/err.h
"

40 #include 
	~"lwip/pbuf.h
"

41 #include 
	~"lwip/snmp.h
"

43 #ifdef 
__cplusplus


47 #define 
	#SNMP_ASN1_UNIV
 (!0x80 | !0x40)

	)

48 #define 
	#SNMP_ASN1_APPLIC
 (!0x80 | 0x40)

	)

49 #define 
	#SNMP_ASN1_CONTXT
 ( 0x80 | !0x40)

	)

51 #define 
	#SNMP_ASN1_CONSTR
 (0x20)

	)

52 #define 
	#SNMP_ASN1_PRIMIT
 (!0x20)

	)

55 #define 
	#SNMP_ASN1_INTEG
 2

	)

56 #define 
	#SNMP_ASN1_OC_STR
 4

	)

57 #define 
	#SNMP_ASN1_NUL
 5

	)

58 #define 
	#SNMP_ASN1_OBJ_ID
 6

	)

59 #define 
	#SNMP_ASN1_SEQ
 16

	)

62 #define 
	#SNMP_ASN1_IPADDR
 0

	)

63 #define 
	#SNMP_ASN1_COUNTER
 1

	)

64 #define 
	#SNMP_ASN1_GAUGE
 2

	)

65 #define 
	#SNMP_ASN1_TIMETICKS
 3

	)

66 #define 
	#SNMP_ASN1_OPAQUE
 4

	)

69 #define 
	#SNMP_ASN1_PDU_GET_REQ
 0

	)

70 #define 
	#SNMP_ASN1_PDU_GET_NEXT_REQ
 1

	)

71 #define 
	#SNMP_ASN1_PDU_GET_RESP
 2

	)

72 #define 
	#SNMP_ASN1_PDU_SET_REQ
 3

	)

73 #define 
	#SNMP_ASN1_PDU_TRAP
 4

	)

75 
err_t
 
snmp_asn1_dec_type
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 *
type
);

76 
err_t
 
snmp_asn1_dec_length
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 *
octets_used
, u16_t *
length
);

77 
err_t
 
snmp_asn1_dec_u32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, 
u32_t
 *
value
);

78 
err_t
 
snmp_asn1_dec_s32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, 
s32_t
 *
value
);

79 
err_t
 
snmp_asn1_dec_oid
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, struct 
snmp_obj_id
 *
oid
);

80 
err_t
 
snmp_asn1_dec_raw
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
len
, u16_t 
raw_len
, 
u8_t
 *
raw
);

82 void 
snmp_asn1_enc_length_cnt
(
u16_t
 
length
, 
u8_t
 *
octets_needed
);

83 void 
snmp_asn1_enc_u32t_cnt
(
u32_t
 
value
, 
u16_t
 *
octets_needed
);

84 void 
snmp_asn1_enc_s32t_cnt
(
s32_t
 
value
, 
u16_t
 *
octets_needed
);

85 void 
snmp_asn1_enc_oid_cnt
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, 
u16_t
 *
octets_needed
);

86 
err_t
 
snmp_asn1_enc_type
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
type
);

87 
err_t
 
snmp_asn1_enc_length
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, u16_t 
length
);

88 
err_t
 
snmp_asn1_enc_u32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
octets_needed
, 
u32_t
 
value
);

89 
err_t
 
snmp_asn1_enc_s32t
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
octets_needed
, 
s32_t
 
value
);

90 
err_t
 
snmp_asn1_enc_oid
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
ident_len
, 
s32_t
 *
ident
);

91 
err_t
 
snmp_asn1_enc_raw
(struct 
pbuf
 *
p
, 
u16_t
 
ofs
, 
u8_t
 
raw_len
, u8_t *
raw
);

93 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/snmp_msg.h

35 #ifndef 
__LWIP_SNMP_MSG_H__


36 #define 
	#__LWIP_SNMP_MSG_H__


	)

38 #include 
	~"lwip/opt.h
"

39 #include 
	~"lwip/snmp.h
"

40 #include 
	~"lwip/snmp_structs.h
"

42 #if 
SNMP_PRIVATE_MIB


43 #include 
	~"private_mib.h
"

46 #ifdef 
__cplusplus


52 #ifndef 
SNMP_IN_PORT


53 #define 
	#SNMP_IN_PORT
 161

	)

57 #ifndef 
SNMP_TRAP_PORT


58 #define 
	#SNMP_TRAP_PORT
 162

	)

61 #define 
	#SNMP_ES_NOERROR
 0

	)

62 #define 
	#SNMP_ES_TOOBIG
 1

	)

63 #define 
	#SNMP_ES_NOSUCHNAME
 2

	)

64 #define 
	#SNMP_ES_BADVALUE
 3

	)

65 #define 
	#SNMP_ES_READONLY
 4

	)

66 #define 
	#SNMP_ES_GENERROR
 5

	)

68 #define 
	#SNMP_GENTRAP_COLDSTART
 0

	)

69 #define 
	#SNMP_GENTRAP_WARMSTART
 1

	)

70 #define 
	#SNMP_GENTRAP_AUTHFAIL
 4

	)

71 #define 
	#SNMP_GENTRAP_ENTERPRISESPC
 6

	)

73 struct 
	ssnmp_varbind


76 struct 
snmp_varbind
 *
next
;

78 struct 
snmp_varbind
 *
prev
;

81 
u8_t
 
ident_len
;

83 
s32_t
 *
ident
;

86 
u8_t
 
value_type
;

88 
u8_t
 
value_len
;

90 void *
value
;

93 
u8_t
 
seqlenlen
;

95 
u8_t
 
olenlen
;

97 
u8_t
 
vlenlen
;

99 
u16_t
 
seqlen
;

101 
u16_t
 
olen
;

103 
u16_t
 
vlen
;

106 struct 
	ssnmp_varbind_root


108 struct 
snmp_varbind
 *
head
;

109 struct 
snmp_varbind
 *
tail
;

111 
u8_t
 
count
;

113 
u8_t
 
seqlenlen
;

115 
u16_t
 
seqlen
;

119 struct 
	ssnmp_resp_header_lengths


122 
u8_t
 
erridxlenlen
;

124 
u8_t
 
errstatlenlen
;

126 
u8_t
 
ridlenlen
;

128 
u8_t
 
pdulenlen
;

130 
u8_t
 
comlenlen
;

132 
u8_t
 
verlenlen
;

134 
u8_t
 
seqlenlen
;

137 
u16_t
 
erridxlen
;

139 
u16_t
 
errstatlen
;

141 
u16_t
 
ridlen
;

143 
u16_t
 
pdulen
;

145 
u16_t
 
comlen
;

147 
u16_t
 
verlen
;

149 
u16_t
 
seqlen
;

153 struct 
	ssnmp_trap_header_lengths


156 
u8_t
 
tslenlen
;

158 
u8_t
 
strplenlen
;

160 
u8_t
 
gtrplenlen
;

162 
u8_t
 
aaddrlenlen
;

164 
u8_t
 
eidlenlen
;

166 
u8_t
 
pdulenlen
;

168 
u8_t
 
comlenlen
;

170 
u8_t
 
verlenlen
;

172 
u8_t
 
seqlenlen
;

175 
u16_t
 
tslen
;

177 
u16_t
 
strplen
;

179 
u16_t
 
gtrplen
;

181 
u16_t
 
aaddrlen
;

183 
u16_t
 
eidlen
;

185 
u16_t
 
pdulen
;

187 
u16_t
 
comlen
;

189 
u16_t
 
verlen
;

191 
u16_t
 
seqlen
;

195 #define 
	#SNMP_MSG_EMPTY
 0

	)

197 #define 
	#SNMP_MSG_SEARCH_OBJ
 1

	)

200 #define 
	#SNMP_MSG_INTERNAL_GET_OBJDEF
 2

	)

201 #define 
	#SNMP_MSG_INTERNAL_GET_VALUE
 3

	)

202 #define 
	#SNMP_MSG_INTERNAL_SET_TEST
 4

	)

203 #define 
	#SNMP_MSG_INTERNAL_GET_OBJDEF_S
 5

	)

204 #define 
	#SNMP_MSG_INTERNAL_SET_VALUE
 6

	)

208 #define 
	#SNMP_MSG_EXTERNAL_GET_OBJDEF
 7

	)

209 #define 
	#SNMP_MSG_EXTERNAL_GET_VALUE
 8

	)

210 #define 
	#SNMP_MSG_EXTERNAL_SET_TEST
 9

	)

211 #define 
	#SNMP_MSG_EXTERNAL_GET_OBJDEF_S
 10

	)

212 #define 
	#SNMP_MSG_EXTERNAL_SET_VALUE
 11

	)

214 #define 
	#SNMP_COMMUNITY_STR_LEN
 64

	)

215 struct 
	ssnmp_msg_pstat


218 struct 
udp_pcb
 *
pcb
;

220 struct 
ip_addr
 
sip
;

222 
u16_t
 
sp
;

224 
u8_t
 
rt
;

226 
s32_t
 
rid
;

228 
s32_t
 
error_status
;

230 
s32_t
 
error_index
;

232 
u8_t
 
community
[
SNMP_COMMUNITY_STR_LEN
 + 1];

234 
u8_t
 
com_strlen
;

236 
u8_t
 
state
;

238 struct 
mib_external_node
 *
ext_mib_node
;

239 struct 
snmp_name_ptr
 
ext_name_ptr
;

240 struct 
obj_def
 
ext_object_def
;

241 struct 
snmp_obj_id
 
ext_oid
;

243 
u8_t
 
vb_idx
;

245 struct 
snmp_varbind
 *
vb_ptr
;

247 struct 
snmp_varbind_root
 
invb
;

249 struct 
snmp_varbind_root
 
outvb
;

251 struct 
snmp_resp_header_lengths
 
rhl
;

254 struct 
	ssnmp_msg_trap


257 struct 
udp_pcb
 *
pcb
;

259 struct 
ip_addr
 
dip
;

262 struct 
snmp_obj_id
 *
enterprise
;

264 
u8_t
 
sip_raw
[4];

266 
u32_t
 
gen_trap
;

268 
u32_t
 
spc_trap
;

270 
u32_t
 
ts
;

272 struct 
snmp_varbind_root
 
outvb
;

274 struct 
snmp_trap_header_lengths
 
thl
;

278 extern const 
s32_t
 
snmp_version
;

280 extern const char 
snmp_publiccommunity
[7];

282 extern struct 
snmp_msg_trap
 
trap_msg
;

285 void 
snmp_init
(void);

286 void 
snmp_trap_dst_enable
(
u8_t
 
dst_idx
, u8_t 
enable
);

287 void 
snmp_trap_dst_ip_set
(
u8_t
 
dst_idx
, struct 
ip_addr
 *
dst
);

290 struct 
snmp_varbind
* 
snmp_varbind_alloc
(struct 
snmp_obj_id
 *
oid
, 
u8_t
 
type
, u8_t 
len
);

291 void 
snmp_varbind_free
(struct 
snmp_varbind
 *
vb
);

292 void 
snmp_varbind_list_free
(struct 
snmp_varbind_root
 *
root
);

293 void 
snmp_varbind_tail_add
(struct 
snmp_varbind_root
 *
root
, struct 
snmp_varbind
 *
vb
);

294 struct 
snmp_varbind
* 
snmp_varbind_tail_remove
(struct 
snmp_varbind_root
 *
root
);

297 void 
snmp_msg_event
(
u8_t
 
request_id
);

298 
err_t
 
snmp_send_response
(struct 
snmp_msg_pstat
 *
m_stat
);

299 
err_t
 
snmp_send_trap
(
s8_t
 
generic_trap
, struct 
snmp_obj_id
 *
eoid
, 
s32_t
 
specific_trap
);

300 void 
snmp_coldstart_trap
(void);

301 void 
snmp_authfail_trap
(void);

303 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/snmp_structs.h

37 #ifndef 
__LWIP_SNMP_STRUCTS_H__


38 #define 
	#__LWIP_SNMP_STRUCTS_H__


	)

40 #include 
	~"lwip/opt.h
"

42 #if 
LWIP_SNMP


44 #include 
	~"lwip/snmp.h
"

46 #if 
SNMP_PRIVATE_MIB


47 #include 
	~"private_mib.h
"

50 #ifdef 
__cplusplus


55 #define 
	#MIB_OBJECT_NONE
 0

	)

56 #define 
	#MIB_OBJECT_SCALAR
 1

	)

57 #define 
	#MIB_OBJECT_TAB
 2

	)

60 #define 
	#MIB_OBJECT_READ_ONLY
 0

	)

61 #define 
	#MIB_OBJECT_READ_WRITE
 1

	)

62 #define 
	#MIB_OBJECT_WRITE_ONLY
 2

	)

63 #define 
	#MIB_OBJECT_NOT_ACCESSIBLE
 3

	)

66 struct 
	sobj_def


69 
u8_t
 
instance
;

71 
u8_t
 
access
;

73 
u8_t
 
asn_type
;

75 
u16_t
 
v_len
;

77 
u8_t
 
id_inst_len
;

79 
s32_t
 *
id_inst_ptr
;

82 struct 
	ssnmp_name_ptr


84 
u8_t
 
ident_len
;

85 
s32_t
 *
ident
;

89 #define 
	#MIB_NODE_SC
 0x01

	)

91 #define 
	#MIB_NODE_AR
 0x02

	)

93 #define 
	#MIB_NODE_RA
 0x03

	)

95 #define 
	#MIB_NODE_LR
 0x04

	)

97 #define 
	#MIB_NODE_EX
 0x05

	)

100 struct 
	smib_node


103 void (*
get_object_def
)(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

106 void (*
get_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

108 
u8_t
 (*
set_test
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

110 void (*
set_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

112 const 
u8_t
 
node_type
;

114 const 
u16_t
 
maxlength
;

118 typedef struct 
mib_node
 
	tmib_scalar_node
;

122 struct 
	smib_array_node


125 void (* const 
get_object_def
)(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

126 void (* const 
get_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

127 
u8_t
 (*
set_test
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

128 void (*
set_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

130 const 
u8_t
 
node_type
;

131 const 
u16_t
 
maxlength
;

134 const 
s32_t
 *
objid
;

135 struct 
mib_node
* const *
nptr
;

140 struct 
	smib_ram_array_node


143 void (*
get_object_def
)(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

144 void (*
get_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

145 
u8_t
 (*
set_test
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

146 void (*
set_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

148 
u8_t
 
node_type
;

149 
u16_t
 
maxlength
;

152 
s32_t
 *
objid
;

153 struct 
mib_node
 **
nptr
;

156 struct 
	smib_list_node


158 struct 
mib_list_node
 *
prev
;

159 struct 
mib_list_node
 *
next
;

160 
s32_t
 
objid
;

161 struct 
mib_node
 *
nptr
;

166 struct 
	smib_list_rootnode


169 void (*
get_object_def
)(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

170 void (*
get_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

171 
u8_t
 (*
set_test
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

172 void (*
set_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

174 
u8_t
 
node_type
;

175 
u16_t
 
maxlength
;

178 struct 
mib_list_node
 *
head
;

179 struct 
mib_list_node
 *
tail
;

181 
u16_t
 
count
;

186 struct 
	smib_external_node


189 void (*
get_object_def
)(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

190 void (*
get_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

191 
u8_t
 (*
set_test
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

192 void (*
set_value
)(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

194 
u8_t
 
node_type
;

195 
u16_t
 
maxlength
;

200 void* 
addr_inf
;

202 
u8_t
 
tree_levels
;

204 
u16_t
 (*
level_length
)(void* 
addr_inf
, 
u8_t
 
level
);

207 
s32_t
 (*
ident_cmp
)(void* 
addr_inf
, 
u8_t
 
level
, 
u16_t
 
idx
, s32_t 
sub_id
);

208 void (*
get_objid
)(void* 
addr_inf
, 
u8_t
 
level
, 
u16_t
 
idx
, 
s32_t
 *
sub_id
);

211 void (*
get_object_def_q
)(void* 
addr_inf
, 
u8_t
 
rid
, u8_t 
ident_len
, 
s32_t
 *
ident
);

212 void (*
get_value_q
)(
u8_t
 
rid
, struct 
obj_def
 *
od
);

213 void (*
set_test_q
)(
u8_t
 
rid
, struct 
obj_def
 *
od
);

214 void (*
set_value_q
)(
u8_t
 
rid
, struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

216 void (*
get_object_def_a
)(
u8_t
 
rid
, u8_t 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

217 void (*
get_value_a
)(
u8_t
 
rid
, struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

218 
u8_t
 (*
set_test_a
)(u8_t 
rid
, struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

219 void (*
set_value_a
)(
u8_t
 
rid
, struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

222 void (*
get_object_def_pc
)(
u8_t
 
rid
, u8_t 
ident_len
, 
s32_t
 *
ident
);

223 void (*
get_value_pc
)(
u8_t
 
rid
, struct 
obj_def
 *
od
);

224 void (*
set_test_pc
)(
u8_t
 
rid
, struct 
obj_def
 *
od
);

225 void (*
set_value_pc
)(
u8_t
 
rid
, struct 
obj_def
 *
od
);

229 extern const struct 
mib_array_node
 
internet
;

232 void 
noleafs_get_object_def
(
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
obj_def
 *
od
);

233 void 
noleafs_get_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

234 
u8_t
 
noleafs_set_test
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

235 void 
noleafs_set_value
(struct 
obj_def
 *
od
, 
u16_t
 
len
, void *
value
);

237 void 
snmp_oidtoip
(
s32_t
 *
ident
, struct 
ip_addr
 *
ip
);

238 void 
snmp_iptooid
(struct 
ip_addr
 *
ip
, 
s32_t
 *
ident
);

239 void 
snmp_ifindextonetif
(
s32_t
 
ifindex
, struct 
netif
 **netif);

240 void 
snmp_netiftoifindex
(struct 
netif
 *netif, 
s32_t
 *
ifidx
);

242 struct 
mib_list_node
* 
snmp_mib_ln_alloc
(
s32_t
 
id
);

243 void 
snmp_mib_ln_free
(struct 
mib_list_node
 *
ln
);

244 struct 
mib_list_rootnode
* 
snmp_mib_lrn_alloc
(void);

245 void 
snmp_mib_lrn_free
(struct 
mib_list_rootnode
 *
lrn
);

247 
s8_t
 
snmp_mib_node_insert
(struct 
mib_list_rootnode
 *
rn
, 
s32_t
 
objid
, struct 
mib_list_node
 **
insn
);

248 
s8_t
 
snmp_mib_node_find
(struct 
mib_list_rootnode
 *
rn
, 
s32_t
 
objid
, struct 
mib_list_node
 **
fn
);

249 struct 
mib_list_rootnode
 *
snmp_mib_node_delete
(struct mib_list_rootnode *
rn
, struct 
mib_list_node
 *
n
);

251 struct 
mib_node
* 
snmp_search_tree
(struct mib_node *
node
, 
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
snmp_name_ptr
 *
np
);

252 struct 
mib_node
* 
snmp_expand_tree
(struct mib_node *
node
, 
u8_t
 
ident_len
, 
s32_t
 *
ident
, struct 
snmp_obj_id
 *
oidret
);

253 
u8_t
 
snmp_iso_prefix_tst
(u8_t 
ident_len
, 
s32_t
 *
ident
);

254 
u8_t
 
snmp_iso_prefix_expand
(u8_t 
ident_len
, 
s32_t
 *
ident
, struct 
snmp_obj_id
 *
oidret
);

256 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/sockets.h

34 #ifndef 
__LWIP_SOCKETS_H__


35 #define 
	#__LWIP_SOCKETS_H__


	)

37 #include 
	~"lwip/opt.h
"

39 #if 
LWIP_SOCKET


41 #include 
	~"lwip/ip_addr.h
"

42 #include 
	~"lwip/inet.h
"

44 #ifdef 
__cplusplus


49 struct 
	ssockaddr_in
 {

50 
u8_t
 
sin_len
;

51 
u8_t
 
sin_family
;

52 
u16_t
 
sin_port
;

53 struct 
in_addr
 
sin_addr
;

54 char 
sin_zero
[8];

57 struct 
	ssockaddr
 {

58 
u8_t
 
sa_len
;

59 
u8_t
 
sa_family
;

60 char 
sa_data
[14];

63 #ifndef 
socklen_t


64 #define 
	#socklen_t
 
u32_t


	)

68 #define 
	#SOCK_STREAM
 1

	)

69 #define 
	#SOCK_DGRAM
 2

	)

70 #define 
	#SOCK_RAW
 3

	)

75 #define 
	#SO_DEBUG
 0x0001

	)

76 #define 
	#SO_ACCEPTCONN
 0x0002

	)

77 #define 
	#SO_REUSEADDR
 0x0004

	)

78 #define 
	#SO_KEEPALIVE
 0x0008

	)

79 #define 
	#SO_DONTROUTE
 0x0010

	)

80 #define 
	#SO_BROADCAST
 0x0020

	)

81 #define 
	#SO_USELOOPBACK
 0x0040

	)

82 #define 
	#SO_LINGER
 0x0080

	)

83 #define 
	#SO_OOBINLINE
 0x0100

	)

84 #define 
	#SO_REUSEPORT
 0x0200

	)

86 #define 
	#SO_DONTLINGER
 ((int)(~
SO_LINGER
))

	)

91 #define 
	#SO_SNDBUF
 0x1001

	)

92 #define 
	#SO_RCVBUF
 0x1002

	)

93 #define 
	#SO_SNDLOWAT
 0x1003

	)

94 #define 
	#SO_RCVLOWAT
 0x1004

	)

95 #define 
	#SO_SNDTIMEO
 0x1005

	)

96 #define 
	#SO_RCVTIMEO
 0x1006

	)

97 #define 
	#SO_ERROR
 0x1007

	)

98 #define 
	#SO_TYPE
 0x1008

	)

99 #define 
	#SO_CONTIMEO
 0x1009

	)

100 #define 
	#SO_NO_CHECK
 0x100a

	)

106 struct 
	slinger
 {

107 int 
l_onoff
;

108 int 
l_linger
;

114 #define 
	#SOL_SOCKET
 0xfff

	)

117 #define 
	#AF_UNSPEC
 0

	)

118 #define 
	#AF_INET
 2

	)

119 #define 
	#PF_INET
 
AF_INET


	)

120 #define 
	#PF_UNSPEC
 
AF_UNSPEC


	)

122 #define 
	#IPPROTO_IP
 0

	)

123 #define 
	#IPPROTO_TCP
 6

	)

124 #define 
	#IPPROTO_UDP
 17

	)

125 #define 
	#IPPROTO_UDPLITE
 136

	)

127 #define 
	#INADDR_ANY
 0

	)

128 #define 
	#INADDR_BROADCAST
 0xffffffff

	)

131 #define 
	#MSG_PEEK
 0x01

	)

132 #define 
	#MSG_WAITALL
 0x02

	)

133 #define 
	#MSG_OOB
 0x04

	)

134 #define 
	#MSG_DONTWAIT
 0x08

	)

135 #define 
	#MSG_MORE
 0x10

	)

141 #define 
	#IP_TOS
 1

	)

142 #define 
	#IP_TTL
 2

	)

144 #if 
LWIP_TCP


148 #define 
	#TCP_NODELAY
 0x01

	)

149 #define 
	#TCP_KEEPALIVE
 0x02

	)

150 #define 
	#TCP_KEEPIDLE
 0x03

	)

151 #define 
	#TCP_KEEPINTVL
 0x04

	)

152 #define 
	#TCP_KEEPCNT
 0x05

	)

155 #if 
LWIP_UDP
 && 
LWIP_UDPLITE


159 #define 
	#UDPLITE_SEND_CSCOV
 0x01

	)

160 #define 
	#UDPLITE_RECV_CSCOV
 0x02

	)

164 #if 
LWIP_IGMP


168 #define 
	#IP_ADD_MEMBERSHIP
 3

	)

169 #define 
	#IP_DROP_MEMBERSHIP
 4

	)

170 #define 
	#IP_MULTICAST_TTL
 5

	)

171 #define 
	#IP_MULTICAST_IF
 6

	)

172 #define 
	#IP_MULTICAST_LOOP
 7

	)

174 typedef struct 
	sip_mreq
 {

175 struct 
in_addr
 
imr_multiaddr
;

176 struct 
in_addr
 
imr_interface
;

177 } 
	tip_mreq
;

196 #define 
	#IPTOS_TOS_MASK
 0x1E

	)

197 #define 
	#IPTOS_TOS
(
tos
) ((tos) & 
IPTOS_TOS_MASK
)

	)

198 #define 
	#IPTOS_LOWDELAY
 0x10

	)

199 #define 
	#IPTOS_THROUGHPUT
 0x08

	)

200 #define 
	#IPTOS_RELIABILITY
 0x04

	)

201 #define 
	#IPTOS_LOWCOST
 0x02

	)

202 #define 
	#IPTOS_MINCOST
 
IPTOS_LOWCOST


	)

213 #define 
	#IPTOS_PREC_MASK
 0xe0

	)

214 #define 
	#IPTOS_PREC
(
tos
) ((tos) & 
IPTOS_PREC_MASK
)

	)

215 #define 
	#IPTOS_PREC_NETCONTROL
 0xe0

	)

216 #define 
	#IPTOS_PREC_INTERNETCONTROL
 0xc0

	)

217 #define 
	#IPTOS_PREC_CRITIC_ECP
 0xa0

	)

218 #define 
	#IPTOS_PREC_FLASHOVERRIDE
 0x80

	)

219 #define 
	#IPTOS_PREC_FLASH
 0x60

	)

220 #define 
	#IPTOS_PREC_IMMEDIATE
 0x40

	)

221 #define 
	#IPTOS_PREC_PRIORITY
 0x20

	)

222 #define 
	#IPTOS_PREC_ROUTINE
 0x00

	)

235 #if !
defined
(
FIONREAD
) || !defined(
FIONBIO
)

236 #define 
	#IOCPARM_MASK
 0x7fU

	)

237 #define 
	#IOC_VOID
 0x20000000UL

	)

238 #define 
	#IOC_OUT
 0x40000000UL

	)

239 #define 
	#IOC_IN
 0x80000000UL

	)

240 #define 
	#IOC_INOUT
 (
IOC_IN
|
IOC_OUT
)

	)

243 #define 
	#_IO
(
x
,
y
) (
IOC_VOID
|((x)<<8)|(y))

	)

245 #define 
	#_IOR
(
x
,
y
,
t
) (
IOC_OUT
|(((long)sizeof(t)&
IOCPARM_MASK
)<<16)|((x)<<8)|(y))

	)

247 #define 
	#_IOW
(
x
,
y
,
t
) (
IOC_IN
|(((long)sizeof(t)&
IOCPARM_MASK
)<<16)|((x)<<8)|(y))

	)

250 #ifndef 
FIONREAD


251 #define 
	#FIONREAD
 
	`_IOR
('f', 127, unsigned long)

	)

253 #ifndef 
FIONBIO


254 #define 
	#FIONBIO
 
	`_IOW
('f', 126, unsigned long)

	)

258 #ifndef 
SIOCSHIWAT


259 #define 
	#SIOCSHIWAT
 
	`_IOW
('s', 0, unsigned long)

	)

260 #define 
	#SIOCGHIWAT
 
	`_IOR
('s', 1, unsigned long)

	)

261 #define 
	#SIOCSLOWAT
 
	`_IOW
('s', 2, unsigned long)

	)

262 #define 
	#SIOCGLOWAT
 
	`_IOR
('s', 3, unsigned long)

	)

263 #define 
	#SIOCATMARK
 
	`_IOR
('s', 7, unsigned long)

	)

267 #ifndef 
O_NONBLOCK


268 #define 
	#O_NONBLOCK
 04000U

	)

272 #ifndef 
FD_SET


273 #undef 
FD_SETSIZE


275 #define 
	#FD_SETSIZE
 
MEMP_NUM_NETCONN


	)

276 #define 
	#FD_SET
(
n
, 
p
) ((p)->
fd_bits
[(n)/8] |= (1 << ((n) & 7)))

	)

277 #define 
	#FD_CLR
(
n
, 
p
) ((p)->
fd_bits
[(n)/8] &= ~(1 << ((n) & 7)))

	)

278 #define 
	#FD_ISSET
(
n
,
p
) ((p)->
fd_bits
[(n)/8] & (1 << ((n) & 7)))

	)

279 #define 
	#FD_ZERO
(
p
) 
	`memset
((void*)(p),0,sizeof(*(p)))

	)

281 typedef struct 
	sfd_set
 {

282 unsigned char 
fd_bits
 [(
FD_SETSIZE
+7)/8];

283 } 
	tfd_set
;

289 #ifndef 
LWIP_TIMEVAL_PRIVATE


290 #define 
	#LWIP_TIMEVAL_PRIVATE
 1

	)

293 #if 
LWIP_TIMEVAL_PRIVATE


294 struct 
	stimeval
 {

295 long 
tv_sec
;

296 long 
tv_usec
;

300 void 
lwip_socket_init
(void);

302 int 
lwip_accept
(int 
s
, struct 
sockaddr
 *
addr
, 
socklen_t
 *
addrlen
);

303 int 
lwip_bind
(int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
);

304 int 
lwip_shutdown
(int 
s
, int 
how
);

305 int 
lwip_getpeername
 (int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 *
namelen
);

306 int 
lwip_getsockname
 (int 
s
, struct 
sockaddr
 *
name
, 
socklen_t
 *
namelen
);

307 int 
lwip_getsockopt
 (int 
s
, int 
level
, int 
optname
, void *
optval
, 
socklen_t
 *
optlen
);

308 int 
lwip_setsockopt
 (int 
s
, int 
level
, int 
optname
, const void *
optval
, 
socklen_t
 
optlen
);

309 int 
lwip_close
(int 
s
);

310 int 
lwip_connect
(int 
s
, const struct 
sockaddr
 *
name
, 
socklen_t
 
namelen
);

311 int 
lwip_listen
(int 
s
, int 
backlog
);

312 int 
lwip_recv
(int 
s
, void *
mem
, int 
len
, unsigned int 
flags
);

313 int 
lwip_read
(int 
s
, void *
mem
, int 
len
);

314 int 
lwip_recvfrom
(int 
s
, void *
mem
, int 
len
, unsigned int 
flags
,

315 struct 
sockaddr
 *
from
, 
socklen_t
 *
fromlen
);

316 int 
lwip_send
(int 
s
, const void *
dataptr
, int 
size
, unsigned int 
flags
);

317 int 
lwip_sendto
(int 
s
, const void *
dataptr
, int 
size
, unsigned int 
flags
,

318 struct 
sockaddr
 *
to
, 
socklen_t
 
tolen
);

319 int 
lwip_socket
(int 
domain
, int 
type
, int 
protocol
);

320 int 
lwip_write
(int 
s
, const void *
dataptr
, int 
size
);

321 int 
lwip_select
(int 
maxfdp1
, 
fd_set
 *
readset
, fd_set *
writeset
, fd_set *
exceptset
,

322 struct 
timeval
 *
timeout
);

323 int 
lwip_ioctl
(int 
s
, long 
cmd
, void *
argp
);

325 #if 
LWIP_COMPAT_SOCKETS


326 #define 
	#accept
(
a
,
b
,
c
) 
	`lwip_accept
(a,b,c)

	)

327 #define 
	#bind
(
a
,
b
,
c
) 
	`lwip_bind
(a,b,c)

	)

328 #define 
	#shutdown
(
a
,
b
) 
	`lwip_shutdown
(a,b)

	)

329 #define 
	#closesocket
(
s
) 
	`lwip_close
(s)

	)

330 #define 
	#connect
(
a
,
b
,
c
) 
	`lwip_connect
(a,b,c)

	)

331 #define 
	#getsockname
(
a
,
b
,
c
) 
	`lwip_getsockname
(a,b,c)

	)

332 #define 
	#getpeername
(
a
,
b
,
c
) 
	`lwip_getpeername
(a,b,c)

	)

333 #define 
	#setsockopt
(
a
,
b
,
c
,
d
,
e
) 
	`lwip_setsockopt
(a,b,c,d,e)

	)

334 #define 
	#getsockopt
(
a
,
b
,
c
,
d
,
e
) 
	`lwip_getsockopt
(a,b,c,d,e)

	)

335 #define 
	#listen
(
a
,
b
) 
	`lwip_listen
(a,b)

	)

336 #define 
	#recv
(
a
,
b
,
c
,
d
) 
	`lwip_recv
(a,b,c,d)

	)

337 #define 
	#recvfrom
(
a
,
b
,
c
,
d
,
e
,
f
) 
	`lwip_recvfrom
(a,b,c,d,e,f)

	)

338 #define 
	#send
(
a
,
b
,
c
,
d
) 
	`lwip_send
(a,b,c,d)

	)

339 #define 
	#sendto
(
a
,
b
,
c
,
d
,
e
,
f
) 
	`lwip_sendto
(a,b,c,d,e,f)

	)

340 #define 
	#socket
(
a
,
b
,
c
) 
	`lwip_socket
(a,b,c)

	)

341 #define 
	#select
(
a
,
b
,
c
,
d
,
e
) 
	`lwip_select
(a,b,c,d,e)

	)

342 #define 
	#ioctlsocket
(
a
,
b
,
c
) 
	`lwip_ioctl
(a,b,c)

	)

344 #if 
LWIP_POSIX_SOCKETS_IO_NAMES


345 #define 
	#read
(
a
,
b
,
c
) 
	`lwip_read
(a,b,c)

	)

346 #define 
	#write
(
a
,
b
,
c
) 
	`lwip_write
(a,b,c)

	)

347 #define 
	#close
(
s
) 
	`lwip_close
(s)

	)

352 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/stats.h

32 #ifndef 
__LWIP_STATS_H__


33 #define 
	#__LWIP_STATS_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #include 
	~"lwip/mem.h
"

38 #include 
	~"lwip/memp.h
"

40 #ifdef 
__cplusplus


44 #if 
LWIP_STATS


46 #ifndef 
LWIP_STATS_LARGE


47 #define 
	#LWIP_STATS_LARGE
 0

	)

50 #if 
LWIP_STATS_LARGE


51 #define 
	#STAT_COUNTER
 
u32_t


	)

52 #define 
	#STAT_COUNTER_F
 
U32_F


	)

54 #define 
	#STAT_COUNTER
 
u16_t


	)

55 #define 
	#STAT_COUNTER_F
 
U16_F


	)

58 struct 
	sstats_proto
 {

59 
STAT_COUNTER
 
xmit
;

60 
STAT_COUNTER
 
recv
;

61 
STAT_COUNTER
 
fw
;

62 
STAT_COUNTER
 
drop
;

63 
STAT_COUNTER
 
chkerr
;

64 
STAT_COUNTER
 
lenerr
;

65 
STAT_COUNTER
 
memerr
;

66 
STAT_COUNTER
 
rterr
;

67 
STAT_COUNTER
 
proterr
;

68 
STAT_COUNTER
 
opterr
;

69 
STAT_COUNTER
 
err
;

70 
STAT_COUNTER
 
cachehit
;

73 struct 
	sstats_igmp
 {

74 
STAT_COUNTER
 
	mlenerr
;

75 
STAT_COUNTER
 
	mchkerr
;

76 
STAT_COUNTER
 
	mv1_rxed
;

77 
STAT_COUNTER
 
	mjoin_sent
;

78 
STAT_COUNTER
 
	mleave_sent
;

79 
STAT_COUNTER
 
	municast_query
;

80 
STAT_COUNTER
 
	mreport_sent
;

81 
STAT_COUNTER
 
	mreport_rxed
;

82 
STAT_COUNTER
 
	mgroup_query_rxed
;

85 struct 
	sstats_mem
 {

86 
mem_size_t
 
	mavail
;

87 
mem_size_t
 
	mused
;

88 
mem_size_t
 
	mmax
;

89 
STAT_COUNTER
 
	merr
;

90 
STAT_COUNTER
 
	millegal
;

93 struct 
	sstats_syselem
 {

94 
STAT_COUNTER
 
	mused
;

95 
STAT_COUNTER
 
	mmax
;

96 
STAT_COUNTER
 
	merr
;

99 struct 
	sstats_sys
 {

100 struct 
stats_syselem
 
	msem
;

101 struct 
stats_syselem
 
	mmbox
;

104 struct 
	sstats_
 {

105 #if 
LINK_STATS


106 struct 
stats_proto
 
	mlink
;

108 #if 
ETHARP_STATS


109 struct 
stats_proto
 
	metharp
;

111 #if 
IPFRAG_STATS


112 struct 
stats_proto
 
	mip_frag
;

114 #if 
IP_STATS


115 struct 
stats_proto
 
	mip
;

117 #if 
ICMP_STATS


118 struct 
stats_proto
 
	micmp
;

120 #if 
IGMP_STATS


121 struct 
stats_igmp
 
	migmp
;

123 #if 
UDP_STATS


124 struct 
stats_proto
 
	mudp
;

126 #if 
TCP_STATS


127 struct 
stats_proto
 
	mtcp
;

129 #if 
MEM_STATS


130 struct 
stats_mem
 
	mmem
;

132 #if 
MEMP_STATS


133 struct 
stats_mem
 
	mmemp
[
MEMP_MAX
];

135 #if 
SYS_STATS


136 struct 
stats_sys
 
	msys
;

140 extern struct 
stats_
 
lwip_stats
;

142 #define 
	#stats_init
()

	)

144 #define 
	#STATS_INC
(
x
) ++
lwip_stats
.
	)
x

145 #define 
	#STATS_DEC
(
x
) --
lwip_stats
.
	)
x

147 #define 
	#stats_init
()

	)

148 #define 
	#STATS_INC
(
x
)

	)

149 #define 
	#STATS_DEC
(
x
)

	)

152 #if 
TCP_STATS


153 #define 
	#TCP_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

154 #define 
	#TCP_STATS_DISPLAY
() 
	`stats_display_proto
(&
lwip_stats
.
tcp
, "TCP")

	)

156 #define 
	#TCP_STATS_INC
(
x
)

	)

157 #define 
	#TCP_STATS_DISPLAY
()

	)

160 #if 
UDP_STATS


161 #define 
	#UDP_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

162 #define 
	#UDP_STATS_DISPLAY
() 
	`stats_display_proto
(&
lwip_stats
.
udp
, "UDP")

	)

164 #define 
	#UDP_STATS_INC
(
x
)

	)

165 #define 
	#UDP_STATS_DISPLAY
()

	)

168 #if 
ICMP_STATS


169 #define 
	#ICMP_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

170 #define 
	#ICMP_STATS_DISPLAY
() 
	`stats_display_proto
(&
lwip_stats
.
icmp
, "ICMP")

	)

172 #define 
	#ICMP_STATS_INC
(
x
)

	)

173 #define 
	#ICMP_STATS_DISPLAY
()

	)

176 #if 
IGMP_STATS


177 #define 
	#IGMP_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

178 #define 
	#IGMP_STATS_DISPLAY
() 
	`stats_display_igmp
(&
lwip_stats
.
igmp
)

	)

180 #define 
	#IGMP_STATS_INC
(
x
)

	)

181 #define 
	#IGMP_STATS_DISPLAY
()

	)

184 #if 
IP_STATS


185 #define 
	#IP_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

186 #define 
	#IP_STATS_DISPLAY
() 
	`stats_display_proto
(&
lwip_stats
.
ip
, "IP")

	)

188 #define 
	#IP_STATS_INC
(
x
)

	)

189 #define 
	#IP_STATS_DISPLAY
()

	)

192 #if 
IPFRAG_STATS


193 #define 
	#IPFRAG_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

194 #define 
	#IPFRAG_STATS_DISPLAY
() 
	`stats_display_proto
(&
lwip_stats
.
ip_frag
, "IP_FRAG")

	)

196 #define 
	#IPFRAG_STATS_INC
(
x
)

	)

197 #define 
	#IPFRAG_STATS_DISPLAY
()

	)

200 #if 
ETHARP_STATS


201 #define 
	#ETHARP_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

202 #define 
	#ETHARP_STATS_DISPLAY
() 
	`stats_display_proto
(&
lwip_stats
.
etharp
, "ETHARP")

	)

204 #define 
	#ETHARP_STATS_INC
(
x
)

	)

205 #define 
	#ETHARP_STATS_DISPLAY
()

	)

208 #if 
LINK_STATS


209 #define 
	#LINK_STATS_INC
(
x
) 
	`STATS_INC
(x)

	)

210 #define 
	#LINK_STATS_DISPLAY
() 
	`stats_display_proto
(&
lwip_stats
.
link
, "LINK")

	)

212 #define 
	#LINK_STATS_INC
(
x
)

	)

213 #define 
	#LINK_STATS_DISPLAY
()

	)

216 #if 
MEM_STATS


217 #define 
	#MEM_STATS_AVAIL
(
x
, 
y
) 
lwip_stats
.
mem
.x = 
	)
y

218 #define 
	#MEM_STATS_INC
(
x
) 
	`STATS_INC
(
mem
.x)

	)

219 #define 
	#MEM_STATS_INC_USED
(
x
, 
y
) do { 
lwip_stats
.
mem
.
used
 += y; \

220 if (
lwip_stats
.
mem
.
max
 < lwip_stats.mem.
used
) { \

221 
lwip_stats
.
mem
.
max
 = lwip_stats.mem.
used
; \

223 } while(0)

	)

224 #define 
	#MEM_STATS_DEC_USED
(
x
, 
y
) 
lwip_stats
.
mem
.x -= 
	)
y

225 #define 
	#MEM_STATS_DISPLAY
() 
	`stats_display_mem
(&
lwip_stats
.
mem
, "HEAP")

	)

227 #define 
	#MEM_STATS_AVAIL
(
x
, 
y
)

	)

228 #define 
	#MEM_STATS_INC
(
x
)

	)

229 #define 
	#MEM_STATS_INC_USED
(
x
, 
y
)

	)

230 #define 
	#MEM_STATS_DEC_USED
(
x
, 
y
)

	)

231 #define 
	#MEM_STATS_DISPLAY
()

	)

234 #if 
MEMP_STATS


235 #define 
	#MEMP_STATS_AVAIL
(
x
, 
i
, 
y
) 
lwip_stats
.
memp
[i].x = 
	)
y

236 #define 
	#MEMP_STATS_INC
(
x
, 
i
) 
	`STATS_INC
(
memp
[i].x)

	)

237 #define 
	#MEMP_STATS_DEC
(
x
, 
i
) 
	`STATS_DEC
(
memp
[i].x)

	)

238 #define 
	#MEMP_STATS_INC_USED
(
x
, 
i
) do { ++
lwip_stats
.
memp
[i].
used
; \

239 if (
lwip_stats
.
memp
[
i
].
max
 < lwip_stats.memp[i].
used
) { \

240 
lwip_stats
.
memp
[
i
].
max
 = lwip_stats.memp[i].
used
; \

242 } while(0)

	)

243 #define 
	#MEMP_STATS_DISPLAY
(
i
) 
	`stats_display_memp
(&
lwip_stats
.
memp
[i], i)

	)

245 #define 
	#MEMP_STATS_AVAIL
(
x
, 
i
, 
y
)

	)

246 #define 
	#MEMP_STATS_INC
(
x
, 
i
)

	)

247 #define 
	#MEMP_STATS_DEC
(
x
, 
i
)

	)

248 #define 
	#MEMP_STATS_INC_USED
(
x
, 
i
)

	)

249 #define 
	#MEMP_STATS_DISPLAY
(
i
)

	)

252 #if 
SYS_STATS


253 #define 
	#SYS_STATS_INC
(
x
) 
	`STATS_INC
(
sys
.x)

	)

254 #define 
	#SYS_STATS_DEC
(
x
) 
	`STATS_DEC
(
sys
.x)

	)

255 #define 
	#SYS_STATS_DISPLAY
() 
	`stats_display_sys
(&
lwip_stats
.
sys
)

	)

257 #define 
	#SYS_STATS_INC
(
x
)

	)

258 #define 
	#SYS_STATS_DEC
(
x
)

	)

259 #define 
	#SYS_STATS_DISPLAY
()

	)

263 #if 
LWIP_STATS_DISPLAY


264 void 
stats_display
(void);

265 void 
stats_display_proto
(struct 
stats_proto
 *
proto
, char *
name
);

266 void 
stats_display_igmp
(struct 
stats_igmp
 *
igmp
);

267 void 
stats_display_mem
(struct 
stats_mem
 *
mem
, char *
name
);

268 void 
stats_display_memp
(struct 
stats_mem
 *
mem
, int 
index
);

269 void 
stats_display_sys
(struct 
stats_sys
 *
sys
);

271 #define 
	#stats_display
()

	)

272 #define 
	#stats_display_proto
(
proto
, 
name
)

	)

273 #define 
	#stats_display_igmp
(
igmp
)

	)

274 #define 
	#stats_display_mem
(
mem
, 
name
)

	)

275 #define 
	#stats_display_memp
(
mem
, 
index
)

	)

276 #define 
	#stats_display_sys
(
sys
)

	)

279 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/sys.h

32 #ifndef 
__LWIP_SYS_H__


33 #define 
	#__LWIP_SYS_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #ifdef 
__cplusplus


41 #if 
NO_SYS


45 typedef 
u8_t
 
	tsys_sem_t
;

46 typedef 
u8_t
 
	tsys_mbox_t
;

47 typedef 
u8_t
 
	tsys_prot_t
;

48 struct 
	ssys_timeo
 {
u8_t
 
	mdummy
;};

50 #define 
	#sys_init
()

	)

51 #define 
	#sys_timeout
(
m
,
h
,
a
)

	)

52 #define 
	#sys_untimeout
(
m
,
a
)

	)

53 #define 
	#sys_sem_new
(
c
) 
	)
c

54 #define 
	#sys_sem_signal
(
s
)

	)

55 #define 
	#sys_sem_wait
(
s
)

	)

56 #define 
	#sys_sem_wait_timeout
(
s
,
t
)

	)

57 #define 
	#sys_arch_sem_wait
(
s
,
t
)

	)

58 #define 
	#sys_sem_free
(
s
)

	)

59 #define 
	#sys_mbox_new
(
s
) 0

	)

60 #define 
	#sys_mbox_fetch
(
m
,
d
)

	)

61 #define 
	#sys_mbox_tryfetch
(
m
,
d
)

	)

62 #define 
	#sys_mbox_post
(
m
,
d
)

	)

63 #define 
	#sys_mbox_trypost
(
m
,
d
)

	)

64 #define 
	#sys_mbox_free
(
m
)

	)

66 #define 
	#sys_thread_new
(
n
,
t
,
a
,
s
,
p
)

	)

71 #define 
	#SYS_ARCH_TIMEOUT
 0xffffffffUL

	)

76 #define 
	#SYS_MBOX_EMPTY
 
SYS_ARCH_TIMEOUT


	)

78 #include 
	~"lwip/err.h
"

79 #include 
	~"arch/sys_arch.h
"

81 typedef void (* 
	tsys_timeout_handler
)(void *
	targ
);

83 struct 
	ssys_timeo
 {

84 struct 
sys_timeo
 *
next
;

85 
u32_t
 
time
;

86 
sys_timeout_handler
 
h
;

87 void *
arg
;

90 struct 
	ssys_timeouts
 {

91 struct 
sys_timeo
 *
next
;

95 void 
	`sys_init
(void);

106 void 
	`sys_timeout
(
u32_t
 
msecs
, 
sys_timeout_handler
 
h
, void *
arg
);

107 void 
	`sys_untimeout
(
sys_timeout_handler
 
h
, void *
arg
);

108 struct 
sys_timeouts
 *
	`sys_arch_timeouts
(void);

111 
sys_sem_t
 
	`sys_sem_new
(
u8_t
 
count
);

112 void 
	`sys_sem_signal
(
sys_sem_t
 
sem
);

113 
u32_t
 
	`sys_arch_sem_wait
(
sys_sem_t
 
sem
, u32_t 
timeout
);

114 void 
	`sys_sem_free
(
sys_sem_t
 
sem
);

115 void 
	`sys_sem_wait
(
sys_sem_t
 
sem
);

116 int 
	`sys_sem_wait_timeout
(
sys_sem_t
 
sem
, 
u32_t
 
timeout
);

119 #ifndef 
sys_msleep


120 void 
	`sys_msleep
(
u32_t
 
ms
);

122 #ifndef 
sys_jiffies


123 
u32_t
 
	`sys_jiffies
(void);

127 
sys_mbox_t
 
	`sys_mbox_new
(int 
size
);

128 void 
	`sys_mbox_post
(
sys_mbox_t
 
mbox
, void *
msg
);

129 
err_t
 
	`sys_mbox_trypost
(
sys_mbox_t
 
mbox
, void *
msg
);

130 
u32_t
 
	`sys_arch_mbox_fetch
(
sys_mbox_t
 
mbox
, void **
msg
, u32_t 
timeout
);

131 #ifndef 
sys_arch_mbox_tryfetch


132 
u32_t
 
	`sys_arch_mbox_tryfetch
(
sys_mbox_t
 
mbox
, void **
msg
);

135 #define 
	#sys_mbox_tryfetch
(
mbox
, 
msg
) 
	`sys_arch_mbox_tryfetch
(mbox, msg)

	)

136 void 
	`sys_mbox_free
(
sys_mbox_t
 
mbox
);

137 void 
	`sys_mbox_fetch
(
sys_mbox_t
 
mbox
, void **
msg
);

140 
sys_thread_t
 
	`sys_thread_new
(char *
name
, void (* 
thread
)(void *
arg
), void *arg, int 
stacksize
, int 
prio
);

145 unsigned long 
	`sys_now
(void);

154 #ifndef 
SYS_ARCH_PROTECT


160 #if 
SYS_LIGHTWEIGHT_PROT


167 #define 
	#SYS_ARCH_DECL_PROTECT
(
lev
) 
sys_prot_t
 
	)
lev

177 #define 
	#SYS_ARCH_PROTECT
(
lev
) lev = 
	`sys_arch_protect
()

	)

186 #define 
	#SYS_ARCH_UNPROTECT
(
lev
) 
	`sys_arch_unprotect
(lev)

	)

187 
sys_prot_t
 
	`sys_arch_protect
(void);

188 void 
	`sys_arch_unprotect
(
sys_prot_t
 
pval
);

192 #define 
	#SYS_ARCH_DECL_PROTECT
(
lev
)

	)

193 #define 
	#SYS_ARCH_PROTECT
(
lev
)

	)

194 #define 
	#SYS_ARCH_UNPROTECT
(
lev
)

	)

205 #ifndef 
SYS_ARCH_INC


206 #define 
	#SYS_ARCH_INC
(
var
, 
val
) do { \

207 
	`SYS_ARCH_DECL_PROTECT
(
old_level
); \

208 
	`SYS_ARCH_PROTECT
(
old_level
); \

209 
var
 += 
val
; \

210 
	`SYS_ARCH_UNPROTECT
(
old_level
); \

211 } while(0)

	)

214 #ifndef 
SYS_ARCH_DEC


215 #define 
	#SYS_ARCH_DEC
(
var
, 
val
) do { \

216 
	`SYS_ARCH_DECL_PROTECT
(
old_level
); \

217 
	`SYS_ARCH_PROTECT
(
old_level
); \

218 
var
 -= 
val
; \

219 
	`SYS_ARCH_UNPROTECT
(
old_level
); \

220 } while(0)

	)

223 #ifndef 
SYS_ARCH_GET


224 #define 
	#SYS_ARCH_GET
(
var
, 
ret
) do { \

225 
	`SYS_ARCH_DECL_PROTECT
(
old_level
); \

226 
	`SYS_ARCH_PROTECT
(
old_level
); \

227 
ret
 = 
var
; \

228 
	`SYS_ARCH_UNPROTECT
(
old_level
); \

229 } while(0)

	)

232 #ifndef 
SYS_ARCH_SET


233 #define 
	#SYS_ARCH_SET
(
var
, 
val
) do { \

234 
	`SYS_ARCH_DECL_PROTECT
(
old_level
); \

235 
	`SYS_ARCH_PROTECT
(
old_level
); \

236 
var
 = 
val
; \

237 
	`SYS_ARCH_UNPROTECT
(
old_level
); \

238 } while(0)

	)

242 #ifdef 
__cplusplus


243 
	}
}

	@/root/Robux/net/lwip/include/lwip/tcp.h

32 #ifndef 
__LWIP_TCP_H__


33 #define 
	#__LWIP_TCP_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_TCP


39 #include 
	~"lwip/sys.h
"

40 #include 
	~"lwip/mem.h
"

41 #include 
	~"lwip/pbuf.h
"

42 #include 
	~"lwip/ip.h
"

43 #include 
	~"lwip/icmp.h
"

44 #include 
	~"lwip/err.h
"

46 #ifdef 
__cplusplus


50 struct 
tcp_pcb
;

55 #define 
	#tcp_init
()

	)

56 void 
tcp_tmr
 (void);

60 struct 
tcp_pcb
 * 
tcp_new
 (void);

61 struct 
tcp_pcb
 * 
tcp_alloc
 (
u8_t
 
prio
);

63 void 
tcp_arg
 (struct 
tcp_pcb
 *
pcb
, void *
arg
);

64 void 
tcp_accept
 (struct 
tcp_pcb
 *
pcb
,

65 
err_t
 (* 
accept
)(void *
arg
, struct 
tcp_pcb
 *
newpcb
,

66 
err_t
 
err
));

67 void 
tcp_recv
 (struct 
tcp_pcb
 *
pcb
,

68 
err_t
 (* 
recv
)(void *
arg
, struct 
tcp_pcb
 *
tpcb
,

69 struct 
pbuf
 *
p
, 
err_t
 
err
));

70 void 
tcp_sent
 (struct 
tcp_pcb
 *
pcb
,

71 
err_t
 (* 
sent
)(void *
arg
, struct 
tcp_pcb
 *
tpcb
,

72 
u16_t
 
len
));

73 void 
tcp_poll
 (struct 
tcp_pcb
 *
pcb
,

74 
err_t
 (* 
poll
)(void *
arg
, struct 
tcp_pcb
 *
tpcb
),

75 
u8_t
 
interval
);

76 void 
tcp_err
 (struct 
tcp_pcb
 *
pcb
,

77 void (* 
err
)(void *
arg
, 
err_t
 err));

79 #define 
	#tcp_mss
(
pcb
) ((pcb)->
mss
)

	)

80 #define 
	#tcp_sndbuf
(
pcb
) ((pcb)->
snd_buf
)

	)

82 #if 
TCP_LISTEN_BACKLOG


83 #define 
	#tcp_accepted
(
pcb
) (((struct 
tcp_pcb_listen
 *)(pcb))->
accepts_pending
--)

	)

85 #define 
	#tcp_accepted
(
pcb
)

	)

88 void 
tcp_recved
 (struct 
tcp_pcb
 *
pcb
, 
u16_t
 
len
);

89 
err_t
 
tcp_bind
 (struct 
tcp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
,

90 
u16_t
 
port
);

91 
err_t
 
tcp_connect
 (struct 
tcp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
,

92 
u16_t
 
port
, 
err_t
 (* 
connected
)(void *
arg
,

93 struct 
tcp_pcb
 *
tpcb
,

94 
err_t
 
err
));

96 struct 
tcp_pcb
 * 
tcp_listen_with_backlog
(struct tcp_pcb *
pcb
, 
u8_t
 
backlog
);

97 #define 
	#tcp_listen
(
pcb
) 
	`tcp_listen_with_backlog
(pcb, 
TCP_DEFAULT_LISTEN_BACKLOG
)

	)

99 void 
tcp_abort
 (struct 
tcp_pcb
 *
pcb
);

100 
err_t
 
tcp_close
 (struct 
tcp_pcb
 *
pcb
);

103 #define 
	#TCP_WRITE_FLAG_COPY
 0x01

	)

104 #define 
	#TCP_WRITE_FLAG_MORE
 0x02

	)

106 
err_t
 
tcp_write
 (struct 
tcp_pcb
 *
pcb
, const void *
dataptr
, 
u16_t
 
len
,

107 
u8_t
 
apiflags
);

109 void 
tcp_setprio
 (struct 
tcp_pcb
 *
pcb
, 
u8_t
 
prio
);

111 #define 
	#TCP_PRIO_MIN
 1

	)

112 #define 
	#TCP_PRIO_NORMAL
 64

	)

113 #define 
	#TCP_PRIO_MAX
 127

	)

117 void 
tcp_slowtmr
 (void);

118 void 
tcp_fasttmr
 (void);

122 void 
tcp_input
 (struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

124 
err_t
 
tcp_output
 (struct 
tcp_pcb
 *
pcb
);

125 void 
tcp_rexmit
 (struct 
tcp_pcb
 *
pcb
);

126 void 
tcp_rexmit_rto
 (struct 
tcp_pcb
 *
pcb
);

134 #define 
	#tcp_do_output_nagle
(
tpcb
) ((((tpcb)->
unacked
 == 
NULL
) || \

135 ((
tpcb
)->
flags
 & 
TF_NODELAY
) || \

136 (((
tpcb
)->
unsent
 != 
NULL
) && ((tpcb)->unsent->
next
 != NULL))) ? \

137 1 : 0)

	)

138 #define 
	#tcp_output_nagle
(
tpcb
) (
	`tcp_do_output_nagle
(tpcb) ? 
	`tcp_output
(tpcb) : 
ERR_OK
)

	)

142 #define 
	#TCP_BUILD_MSS_OPTION
() 
	`htonl
(((
u32_t
)2 << 24) | \

143 ((
u32_t
)4 << 16) | \

144 (((
u32_t
)
TCP_MSS
 / 256) << 8) | \

145 (
TCP_MSS
 & 255))

	)

147 #define 
	#TCP_SEQ_LT
(
a
,
b
) ((
s32_t
)((a)-(b)) < 0)

	)

148 #define 
	#TCP_SEQ_LEQ
(
a
,
b
) ((
s32_t
)((a)-(b)) <= 0)

	)

149 #define 
	#TCP_SEQ_GT
(
a
,
b
) ((
s32_t
)((a)-(b)) > 0)

	)

150 #define 
	#TCP_SEQ_GEQ
(
a
,
b
) ((
s32_t
)((a)-(b)) >= 0)

	)

153 #define 
	#TCP_SEQ_BETWEEN
(
a
,
b
,
c
) ((c)-(b) >= (a)-(b))

	)

155 #define 
	#TCP_SEQ_BETWEEN
(
a
,
b
,
c
) (
	`TCP_SEQ_GEQ
(a,b) && 
	`TCP_SEQ_LEQ
(a,c))

	)

156 #define 
	#TCP_FIN
 0x01U

	)

157 #define 
	#TCP_SYN
 0x02U

	)

158 #define 
	#TCP_RST
 0x04U

	)

159 #define 
	#TCP_PSH
 0x08U

	)

160 #define 
	#TCP_ACK
 0x10U

	)

161 #define 
	#TCP_URG
 0x20U

	)

162 #define 
	#TCP_ECE
 0x40U

	)

163 #define 
	#TCP_CWR
 0x80U

	)

165 #define 
	#TCP_FLAGS
 0x3fU

	)

168 #define 
	#TCP_HLEN
 20

	)

170 #ifndef 
TCP_TMR_INTERVAL


171 #define 
	#TCP_TMR_INTERVAL
 250

	)

174 #ifndef 
TCP_FAST_INTERVAL


175 #define 
	#TCP_FAST_INTERVAL
 
TCP_TMR_INTERVAL


	)

178 #ifndef 
TCP_SLOW_INTERVAL


179 #define 
	#TCP_SLOW_INTERVAL
 (2*
TCP_TMR_INTERVAL
)

	)

182 #define 
	#TCP_FIN_WAIT_TIMEOUT
 20000

	)

183 #define 
	#TCP_SYN_RCVD_TIMEOUT
 20000

	)

185 #define 
	#TCP_OOSEQ_TIMEOUT
 6U

	)

187 #ifndef 
TCP_MSL


188 #define 
	#TCP_MSL
 60000U

	)

192 #ifndef 
TCP_KEEPIDLE_DEFAULT


193 #define 
	#TCP_KEEPIDLE_DEFAULT
 7200000UL

	)

196 #ifndef 
TCP_KEEPINTVL_DEFAULT


197 #define 
	#TCP_KEEPINTVL_DEFAULT
 75000UL

	)

200 #ifndef 
TCP_KEEPCNT_DEFAULT


201 #define 
	#TCP_KEEPCNT_DEFAULT
 9U

	)

204 #define 
	#TCP_MAXIDLE
 
TCP_KEEPCNT_DEFAULT
 * 
TCP_KEEPINTVL_DEFAULT


	)

209 #ifdef 
PACK_STRUCT_USE_INCLUDES


210 #include 
	~"arch/bpstruct.h
"

212 
PACK_STRUCT_BEGIN


213 struct 
	stcp_hdr
 {

214 
PACK_STRUCT_FIELD
(
u16_t
 
src
);

215 
PACK_STRUCT_FIELD
(
u16_t
 
dest
);

216 
PACK_STRUCT_FIELD
(
u32_t
 
seqno
);

217 
PACK_STRUCT_FIELD
(
u32_t
 
ackno
);

218 
PACK_STRUCT_FIELD
(
u16_t
 
_hdrlen_rsvd_flags
);

219 
PACK_STRUCT_FIELD
(
u16_t
 
wnd
);

220 
PACK_STRUCT_FIELD
(
u16_t
 
chksum
);

221 
PACK_STRUCT_FIELD
(
u16_t
 
urgp
);

222 } 
PACK_STRUCT_STRUCT
;

223 
PACK_STRUCT_END


224 #ifdef 
PACK_STRUCT_USE_INCLUDES


225 #include 
	~"arch/epstruct.h
"

228 #define 
	#TCPH_OFFSET
(
phdr
) (
	`ntohs
((phdr)->
_hdrlen_rsvd_flags
) >> 8)

	)

229 #define 
	#TCPH_HDRLEN
(
phdr
) (
	`ntohs
((phdr)->
_hdrlen_rsvd_flags
) >> 12)

	)

230 #define 
	#TCPH_FLAGS
(
phdr
) (
	`ntohs
((phdr)->
_hdrlen_rsvd_flags
) & 
TCP_FLAGS
)

	)

232 #define 
	#TCPH_OFFSET_SET
(
phdr
, 
offset
) (phdr)->
_hdrlen_rsvd_flags
 = 
	`htons
(((offset) << 8) | 
	`TCPH_FLAGS
(phdr))

	)

233 #define 
	#TCPH_HDRLEN_SET
(
phdr
, 
len
) (phdr)->
_hdrlen_rsvd_flags
 = 
	`htons
(((len) << 12) | 
	`TCPH_FLAGS
(phdr))

	)

234 #define 
	#TCPH_FLAGS_SET
(
phdr
, 
flags
) (phdr)->
_hdrlen_rsvd_flags
 = 
	`htons
((
	`ntohs
((phdr)->_hdrlen_rsvd_flags) & ~
TCP_FLAGS
) | (flags))

	)

235 #define 
	#TCPH_SET_FLAG
(
phdr
, 
flags
 ) (phdr)->
_hdrlen_rsvd_flags
 = 
	`htons
(
	`ntohs
((phdr)->_hdrlen_rsvd_flags) | (flags))

	)

236 #define 
	#TCPH_UNSET_FLAG
(
phdr
, 
flags
) (phdr)->
_hdrlen_rsvd_flags
 = 
	`htons
(
	`ntohs
((phdr)->_hdrlen_rsvd_flags) | (
	`TCPH_FLAGS
(phdr) & ~(flags)) )

	)

238 #define 
	#TCP_TCPLEN
(
seg
) ((seg)->
len
 + ((
	`TCPH_FLAGS
((seg)->
tcphdr
) & 
TCP_FIN
 || \

239 
	`TCPH_FLAGS
((
seg
)->
tcphdr
) & 
TCP_SYN
)? 1: 0))

	)

241 enum 
	etcp_state
 {

242 
CLOSED
 = 0,

243 
LISTEN
 = 1,

244 
SYN_SENT
 = 2,

245 
SYN_RCVD
 = 3,

246 
ESTABLISHED
 = 4,

247 
FIN_WAIT_1
 = 5,

248 
FIN_WAIT_2
 = 6,

249 
CLOSE_WAIT
 = 7,

250 
CLOSING
 = 8,

251 
LAST_ACK
 = 9,

252 
TIME_WAIT
 = 10

257 #define 
	#TF_RESET
 (
u8_t
)0x08U

	)

258 #define 
	#TF_CLOSED
 (
u8_t
)0x10U

	)

259 #define 
	#TF_GOT_FIN
 (
u8_t
)0x20U

	)

264 #define 
	#TCP_PCB_COMMON
(
type
) \

265 
type
 *
next
; \

266 enum 
tcp_state
 
state
; \

267 
u8_t
 
prio
; \

268 void *
callback_arg
; \

270 
u16_t
 
local_port


	)

273 struct 
	stcp_pcb
 {

275 
IP_PCB
;

277 
TCP_PCB_COMMON
(struct 
tcp_pcb
);

280 
u16_t
 
remote_port
;

282 
u8_t
 
flags
;

283 #define 
	#TF_ACK_DELAY
 (
u8_t
)0x01U

	)

284 #define 
	#TF_ACK_NOW
 (
u8_t
)0x02U

	)

285 #define 
	#TF_INFR
 (
u8_t
)0x04U

	)

286 #define 
	#TF_FIN
 (
u8_t
)0x20U

	)

287 #define 
	#TF_NODELAY
 (
u8_t
)0x40U

	)

288 #define 
	#TF_NAGLEMEMERR
 (
u8_t
)0x80U

	)

293 
u32_t
 
rcv_nxt
;

294 
u16_t
 
rcv_wnd
;

295 
u16_t
 
rcv_ann_wnd
;

298 
u32_t
 
tmr
;

299 
u8_t
 
polltmr
, 
pollinterval
;

302 
s16_t
 
rtime
;

304 
u16_t
 
mss
;

307 
u32_t
 
rttest
;

308 
u32_t
 
rtseq
;

309 
s16_t
 
sa
, 
sv
;

311 
s16_t
 
rto
;

312 
u8_t
 
nrtx
;

315 
u32_t
 
lastack
;

316 
u8_t
 
dupacks
;

319 
u16_t
 
cwnd
;

320 
u16_t
 
ssthresh
;

323 
u32_t
 
snd_nxt
,

324 
snd_max
;

325 
u16_t
 
snd_wnd
;

326 
u32_t
 
snd_wl1
, 
snd_wl2
,

328 
snd_lbb
;

330 
u16_t
 
acked
;

332 
u16_t
 
snd_buf
;

333 #define 
	#TCP_SNDQUEUELEN_OVERFLOW
 (0xffff-3)

	)

334 
u16_t
 
snd_queuelen
;

338 struct 
tcp_seg
 *
unsent
;

339 struct 
tcp_seg
 *
unacked
;

340 #if 
TCP_QUEUE_OOSEQ


341 struct 
tcp_seg
 *
ooseq
;

344 struct 
pbuf
 *
refused_data
;

346 #if 
LWIP_CALLBACK_API


353 
err_t
 (* 
sent
)(void *
arg
, struct 
tcp_pcb
 *
pcb
, 
u16_t
 
space
);

362 
err_t
 (* 
recv
)(void *
arg
, struct 
tcp_pcb
 *
pcb
, struct 
pbuf
 *
p
, err_t 
err
);

370 
err_t
 (* 
connected
)(void *
arg
, struct 
tcp_pcb
 *
pcb
, err_t 
err
);

379 
err_t
 (* 
accept
)(void *
arg
, struct 
tcp_pcb
 *
newpcb
, err_t 
err
);

388 
err_t
 (* 
poll
)(void *
arg
, struct 
tcp_pcb
 *
pcb
);

398 void (* 
errf
)(void *
arg
, 
err_t
 
err
);

402 
u32_t
 
keep_idle
;

403 #if 
LWIP_TCP_KEEPALIVE


404 
u32_t
 
keep_intvl
;

405 
u32_t
 
keep_cnt
;

409 
u32_t
 
persist_cnt
;

411 
u8_t
 
persist_backoff
;

414 
u8_t
 
keep_cnt_sent
;

417 struct 
	stcp_pcb_listen
 {

419 
IP_PCB
;

421 
TCP_PCB_COMMON
(struct 
tcp_pcb_listen
);

423 #if 
LWIP_CALLBACK_API


431 
err_t
 (* 
accept
)(void *
arg
, struct 
tcp_pcb
 *
newpcb
, err_t 
err
);

433 #if 
TCP_LISTEN_BACKLOG


434 
u8_t
 
backlog
;

435 
u8_t
 
accepts_pending
;

439 #if 
LWIP_EVENT_API


441 enum 
	elwip_event
 {

442 
LWIP_EVENT_ACCEPT
,

443 
LWIP_EVENT_SENT
,

444 
LWIP_EVENT_RECV
,

445 
LWIP_EVENT_CONNECTED
,

446 
LWIP_EVENT_POLL
,

447 
LWIP_EVENT_ERR


450 
err_t
 
lwip_tcp_event
(void *
arg
, struct 
tcp_pcb
 *
pcb
,

451 enum 
lwip_event
,

452 struct 
pbuf
 *
p
,

453 
u16_t
 
size
,

454 
err_t
 
err
);

456 #define 
	#TCP_EVENT_ACCEPT
(
pcb
,
err
,
ret
) ret = 
	`lwip_tcp_event
((pcb)->
callback_arg
, (pcb),\

457 
LWIP_EVENT_ACCEPT
, 
NULL
, 0, 
err
)

	)

458 #define 
	#TCP_EVENT_SENT
(
pcb
,
space
,
ret
) ret = 
	`lwip_tcp_event
((pcb)->
callback_arg
, (pcb),\

459 
LWIP_EVENT_SENT
, 
NULL
, 
space
, 
ERR_OK
)

	)

460 #define 
	#TCP_EVENT_RECV
(
pcb
,
p
,
err
,
ret
) ret = 
	`lwip_tcp_event
((pcb)->
callback_arg
, (pcb),\

461 
LWIP_EVENT_RECV
, (
p
), 0, (
err
))

	)

462 #define 
	#TCP_EVENT_CONNECTED
(
pcb
,
err
,
ret
) ret = 
	`lwip_tcp_event
((pcb)->
callback_arg
, (pcb),\

463 
LWIP_EVENT_CONNECTED
, 
NULL
, 0, (
err
))

	)

464 #define 
	#TCP_EVENT_POLL
(
pcb
,
ret
) ret = 
	`lwip_tcp_event
((pcb)->
callback_arg
, (pcb),\

465 
LWIP_EVENT_POLL
, 
NULL
, 0, 
ERR_OK
)

	)

466 #define 
	#TCP_EVENT_ERR
(
errf
,
arg
,
err
) 
	`lwip_tcp_event
((arg), 
NULL
, \

467 
LWIP_EVENT_ERR
, 
NULL
, 0, (
err
))

	)

469 #define 
	#TCP_EVENT_ACCEPT
(
pcb
,
err
,
ret
) \

470 if((
pcb
)->
accept
 != 
NULL
) \

471 (
ret
 = (
pcb
)->
	`accept
((pcb)->
callback_arg
,(pcb),(
err
)))

	)

472 #define 
	#TCP_EVENT_SENT
(
pcb
,
space
,
ret
) \

473 if((
pcb
)->
sent
 != 
NULL
) \

474 (
ret
 = (
pcb
)->
	`sent
((pcb)->
callback_arg
,(pcb),(
space
)))

	)

475 #define 
	#TCP_EVENT_RECV
(
pcb
,
p
,
err
,
ret
) \

476 if((
pcb
)->
recv
 != 
NULL
) \

477 { 
ret
 = (
pcb
)->
	`recv
((pcb)->
callback_arg
,(pcb),(
p
),(
err
)); } else { \

478 
ret
 = 
ERR_OK
; \

479 if (
p
) 
	`pbuf_free
(p); }

	)

480 #define 
	#TCP_EVENT_CONNECTED
(
pcb
,
err
,
ret
) \

481 if((
pcb
)->
connected
 != 
NULL
) \

482 (
ret
 = (
pcb
)->
	`connected
((pcb)->
callback_arg
,(pcb),(
err
)))

	)

483 #define 
	#TCP_EVENT_POLL
(
pcb
,
ret
) \

484 if((
pcb
)->
poll
 != 
NULL
) \

485 (
ret
 = (
pcb
)->
	`poll
((pcb)->
callback_arg
,(pcb)))

	)

486 #define 
	#TCP_EVENT_ERR
(
errf
,
arg
,
err
) \

487 if((
errf
) != 
NULL
) \

488 (
errf
)((
arg
),(
err
))

	)

492 struct 
	stcp_seg
 {

493 struct 
tcp_seg
 *
next
;

494 struct 
pbuf
 *
p
;

495 void *
dataptr
;

496 
u16_t
 
len
;

497 struct 
tcp_hdr
 *
tcphdr
;

501 struct 
tcp_pcb
 *
tcp_pcb_copy
(struct tcp_pcb *
pcb
);

502 void 
tcp_pcb_purge
(struct 
tcp_pcb
 *
pcb
);

503 void 
tcp_pcb_remove
(struct 
tcp_pcb
 **
pcblist
, struct tcp_pcb *
pcb
);

505 
u8_t
 
tcp_segs_free
(struct 
tcp_seg
 *
seg
);

506 
u8_t
 
tcp_seg_free
(struct 
tcp_seg
 *
seg
);

507 struct 
tcp_seg
 *
tcp_seg_copy
(struct tcp_seg *
seg
);

509 #define 
	#tcp_ack
(
pcb
) if((pcb)->
flags
 & 
TF_ACK_DELAY
) { \

510 (
pcb
)->
flags
 &= ~
TF_ACK_DELAY
; \

511 (
pcb
)->
flags
 |= 
TF_ACK_NOW
; \

512 
	`tcp_output
(
pcb
); \

514 (
pcb
)->
flags
 |= 
TF_ACK_DELAY
; \

515 }

	)

517 #define 
	#tcp_ack_now
(
pcb
) (pcb)->
flags
 |= 
TF_ACK_NOW
; \

518 
	`tcp_output
(
pcb
)

	)

520 
err_t
 
tcp_send_ctrl
(struct 
tcp_pcb
 *
pcb
, 
u8_t
 
flags
);

521 
err_t
 
tcp_enqueue
(struct 
tcp_pcb
 *
pcb
, void *
dataptr
, 
u16_t
 
len
,

522 
u8_t
 
flags
, u8_t 
apiflags
,

523 
u8_t
 *
optdata
, u8_t 
optlen
);

525 void 
tcp_rexmit_seg
(struct 
tcp_pcb
 *
pcb
, struct 
tcp_seg
 *
seg
);

527 void 
tcp_rst
(
u32_t
 
seqno
, u32_t 
ackno
,

528 struct 
ip_addr
 *
local_ip
, struct ip_addr *
remote_ip
,

529 
u16_t
 
local_port
, u16_t 
remote_port
);

531 
u32_t
 
tcp_next_iss
(void);

533 void 
tcp_keepalive
(struct 
tcp_pcb
 *
pcb
);

534 void 
tcp_zero_window_probe
(struct 
tcp_pcb
 *
pcb
);

536 #if 
TCP_CALCULATE_EFF_SEND_MSS


537 
u16_t
 
tcp_eff_send_mss
(u16_t 
sendmss
, struct 
ip_addr
 *
addr
);

540 extern struct 
tcp_pcb
 *
tcp_input_pcb
;

541 extern 
u32_t
 
tcp_ticks
;

543 #if 
TCP_DEBUG
 || 
TCP_INPUT_DEBUG
 || 
TCP_OUTPUT_DEBUG


544 void 
tcp_debug_print
(struct 
tcp_hdr
 *
tcphdr
);

545 void 
tcp_debug_print_flags
(
u8_t
 
flags
);

546 void 
tcp_debug_print_state
(enum 
tcp_state
 
s
);

547 void 
tcp_debug_print_pcbs
(void);

548 
s16_t
 
tcp_pcbs_sane
(void);

550 #define 
	#tcp_debug_print
(
tcphdr
)

	)

551 #define 
	#tcp_debug_print_flags
(
flags
)

	)

552 #define 
	#tcp_debug_print_state
(
s
)

	)

553 #define 
	#tcp_debug_print_pcbs
()

	)

554 #define 
	#tcp_pcbs_sane
() 1

	)

557 #if 
NO_SYS


558 #define 
	#tcp_timer_needed
()

	)

560 void 
tcp_timer_needed
(void);

564 union 
	utcp_listen_pcbs_t
 {

565 struct 
tcp_pcb_listen
 *
	glisten_pcbs
;

566 struct 
tcp_pcb
 *
	gpcbs
;

568 extern union 
tcp_listen_pcbs_t
 
tcp_listen_pcbs
;

569 extern struct 
tcp_pcb
 *
tcp_active_pcbs
;

572 extern struct 
tcp_pcb
 *
tcp_tw_pcbs
;

574 extern struct 
tcp_pcb
 *
tcp_tmp_pcb
;

586 #define 
	#TCP_REG
(
pcbs
, 
npcb
) do {\

587 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP_REG %p local port %d\n", 
npcb
, npcb->
local_port
)); \

588 for(
tcp_tmp_pcb
 = *
pcbs
; \

589 
tcp_tmp_pcb
 != 
NULL
; \

590 
tcp_tmp_pcb
 = tcp_tmp_pcb->
next
) { \

591 
	`LWIP_ASSERT
("TCP_REG: already registered\n", 
tcp_tmp_pcb
 != 
npcb
); \

593 
	`LWIP_ASSERT
("TCP_REG: pcb->state != CLOSED", 
npcb
->
state
 != 
CLOSED
); \

594 
npcb
->
next
 = *
pcbs
; \

595 
	`LWIP_ASSERT
("TCP_REG: npcb->next != npcb", 
npcb
->
next
 != npcb); \

596 *(
pcbs
) = 
npcb
; \

597 
	`LWIP_ASSERT
("TCP_RMV: tcp_pcbs sane", 
	`tcp_pcbs_sane
()); \

598 
	`tcp_timer_needed
(); \

599 } while(0)

	)

600 #define 
	#TCP_RMV
(
pcbs
, 
npcb
) do { \

601 
	`LWIP_ASSERT
("TCP_RMV: pcbs != NULL", *
pcbs
 != 
NULL
); \

602 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP_RMV: removing %p from %p\n", 
npcb
, *
pcbs
)); \

603 if(*
pcbs
 == 
npcb
) { \

604 *
pcbs
 = (*pcbs)->
next
; \

605 } else for(
tcp_tmp_pcb
 = *
pcbs
; tcp_tmp_pcb != 
NULL
; tcp_tmp_pcb = tcp_tmp_pcb->
next
) { \

606 if(
tcp_tmp_pcb
->
next
 != 
NULL
 && tcp_tmp_pcb->next == 
npcb
) { \

607 
tcp_tmp_pcb
->
next
 = 
npcb
->next; \

611 
npcb
->
next
 = 
NULL
; \

612 
	`LWIP_ASSERT
("TCP_RMV: tcp_pcbs sane", 
	`tcp_pcbs_sane
()); \

613 
	`LWIP_DEBUGF
(
TCP_DEBUG
, ("TCP_RMV: removed %p from %p\n", 
npcb
, *
pcbs
)); \

614 } while(0)

	)

617 #define 
	#TCP_REG
(
pcbs
, 
npcb
) do { \

618 
npcb
->
next
 = *
pcbs
; \

619 *(
pcbs
) = 
npcb
; \

620 
	`tcp_timer_needed
(); \

621 } while(0)

	)

622 #define 
	#TCP_RMV
(
pcbs
, 
npcb
) do { \

623 if(*(
pcbs
) == 
npcb
) { \

624 (*(
pcbs
)) = (*pcbs)->
next
; \

625 } else for(
tcp_tmp_pcb
 = *
pcbs
; tcp_tmp_pcb != 
NULL
; tcp_tmp_pcb = tcp_tmp_pcb->
next
) { \

626 if(
tcp_tmp_pcb
->
next
 != 
NULL
 && tcp_tmp_pcb->next == 
npcb
) { \

627 
tcp_tmp_pcb
->
next
 = 
npcb
->next; \

631 
npcb
->
next
 = 
NULL
; \

632 } while(0)

	)

635 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/tcpip.h

32 #ifndef 
__LWIP_TCPIP_H__


33 #define 
	#__LWIP_TCPIP_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if !
NO_SYS


39 #include 
	~"lwip/api_msg.h
"

40 #include 
	~"lwip/netifapi.h
"

41 #include 
	~"lwip/pbuf.h
"

42 #include 
	~"lwip/api.h
"

43 #include 
	~"lwip/sys.h
"

45 #ifdef 
__cplusplus


49 #if 
LWIP_TCPIP_CORE_LOCKING


51 extern 
sys_sem_t
 
lock_tcpip_core
;

52 #define 
	#LOCK_TCPIP_CORE
() 
	`sys_sem_wait
(
lock_tcpip_core
)

	)

53 #define 
	#UNLOCK_TCPIP_CORE
() 
	`sys_sem_signal
(
lock_tcpip_core
)

	)

54 #define 
	#TCPIP_APIMSG
(
m
) 
	`tcpip_apimsg_lock
(m)

	)

55 #define 
	#TCPIP_APIMSG_ACK
(
m
)

	)

56 #define 
	#TCPIP_NETIFAPI
(
m
) 
	`tcpip_netifapi_lock
(m)

	)

57 #define 
	#TCPIP_NETIFAPI_ACK
(
m
)

	)

59 #define 
	#LOCK_TCPIP_CORE
()

	)

60 #define 
	#UNLOCK_TCPIP_CORE
()

	)

61 #define 
	#TCPIP_APIMSG
(
m
) 
	`tcpip_apimsg
(m)

	)

62 #define 
	#TCPIP_APIMSG_ACK
(
m
) 
	`sys_sem_signal
(m->
conn
->
op_completed
)

	)

63 #define 
	#TCPIP_NETIFAPI
(
m
) 
	`tcpip_netifapi
(m)

	)

64 #define 
	#TCPIP_NETIFAPI_ACK
(
m
) 
	`sys_sem_signal
(m->
sem
)

	)

67 void 
tcpip_init
(void (* 
tcpip_init_done
)(void *), void *
arg
);

69 #if 
LWIP_NETCONN


70 
err_t
 
tcpip_apimsg
(struct 
api_msg
 *
apimsg
);

71 #if 
LWIP_TCPIP_CORE_LOCKING


72 
err_t
 
tcpip_apimsg_lock
(struct 
api_msg
 *
apimsg
);

76 
err_t
 
tcpip_input
(struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

78 #if 
LWIP_NETIF_API


79 
err_t
 
tcpip_netifapi
(struct 
netifapi_msg
 *
netifapimsg
);

80 #if 
LWIP_TCPIP_CORE_LOCKING


81 
err_t
 
tcpip_netifapi_lock
(struct 
netifapi_msg
 *
netifapimsg
);

85 
err_t
 
tcpip_callback_with_block
(void (*
f
)(void *
ctx
), void *ctx, 
u8_t
 
block
);

86 #define 
	#tcpip_callback
(
f
, 
ctx
) 
	`tcpip_callback_with_block
(f, ctx, 1)

	)

89 
err_t
 
pbuf_free_callback
(struct 
pbuf
 *
p
);

90 
err_t
 
mem_free_callback
(void *
m
);

92 
err_t
 
tcpip_timeout
(
u32_t
 
msecs
, 
sys_timeout_handler
 
h
, void *
arg
);

93 #define 
	#tcpip_untimeout
(
h
, 
arg
) 
	`tcpip_timeout
(0xffffffff, h, arg)

	)

95 enum 
	etcpip_msg_type
 {

96 #if 
LWIP_NETCONN


97 
	gTCPIP_MSG_API
,

99 
	gTCPIP_MSG_INPKT
,

100 #if 
LWIP_NETIF_API


101 
	gTCPIP_MSG_NETIFAPI
,

103 
	gTCPIP_MSG_CALLBACK
,

104 
	gTCPIP_MSG_TIMEOUT


107 struct 
	stcpip_msg
 {

108 enum 
tcpip_msg_type
 
	gtype
;

109 
sys_sem_t
 *
	gsem
;

111 #if 
LWIP_NETCONN


112 struct 
api_msg
 *
	gapimsg
;

114 #if 
LWIP_NETIF_API


115 struct 
netifapi_msg
 *
	gnetifapimsg
;

118 struct 
pbuf
 *
	gp
;

119 struct 
netif
 *
	gnetif
;

120 } 
	ginp
;

122 void (*
	gf
)(void *
	gctx
);

123 void *
	gctx
;

124 } 
	gcb
;

126 
u32_t
 
	gmsecs
;

127 
sys_timeout_handler
 
	gh
;

128 void *
	garg
;

129 } 
	gtmo
;

130 } 
	gmsg
;

133 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/lwip/udp.h

32 #ifndef 
__LWIP_UDP_H__


33 #define 
	#__LWIP_UDP_H__


	)

35 #include 
	~"lwip/opt.h
"

37 #if 
LWIP_UDP


39 #include 
	~"lwip/pbuf.h
"

40 #include 
	~"lwip/netif.h
"

41 #include 
	~"lwip/ip_addr.h
"

42 #include 
	~"lwip/ip.h
"

44 #ifdef 
__cplusplus


48 #define 
	#UDP_HLEN
 8

	)

51 #ifdef 
PACK_STRUCT_USE_INCLUDES


52 #include 
	~"arch/bpstruct.h
"

54 
PACK_STRUCT_BEGIN


55 struct 
	sudp_hdr
 {

56 
PACK_STRUCT_FIELD
(
u16_t
 
src
);

57 
PACK_STRUCT_FIELD
(
u16_t
 
dest
);

58 
PACK_STRUCT_FIELD
(
u16_t
 
len
);

59 
PACK_STRUCT_FIELD
(
u16_t
 
chksum
);

60 } 
PACK_STRUCT_STRUCT
;

61 
PACK_STRUCT_END


62 #ifdef 
PACK_STRUCT_USE_INCLUDES


63 #include 
	~"arch/epstruct.h
"

66 #define 
	#UDP_FLAGS_NOCHKSUM
 0x01U

	)

67 #define 
	#UDP_FLAGS_UDPLITE
 0x02U

	)

68 #define 
	#UDP_FLAGS_CONNECTED
 0x04U

	)

70 struct 
	sudp_pcb
 {

72 
IP_PCB
;

76 struct 
udp_pcb
 *
next
;

78 
u8_t
 
flags
;

80 
u16_t
 
local_port
, 
remote_port
;

82 #if 
LWIP_IGMP


84 struct 
ip_addr
 
multicast_ip
;

87 #if 
LWIP_UDPLITE


89 
u16_t
 
chksum_len_rx
, 
chksum_len_tx
;

103 void (* 
recv
)(void *
arg
, struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
,

104 struct 
ip_addr
 *
addr
, 
u16_t
 
port
);

106 void *
recv_arg
;

109 extern struct 
udp_pcb
 *
udp_pcbs
;

113 struct 
udp_pcb
 * 
udp_new
 (void);

114 void 
udp_remove
 (struct 
udp_pcb
 *
pcb
);

115 
err_t
 
udp_bind
 (struct 
udp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
,

116 
u16_t
 
port
);

117 
err_t
 
udp_connect
 (struct 
udp_pcb
 *
pcb
, struct 
ip_addr
 *
ipaddr
,

118 
u16_t
 
port
);

119 void 
udp_disconnect
 (struct 
udp_pcb
 *
pcb
);

120 void 
udp_recv
 (struct 
udp_pcb
 *
pcb
,

121 void (* 
recv
)(void *
arg
, struct 
udp_pcb
 *
upcb
,

122 struct 
pbuf
 *
p
,

123 struct 
ip_addr
 *
addr
,

124 
u16_t
 
port
),

125 void *
recv_arg
);

126 
err_t
 
udp_sendto_if
 (struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
dst_ip
, 
u16_t
 
dst_port
, struct 
netif
 *netif);

127 
err_t
 
udp_sendto
 (struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
, struct 
ip_addr
 *
dst_ip
, 
u16_t
 
dst_port
);

128 
err_t
 
udp_send
 (struct 
udp_pcb
 *
pcb
, struct 
pbuf
 *
p
);

130 #define 
	#udp_flags
(
pcb
) ((pcb)->
flags
)

	)

131 #define 
	#udp_setflags
(
pcb
, 
f
) ((pcb)->
flags
 = (f))

	)

134 void 
udp_input
 (struct 
pbuf
 *
p
, struct 
netif
 *
inp
);

136 #define 
	#udp_init
()

	)

138 #if 
UDP_DEBUG


139 void 
udp_debug_print
(struct 
udp_hdr
 *
udphdr
);

141 #define 
	#udp_debug_print
(
udphdr
)

	)

144 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/netif/etharp.h

35 #ifndef 
__NETIF_ETHARP_H__


36 #define 
	#__NETIF_ETHARP_H__


	)

38 #include 
	~"lwip/opt.h
"

40 #if 
LWIP_ARP


42 #include 
	~"lwip/pbuf.h
"

43 #include 
	~"lwip/ip_addr.h
"

44 #include 
	~"lwip/netif.h
"

45 #include 
	~"lwip/ip.h
"

47 #ifdef 
__cplusplus


51 #ifndef 
ETH_PAD_SIZE


52 #define 
	#ETH_PAD_SIZE
 0

	)

55 #ifndef 
ETHARP_HWADDR_LEN


56 #define 
	#ETHARP_HWADDR_LEN
 6

	)

59 #ifdef 
PACK_STRUCT_USE_INCLUDES


60 #include 
	~"arch/bpstruct.h
"

62 
PACK_STRUCT_BEGIN


63 struct 
	seth_addr
 {

64 
PACK_STRUCT_FIELD
(
u8_t
 
addr
[
ETHARP_HWADDR_LEN
]);

65 } 
PACK_STRUCT_STRUCT
;

66 
PACK_STRUCT_END


67 #ifdef 
PACK_STRUCT_USE_INCLUDES


68 #include 
	~"arch/epstruct.h
"

71 #ifdef 
PACK_STRUCT_USE_INCLUDES


72 #include 
	~"arch/bpstruct.h
"

74 
PACK_STRUCT_BEGIN


75 struct 
	seth_hdr
 {

76 #if 
ETH_PAD_SIZE


77 
PACK_STRUCT_FIELD
(
u8_t
 
padding
[
ETH_PAD_SIZE
]);

79 
PACK_STRUCT_FIELD
(struct 
eth_addr
 
dest
);

80 
PACK_STRUCT_FIELD
(struct 
eth_addr
 
src
);

81 
PACK_STRUCT_FIELD
(
u16_t
 
type
);

82 } 
PACK_STRUCT_STRUCT
;

83 
PACK_STRUCT_END


84 #ifdef 
PACK_STRUCT_USE_INCLUDES


85 #include 
	~"arch/epstruct.h
"

88 #ifdef 
PACK_STRUCT_USE_INCLUDES


89 #include 
	~"arch/bpstruct.h
"

91 
PACK_STRUCT_BEGIN


93 struct 
	setharp_hdr
 {

94 
PACK_STRUCT_FIELD
(struct 
eth_hdr
 
ethhdr
);

95 
PACK_STRUCT_FIELD
(
u16_t
 
hwtype
);

96 
PACK_STRUCT_FIELD
(
u16_t
 
proto
);

97 
PACK_STRUCT_FIELD
(
u16_t
 
_hwlen_protolen
);

98 
PACK_STRUCT_FIELD
(
u16_t
 
opcode
);

99 
PACK_STRUCT_FIELD
(struct 
eth_addr
 
shwaddr
);

100 
PACK_STRUCT_FIELD
(struct 
ip_addr2
 
sipaddr
);

101 
PACK_STRUCT_FIELD
(struct 
eth_addr
 
dhwaddr
);

102 
PACK_STRUCT_FIELD
(struct 
ip_addr2
 
dipaddr
);

103 } 
PACK_STRUCT_STRUCT
;

104 
PACK_STRUCT_END


105 #ifdef 
PACK_STRUCT_USE_INCLUDES


106 #include 
	~"arch/epstruct.h
"

109 #ifdef 
PACK_STRUCT_USE_INCLUDES


110 #include 
	~"arch/bpstruct.h
"

112 
PACK_STRUCT_BEGIN


113 struct 
	sethip_hdr
 {

114 
PACK_STRUCT_FIELD
(struct 
eth_hdr
 
eth
);

115 
PACK_STRUCT_FIELD
(struct 
ip_hdr
 
ip
);

116 } 
PACK_STRUCT_STRUCT
;

117 
PACK_STRUCT_END


118 #ifdef 
PACK_STRUCT_USE_INCLUDES


119 #include 
	~"arch/epstruct.h
"

123 #define 
	#ARP_TMR_INTERVAL
 5000

	)

125 #define 
	#ETHTYPE_ARP
 0x0806

	)

126 #define 
	#ETHTYPE_IP
 0x0800

	)

127 #define 
	#ETHTYPE_PPPOEDISC
 0x8863

	)

128 #define 
	#ETHTYPE_PPPOE
 0x8864

	)

131 #define 
	#ARP_REQUEST
 1

	)

132 #define 
	#ARP_REPLY
 2

	)

134 #if 
ARP_QUEUEING


138 struct 
	setharp_q_entry
 {

139 struct 
etharp_q_entry
 *
next
;

140 struct 
pbuf
 *
p
;

144 #define 
	#etharp_init
()

	)

145 void 
etharp_tmr
(void);

146 
s8_t
 
etharp_find_addr
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
,

147 struct 
eth_addr
 **
eth_ret
, struct 
ip_addr
 **
ip_ret
);

148 void 
etharp_ip_input
(struct 
netif
 *netif, struct 
pbuf
 *
p
);

149 void 
etharp_arp_input
(struct 
netif
 *netif, struct 
eth_addr
 *
ethaddr
,

150 struct 
pbuf
 *
p
);

151 
err_t
 
etharp_output
(struct 
netif
 *netif, struct 
pbuf
 *
q
, struct 
ip_addr
 *
ipaddr
);

152 
err_t
 
etharp_query
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
, struct 
pbuf
 *
q
);

153 
err_t
 
etharp_request
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
);

155 
err_t
 
ethernet_input
(struct 
pbuf
 *
p
, struct 
netif
 *netif);

157 #if 
LWIP_AUTOIP


158 
err_t
 
etharp_raw
(struct 
netif
 *netif, const struct 
eth_addr
 *
ethsrc_addr
,

159 const struct 
eth_addr
 *
ethdst_addr
,

160 const struct 
eth_addr
 *
hwsrc_addr
, const struct 
ip_addr
 *
ipsrc_addr
,

161 const struct 
eth_addr
 *
hwdst_addr
, const struct 
ip_addr
 *
ipdst_addr
,

162 const 
u16_t
 
opcode
);

165 #define 
	#eth_addr_cmp
(
addr1
, 
addr2
) (
	`memcmp
((addr1)->
addr
, (addr2)->addr, 
ETHARP_HWADDR_LEN
) == 0)

	)

167 extern const struct 
eth_addr
 
ethbroadcast
, 
ethzero
;

169 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/netif/loopif.h

32 #ifndef 
__NETIF_LOOPIF_H__


33 #define 
	#__NETIF_LOOPIF_H__


	)

35 #include 
	~"lwip/opt.h
"

36 #include 
	~"lwip/netif.h
"

37 #include 
	~"lwip/err.h
"

39 #ifdef 
__cplusplus


43 #if !
LWIP_NETIF_LOOPBACK_MULTITHREADING


44 #define 
	#loopif_poll
 
netif_poll


	)

47 
err_t
 
loopif_init
(struct 
netif
 *netif);

49 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/include/netif/ppp_oe.h

70 #ifndef 
PPP_OE_H


71 #define 
	#PPP_OE_H


	)

73 #include 
	~"lwip/opt.h
"

75 #if 
PPPOE_SUPPORT
 > 0

77 #ifdef 
PACK_STRUCT_USE_INCLUDES


78 #include 
	~"arch/bpstruct.h
"

80 
PACK_STRUCT_BEGIN


81 struct 
	spppoehdr
 {

82 
PACK_STRUCT_FIELD
(
u8_t
 
vertype
);

83 
PACK_STRUCT_FIELD
(
u8_t
 
code
);

84 
PACK_STRUCT_FIELD
(
u16_t
 
session
);

85 
PACK_STRUCT_FIELD
(
u16_t
 
plen
);

86 } 
	gPACK_STRUCT_STRUCT
;

87 
	gPACK_STRUCT_END


88 #ifdef 
PACK_STRUCT_USE_INCLUDES


89 #include 
	~"arch/epstruct.h
"

92 #ifdef 
PACK_STRUCT_USE_INCLUDES


93 #include 
	~"arch/bpstruct.h
"

95 
PACK_STRUCT_BEGIN


96 struct 
	spppoetag
 {

97 
PACK_STRUCT_FIELD
(
u16_t
 
tag
);

98 
PACK_STRUCT_FIELD
(
u16_t
 
len
);

99 } 
	gPACK_STRUCT_STRUCT
;

100 
	gPACK_STRUCT_END


101 #ifdef 
PACK_STRUCT_USE_INCLUDES


102 #include 
	~"arch/epstruct.h
"

106 #define 
	#PPPOE_STATE_INITIAL
 0

	)

107 #define 
	#PPPOE_STATE_PADI_SENT
 1

	)

108 #define 
	#PPPOE_STATE_PADR_SENT
 2

	)

109 #define 
	#PPPOE_STATE_SESSION
 3

	)

110 #define 
	#PPPOE_STATE_CLOSING
 4

	)

112 #define 
	#PPPOE_STATE_PADO_SENT
 1

	)

114 #define 
	#PPPOE_HEADERLEN
 sizeof(struct 
pppoehdr
)

	)

115 #define 
	#PPPOE_VERTYPE
 0x11

	)

117 #define 
	#PPPOE_TAG_EOL
 0x0000

	)

118 #define 
	#PPPOE_TAG_SNAME
 0x0101

	)

119 #define 
	#PPPOE_TAG_ACNAME
 0x0102

	)

120 #define 
	#PPPOE_TAG_HUNIQUE
 0x0103

	)

121 #define 
	#PPPOE_TAG_ACCOOKIE
 0x0104

	)

122 #define 
	#PPPOE_TAG_VENDOR
 0x0105

	)

123 #define 
	#PPPOE_TAG_RELAYSID
 0x0110

	)

124 #define 
	#PPPOE_TAG_SNAME_ERR
 0x0201

	)

125 #define 
	#PPPOE_TAG_ACSYS_ERR
 0x0202

	)

126 #define 
	#PPPOE_TAG_GENERIC_ERR
 0x0203

	)

128 #define 
	#PPPOE_CODE_PADI
 0x09

	)

129 #define 
	#PPPOE_CODE_PADO
 0x07

	)

130 #define 
	#PPPOE_CODE_PADR
 0x19

	)

131 #define 
	#PPPOE_CODE_PADS
 0x65

	)

132 #define 
	#PPPOE_CODE_PADT
 0xA7

	)

134 #ifndef 
ETHERMTU


135 #define 
	#ETHERMTU
 1500

	)

139 #define 
	#PPPOE_MAXMTU
 (
ETHERMTU
-
PPPOE_HEADERLEN
-2)

	)

141 struct 
	gpppoe_softc
;

144 void 
pppoe_init
(void);

146 
err_t
 
pppoe_create
(struct 
netif
 *
ethif
, int 
pd
, void (*
linkStatusCB
)(int pd, int 
up
), struct 
pppoe_softc
 **
scptr
);

147 
err_t
 
	`pppoe_destroy
(struct 
netif
 *
ifp
);

149 int 
	`pppoe_connect
(struct 
pppoe_softc
 *
sc
);

150 void 
	`pppoe_disconnect
(struct 
pppoe_softc
 *
sc
);

152 void 
	`pppoe_disc_input
(struct 
netif
 *netif, struct 
pbuf
 *
p
);

153 void 
	`pppoe_data_input
(struct 
netif
 *netif, struct 
pbuf
 *
p
);

155 
err_t
 
	`pppoe_xmit
(struct 
pppoe_softc
 *
sc
, struct 
pbuf
 *
pb
);

157 extern int 
pppoe_hdrlen
;

	@/root/Robux/net/lwip/include/netif/slipif.h

34 #ifndef 
__NETIF_SLIPIF_H__


35 #define 
	#__NETIF_SLIPIF_H__


	)

37 #include 
	~"lwip/netif.h
"

39 #ifdef 
__cplusplus


43 
err_t
 
slipif_init
(struct 
netif
 * netif);

45 #ifdef 
__cplusplus


	@/root/Robux/net/lwip/jos/arch/cc.h

1 #ifndef 
LWIP_ARCH_CC_H


2 #define 
	#LWIP_ARCH_CC_H


	)

4 #include 
	~<inc/types.h
>

5 #include 
	~<inc/assert.h
>

7 typedef 
uint32_t
 
	tu32_t
;

8 typedef 
int32_t
 
	ts32_t
;

10 typedef 
uint64_t
 
	tu64_t
;

11 typedef 
int64_t
 
	ts64_t
;

13 typedef 
uint16_t
 
	tu16_t
;

14 typedef 
int16_t
 
	ts16_t
;

16 typedef 
uint8_t
 
	tu8_t
;

17 typedef 
int8_t
 
	ts8_t
;

19 typedef 
uintptr_t
 
	tmem_ptr_t
;

21 #define 
	#PACK_STRUCT_FIELD
(
x
) 
	)
x

22 #define 
	#PACK_STRUCT_STRUCT


	)

23 #define 
	#PACK_STRUCT_BEGIN


	)

24 #define 
	#PACK_STRUCT_END


	)

26 #define 
	#S16_F
 "d"

	)

27 #define 
	#U16_F
 "u"

	)

28 #define 
	#X16_F
 "x"

	)

30 #define 
	#S32_F
 "d"

	)

31 #define 
	#U32_F
 "u"

	)

32 #define 
	#X32_F
 "x"

	)

34 #define 
	#LWIP_PLATFORM_DIAG
(
x
) 
cprintf
 
	)
x

35 #define 
	#LWIP_PLATFORM_ASSERT
(
x
) 
	`panic
(x)

	)

37 #ifndef 
BYTE_ORDER


38 #define 
	#BYTE_ORDER
 
LITTLE_ENDIAN


	)

	@/root/Robux/net/lwip/jos/arch/i386/setjmp.h

1 #ifndef 
JOS_MACHINE_SETJMP_H


2 #define 
	#JOS_MACHINE_SETJMP_H


	)

4 #include 
	~<inc/types.h
>

6 #define 
	#JOS_LONGJMP_GCCATTR
 
	`regparm
(2)

	)

8 struct 
	sjos_jmp_buf
 {

9 
uint32_t
 
	mjb_eip
;

10 
uint32_t
 
	mjb_esp
;

11 
uint32_t
 
	mjb_ebp
;

12 
uint32_t
 
	mjb_ebx
;

13 
uint32_t
 
	mjb_esi
;

14 
uint32_t
 
	mjb_edi
;

	@/root/Robux/net/lwip/jos/arch/perf.h

1 #ifndef 
LWIP_ARCH_PERF_H


2 #define 
	#LWIP_ARCH_PERF_H


	)

4 #define 
	#PERF_START


	)

5 #define 
	#PERF_STOP
(
x
)

	)

	@/root/Robux/net/lwip/jos/arch/perror.c

2 #define 
	#LWIP_PROVIDE_ERRNO


	)

3 #include 
	~<arch/perror.h
>

4 #include 
	~<lwip/arch.h
>

6 const char *
	gsys_errlist
[] = {

7 [
EPERM
] = "EPERM",

8 [
ENOENT
] = "ENOENT",

9 [
ESRCH
] = "ESRCH",

10 [
EINTR
] = "EINTR",

11 [
EIO
] = "EIO",

12 [
ENXIO
] = "ENXIO",

13 [
E2BIG
] = "E2BIG",

14 [
ENOEXEC
] = "ENOEXEC",

15 [
EBADF
] = "EBADF",

16 [
ECHILD
] = "ECHILD",

17 [
EAGAIN
] = "EAGAIN",

18 [
ENOMEM
] = "ENOMEM",

19 [
EACCES
] = "EACCES",

20 [
EFAULT
] = "EFAULT",

21 [
ENOTBLK
] = "ENOTBLK",

22 [
EBUSY
] = "EBUSY",

23 [
EEXIST
] = "EEXIST",

24 [
EXDEV
] = "EXDEV",

25 [
ENODEV
] = "ENODEV",

26 [
ENOTDIR
] = "ENOTDIR",

27 [
EISDIR
] = "EISDIR",

28 [
EINVAL
] = "EINVAL",

29 [
ENFILE
] = "ENFILE",

30 [
EMFILE
] = "EMFILE",

31 [
ENOTTY
] = "ENOTTY",

32 [
ETXTBSY
] = "ETXTBSY",

33 [
EFBIG
] = "EFBIG",

34 [
ENOSPC
] = "ENOSPC",

35 [
ESPIPE
] = "ESPIPE",

36 [
EROFS
] = "EROFS",

37 [
EMLINK
] = "EMLINK",

38 [
EPIPE
] = "EPIPE",

39 [
EDOM
] = "EDOM",

40 [
ERANGE
] = "ERANGE",

41 [
EDEADLK
] = "EDEADLK",

42 [
ENAMETOOLONG
] = "ENAMETOOLONG",

43 [
ENOLCK
] = "ENOLCK",

44 [
ENOSYS
] = "ENOSYS",

45 [
ENOTEMPTY
] = "ENOTEMPTY",

46 [
ELOOP
] = "ELOOP",

47 [
EWOULDBLOCK
] = "EWOULDBLOCK",

48 [
ENOMSG
] = "ENOMSG",

49 [
EIDRM
] = "EIDRM",

50 [
ECHRNG
] = "ECHRNG",

51 [
EL2NSYNC
] = "EL2NSYNC",

52 [
EL3HLT
] = "EL3HLT",

53 [
EL3RST
] = "EL3RST",

54 [
ELNRNG
] = "ELNRNG",

55 [
EUNATCH
] = "EUNATCH",

56 [
ENOCSI
] = "ENOCSI",

57 [
EL2HLT
] = "EL2HLT",

58 [
EBADE
] = "EBADE",

59 [
EBADR
] = "EBADR",

60 [
EXFULL
] = "EXFULL",

61 [
ENOANO
] = "ENOANO",

62 [
EBADRQC
] = "EBADRQC",

63 [
EBADSLT
] = "EBADSLT",

65 [
EDEADLOCK
] = "EDEADLOCK",

67 [
EBFONT
] = "EBFONT",

68 [
ENOSTR
] = "ENOSTR",

69 [
ENODATA
] = "ENODATA",

70 [
ETIME
] = "ETIME",

71 [
ENOSR
] = "ENOSR",

72 [
ENONET
] = "ENONET",

73 [
ENOPKG
] = "ENOPKG",

74 [
EREMOTE
] = "EREMOTE",

75 [
ENOLINK
] = "ENOLINK",

76 [
EADV
] = "EADV",

77 [
ESRMNT
] = "ESRMNT",

78 [
ECOMM
] = "ECOMM",

79 [
EPROTO
] = "EPROTO",

80 [
EMULTIHOP
] = "EMULTIHOP",

81 [
EDOTDOT
] = "EDOTDOT",

82 [
EBADMSG
] = "EBADMSG",

83 [
EOVERFLOW
] = "EOVERFLOW",

84 [
ENOTUNIQ
] = "ENOTUNIQ",

85 [
EBADFD
] = "EBADFD",

86 [
EREMCHG
] = "EREMCHG",

87 [
ELIBACC
] = "ELIBACC",

88 [
ELIBBAD
] = "ELIBBAD",

89 [
ELIBSCN
] = "ELIBSCN",

90 [
ELIBMAX
] = "ELIBMAX",

91 [
ELIBEXEC
] = "ELIBEXEC",

92 [
EILSEQ
] = "EILSEQ",

93 [
ERESTART
] = "ERESTART",

94 [
ESTRPIPE
] = "ESTRPIPE",

95 [
EUSERS
] = "EUSERS",

96 [
ENOTSOCK
] = "ENOTSOCK",

97 [
EDESTADDRREQ
] = "EDESTADDRREQ",

98 [
EMSGSIZE
] = "EMSGSIZE",

99 [
EPROTOTYPE
] = "EPROTOTYPE",

100 [
ENOPROTOOPT
] = "ENOPROTOOPT",

101 [
EPROTONOSUPPORT
] = "EPROTONOSUPPORT",

102 [
ESOCKTNOSUPPORT
] = "ESOCKTNOSUPPORT",

103 [
EOPNOTSUPP
] = "EOPNOTSUPP",

104 [
EPFNOSUPPORT
] = "EPFNOSUPPORT",

105 [
EAFNOSUPPORT
] = "EAFNOSUPPORT",

106 [
EADDRINUSE
] = "EADDRINUSE",

107 [
EADDRNOTAVAIL
] = "EADDRNOTAVAIL",

108 [
ENETDOWN
] = "ENETDOWN",

109 [
ENETUNREACH
] = "ENETUNREACH",

110 [
ENETRESET
] = "ENETRESET",

111 [
ECONNABORTED
] = "ECONNABORTED",

112 [
ECONNRESET
] = "ECONNRESET",

113 [
ENOBUFS
] = "ENOBUFS",

114 [
EISCONN
] = "EISCONN",

115 [
ENOTCONN
] = "ENOTCONN",

116 [
ESHUTDOWN
] = "ESHUTDOWN",

117 [
ETOOMANYREFS
] = "ETOOMANYREFS",

118 [
ETIMEDOUT
] = "ETIMEDOUT",

119 [
ECONNREFUSED
] = "ECONNREFUSED",

120 [
EHOSTDOWN
] = "EHOSTDOWN",

121 [
EHOSTUNREACH
] = "EHOSTUNREACH",

122 [
EALREADY
] = "EALREADY",

123 [
EINPROGRESS
] = "EINPROGRESS",

124 [
ESTALE
] = "ESTALE",

125 [
EUCLEAN
] = "EUCLEAN",

126 [
ENOTNAM
] = "ENOTNAM",

127 [
ENAVAIL
] = "ENAVAIL",

128 [
EISNAM
] = "EISNAM",

129 [
EREMOTEIO
] = "EREMOTEIO",

130 [
EDQUOT
] = "EDQUOT",

132 [
ENOMEDIUM
] = "ENOMEDIUM",

133 [
EMEDIUMTYPE
] = "EMEDIUMTYPE",

136 [
ENSROK
] = "ENSROK",

137 [
ENSRNODATA
] = "ENSRNODATA",

138 [
ENSRFORMERR
] = "ENSRFORMERR",

139 [
ENSRSERVFAIL
] = "ENSRSERVFAIL",

140 [
ENSRNOTFOUND
] = "ENSRNOTFOUND",

141 [
ENSRNOTIMP
] = "ENSRNOTIMP",

142 [
ENSRREFUSED
] = "ENSRREFUSED",

143 [
ENSRBADQUERY
] = "ENSRBADQUERY",

144 [
ENSRBADNAME
] = "ENSRBADNAME",

145 [
ENSRBADFAMILY
] = "ENSRBADFAMILY",

146 [
ENSRBADRESP
] = "ENSRBADRESP",

147 [
ENSRCONNREFUSED
] = "ENSRCONNREFUSED",

148 [
ENSRTIMEOUT
] = "ENSRTIMEOUT",

149 [
ENSROF
] = "ENSROF",

150 [
ENSRFILE
] = "ENSRFILE",

151 [
ENSRNOMEM
] = "ENSRNOMEM",

152 [
ENSRDESTRUCTION
] = "ENSRDESTRUCTION",

153 [
ENSRQUERYDOMAINTOOLONG
] = "ENSRQUERYDOMAINTOOLONG",

154 [
ENSRCNAMELOOP
] = "ENSRCNAMELOOP"

158 
	$perror
(const char *
s
) {

159 int 
err
 = 
errno
;

160 
	`cprintf
("%s: %s\n", 
s
, 
	`e2s
(
err
));

161 
	}
}

164 
	$e2s
(int 
err
) {

165 return 
sys_errlist
[
err
];

166 
	}
}

	@/root/Robux/net/lwip/jos/arch/perror.h

1 #ifndef 
JOS_INC_PERROR_H


2 #define 
	#JOS_INC_PERROR_H


	)

4 void 
perror
(const char *
s
);

5 const char *
e2s
(int 
e
);

	@/root/Robux/net/lwip/jos/arch/setjmp.h

1 #ifndef 
JOS_INC_SETJMP_H


2 #define 
	#JOS_INC_SETJMP_H


	)

4 #include 
	~<arch/i386/setjmp.h
>

6 int 
jos_setjmp
(volatile struct 
jos_jmp_buf
 *
buf
);

7 void 
	$jos_longjmp
(volatile struct 
jos_jmp_buf
 *
buf
, int 
val
)

8 
	`__attribute__
((
__noreturn__
, 
JOS_LONGJMP_GCCATTR
));

	@/root/Robux/net/lwip/jos/arch/sys_arch.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<inc/queue.h
>

4 #include 
	~<lwip/sys.h
>

5 #include 
	~<arch/thread.h
>

6 #include 
	~<arch/cc.h
>

7 #include 
	~<arch/sys_arch.h
>

8 #include 
	~<arch/perror.h
>

9 #include 
	~<arch/thread.h
>

11 #define 
	#debug
 0

	)

13 #define 
	#NSEM
 256

	)

14 #define 
	#NMBOX
 128

	)

15 #define 
	#MBOXSLOTS
 32

	)

17 struct 
	ssys_sem_entry
 {

18 int 
	mfreed
;

19 int 
	mgen
;

21 
uint32_t
 
	mv
;

23 
uint16_t
 
	mcounter
;

24 
uint16_t
 
	mwaiters
;

27 
LIST_ENTRY
(
sys_sem_entry
) 
	mlink
;

29 static struct 
sys_sem_entry
 
	gsems
[
NSEM
];

30 static 
	$LIST_HEAD
(
sem_list
, 
sys_sem_entry
) 
sem_free
;

32 struct 
	ssys_mbox_entry
 {

33 int 
freed
;

34 int 
head
, 
nextq
;

35 void *
msg
[
MBOXSLOTS
];

36 
sys_sem_t
 
queued_msg
;

37 
sys_sem_t
 
free_msg
;

38 
	`LIST_ENTRY
(
sys_mbox_entry
) 
link
;

40 static struct 
sys_mbox_entry
 
mboxes
[
NMBOX
];

41 static 
	$LIST_HEAD
(
mbox_list
, 
sys_mbox_entry
) 
mbox_free
;

43 struct 
	ssys_thread
 {

44 
thread_id_t
 
tid
;

45 struct 
sys_timeouts
 
tmo
;

46 
	`LIST_ENTRY
(
sys_thread
) 
link
;

49 enum { 
thread_hash_size
 = 257 };

50 static 
	$LIST_HEAD
(
thread_list
, 
sys_thread
) 
threads
[
thread_hash_size
];

53 
	$sys_init
(void)

55 int 
i
 = 0;

56 for (
i
 = 0; i < 
NSEM
; i++) {

57 
sems
[
i
].
freed
 = 1;

58 
	`LIST_INSERT_HEAD
(&
sem_free
, &
sems
[
i
], 
link
);

61 for (
i
 = 0; i < 
NMBOX
; i++) {

62 
mboxes
[
i
].
freed
 = 1;

63 
	`LIST_INSERT_HEAD
(&
mbox_free
, &
mboxes
[
i
], 
link
);

65 
	}
}

67 
sys_mbox_t


68 
	$sys_mbox_new
(int 
size
)

70 
	`assert
(
size
 < 
MBOXSLOTS
);

71 struct 
sys_mbox_entry
 *
mbe
 = 
	`LIST_FIRST
(&
mbox_free
);

72 if (!
mbe
) {

73 
	`cprintf
("lwip: sys_mbox_new: out of mailboxes\n");

74 return 
SYS_MBOX_NULL
;

76 
	`LIST_REMOVE
(
mbe
, 
link
);

77 
	`assert
(
mbe
->
freed
);

78 
mbe
->
freed
 = 0;

80 int 
i
 = 
mbe
 - &
mboxes
[0];

81 
mbe
->
head
 = -1;

82 
mbe
->
nextq
 = 0;

83 
mbe
->
queued_msg
 = 
	`sys_sem_new
(0);

84 
mbe
->
free_msg
 = 
	`sys_sem_new
(
MBOXSLOTS
);

86 if (
mbe
->
queued_msg
 == 
SYS_SEM_NULL
 ||

87 
mbe
->
free_msg
 == 
SYS_SEM_NULL
)

89 
	`sys_mbox_free
(
i
);

90 
	`cprintf
("lwip: sys_mbox_new: can't get semaphore\n");

91 return 
SYS_MBOX_NULL
;

93 return 
i
;

94 
	}
}

97 
	$sys_mbox_free
(
sys_mbox_t
 
mbox
)

99 
	`assert
(!
mboxes
[
mbox
].
freed
);

100 
	`sys_sem_free
(
mboxes
[
mbox
].
queued_msg
);

101 
	`sys_sem_free
(
mboxes
[
mbox
].
free_msg
);

102 
	`LIST_INSERT_HEAD
(&
mbox_free
, &
mboxes
[
mbox
], 
link
);

103 
mboxes
[
mbox
].
freed
 = 1;

104 
	}
}

107 
	$sys_mbox_post
(
sys_mbox_t
 
mbox
, void *
msg
)

109 
	`assert
(
	`sys_mbox_trypost
(
mbox
, 
msg
) == 
ERR_OK
);

110 
	}
}

112 
err_t


113 
	$sys_mbox_trypost
(
sys_mbox_t
 
mbox
, void *
msg
)

115 
	`assert
(!
mboxes
[
mbox
].
freed
);

117 
	`sys_arch_sem_wait
(
mboxes
[
mbox
].
free_msg
, 0);

118 if (
mboxes
[
mbox
].
nextq
 == mboxes[mbox].
head
)

119 return 
ERR_MEM
;

121 int 
slot
 = 
mboxes
[
mbox
].
nextq
;

122 
mboxes
[
mbox
].
nextq
 = (
slot
 + 1) % 
MBOXSLOTS
;

123 
mboxes
[
mbox
].
msg
[
slot
] = msg;

125 if (
mboxes
[
mbox
].
head
 == -1)

126 
mboxes
[
mbox
].
head
 = 
slot
;

128 
	`sys_sem_signal
(
mboxes
[
mbox
].
queued_msg
);

130 return 
ERR_OK
;

131 
	}
}

133 
sys_sem_t


134 
	$sys_sem_new
(
u8_t
 
count
)

136 struct 
sys_sem_entry
 *
se
 = 
	`LIST_FIRST
(&
sem_free
);

137 if (!
se
) {

138 
	`cprintf
("lwip: sys_sem_new: out of semaphores\n");

139 return 
SYS_SEM_NULL
;

141 
	`LIST_REMOVE
(
se
, 
link
);

142 
	`assert
(
se
->
freed
);

143 
se
->
freed
 = 0;

145 
se
->
counter
 = 
count
;

146 
se
->
gen
++;

147 return 
se
 - &
sems
[0];

148 
	}
}

151 
	$sys_sem_free
(
sys_sem_t
 
sem
)

153 
	`assert
(!
sems
[
sem
].
freed
);

154 
sems
[
sem
].
freed
 = 1;

155 
sems
[
sem
].
gen
++;

156 
	`LIST_INSERT_HEAD
(&
sem_free
, &
sems
[
sem
], 
link
);

157 
	}
}

160 
	$sys_sem_signal
(
sys_sem_t
 
sem
)

162 
	`assert
(!
sems
[
sem
].
freed
);

163 
sems
[
sem
].
counter
++;

164 if (
sems
[
sem
].
waiters
) {

165 
sems
[
sem
].
waiters
 = 0;

166 
	`thread_wakeup
(&
sems
[
sem
].
v
);

168 
	}
}

170 
u32_t


171 
	$sys_arch_sem_wait
(
sys_sem_t
 
sem
, 
u32_t
 
tm_msec
)

173 
	`assert
(!
sems
[
sem
].
freed
);

174 
u32_t
 
waited
 = 0;

176 int 
gen
 = 
sems
[
sem
].gen;

178 while (
tm_msec
 == 0 || 
waited
 < tm_msec) {

179 if (
sems
[
sem
].
counter
 > 0) {

180 
sems
[
sem
].
counter
--;

181 return 
waited
;

182 } else if (
tm_msec
 == 
SYS_ARCH_NOWAIT
) {

183 return 
SYS_ARCH_TIMEOUT
;

185 
uint32_t
 
a
 = 
	`sys_time_msec
();

186 
uint32_t
 
sleep_until
 = 
tm_msec
 ? 
a
 + (tm_msec - 
waited
) : ~0;

187 
sems
[
sem
].
waiters
 = 1;

188 
uint32_t
 
cur_v
 = 
sems
[
sem
].
v
;

189 
	`lwip_core_unlock
();

190 
	`thread_wait
(&
sems
[
sem
].
v
, 
cur_v
, 
sleep_until
);

191 
	`lwip_core_lock
();

192 if (
gen
 != 
sems
[
sem
].gen) {

193 
	`cprintf
("sys_arch_sem_wait: sem freed under waiter!\n");

194 return 
SYS_ARCH_TIMEOUT
;

196 
uint32_t
 
b
 = 
	`sys_time_msec
();

197 
waited
 += (
b
 - 
a
);

201 return 
SYS_ARCH_TIMEOUT
;

202 
	}
}

204 
u32_t


205 
	$sys_arch_mbox_fetch
(
sys_mbox_t
 
mbox
, void **
msg
, 
u32_t
 
tm_msec
)

207 
	`assert
(!
mboxes
[
mbox
].
freed
);

209 
u32_t
 
waited
 = 
	`sys_arch_sem_wait
(
mboxes
[
mbox
].
queued_msg
, 
tm_msec
);

210 if (
waited
 == 
SYS_ARCH_TIMEOUT
)

211 return 
waited
;

213 int 
slot
 = 
mboxes
[
mbox
].
head
;

214 if (
slot
 == -1)

215 
	`panic
("lwip: sys_arch_mbox_fetch: no message");

216 if (
msg
)

217 *
msg
 = 
mboxes
[
mbox
].msg[
slot
];

219 
mboxes
[
mbox
].
head
 = (
slot
 + 1) % 
MBOXSLOTS
;

220 if (
mboxes
[
mbox
].
head
 == mboxes[mbox].
nextq
)

221 
mboxes
[
mbox
].
head
 = -1;

223 
	`sys_sem_signal
(
mboxes
[
mbox
].
free_msg
);

224 return 
waited
;

225 
	}
}

227 
u32_t


228 
	$sys_arch_mbox_tryfetch
(
sys_mbox_t
 
mbox
, void **
msg
)

230 return 
	`sys_arch_mbox_fetch
(
mbox
, 
msg
, 
SYS_ARCH_NOWAIT
);

231 
	}
}

233 struct 
	slwip_thread
 {

234 void (*
	mfunc
)(void *
	marg
);

235 void *
	marg
;

239 
	$lwip_thread_entry
(
uint32_t
 
arg
)

241 struct 
lwip_thread
 *
lt
 = (struct lwip_thread *)
arg
;

242 
	`lwip_core_lock
();

243 
lt
->
	`func
(lt->
arg
);

244 
	`lwip_core_unlock
();

245 
	`free
(
lt
);

246 
	}
}

248 
sys_thread_t


249 
sys_thread_new
(char *
name
, void (* 
thread
)(void *
arg
), void *arg,

250 int 
stacksize
, int 
prio
)

252 struct 
lwip_thread
 *
lt
 = 
	`malloc
(sizeof(*lt));

253 if (
lt
 == 0)

254 
	`panic
("sys_thread_new: cannot allocate thread struct");

256 if (
stacksize
 > 
PGSIZE
)

257 
	`panic
("large stack %d", 
stacksize
);

259 
lt
->
func
 = 
thread
;

260 
lt
->
arg
 = arg;

262 
thread_id_t
 
tid
;

263 int 
r
 = 
	`thread_create
(&
tid
, 
name
, 
lwip_thread_entry
, (
uint32_t
)
lt
);

265 if (
r
 < 0)

266 
	`panic
("lwip: sys_thread_new: cannot create: %s\n", 
	`e2s
(
r
));

268 return 
tid
;

269 
	}
}

272 
	$timeout_cleanup
(
thread_id_t
 
tid
)

274 
	`lwip_core_lock
();

276 struct 
sys_thread
 *
t
;

277 
	`LIST_FOREACH
(
t
, &
threads
[
tid
 % 
thread_hash_size
], 
link
)

278 if (
t
->
tid
 == tid) {

279 
	`LIST_REMOVE
(
t
, 
link
);

280 
	`free
(
t
);

281 goto 
done
;

284 if (
debug
) 
	`cprintf
("timeout_cleanup: bogus tid %ld\n", 
tid
);

285 
done
:

286 
	`lwip_core_unlock
();

287 
	}
}

289 struct 
sys_timeouts
 *

290 
	$sys_arch_timeouts
(void)

292 
thread_id_t
 
tid
 = 
	`thread_id
();

294 struct 
sys_thread
 *
t
;

295 
	`LIST_FOREACH
(
t
, &
threads
[
tid
 % 
thread_hash_size
], 
link
)

296 if (
t
->
tid
 == tid)

297 goto 
out
;

299 
t
 = 
	`malloc
(sizeof(*t));

300 if (
t
 == 0)

301 
	`panic
("sys_arch_timeouts: cannot malloc");

303 int 
r
 = 
	`thread_onhalt
(
timeout_cleanup
);

304 if (
r
 < 0)

305 
	`panic
("thread_onhalt failed: %s", 
	`e2s
(
r
));

307 
t
->
tid
 = tid;

308 
	`memset
(&
t
->
tmo
, 0, sizeof(t->tmo));

309 
	`LIST_INSERT_HEAD
(&
threads
[
tid
 % 
thread_hash_size
], 
t
, 
link
);

311 
out
:

312 return &
t
->
tmo
;

313 
	}
}

316 
	$lwip_core_lock
(void)

318 
	}
}

321 
	$lwip_core_unlock
(void)

323 
	}
}

	@/root/Robux/net/lwip/jos/arch/sys_arch.h

1 #ifndef 
LWIP_ARCH_SYS_ARCH_H


2 #define 
	#LWIP_ARCH_SYS_ARCH_H


	)

4 #include 
	~<inc/types.h
>

6 typedef int 
	tsys_sem_t
;

7 typedef int 
	tsys_mbox_t
;

8 typedef int 
	tsys_thread_t
;

10 #define 
	#SYS_MBOX_NULL
 (-1)

	)

11 #define 
	#SYS_SEM_NULL
 (-1)

	)

13 void 
lwip_core_lock
(void);

14 void 
lwip_core_unlock
(void);

15 void 
lwip_core_init
(void);

17 #define 
	#SYS_ARCH_DECL_PROTECT
(
lev
)

	)

18 #define 
	#SYS_ARCH_PROTECT
(
lev
)

	)

19 #define 
	#SYS_ARCH_UNPROTECT
(
lev
)

	)

21 #define 
	#SYS_ARCH_NOWAIT
 0xfffffffe

	)

	@/root/Robux/net/lwip/jos/arch/thread.c

1 #include 
	~<inc/lib.h
>

3 #include 
	~<arch/thread.h
>

4 #include 
	~<arch/threadq.h
>

5 #include 
	~<arch/setjmp.h
>

7 static 
thread_id_t
 
	gmax_tid
;

8 static struct 
thread_context
 *
	gcur_tc
;

10 static struct 
thread_queue
 
	gthread_queue
;

11 static struct 
thread_queue
 
	gkill_queue
;

14 
	$thread_init
(void) {

15 
	`threadq_init
(&
thread_queue
);

16 
max_tid
 = 0;

17 
	}
}

19 
uint32_t


20 
	$thread_id
(void) {

21 return 
cur_tc
->
tc_tid
;

22 
	}
}

25 
	$thread_wakeup
(volatile 
uint32_t
 *
addr
) {

26 struct 
thread_context
 *
tc
 = 
thread_queue
.
tq_first
;

27 while (
tc
) {

28 if (
tc
->
tc_wait_addr
 == 
addr
)

29 
tc
->
tc_wakeup
 = 1;

30 
tc
 = tc->
tc_queue_link
;

32 
	}
}

35 
	$thread_wait
(volatile 
uint32_t
 *
addr
, uint32_t 
val
, uint32_t 
msec
) {

36 
uint32_t
 
s
 = 
	`sys_time_msec
();

37 
uint32_t
 
p
 = 
s
;

39 
cur_tc
->
tc_wait_addr
 = 
addr
;

40 
cur_tc
->
tc_wakeup
 = 0;

42 while (
p
 < 
msec
) {

43 if (
p
 < 
s
)

45 if (
addr
 && *addr != 
val
)

47 if (
cur_tc
->
tc_wakeup
)

50 
	`thread_yield
();

51 
p
 = 
	`sys_time_msec
();

54 
cur_tc
->
tc_wait_addr
 = 0;

55 
cur_tc
->
tc_wakeup
 = 0;

56 
	}
}

59 
	$thread_wakeups_pending
(void)

61 struct 
thread_context
 *
tc
 = 
thread_queue
.
tq_first
;

62 int 
n
 = 0;

63 while (
tc
) {

64 if (
tc
->
tc_wakeup
)

65 ++
n
;

66 
tc
 = tc->
tc_queue_link
;

68 return 
n
;

69 
	}
}

72 
thread_onhalt
(void (*
fun
)(
thread_id_t
)) {

73 if (
cur_tc
->
tc_nonhalt
 >= 
THREAD_NUM_ONHALT
)

74 return -
E_NO_MEM
;

76 
cur_tc
->
tc_onhalt
[cur_tc->
tc_nonhalt
++] = 
fun
;

78 
	}
}

80 static 
thread_id_t


81 
	$alloc_tid
(void) {

82 int 
tid
 = 
max_tid
++;

83 if (
max_tid
 == (
uint32_t
)~0)

84 
	`panic
("alloc_tid: no more thread ids");

85 return 
tid
;

86 
	}
}

89 
	$thread_set_name
(struct 
thread_context
 *
tc
, const char *
name
)

91 
	`strncpy
(
tc
->
tc_name
, 
name
, 
name_size
 - 1);

92 
tc
->
tc_name
[
name_size
 - 1] = 0;

93 
	}
}

96 
	$thread_entry
(void) {

97 
cur_tc
->
	`tc_entry
(cur_tc->
tc_arg
);

98 
	`thread_halt
();

99 
	}
}

102 
thread_create
(
thread_id_t
 *
tid
, const char *
name
,

103 void (*
entry
)(
uint32_t
), uint32_t 
arg
) {

104 struct 
thread_context
 *
tc
 = 
	`malloc
(sizeof(struct thread_context));

105 if (!
tc
)

106 return -
E_NO_MEM
;

108 
	`memset
(
tc
, 0, sizeof(struct 
thread_context
));

110 
	`thread_set_name
(
tc
, 
name
);

111 
tc
->
tc_tid
 = 
	`alloc_tid
();

113 
tc
->
tc_stack_bottom
 = 
	`malloc
(
stack_size
);

114 if (!
tc
->
tc_stack_bottom
) {

115 
	`free
(
tc
);

116 return -
E_NO_MEM
;

119 void *
stacktop
 = 
tc
->
tc_stack_bottom
 + 
stack_size
;

121 
stacktop
 = stacktop - 4;

122 
	`memset
(
stacktop
, 0, 4);

124 
	`memset
(&
tc
->
tc_jb
, 0, sizeof(tc->tc_jb));

125 
tc
->
tc_jb
.
jb_esp
 = (
uint32_t
)
stacktop
;

126 
tc
->
tc_jb
.
jb_eip
 = (
uint32_t
)&
thread_entry
;

127 
tc
->
tc_entry
 = 
entry
;

128 
tc
->
tc_arg
 = 
arg
;

130 
	`threadq_push
(&
thread_queue
, 
tc
);

132 if (
tid
)

133 *
tid
 = 
tc
->
tc_tid
;

135 
	}
}

138 
	$thread_clean
(struct 
thread_context
 *
tc
) {

139 if (!
tc
) return;

141 int 
i
;

142 for (
i
 = 0; i < 
tc
->
tc_nonhalt
; i++)

143 
tc
->
tc_onhalt
[
i
](tc->
tc_tid
);

144 
	`free
(
tc
->
tc_stack_bottom
);

145 
	`free
(
tc
);

146 
	}
}

149 
	$thread_halt
() {

152 
	`thread_clean
(
	`threadq_pop
(&
kill_queue
));

154 
	`threadq_push
(&
kill_queue
, 
cur_tc
);

155 
cur_tc
 = 
NULL
;

156 
	`thread_yield
();

159 
	`exit
();

160 
	}
}

163 
	$thread_yield
(void) {

164 struct 
thread_context
 *
next_tc
 = 
	`threadq_pop
(&
thread_queue
);

166 if (!
next_tc
)

169 if (
cur_tc
) {

170 if (
	`jos_setjmp
(&
cur_tc
->
tc_jb
) != 0)

172 
	`threadq_push
(&
thread_queue
, 
cur_tc
);

175 
cur_tc
 = 
next_tc
;

176 
	`jos_longjmp
(&
cur_tc
->
tc_jb
, 1);

177 
	}
}

180 
	$print_jb
(struct 
thread_context
 *
tc
) {

181 
	`cprintf
("jump buffer for thread %s:\n", 
tc
->
tc_name
);

182 
	`cprintf
("\teip: %x\n", 
tc
->
tc_jb
.
jb_eip
);

183 
	`cprintf
("\tesp: %x\n", 
tc
->
tc_jb
.
jb_esp
);

184 
	`cprintf
("\tebp: %x\n", 
tc
->
tc_jb
.
jb_ebp
);

185 
	`cprintf
("\tebx: %x\n", 
tc
->
tc_jb
.
jb_ebx
);

186 
	`cprintf
("\tesi: %x\n", 
tc
->
tc_jb
.
jb_esi
);

187 
	`cprintf
("\tedi: %x\n", 
tc
->
tc_jb
.
jb_edi
);

188 
	}
}

	@/root/Robux/net/lwip/jos/arch/thread.h

1 #ifndef 
LWIP_ARCH_THREAD_H


2 #define 
	#LWIP_ARCH_THREAD_H


	)

4 #include 
	~<inc/types.h
>

6 typedef 
uint32_t
 
	tthread_id_t
;

8 void 
thread_init
(void);

9 
thread_id_t
 
thread_id
(void);

10 void 
thread_wakeup
(volatile 
uint32_t
 *
addr
);

11 void 
thread_wait
(volatile 
uint32_t
 *
addr
, uint32_t 
val
, uint32_t 
msec
);

12 int 
thread_wakeups_pending
(void);

13 int 
thread_onhalt
(void (*
fun
)(
thread_id_t
));

14 int 
	`thread_create
(
thread_id_t
 *
tid
, const char *
name
,

15 void (*
entry
)(
uint32_t
), uint32_t 
arg
);

16 void 
	`thread_yield
(void);

17 void 
	`thread_halt
(void);

	@/root/Robux/net/lwip/jos/arch/threadq.h

1 #ifndef 
JOS_INC_THREADQ_H


2 #define 
	#JOS_INC_THREADQ_H


	)

4 #include 
	~<arch/thread.h
>

5 #include 
	~<arch/setjmp.h
>

7 #define 
	#THREAD_NUM_ONHALT
 4

	)

8 enum { 
	mname_size
 = 32 };

9 enum { 
	mstack_size
 = 
PGSIZE
 };

11 struct 
	gthread_context
;

13 struct 
	sthread_queue


15 struct 
thread_context
 *
	mtq_first
;

16 struct 
thread_context
 *
	mtq_last
;

19 struct 
	sthread_context
 {

20 
thread_id_t
 
	mtc_tid
;

21 void *
	mtc_stack_bottom
;

22 char 
	mtc_name
[
name_size
];

23 void (*
	mtc_entry
)(
	muint32_t
);

24 
uint32_t
 
	mtc_arg
;

25 struct 
jos_jmp_buf
 
	mtc_jb
;

26 volatile 
uint32_t
 *
	mtc_wait_addr
;

27 volatile char 
	mtc_wakeup
;

28 void (*
	mtc_onhalt
[
THREAD_NUM_ONHALT
])(
	mthread_id_t
);

29 int 
	mtc_nonhalt
;

30 struct 
thread_context
 *
	mtc_queue_link
;

33 static 
inline
 void

34 
	$threadq_init
(struct 
thread_queue
 *
tq
)

36 
tq
->
tq_first
 = 0;

37 
tq
->
tq_last
 = 0;

38 
	}
}

40 static 
inline
 void

41 
	$threadq_push
(struct 
thread_queue
 *
tq
, struct 
thread_context
 *
tc
)

43 
tc
->
tc_queue_link
 = 0;

44 if (!
tq
->
tq_first
) {

45 
tq
->
tq_first
 = 
tc
;

46 
tq
->
tq_last
 = 
tc
;

48 
tq
->
tq_last
->
tc_queue_link
 = 
tc
;

49 
tq
->
tq_last
 = 
tc
;

51 
	}
}

53 static 
inline
 struct 
thread_context
 *

54 
	$threadq_pop
(struct 
thread_queue
 *
tq
)

56 if (!
tq
->
tq_first
)

59 struct 
thread_context
 *
tc
 = 
tq
->
tq_first
;

60 
tq
->
tq_first
 = 
tc
->
tc_queue_link
;

61 
tc
->
tc_queue_link
 = 0;

62 return 
tc
;

63 
	}
}

	@/root/Robux/net/lwip/jos/jif/jif.c

33 #include 
	~<inc/lib.h
>

34 #include 
	~<inc/ns.h
>

36 #include 
	~<jif/jif.h
>

38 #include 
	~"lwip/opt.h
"

39 #include 
	~"lwip/def.h
"

40 #include 
	~"lwip/mem.h
"

41 #include 
	~"lwip/pbuf.h
"

42 #include 
	~"lwip/sys.h
"

43 #include 
	~<lwip/stats.h
>

45 #include 
	~<netif/etharp.h
>

47 #define 
	#PKTMAP
 0x10000000

	)

49 struct 
	sjif
 {

50 struct 
eth_addr
 *
	methaddr
;

51 
envid_t
 
	menvid
;

55 
	$low_level_init
(struct 
netif
 *netif)

57 int 
r
;

59 
netif
->
hwaddr_len
 = 6;

60 
netif
->
mtu
 = 1500;

61 
netif
->
flags
 = 
NETIF_FLAG_BROADCAST
;

64 if(
	`sys_get_mac_addr
(
netif
->
hwaddr
) < 0)

65 
	`panic
("Failed to get mac in lwip\n");

66 
	}
}

76 static 
err_t


77 
	$low_level_output
(struct 
netif
 *netif, struct 
pbuf
 *
p
)

79 int 
r
 = 
	`sys_page_alloc
(0, (void *)
PKTMAP
, 
PTE_U
|
PTE_W
|
PTE_P
);

80 if (
r
 < 0)

81 
	`panic
("jif: could not allocate page of memory");

82 struct 
jif_pkt
 *
pkt
 = (struct jif_pkt *)
PKTMAP
;

84 struct 
jif
 *jif;

85 
jif
 = 
netif
->
state
;

87 char *
txbuf
 = 
pkt
->
jp_data
;

88 int 
txsize
 = 0;

89 struct 
pbuf
 *
q
;

90 for (
q
 = 
p
; q != 
NULL
; q = q->
next
) {

95 if (
txsize
 + 
q
->
len
 > 2000)

96 
	`panic
("oversized packet, fragment %d txsize %d\n", 
q
->
len
, 
txsize
);

97 
	`memcpy
(&
txbuf
[
txsize
], 
q
->
payload
, q->
len
);

98 
txsize
 += 
q
->
len
;

101 
pkt
->
jp_len
 = 
txsize
;

103 
	`ipc_send
(
jif
->
envid
, 
NSREQ_OUTPUT
, (void *)
pkt
, 
PTE_P
|
PTE_W
|
PTE_U
);

104 
	`sys_page_unmap
(0, (void *)
pkt
);

106 return 
ERR_OK
;

107 
	}
}

116 static struct 
pbuf
 *

117 
	$low_level_input
(void *
va
)

119 struct 
jif_pkt
 *
pkt
 = (struct jif_pkt *)
va
;

120 
s16_t
 
len
 = 
pkt
->
jp_len
;

122 struct 
pbuf
 *
p
 = 
	`pbuf_alloc
(
PBUF_RAW
, 
len
, 
PBUF_POOL
);

123 if (
p
 == 0)

128 void *
rxbuf
 = (void *) 
pkt
->
jp_data
;

129 int 
copied
 = 0;

130 struct 
pbuf
 *
q
;

131 for (
q
 = 
p
; q != 
NULL
; q = q->
next
) {

135 int 
bytes
 = 
q
->
len
;

136 if (
bytes
 > (
len
 - 
copied
))

137 
bytes
 = 
len
 - 
copied
;

138 
	`memcpy
(
q
->
payload
, 
rxbuf
 + 
copied
, 
bytes
);

139 
copied
 += 
bytes
;

142 return 
p
;

143 
	}
}

153 static 
err_t


154 
	$jif_output
(struct 
netif
 *netif, struct 
pbuf
 *
p
,

155 struct 
ip_addr
 *
ipaddr
)

158 return 
	`etharp_output
(
netif
, 
p
, 
ipaddr
);

159 
	}
}

172 
	$jif_input
(struct 
netif
 *netif, void *
va
)

174 struct 
jif
 *jif;

175 struct 
eth_hdr
 *
ethhdr
;

176 struct 
pbuf
 *
p
;

178 
jif
 = 
netif
->
state
;

181 
p
 = 
	`low_level_input
(
va
);

184 if (
p
 == 
NULL
) return;

186 
ethhdr
 = 
p
->
payload
;

188 switch (
	`htons
(
ethhdr
->
type
)) {

189 case 
ETHTYPE_IP
:

191 
	`etharp_ip_input
(
netif
, 
p
);

193 
	`pbuf_header
(
p
, -(int)sizeof(struct 
eth_hdr
));

195 
netif
->
	`input
(
p
, netif);

198 case 
ETHTYPE_ARP
:

200 
	`etharp_arp_input
(
netif
, 
jif
->
ethaddr
, 
p
);

204 
	`pbuf_free
(
p
);

206 
	}
}

217 
err_t


218 
	$jif_init
(struct 
netif
 *netif)

220 struct 
jif
 *jif;

221 
envid_t
 *
output_envid
;

223 
jif
 = 
	`mem_malloc
(sizeof(struct jif));

225 if (
jif
 == 
NULL
) {

226 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("jif_init: out of memory\n"));

227 return 
ERR_MEM
;

230 
output_envid
 = (
envid_t
 *)
netif
->
state
;

232 
netif
->
state
 = 
jif
;

233 
netif
->
output
 = 
jif_output
;

234 
netif
->
linkoutput
 = 
low_level_output
;

235 
	`memcpy
(&
netif
->
name
[0], "en", 2);

237 
jif
->
ethaddr
 = (struct 
eth_addr
 *)&(
netif
->
hwaddr
[0]);

238 
jif
->
envid
 = *
output_envid
;

240 
	`low_level_init
(
netif
);

242 
	`etharp_init
();

247 
uint32_t
 
ipaddr
 = 
	`inet_addr
("10.0.2.2");

248 
	`etharp_query
(
netif
, (struct 
ip_addr
 *) &
ipaddr
, 0);

250 return 
ERR_OK
;

251 
	}
}

	@/root/Robux/net/lwip/jos/jif/jif.h

1 #include 
	~<lwip/netif.h
>

3 void 
jif_input
(struct 
netif
 *netif, void *
va
);

4 
err_t
 
jif_init
(struct 
netif
 *netif);

	@/root/Robux/net/lwip/jos/lwipopts.h

1 #ifndef 
JOS_LWIP_LWIPOPTS_H


2 #define 
	#JOS_LWIP_LWIPOPTS_H


	)

8 #include 
	~<inc/types.h
>

9 void *
memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

13 #define 
	#LWIP_STATS
 0

	)

14 #define 
	#LWIP_STATS_DISPLAY
 0

	)

15 #define 
	#LWIP_DHCP
 1

	)

16 #define 
	#LWIP_COMPAT_SOCKETS
 0

	)

18 #define 
	#LWIP_PROVIDE_ERRNO
 1

	)

23 #define 
	#MEM_ALIGNMENT
 4

	)

25 #define 
	#MEMP_NUM_PBUF
 64

	)

26 #define 
	#MEMP_NUM_UDP_PCB
 8

	)

27 #define 
	#MEMP_NUM_TCP_PCB
 32

	)

28 #define 
	#MEMP_NUM_TCP_PCB_LISTEN
 16

	)

29 #define 
	#MEMP_NUM_TCP_SEG
 
TCP_SND_QUEUELEN


30 #define 
	#MEMP_NUM_NETBUF
 128

	)

31 #define 
	#MEMP_NUM_NETCONN
 32

	)

32 #define 
	#MEMP_NUM_SYS_TIMEOUT
 6

	)

34 #define 
	#PER_TCP_PCB_BUFFER
 (16 * 4096)

	)

35 #define 
	#MEM_SIZE
 (
PER_TCP_PCB_BUFFER
*
MEMP_NUM_TCP_SEG
 + 4096*MEMP_NUM_TCP_SEG)

	)

37 #define 
	#PBUF_POOL_SIZE
 512

	)

38 #define 
	#PBUF_POOL_BUFSIZE
 2000

	)

40 #define 
	#TCP_MSS
 1460

	)

41 #define 
	#TCP_WND
 24000

	)

42 #define 
	#TCP_SND_BUF
 (16 * 
TCP_MSS
)

	)

45 #define 
	#TCP_SND_QUEUELEN
 (2 * 
TCP_SND_BUF
/
TCP_MSS
)

	)

49 #define 
	#LWIP_DEBUG
 1

	)

57 #define 
	#DBG_MIN_LEVEL
 
DBG_LEVEL_SERIOUS


	)

58 #define 
	#LWIP_DBG_MIN_LEVEL
 0

	)

59 #define 
	#MEMP_SANITY_CHECK
 0

	)

61 #define 
	#ERRNO


	)

	@/root/Robux/net/lwip/netif/etharp.c

47 #include 
	~"lwip/opt.h
"

49 #if 
LWIP_ARP


51 #include 
	~"lwip/inet.h
"

52 #include 
	~"lwip/ip.h
"

53 #include 
	~"lwip/stats.h
"

54 #include 
	~"lwip/snmp.h
"

55 #include 
	~"lwip/dhcp.h
"

56 #include 
	~"lwip/autoip.h
"

57 #include 
	~"netif/etharp.h
"

59 #if 
PPPOE_SUPPORT


60 #include 
	~"netif/ppp_oe.h
"

63 #include 
	~<string.h
>

69 #define 
	#ARP_MAXAGE
 240

	)

77 #define 
	#ARP_MAXPENDING
 2

	)

79 #define 
	#HWTYPE_ETHERNET
 1

	)

81 #define 
	#ARPH_HWLEN
(
hdr
) (
	`ntohs
((hdr)->
_hwlen_protolen
) >> 8)

	)

82 #define 
	#ARPH_PROTOLEN
(
hdr
) (
	`ntohs
((hdr)->
_hwlen_protolen
) & 0xff)

	)

84 #define 
	#ARPH_HWLEN_SET
(
hdr
, 
len
) (hdr)->
_hwlen_protolen
 = 
	`htons
(
	`ARPH_PROTOLEN
(hdr) | ((len) << 8))

	)

85 #define 
	#ARPH_PROTOLEN_SET
(
hdr
, 
len
) (hdr)->
_hwlen_protolen
 = 
	`htons
((len) | (
	`ARPH_HWLEN
(hdr) << 8))

	)

87 enum 
	eetharp_state
 {

88 
	mETHARP_STATE_EMPTY
 = 0,

89 
	mETHARP_STATE_PENDING
,

90 
	mETHARP_STATE_STABLE


93 struct 
	setharp_entry
 {

94 #if 
ARP_QUEUEING


98 struct 
etharp_q_entry
 *
	mq
;

100 struct 
ip_addr
 
	mipaddr
;

101 struct 
eth_addr
 
	methaddr
;

102 enum 
etharp_state
 
	mstate
;

103 
u8_t
 
	mctime
;

104 struct 
netif
 *
	mnetif
;

107 const struct 
eth_addr
 
	gethbroadcast
 = {{0xff,0xff,0xff,0xff,0xff,0xff}};

108 const struct 
eth_addr
 
	gethzero
 = {{0,0,0,0,0,0}};

109 static struct 
etharp_entry
 
	garp_table
[
ARP_TABLE_SIZE
];

110 #if !
LWIP_NETIF_HWADDRHINT


111 static 
u8_t
 
	getharp_cached_entry
;

117 #define 
	#ETHARP_TRY_HARD
 1

	)

118 #define 
	#ETHARP_FIND_ONLY
 2

	)

120 #if 
LWIP_NETIF_HWADDRHINT


121 #define 
	#NETIF_SET_HINT
(
netif
, 
hint
) if (((netif) != 
NULL
) && ((netif)->
addr_hint
 != NULL)) \

122 *((
netif
)->
addr_hint
) = (
hint
);

	)

123 static 
s8_t
 
find_entry
(struct 
ip_addr
 *
ipaddr
, 
u8_t
 
flags
, struct 
netif
 *netif);

125 static 
s8_t
 
find_entry
(struct 
ip_addr
 *
ipaddr
, 
u8_t
 
flags
);

128 static 
err_t
 
update_arp_entry
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
, struct 
eth_addr
 *
ethaddr
, 
u8_t
 
flags
);

132 #if (
LWIP_ARP
 && (
ARP_TABLE_SIZE
 > 0x7f))

137 #if 
ARP_QUEUEING


144 
	$free_etharp_q
(struct 
etharp_q_entry
 *
q
)

146 struct 
etharp_q_entry
 *
r
;

147 
	`LWIP_ASSERT
("q != NULL", 
q
 != 
NULL
);

148 
	`LWIP_ASSERT
("q->p != NULL", 
q
->
p
 != 
NULL
);

149 while (
q
) {

150 
r
 = 
q
;

151 
q
 = q->
next
;

152 
	`LWIP_ASSERT
("r->p != NULL", (
r
->
p
 != 
NULL
));

153 
	`pbuf_free
(
r
->
p
);

154 
	`memp_free
(
MEMP_ARP_QUEUE
, 
r
);

156 
	}
}

166 
	$etharp_tmr
(void)

168 
u8_t
 
i
;

170 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
, ("etharp_timer\n"));

172 for (
i
 = 0; i < 
ARP_TABLE_SIZE
; ++i) {

173 
arp_table
[
i
].
ctime
++;

174 if (((
arp_table
[
i
].
state
 == 
ETHARP_STATE_STABLE
) &&

175 (
arp_table
[
i
].
ctime
 >= 
ARP_MAXAGE
)) ||

176 ((
arp_table
[
i
].
state
 == 
ETHARP_STATE_PENDING
) &&

177 (
arp_table
[
i
].
ctime
 >= 
ARP_MAXPENDING
))) {

179 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
, ("etharp_timer: expired %s entry %"
U16_F
".\n",

180 
arp_table
[
i
].
state
 == 
ETHARP_STATE_STABLE
 ? "stable" : "pending", (
u16_t
)i));

183 
	`snmp_delete_arpidx_tree
(
arp_table
[
i
].
netif
, &arp_table[i].
ipaddr
);

184 #if 
ARP_QUEUEING


186 if (
arp_table
[
i
].
q
 != 
NULL
) {

188 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
, ("etharp_timer: freeing entry %"
U16_F
", packet queue %p.\n", (
u16_t
)
i
, (void *)(
arp_table
[i].
q
)));

189 
	`free_etharp_q
(
arp_table
[
i
].
q
);

190 
arp_table
[
i
].
q
 = 
NULL
;

194 
arp_table
[
i
].
state
 = 
ETHARP_STATE_EMPTY
;

196 #if 
ARP_QUEUEING


198 if (
arp_table
[
i
].
state
 == 
ETHARP_STATE_PENDING
) {

203 
	}
}

227 static 
	gs8_t


228 #if 
LWIP_NETIF_HWADDRHINT


229 
	$find_entry
(struct 
ip_addr
 *
ipaddr
, 
u8_t
 
flags
, struct 
netif
 *netif)

231 
	$find_entry
(struct 
ip_addr
 *
ipaddr
, 
u8_t
 
flags
)

234 
s8_t
 
old_pending
 = 
ARP_TABLE_SIZE
, 
old_stable
 = ARP_TABLE_SIZE;

235 
s8_t
 
empty
 = 
ARP_TABLE_SIZE
;

236 
u8_t
 
i
 = 0, 
age_pending
 = 0, 
age_stable
 = 0;

237 #if 
ARP_QUEUEING


239 
s8_t
 
old_queue
 = 
ARP_TABLE_SIZE
;

241 
u8_t
 
age_queue
 = 0;

246 if (
ipaddr
) {

248 #if 
LWIP_NETIF_HWADDRHINT


249 if ((
netif
 != 
NULL
) && (netif->
addr_hint
 != NULL)) {

251 
u8_t
 
per_pcb_cache
 = *(
netif
->
addr_hint
);

252 if ((
per_pcb_cache
 < 
ARP_TABLE_SIZE
) && 
arp_table
[per_pcb_cache].
state
 == 
ETHARP_STATE_STABLE
) {

254 if (
	`ip_addr_cmp
(
ipaddr
, &
arp_table
[
per_pcb_cache
].ipaddr)) {

256 
	`ETHARP_STATS_INC
(
etharp
.
cachehit
);

257 return 
per_pcb_cache
;

262 if (
arp_table
[
etharp_cached_entry
].
state
 == 
ETHARP_STATE_STABLE
) {

264 if (
	`ip_addr_cmp
(
ipaddr
, &
arp_table
[
etharp_cached_entry
].ipaddr)) {

266 
	`ETHARP_STATS_INC
(
etharp
.
cachehit
);

267 return 
etharp_cached_entry
;

288 for (
i
 = 0; i < 
ARP_TABLE_SIZE
; ++i) {

290 if ((
empty
 == 
ARP_TABLE_SIZE
) && (
arp_table
[
i
].
state
 == 
ETHARP_STATE_EMPTY
)) {

291 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
, ("find_entry: found empty entry %"
U16_F
"\n", (
u16_t
)
i
));

293 
empty
 = 
i
;

296 else if (
arp_table
[
i
].
state
 == 
ETHARP_STATE_PENDING
) {

298 if (
ipaddr
 && 
	`ip_addr_cmp
(ipaddr, &
arp_table
[
i
].ipaddr)) {

299 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("find_entry: found matching pending entry %"
U16_F
"\n", (
u16_t
)
i
));

301 #if 
LWIP_NETIF_HWADDRHINT


302 
	`NETIF_SET_HINT
(
netif
, 
i
);

304 
etharp_cached_entry
 = 
i
;

306 return 
i
;

307 #if 
ARP_QUEUEING


309 } else if (
arp_table
[
i
].
q
 != 
NULL
) {

310 if (
arp_table
[
i
].
ctime
 >= 
age_queue
) {

311 
old_queue
 = 
i
;

312 
age_queue
 = 
arp_table
[
i
].
ctime
;

317 if (
arp_table
[
i
].
ctime
 >= 
age_pending
) {

318 
old_pending
 = 
i
;

319 
age_pending
 = 
arp_table
[
i
].
ctime
;

324 else if (
arp_table
[
i
].
state
 == 
ETHARP_STATE_STABLE
) {

326 if (
ipaddr
 && 
	`ip_addr_cmp
(ipaddr, &
arp_table
[
i
].ipaddr)) {

327 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("find_entry: found matching stable entry %"
U16_F
"\n", (
u16_t
)
i
));

329 #if 
LWIP_NETIF_HWADDRHINT


330 
	`NETIF_SET_HINT
(
netif
, 
i
);

332 
etharp_cached_entry
 = 
i
;

334 return 
i
;

336 } else if (
arp_table
[
i
].
ctime
 >= 
age_stable
) {

337 
old_stable
 = 
i
;

338 
age_stable
 = 
arp_table
[
i
].
ctime
;

345 if (((
empty
 == 
ARP_TABLE_SIZE
) && ((
flags
 & 
ETHARP_TRY_HARD
) == 0))

347 || ((
flags
 & 
ETHARP_FIND_ONLY
) != 0)) {

348 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("find_entry: no empty entry found and not allowed to recycle\n"));

349 return (
s8_t
)
ERR_MEM
;

362 if (
empty
 < 
ARP_TABLE_SIZE
) {

363 
i
 = 
empty
;

364 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("find_entry: selecting empty entry %"
U16_F
"\n", (
u16_t
)
i
));

367 else if (
old_stable
 < 
ARP_TABLE_SIZE
) {

369 
i
 = 
old_stable
;

370 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("find_entry: selecting oldest stable entry %"
U16_F
"\n", (
u16_t
)
i
));

371 #if 
ARP_QUEUEING


373 
	`LWIP_ASSERT
("arp_table[i].q == NULL", 
arp_table
[
i
].
q
 == 
NULL
);

376 } else if (
old_pending
 < 
ARP_TABLE_SIZE
) {

378 
i
 = 
old_pending
;

379 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("find_entry: selecting oldest pending entry %"
U16_F
" (without queue)\n", (
u16_t
)
i
));

380 #if 
ARP_QUEUEING


382 } else if (
old_queue
 < 
ARP_TABLE_SIZE
) {

384 
i
 = 
old_queue
;

385 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("find_entry: selecting oldest pending entry %"
U16_F
", freeing packet queue %p\n", (
u16_t
)
i
, (void *)(
arp_table
[i].
q
)));

386 
	`free_etharp_q
(
arp_table
[
i
].
q
);

387 
arp_table
[
i
].
q
 = 
NULL
;

391 return (
s8_t
)
ERR_MEM
;

395 
	`LWIP_ASSERT
("i < ARP_TABLE_SIZE", 
i
 < 
ARP_TABLE_SIZE
);

397 if (
arp_table
[
i
].
state
 != 
ETHARP_STATE_EMPTY
)

399 
	`snmp_delete_arpidx_tree
(
arp_table
[
i
].
netif
, &arp_table[i].
ipaddr
);

402 
arp_table
[
i
].
state
 = 
ETHARP_STATE_EMPTY
;

405 if (
ipaddr
 != 
NULL
) {

407 
	`ip_addr_set
(&
arp_table
[
i
].
ipaddr
, ipaddr);

409 
arp_table
[
i
].
ctime
 = 0;

410 #if 
LWIP_NETIF_HWADDRHINT


411 
	`NETIF_SET_HINT
(
netif
, 
i
);

413 
etharp_cached_entry
 = 
i
;

415 return (
err_t
)
i
;

416 
	}
}

428 static 
err_t


429 
	$etharp_send_ip
(struct 
netif
 *netif, struct 
pbuf
 *
p
, struct 
eth_addr
 *
src
, struct eth_addr *
dst
)

431 struct 
eth_hdr
 *
ethhdr
 = 
p
->
payload
;

432 
u8_t
 
k
;

434 
	`LWIP_ASSERT
("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",

435 (
netif
->
hwaddr_len
 == 
ETHARP_HWADDR_LEN
));

436 
k
 = 
ETHARP_HWADDR_LEN
;

437 while(
k
 > 0) {

438 
k
--;

439 
ethhdr
->
dest
.
addr
[
k
] = 
dst
->addr[k];

440 
ethhdr
->
src
.
addr
[
k
] = src->addr[k];

442 
ethhdr
->
type
 = 
	`htons
(
ETHTYPE_IP
);

443 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_send_ip: sending packet %p\n", (void *)
p
));

445 return 
netif
->
	`linkoutput
(netif, 
p
);

446 
	}
}

467 static 
err_t


468 
	$update_arp_entry
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
, struct 
eth_addr
 *
ethaddr
, 
u8_t
 
flags
)

470 
s8_t
 
i
;

471 
u8_t
 
k
;

472 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
 | 3, ("update_arp_entry()\n"));

473 
	`LWIP_ASSERT
("netif->hwaddr_len == ETHARP_HWADDR_LEN", 
netif
->
hwaddr_len
 == 
ETHARP_HWADDR_LEN
);

474 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("update_arp_entry: %"
U16_F
".%"U16_F".%"U16_F".%"U16_F" - %02"
X16_F
":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",

475 
	`ip4_addr1
(
ipaddr
), 
	`ip4_addr2
(ipaddr), 
	`ip4_addr3
(ipaddr), 
	`ip4_addr4
(ipaddr),

476 
ethaddr
->
addr
[0], ethaddr->addr[1], ethaddr->addr[2],

477 
ethaddr
->
addr
[3], ethaddr->addr[4], ethaddr->addr[5]));

479 if (
	`ip_addr_isany
(
ipaddr
) ||

480 
	`ip_addr_isbroadcast
(
ipaddr
, 
netif
) ||

481 
	`ip_addr_ismulticast
(
ipaddr
)) {

482 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));

483 return 
ERR_ARG
;

486 #if 
LWIP_NETIF_HWADDRHINT


487 
i
 = 
	`find_entry
(
ipaddr
, 
flags
, 
netif
);

489 
i
 = 
	`find_entry
(
ipaddr
, 
flags
);

492 if (
i
 < 0)

493 return (
err_t
)
i
;

496 
arp_table
[
i
].
state
 = 
ETHARP_STATE_STABLE
;

498 
arp_table
[
i
].
netif
 = netif;

501 
	`snmp_insert_arpidx_tree
(
netif
, &
arp_table
[
i
].
ipaddr
);

503 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("update_arp_entry: updating stable entry %"
S16_F
"\n", (
s16_t
)
i
));

505 
k
 = 
ETHARP_HWADDR_LEN
;

506 while (
k
 > 0) {

507 
k
--;

508 
arp_table
[
i
].
ethaddr
.
addr
[
k
] = ethaddr->addr[k];

511 
arp_table
[
i
].
ctime
 = 0;

512 #if 
ARP_QUEUEING


514 while (
arp_table
[
i
].
q
 != 
NULL
) {

515 struct 
pbuf
 *
p
;

517 struct 
etharp_q_entry
 *
q
 = 
arp_table
[
i
].q;

519 
arp_table
[
i
].
q
 = q->
next
;

521 
p
 = 
q
->p;

523 
	`memp_free
(
MEMP_ARP_QUEUE
, 
q
);

525 
	`etharp_send_ip
(
netif
, 
p
, (struct 
eth_addr
*)(netif->
hwaddr
), 
ethaddr
);

527 
	`pbuf_free
(
p
);

530 return 
ERR_OK
;

531 
	}
}

544 
s8_t


545 
	$etharp_find_addr
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
,

546 struct 
eth_addr
 **
eth_ret
, struct 
ip_addr
 **
ip_ret
)

548 
s8_t
 
i
;

550 
	`LWIP_UNUSED_ARG
(
netif
);

552 #if 
LWIP_NETIF_HWADDRHINT


553 
i
 = 
	`find_entry
(
ipaddr
, 
ETHARP_FIND_ONLY
, 
NULL
);

555 
i
 = 
	`find_entry
(
ipaddr
, 
ETHARP_FIND_ONLY
);

557 if((
i
 >= 0) && 
arp_table
[i].
state
 == 
ETHARP_STATE_STABLE
) {

558 *
eth_ret
 = &
arp_table
[
i
].
ethaddr
;

559 *
ip_ret
 = &
arp_table
[
i
].
ipaddr
;

560 return 
i
;

563 
	}
}

581 
	$etharp_ip_input
(struct 
netif
 *netif, struct 
pbuf
 *
p
)

583 struct 
ethip_hdr
 *
hdr
;

584 
	`LWIP_ERROR
("netif != NULL", (
netif
 != 
NULL
), return;);

587 
hdr
 = 
p
->
payload
;

589 if (!
	`ip_addr_netcmp
(&(
hdr
->
ip
.
src
), &(
netif
->
ip_addr
), &(netif->
netmask
))) {

594 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_ip_input: updating ETHARP table.\n"));

598 
	`update_arp_entry
(
netif
, &(
hdr
->
ip
.
src
), &(hdr->
eth
.src), 0);

599 
	}
}

618 
	$etharp_arp_input
(struct 
netif
 *netif, struct 
eth_addr
 *
ethaddr
, struct 
pbuf
 *
p
)

620 struct 
etharp_hdr
 *
hdr
;

622 struct 
ip_addr
 
sipaddr
, 
dipaddr
;

623 
u8_t
 
i
;

624 
u8_t
 
for_us
;

625 #if 
LWIP_AUTOIP


626 const 
u8_t
 * 
ethdst_hwaddr
;

629 
	`LWIP_ERROR
("netif != NULL", (
netif
 != 
NULL
), return;);

633 if (
p
->
len
 < sizeof(struct 
etharp_hdr
)) {

634 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1, ("etharp_arp_input: packet dropped, too short (%"
S16_F
"/%"S16_F")\n", 
p
->
tot_len
, (
s16_t
)sizeof(struct 
etharp_hdr
)));

635 
	`ETHARP_STATS_INC
(
etharp
.
lenerr
);

636 
	`ETHARP_STATS_INC
(
etharp
.
drop
);

637 
	`pbuf_free
(
p
);

641 
hdr
 = 
p
->
payload
;

644 if ((
hdr
->
hwtype
 != 
	`htons
(
HWTYPE_ETHERNET
)) ||

645 (
hdr
->
_hwlen_protolen
 != 
	`htons
((
ETHARP_HWADDR_LEN
 << 8) | sizeof(struct 
ip_addr
))) ||

646 (
hdr
->
proto
 != 
	`htons
(
ETHTYPE_IP
)) ||

647 (
hdr
->
ethhdr
.
type
 != 
	`htons
(
ETHTYPE_ARP
))) {

648 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
 | 1,

649 ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"
U16_F
"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",

650 
hdr
->
hwtype
, 
	`ARPH_HWLEN
(hdr), hdr->
proto
, 
	`ARPH_PROTOLEN
(hdr), hdr->
ethhdr
.
type
));

651 
	`ETHARP_STATS_INC
(
etharp
.
proterr
);

652 
	`ETHARP_STATS_INC
(
etharp
.
drop
);

653 
	`pbuf_free
(
p
);

656 
	`ETHARP_STATS_INC
(
etharp
.
recv
);

658 #if 
LWIP_AUTOIP


662 
	`autoip_arp_reply
(
netif
, 
hdr
);

667 
	`SMEMCPY
(&
sipaddr
, &
hdr
->sipaddr, sizeof(sipaddr));

668 
	`SMEMCPY
(&
dipaddr
, &
hdr
->dipaddr, sizeof(dipaddr));

671 if (
netif
->
ip_addr
.
addr
 == 0) {

672 
for_us
 = 0;

675 
for_us
 = 
	`ip_addr_cmp
(&
dipaddr
, &(
netif
->
ip_addr
));

679 if (
for_us
) {

682 
	`update_arp_entry
(
netif
, &
sipaddr
, &(
hdr
->
shwaddr
), 
ETHARP_TRY_HARD
);

686 
	`update_arp_entry
(
netif
, &
sipaddr
, &(
hdr
->
shwaddr
), 0);

690 switch (
	`htons
(
hdr
->
opcode
)) {

692 case 
ARP_REQUEST
:

697 
	`LWIP_DEBUGF
 (
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_arp_input: incoming ARP request\n"));

699 if (
for_us
) {

701 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_arp_input: replying to ARP request for our IP address\n"));

705 
hdr
->
opcode
 = 
	`htons
(
ARP_REPLY
);

707 
hdr
->
dipaddr
 = hdr->
sipaddr
;

708 
hdr
->
sipaddr
 = *(struct 
ip_addr2
 *)&
netif
->
ip_addr
;

710 
	`LWIP_ASSERT
("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",

711 (
netif
->
hwaddr_len
 == 
ETHARP_HWADDR_LEN
));

712 
i
 = 
ETHARP_HWADDR_LEN
;

713 #if 
LWIP_AUTOIP


716 
ethdst_hwaddr
 = ((
netif
->
autoip
 != 
NULL
) && (netif->autoip->
state
 != 
AUTOIP_STATE_OFF
)) ? (
u8_t
*)(
ethbroadcast
.
addr
) : 
hdr
->
shwaddr
.addr;

719 while(
i
 > 0) {

720 
i
--;

721 
hdr
->
dhwaddr
.
addr
[
i
] = hdr->
shwaddr
.addr[i];

722 #if 
LWIP_AUTOIP


723 
hdr
->
ethhdr
.
dest
.
addr
[
i
] = 
ethdst_hwaddr
[i];

725 
hdr
->
ethhdr
.
dest
.
addr
[
i
] = hdr->
shwaddr
.addr[i];

727 
hdr
->
shwaddr
.
addr
[
i
] = 
ethaddr
->addr[i];

728 
hdr
->
ethhdr
.
src
.
addr
[
i
] = 
ethaddr
->addr[i];

735 
netif
->
	`linkoutput
(netif, 
p
);

737 } else if (
netif
->
ip_addr
.
addr
 == 0) {

739 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));

743 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_arp_input: ARP request was not for us.\n"));

746 case 
ARP_REPLY
:

748 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_arp_input: incoming ARP reply\n"));

749 #if (
LWIP_DHCP
 && 
DHCP_DOES_ARP_CHECK
)

754 
	`dhcp_arp_reply
(
netif
, &
sipaddr
);

758 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_arp_input: ARP unknown opcode type %"
S16_F
"\n", 
	`htons
(
hdr
->
opcode
)));

759 
	`ETHARP_STATS_INC
(
etharp
.
err
);

763 
	`pbuf_free
(
p
);

764 
	}
}

784 
err_t


785 
	$etharp_output
(struct 
netif
 *netif, struct 
pbuf
 *
q
, struct 
ip_addr
 *
ipaddr
)

787 struct 
eth_addr
 *
dest
, 
mcastaddr
;

790 if (
	`pbuf_header
(
q
, sizeof(struct 
eth_hdr
)) != 0) {

792 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("etharp_output: could not allocate room for header.\n"));

793 
	`LINK_STATS_INC
(
link
.
lenerr
);

794 return 
ERR_BUF
;

798 
dest
 = 
NULL
;

803 if (
	`ip_addr_isbroadcast
(
ipaddr
, 
netif
)) {

805 
dest
 = (struct 
eth_addr
 *)&
ethbroadcast
;

807 } else if (
	`ip_addr_ismulticast
(
ipaddr
)) {

809 
mcastaddr
.
addr
[0] = 0x01;

810 
mcastaddr
.
addr
[1] = 0x00;

811 
mcastaddr
.
addr
[2] = 0x5e;

812 
mcastaddr
.
addr
[3] = 
	`ip4_addr2
(
ipaddr
) & 0x7f;

813 
mcastaddr
.
addr
[4] = 
	`ip4_addr3
(
ipaddr
);

814 
mcastaddr
.
addr
[5] = 
	`ip4_addr4
(
ipaddr
);

816 
dest
 = &
mcastaddr
;

820 if (!
	`ip_addr_netcmp
(
ipaddr
, &(
netif
->
ip_addr
), &(netif->
netmask
))) {

822 if (
netif
->
gw
.
addr
 != 0) {

824 
ipaddr
 = &(
netif
->
gw
);

828 return 
ERR_RTE
;

832 return 
	`etharp_query
(
netif
, 
ipaddr
, 
q
);

838 return 
	`etharp_send_ip
(
netif
, 
q
, (struct 
eth_addr
*)(netif->
hwaddr
), 
dest
);

839 
	}
}

874 
err_t


875 
	$etharp_query
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
, struct 
pbuf
 *
q
)

877 struct 
eth_addr
 * 
srcaddr
 = (struct eth_addr *)
netif
->
hwaddr
;

878 
err_t
 
result
 = 
ERR_MEM
;

879 
s8_t
 
i
;

882 if (
	`ip_addr_isbroadcast
(
ipaddr
, 
netif
) ||

883 
	`ip_addr_ismulticast
(
ipaddr
) ||

884 
	`ip_addr_isany
(
ipaddr
)) {

885 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));

886 return 
ERR_ARG
;

890 #if 
LWIP_NETIF_HWADDRHINT


891 
i
 = 
	`find_entry
(
ipaddr
, 
ETHARP_TRY_HARD
, 
netif
);

893 
i
 = 
	`find_entry
(
ipaddr
, 
ETHARP_TRY_HARD
);

897 if (
i
 < 0) {

898 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_query: could not create ARP entry\n"));

899 if (
q
) {

900 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_query: packet dropped\n"));

901 
	`ETHARP_STATS_INC
(
etharp
.
memerr
);

903 return (
err_t
)
i
;

907 if (
arp_table
[
i
].
state
 == 
ETHARP_STATE_EMPTY
) {

908 
arp_table
[
i
].
state
 = 
ETHARP_STATE_PENDING
;

912 
	`LWIP_ASSERT
("arp_table[i].state == PENDING or STABLE",

913 ((
arp_table
[
i
].
state
 == 
ETHARP_STATE_PENDING
) ||

914 (
arp_table
[
i
].
state
 == 
ETHARP_STATE_STABLE
)));

917 if ((
arp_table
[
i
].
state
 == 
ETHARP_STATE_PENDING
) || (
q
 == 
NULL
)) {

919 
result
 = 
	`etharp_request
(
netif
, 
ipaddr
);

920 if (
result
 != 
ERR_OK
) {

929 if (
q
 != 
NULL
) {

931 if (
arp_table
[
i
].
state
 == 
ETHARP_STATE_STABLE
) {

934 
result
 = 
	`etharp_send_ip
(
netif
, 
q
, 
srcaddr
, &(
arp_table
[
i
].
ethaddr
));

936 } else if (
arp_table
[
i
].
state
 == 
ETHARP_STATE_PENDING
) {

937 #if 
ARP_QUEUEING


938 struct 
pbuf
 *
p
;

939 int 
copy_needed
 = 0;

943 
p
 = 
q
;

944 while (
p
) {

945 
	`LWIP_ASSERT
("no packet queues allowed!", (
p
->
len
 != p->
tot_len
) || (p->
next
 == 0));

946 if(
p
->
type
 != 
PBUF_ROM
) {

947 
copy_needed
 = 1;

950 
p
 = p->
next
;

952 if(
copy_needed
) {

954 
p
 = 
	`pbuf_alloc
(
PBUF_RAW
, p->
tot_len
, 
PBUF_RAM
);

955 if(
p
 != 
NULL
) {

956 if (
	`pbuf_copy
(
p
, 
q
) != 
ERR_OK
) {

957 
	`pbuf_free
(
p
);

958 
p
 = 
NULL
;

963 
p
 = 
q
;

964 
	`pbuf_ref
(
p
);

967 if (
p
 != 
NULL
) {

969 struct 
etharp_q_entry
 *
new_entry
;

971 
new_entry
 = 
	`memp_malloc
(
MEMP_ARP_QUEUE
);

972 if (
new_entry
 != 
NULL
) {

973 
new_entry
->
next
 = 0;

974 
new_entry
->
p
 = p;

975 if(
arp_table
[
i
].
q
 != 
NULL
) {

977 struct 
etharp_q_entry
 *
r
;

978 
r
 = 
arp_table
[
i
].
q
;

979 while (
r
->
next
 != 
NULL
) {

980 
r
 = r->
next
;

982 
r
->
next
 = 
new_entry
;

985 
arp_table
[
i
].
q
 = 
new_entry
;

987 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_query: queued packet %p on ARP entry %"
S16_F
"\n", (void *)
q
, (
s16_t
)
i
));

988 
result
 = 
ERR_OK
;

991 
	`pbuf_free
(
p
);

992 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)
q
));

996 
	`ETHARP_STATS_INC
(
etharp
.
memerr
);

997 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)
q
));

1003 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)
q
));

1007 return 
result
;

1008 
	}
}

1025 #if !
LWIP_AUTOIP


1028 
err_t


1029 
	$etharp_raw
(struct 
netif
 *netif, const struct 
eth_addr
 *
ethsrc_addr
,

1030 const struct 
eth_addr
 *
ethdst_addr
,

1031 const struct 
eth_addr
 *
hwsrc_addr
, const struct 
ip_addr
 *
ipsrc_addr
,

1032 const struct 
eth_addr
 *
hwdst_addr
, const struct 
ip_addr
 *
ipdst_addr
,

1033 const 
u16_t
 
opcode
)

1035 struct 
pbuf
 *
p
;

1036 
err_t
 
result
 = 
ERR_OK
;

1037 
u8_t
 
k
;

1038 struct 
etharp_hdr
 *
hdr
;

1039 #if 
LWIP_AUTOIP


1040 const 
u8_t
 * 
ethdst_hwaddr
;

1044 
p
 = 
	`pbuf_alloc
(
PBUF_LINK
, sizeof(struct 
etharp_hdr
), 
PBUF_RAM
);

1046 if (
p
 == 
NULL
) {

1047 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
 | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));

1048 
	`ETHARP_STATS_INC
(
etharp
.
memerr
);

1049 return 
ERR_MEM
;

1051 
	`LWIP_ASSERT
("check that first pbuf can hold struct etharp_hdr",

1052 (
p
->
len
 >= sizeof(struct 
etharp_hdr
)));

1054 
hdr
 = 
p
->
payload
;

1055 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_raw: sending raw ARP packet.\n"));

1056 
hdr
->
opcode
 = 
	`htons
(opcode);

1058 
	`LWIP_ASSERT
("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",

1059 (
netif
->
hwaddr_len
 == 
ETHARP_HWADDR_LEN
));

1060 
k
 = 
ETHARP_HWADDR_LEN
;

1061 #if 
LWIP_AUTOIP


1064 
ethdst_hwaddr
 = ((
netif
->
autoip
 != 
NULL
) && (netif->autoip->
state
 != 
AUTOIP_STATE_OFF
)) ? (
u8_t
*)(
ethbroadcast
.
addr
) : 
ethdst_addr
->addr;

1067 while(
k
 > 0) {

1068 
k
--;

1070 
hdr
->
shwaddr
.
addr
[
k
] = 
hwsrc_addr
->addr[k];

1071 
hdr
->
dhwaddr
.
addr
[
k
] = 
hwdst_addr
->addr[k];

1073 #if 
LWIP_AUTOIP


1074 
hdr
->
ethhdr
.
dest
.
addr
[
k
] = 
ethdst_hwaddr
[k];

1076 
hdr
->
ethhdr
.
dest
.
addr
[
k
] = 
ethdst_addr
->addr[k];

1078 
hdr
->
ethhdr
.
src
.
addr
[
k
] = 
ethsrc_addr
->addr[k];

1080 
hdr
->
sipaddr
 = *(struct 
ip_addr2
 *)
ipsrc_addr
;

1081 
hdr
->
dipaddr
 = *(struct 
ip_addr2
 *)
ipdst_addr
;

1083 
hdr
->
hwtype
 = 
	`htons
(
HWTYPE_ETHERNET
);

1084 
hdr
->
proto
 = 
	`htons
(
ETHTYPE_IP
);

1086 
hdr
->
_hwlen_protolen
 = 
	`htons
((
ETHARP_HWADDR_LEN
 << 8) | sizeof(struct 
ip_addr
));

1088 
hdr
->
ethhdr
.
type
 = 
	`htons
(
ETHTYPE_ARP
);

1090 
result
 = 
netif
->
	`linkoutput
(netif, 
p
);

1091 
	`ETHARP_STATS_INC
(
etharp
.
xmit
);

1093 
	`pbuf_free
(
p
);

1094 
p
 = 
NULL
;

1097 return 
result
;

1098 
	}
}

1109 
err_t


1110 
	$etharp_request
(struct 
netif
 *netif, struct 
ip_addr
 *
ipaddr
)

1112 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
, ("etharp_request: sending ARP request.\n"));

1113 return 
	`etharp_raw
(
netif
, (struct 
eth_addr
 *)netif->
hwaddr
, &
ethbroadcast
,

1114 (struct 
eth_addr
 *)
netif
->
hwaddr
, &netif->
ip_addr
, &
ethzero
,

1115 
ipaddr
, 
ARP_REQUEST
);

1116 
	}
}

1126 
err_t


1127 
	$ethernet_input
(struct 
pbuf
 *
p
, struct 
netif
 *netif)

1129 struct 
eth_hdr
* 
ethhdr
;

1132 
ethhdr
 = 
p
->
payload
;

1133 
	`LWIP_DEBUGF
(
ETHARP_DEBUG
 | 
LWIP_DBG_TRACE
,

1135 (unsigned)
ethhdr
->
dest
.
addr
[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],

1136 (unsigned)
ethhdr
->
dest
.
addr
[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],

1137 (unsigned)
ethhdr
->
src
.
addr
[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],

1138 (unsigned)
ethhdr
->
src
.
addr
[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],

1139 (unsigned)
	`htons
(
ethhdr
->
type
)));

1141 switch (
	`htons
(
ethhdr
->
type
)) {

1143 case 
ETHTYPE_IP
:

1144 #if 
ETHARP_TRUST_IP_MAC


1146 
	`etharp_ip_input
(
netif
, 
p
);

1149 if(
	`pbuf_header
(
p
, -(
s16_t
)sizeof(struct 
eth_hdr
))) {

1150 
	`LWIP_ASSERT
("Can't move over header in packet", 0);

1151 
	`pbuf_free
(
p
);

1152 
p
 = 
NULL
;

1155 
	`ip_input
(
p
, 
netif
);

1159 case 
ETHTYPE_ARP
:

1161 
	`etharp_arp_input
(
netif
, (struct 
eth_addr
*)(netif->
hwaddr
), 
p
);

1164 #if 
PPPOE_SUPPORT


1165 case 
ETHTYPE_PPPOEDISC
:

1166 
	`pppoe_disc_input
(
netif
, 
p
);

1169 case 
ETHTYPE_PPPOE
:

1170 
	`pppoe_data_input
(
netif
, 
p
);

1175 
	`ETHARP_STATS_INC
(
etharp
.
proterr
);

1176 
	`ETHARP_STATS_INC
(
etharp
.
drop
);

1177 
	`pbuf_free
(
p
);

1178 
p
 = 
NULL
;

1184 return 
ERR_OK
;

1185 
	}
}

	@/root/Robux/net/lwip/netif/ethernetif.c

46 #include 
	~"lwip/opt.h
"

50 #include 
	~"lwip/def.h
"

51 #include 
	~"lwip/mem.h
"

52 #include 
	~"lwip/pbuf.h
"

53 #include 
	~"lwip/sys.h
"

54 #include 
	~<lwip/stats.h
>

55 #include 
	~<lwip/snmp.h
>

56 #include 
	~"netif/etharp.h
"

57 #include 
	~"netif/ppp_oe.h
"

60 #define 
	#IFNAME0
 'e'

	)

61 #define 
	#IFNAME1
 'n'

	)

69 struct 
	sethernetif
 {

70 struct 
eth_addr
 *
	methaddr
;

75 static void 
ethernetif_input
(struct 
netif
 *netif);

85 
	$low_level_init
(struct 
netif
 *netif)

87 struct 
ethernetif
 *ethernetif = 
netif
->
state
;

90 
netif
->
hwaddr_len
 = 
ETHARP_HWADDR_LEN
;

93 
netif
->
hwaddr
[0] = ;

95 
netif
->
hwaddr
[5] = ;

98 
netif
->
mtu
 = 1500;

102 
netif
->
flags
 = 
NETIF_FLAG_BROADCAST
 | 
NETIF_FLAG_ETHARP
 | 
NETIF_FLAG_LINK_UP
;

105 
	}
}

123 static 
err_t


124 
	$low_level_output
(struct 
netif
 *netif, struct 
pbuf
 *
p
)

126 struct 
ethernetif
 *ethernetif = 
netif
->
state
;

127 struct 
pbuf
 *
q
;

129 
initiate
 
	`transfer
();

131 #if 
ETH_PAD_SIZE


132 
	`pbuf_header
(
p
, -
ETH_PAD_SIZE
);

135 for(
q
 = 
p
; q != 
NULL
; q = q->
next
) {

139 
send
 
data
 
	`from
(
q
->
payload
, q->
len
);

142 
signal
 
that
 
packet
 
should
 
be
 
	`sent
();

144 #if 
ETH_PAD_SIZE


145 
	`pbuf_header
(
p
, 
ETH_PAD_SIZE
);

148 
	`LINK_STATS_INC
(
link
.
xmit
);

150 return 
ERR_OK
;

151 
	}
}

161 static struct 
pbuf
 *

162 
	$low_level_input
(struct 
netif
 *netif)

164 struct 
ethernetif
 *ethernetif = 
netif
->
state
;

165 struct 
pbuf
 *
p
, *
q
;

166 
u16_t
 
len
;

170 
len
 = ;

172 #if 
ETH_PAD_SIZE


173 
len
 += 
ETH_PAD_SIZE
;

177 
p
 = 
	`pbuf_alloc
(
PBUF_RAW
, 
len
, 
PBUF_POOL
);

179 if (
p
 != 
NULL
) {

181 #if 
ETH_PAD_SIZE


182 
	`pbuf_header
(
p
, -
ETH_PAD_SIZE
);

187 for(
q
 = 
p
; q != 
NULL
; q = q->
next
) {

191 
read
 
data
 
	`into
(
q
->
payload
, q->
len
);

193 
acknowledge
 
that
 
packet
 
has
 
been
 
	`read
();

195 #if 
ETH_PAD_SIZE


196 
	`pbuf_header
(
p
, 
ETH_PAD_SIZE
);

199 
	`LINK_STATS_INC
(
link
.
recv
);

201 
drop
 
	`packet
();

202 
	`LINK_STATS_INC
(
link
.
memerr
);

203 
	`LINK_STATS_INC
(
link
.
drop
);

206 return 
p
;

207 
	}
}

219 
	$ethernetif_input
(struct 
netif
 *netif)

221 struct 
ethernetif
 *ethernetif;

222 struct 
eth_hdr
 *
ethhdr
;

223 struct 
pbuf
 *
p
;

225 
ethernetif
 = 
netif
->
state
;

228 
p
 = 
	`low_level_input
(
netif
);

230 if (
p
 == 
NULL
) return;

232 
ethhdr
 = 
p
->
payload
;

234 switch (
	`htons
(
ethhdr
->
type
)) {

236 case 
ETHTYPE_IP
:

237 case 
ETHTYPE_ARP
:

238 #if 
PPPOE_SUPPORT


240 case 
ETHTYPE_PPPOEDISC
:

241 case 
ETHTYPE_PPPOE
:

244 if (
netif
->
	`input
(
p
, netif)!=
ERR_OK
)

245 { 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("ethernetif_input: IP input error\n"));

246 
	`pbuf_free
(
p
);

247 
p
 = 
NULL
;

252 
	`pbuf_free
(
p
);

253 
p
 = 
NULL
;

256 
	}
}

270 
err_t


271 
	$ethernetif_init
(struct 
netif
 *netif)

273 struct 
ethernetif
 *ethernetif;

275 
	`LWIP_ASSERT
("netif != NULL", (
netif
 != 
NULL
));

277 
ethernetif
 = 
	`mem_malloc
(sizeof(struct ethernetif));

278 if (
ethernetif
 == 
NULL
) {

279 
	`LWIP_DEBUGF
(
NETIF_DEBUG
, ("ethernetif_init: out of memory\n"));

280 return 
ERR_MEM
;

283 #if 
LWIP_NETIF_HOSTNAME


285 
netif
->
hostname
 = "lwip";

293 
	`NETIF_INIT_SNMP
(
netif
, 
snmp_ifType_ethernet_csmacd
, ???);

295 
netif
->
state
 = 
ethernetif
;

296 
netif
->
name
[0] = 
IFNAME0
;

297 
netif
->
name
[1] = 
IFNAME1
;

302 
netif
->
output
 = 
etharp_output
;

303 
netif
->
linkoutput
 = 
low_level_output
;

305 
ethernetif
->
ethaddr
 = (struct 
eth_addr
 *)&(
netif
->
hwaddr
[0]);

308 
	`low_level_init
(
netif
);

310 return 
ERR_OK
;

311 
	}
}

	@/root/Robux/net/lwip/netif/loopif.c

38 #include 
	~"lwip/opt.h
"

40 #if 
LWIP_HAVE_LOOPIF


42 #include 
	~"netif/loopif.h
"

43 #include 
	~"lwip/snmp.h
"

52 
err_t


53 
	$loopif_init
(struct 
netif
 *netif)

58 
	`NETIF_INIT_SNMP
(
netif
, 
snmp_ifType_softwareLoopback
, 0);

60 
netif
->
name
[0] = 'l';

61 
netif
->
name
[1] = 'o';

62 
netif
->
output
 = 
netif_loop_output
;

63 return 
ERR_OK
;

64 
	}
}

	@/root/Robux/net/lwip/netif/ppp/auth.c

67 #include 
	~"lwip/opt.h
"

69 #if 
PPP_SUPPORT


71 #include 
	~"ppp.h
"

72 #include 
	~"pppdebug.h
"

74 #include 
	~"fsm.h
"

75 #include 
	~"lcp.h
"

76 #include 
	~"pap.h
"

77 #include 
	~"chap.h
"

78 #include 
	~"auth.h
"

79 #include 
	~"ipcp.h
"

81 #if 
CBCP_SUPPORT


82 #include 
	~"cbcp.h
"

90 #define 
	#PAP_WITHPEER
 1

	)

91 #define 
	#PAP_PEER
 2

	)

92 #define 
	#CHAP_WITHPEER
 4

	)

93 #define 
	#CHAP_PEER
 8

	)

100 struct 
	swordlist
 {

101 struct 
wordlist
 *
	mnext
;

102 char 
	mword
[1];

109 extern char *
crypt
 (const char *, const char *);

113 static void 
network_phase
 (int);

114 static void 
check_idle
 (void *);

115 static void 
connect_time_expired
 (void *);

117 static int 
login
 (char *, char *, char **, int *);

119 static void 
logout
 (void);

120 static int 
null_login
 (int);

121 static int 
get_pap_passwd
 (int, char *, char *);

122 static int 
have_pap_secret
 (void);

123 static int 
have_chap_secret
 (char *, char *, 
u32_t
);

124 static int 
ip_addr_check
 (
u32_t
, struct 
wordlist
 *);

126 static void 
set_allowed_addrs
(int 
unit
, struct 
wordlist
 *
addrs
);

127 static void 
free_wordlist
 (struct 
wordlist
 *);

129 #if 
CBCP_SUPPORT


130 static void 
callback_phase
 (int);

142 #if 
PAP_SUPPORT
 || 
CHAP_SUPPORT


144 static char 
	gpeer_authname
[
MAXNAMELEN
];

148 static int 
	gauth_pending
[
NUM_PPP
];

151 static int 
	glogged_in
;

154 static int 
	gdid_authup
;

157 static struct 
wordlist
 *
	gaddresses
[
NUM_PPP
];

160 static int 
	gnum_np_open
;

163 static int 
	gnum_np_up
;

165 #if 
PAP_SUPPORT
 || 
CHAP_SUPPORT


167 static int 
	gpasswd_from_file
;

179 
	$link_required
(int 
unit
)

181 
	`LWIP_UNUSED_ARG
(
unit
);

183 
	`AUTHDEBUG
((
LOG_INFO
, "link_required: %d\n", 
unit
));

184 
	}
}

191 
	$link_terminated
(int 
unit
)

193 
	`AUTHDEBUG
((
LOG_INFO
, "link_terminated: %d\n", 
unit
));

194 if (
lcp_phase
[
unit
] == 
PHASE_DEAD
) {

197 if (
logged_in
) {

198 
	`logout
();

200 
lcp_phase
[
unit
] = 
PHASE_DEAD
;

201 
	`AUTHDEBUG
((
LOG_NOTICE
, "Connection terminated.\n"));

202 
	`pppLinkTerminated
(
unit
);

203 
	}
}

209 
	$link_down
(int 
unit
)

211 int 
i
;

212 struct 
protent
 *
protp
;

214 
	`AUTHDEBUG
((
LOG_INFO
, "link_down: %d\n", 
unit
));

215 if (
did_authup
) {

217 
did_authup
 = 0;

219 for (
i
 = 0; (
protp
 = 
ppp_protocols
[i]) != 
NULL
; ++i) {

220 if (!
protp
->
enabled_flag
) {

223 if (
protp
->
protocol
 != 
PPP_LCP
 && protp->
lowerdown
 != 
NULL
) {

224 (*
protp
->
lowerdown
)(
unit
);

226 if (
protp
->
protocol
 < 0xC000 && protp->
close
 != 
NULL
) {

227 (*
protp
->
close
)(
unit
, "LCP down");

230 
num_np_open
 = 0;

231 
num_np_up
 = 0;

232 if (
lcp_phase
[
unit
] != 
PHASE_DEAD
) {

233 
lcp_phase
[
unit
] = 
PHASE_TERMINATE
;

235 
	`pppLinkDown
(
unit
);

236 
	}
}

243 
	$link_established
(int 
unit
)

245 int 
auth
;

246 int 
i
;

247 struct 
protent
 *
protp
;

248 
lcp_options
 *
wo
 = &
lcp_wantoptions
[
unit
];

249 
lcp_options
 *
go
 = &
lcp_gotoptions
[
unit
];

250 #if 
PAP_SUPPORT
 || 
CHAP_SUPPORT


251 
lcp_options
 *
ho
 = &
lcp_hisoptions
[
unit
];

254 
	`AUTHDEBUG
((
LOG_INFO
, "link_established: %d\n", 
unit
));

258 for (
i
 = 0; (
protp
 = 
ppp_protocols
[i]) != 
NULL
; ++i) {

259 if (
protp
->
protocol
 != 
PPP_LCP
 && protp->
enabled_flag
 && protp->
lowerup
 != 
NULL
) {

260 (*
protp
->
lowerup
)(
unit
);

263 if (
ppp_settings
.
auth_required
 && !(
go
->
neg_chap
 || go->
neg_upap
)) {

269 if (!
wo
->
neg_upap
 || !
	`null_login
(
unit
)) {

270 
	`AUTHDEBUG
((
LOG_WARNING
, "peer refused to authenticate\n"));

271 
	`lcp_close
(
unit
, "peer refused to authenticate");

276 
lcp_phase
[
unit
] = 
PHASE_AUTHENTICATE
;

277 
auth
 = 0;

278 #if 
CHAP_SUPPORT


279 if (
go
->
neg_chap
) {

280 
	`ChapAuthPeer
(
unit
, 
ppp_settings
.
our_name
, 
go
->
chap_mdtype
);

281 
auth
 |= 
CHAP_PEER
;

284 #if 
PAP_SUPPORT
 && 
CHAP_SUPPORT


287 #if 
PAP_SUPPORT


288 if (
go
->
neg_upap
) {

289 
	`upap_authpeer
(
unit
);

290 
auth
 |= 
PAP_PEER
;

293 #if 
CHAP_SUPPORT


294 if (
ho
->
neg_chap
) {

295 
	`ChapAuthWithPeer
(
unit
, 
ppp_settings
.
user
, 
ho
->
chap_mdtype
);

296 
auth
 |= 
CHAP_WITHPEER
;

299 #if 
PAP_SUPPORT
 && 
CHAP_SUPPORT


302 #if 
PAP_SUPPORT


303 if (
ho
->
neg_upap
) {

304 if (
ppp_settings
.
passwd
[0] == 0) {

305 
passwd_from_file
 = 1;

306 if (!
	`get_pap_passwd
(
unit
, 
ppp_settings
.
user
, ppp_settings.
passwd
)) {

307 
	`AUTHDEBUG
((
LOG_ERR
, "No secret found for PAP login\n"));

310 
	`upap_authwithpeer
(
unit
, 
ppp_settings
.
user
, ppp_settings.
passwd
);

311 
auth
 |= 
PAP_WITHPEER
;

314 
auth_pending
[
unit
] = 
auth
;

316 if (!
auth
) {

317 
	`network_phase
(
unit
);

319 
	}
}

325 
	$auth_peer_fail
(int 
unit
, 
u16_t
 
protocol
)

327 
	`LWIP_UNUSED_ARG
(
protocol
);

329 
	`AUTHDEBUG
((
LOG_INFO
, "auth_peer_fail: %d proto=%X\n", 
unit
, 
protocol
));

333 
	`lcp_close
(
unit
, "Authentication failed");

334 
	}
}

337 #if 
PAP_SUPPORT
 || 
CHAP_SUPPORT


342 
	$auth_peer_success
(int 
unit
, 
u16_t
 
protocol
, char *
name
, int 
namelen
)

344 int 
pbit
;

346 
	`AUTHDEBUG
((
LOG_INFO
, "auth_peer_success: %d proto=%X\n", 
unit
, 
protocol
));

347 switch (
protocol
) {

348 case 
PPP_CHAP
:

349 
pbit
 = 
CHAP_PEER
;

351 case 
PPP_PAP
:

352 
pbit
 = 
PAP_PEER
;

355 
	`AUTHDEBUG
((
LOG_WARNING
, "auth_peer_success: unknown protocol %x\n", 
protocol
));

362 if (
namelen
 > sizeof(
peer_authname
) - 1) {

363 
namelen
 = sizeof(
peer_authname
) - 1;

365 
	`BCOPY
(
name
, 
peer_authname
, 
namelen
);

366 
peer_authname
[
namelen
] = 0;

372 if ((
auth_pending
[
unit
] &= ~
pbit
) == 0) {

373 
	`network_phase
(
unit
);

375 
	}
}

381 
	$auth_withpeer_fail
(int 
unit
, 
u16_t
 
protocol
)

383 int 
errCode
 = 
PPPERR_AUTHFAIL
;

385 
	`LWIP_UNUSED_ARG
(
protocol
);

387 
	`AUTHDEBUG
((
LOG_INFO
, "auth_withpeer_fail: %d proto=%X\n", 
unit
, 
protocol
));

388 if (
passwd_from_file
) {

389 
	`BZERO
(
ppp_settings
.
passwd
, 
MAXSECRETLEN
);

396 
	`pppIOCtl
(
unit
, 
PPPCTLS_ERRCODE
, &
errCode
);

403 
	}
}

409 
	$auth_withpeer_success
(int 
unit
, 
u16_t
 
protocol
)

411 int 
pbit
;

413 
	`AUTHDEBUG
((
LOG_INFO
, "auth_withpeer_success: %d proto=%X\n", 
unit
, 
protocol
));

414 switch (
protocol
) {

415 case 
PPP_CHAP
:

416 
pbit
 = 
CHAP_WITHPEER
;

418 case 
PPP_PAP
:

419 if (
passwd_from_file
) {

420 
	`BZERO
(
ppp_settings
.
passwd
, 
MAXSECRETLEN
);

422 
pbit
 = 
PAP_WITHPEER
;

425 
	`AUTHDEBUG
((
LOG_WARNING
, "auth_peer_success: unknown protocol %x\n", 
protocol
));

426 
pbit
 = 0;

433 if ((
auth_pending
[
unit
] &= ~
pbit
) == 0) {

434 
	`network_phase
(
unit
);

436 
	}
}

444 
	$np_up
(int 
unit
, 
u16_t
 
proto
)

446 
	`LWIP_UNUSED_ARG
(
unit
);

447 
	`LWIP_UNUSED_ARG
(
proto
);

449 
	`AUTHDEBUG
((
LOG_INFO
, "np_up: %d proto=%X\n", 
unit
, 
proto
));

450 if (
num_np_up
 == 0) {

451 
	`AUTHDEBUG
((
LOG_INFO
, "np_up: maxconnect=%d idle_time_limit=%d\n",
ppp_settings
.
maxconnect
,ppp_settings.
idle_time_limit
));

455 if (
ppp_settings
.
idle_time_limit
 > 0) {

456 
	`TIMEOUT
(
check_idle
, 
NULL
, 
ppp_settings
.
idle_time_limit
);

463 if (
ppp_settings
.
maxconnect
 > 0) {

464 
	`TIMEOUT
(
connect_time_expired
, 0, 
ppp_settings
.
maxconnect
);

467 ++
num_np_up
;

468 
	}
}

474 
	$np_down
(int 
unit
, 
u16_t
 
proto
)

476 
	`LWIP_UNUSED_ARG
(
unit
);

477 
	`LWIP_UNUSED_ARG
(
proto
);

479 
	`AUTHDEBUG
((
LOG_INFO
, "np_down: %d proto=%X\n", 
unit
, 
proto
));

480 if (--
num_np_up
 == 0 && 
ppp_settings
.
idle_time_limit
 > 0) {

481 
	`UNTIMEOUT
(
check_idle
, 
NULL
);

483 
	}
}

489 
	$np_finished
(int 
unit
, 
u16_t
 
proto
)

491 
	`LWIP_UNUSED_ARG
(
unit
);

492 
	`LWIP_UNUSED_ARG
(
proto
);

494 
	`AUTHDEBUG
((
LOG_INFO
, "np_finished: %d proto=%X\n", 
unit
, 
proto
));

495 if (--
num_np_open
 <= 0) {

497 
	`lcp_close
(0, "No network protocols running");

499 
	}
}

507 
	$auth_reset
(int 
unit
)

509 
lcp_options
 *
go
 = &
lcp_gotoptions
[
unit
];

510 
lcp_options
 *
ao
 = &
lcp_allowoptions
[0];

511 
ipcp_options
 *
ipwo
 = &
ipcp_wantoptions
[0];

512 
u32_t
 
remote
;

514 
	`AUTHDEBUG
((
LOG_INFO
, "auth_reset: %d\n", 
unit
));

515 
ao
->
neg_upap
 = !
ppp_settings
.
refuse_pap
 && (ppp_settings.
passwd
[0] != 0 || 
	`get_pap_passwd
(
unit
, 
NULL
, NULL));

516 
ao
->
neg_chap
 = !
ppp_settings
.
refuse_chap
 && ppp_settings.
passwd
[0] != 0 ;

518 if (
go
->
neg_upap
 && !
	`have_pap_secret
()) {

519 
go
->
neg_upap
 = 0;

521 if (
go
->
neg_chap
) {

522 
remote
 = 
ipwo
->
accept_remote
? 0: ipwo->
hisaddr
;

523 if (!
	`have_chap_secret
(
ppp_settings
.
remote_name
, ppp_settings.
our_name
, 
remote
)) {

524 
go
->
neg_chap
 = 0;

527 
	}
}

529 #if 
PAP_SUPPORT


541 
	$check_passwd
( int 
unit
, char *
auser
, int 
userlen
, char *
apasswd
, int 
passwdlen
, char **
msg
, int *
msglen
)

544 
	`LWIP_UNUSED_ARG
(
unit
);

545 
	`LWIP_UNUSED_ARG
(
auser
);

546 
	`LWIP_UNUSED_ARG
(
userlen
);

547 
	`LWIP_UNUSED_ARG
(
apasswd
);

548 
	`LWIP_UNUSED_ARG
(
passwdlen
);

549 
	`LWIP_UNUSED_ARG
(
msglen
);

550 *
msg
 = (char *) 0;

551 return 
UPAP_AUTHACK
;

553 int 
ret
 = 0;

554 struct 
wordlist
 *
addrs
 = 
NULL
;

555 char 
passwd
[256], 
user
[256];

556 char 
secret
[
MAXWORDLEN
];

557 static 
u_short
 
attempts
 = 0;

562 
	`BCOPY
(
apasswd
, 
passwd
, 
passwdlen
);

563 
passwd
[
passwdlen
] = '\0';

564 
	`BCOPY
(
auser
, 
user
, 
userlen
);

565 
user
[
userlen
] = '\0';

566 *
msg
 = (char *) 0;

569 
ret
 = 
UPAP_AUTHACK
;

571 if (
ret
 == 
UPAP_AUTHNAK
) {

572 if (*
msg
 == (char *) 0) {

573 *
msg
 = "Login incorrect";

575 *
msglen
 = 
	`strlen
(*
msg
);

581 if (
attempts
++ >= 10) {

582 
	`AUTHDEBUG
((
LOG_WARNING
, "%d LOGIN FAILURES BY %s\n", 
attempts
, 
user
));

585 if (
attempts
 > 3) {

586 
	`sys_msleep
((
attempts
 - 3) * 5);

588 if (
addrs
 != 
NULL
) {

589 
	`free_wordlist
(
addrs
);

592 
attempts
 = 0;

593 if (*
msg
 == (char *) 0) {

594 *
msg
 = "Login ok";

596 *
msglen
 = 
	`strlen
(*
msg
);

597 
	`set_allowed_addrs
(
unit
, 
addrs
);

600 
	`BZERO
(
passwd
, sizeof(passwd));

601 
	`BZERO
(
secret
, sizeof(secret));

603 return 
ret
;

605 
	}
}

614 
	$auth_ip_addr
(int 
unit
, 
u32_t
 
addr
)

616 return 
	`ip_addr_check
(
addr
, 
addresses
[
unit
]);

617 
	}
}

625 
	$bad_ip_adrs
(
u32_t
 
addr
)

627 
addr
 = 
	`ntohl
(addr);

628 return (
addr
 >> 
IN_CLASSA_NSHIFT
) == 
IN_LOOPBACKNET


629 || 
	`IN_MULTICAST
(
addr
) || 
	`IN_BADCLASS
(addr);

630 
	}
}

633 #if 
CHAP_SUPPORT


639 int 
	$get_secret
( int 
unit
, char *
client
, char *
server
, char *
secret
, int *
secret_len
, int 
save_addrs
)

642 int 
len
;

643 struct 
wordlist
 *
addrs
;

645 
	`LWIP_UNUSED_ARG
(
unit
);

646 
	`LWIP_UNUSED_ARG
(
server
);

647 
	`LWIP_UNUSED_ARG
(
save_addrs
);

649 
addrs
 = 
NULL
;

651 if(!
client
 || !client[0] || 
	`strcmp
(client, 
ppp_settings
.
user
)) {

655 
len
 = 
	`strlen
(
ppp_settings
.
passwd
);

656 if (
len
 > 
MAXSECRETLEN
) {

657 
	`AUTHDEBUG
((
LOG_ERR
, "Secret for %s on %s is too long\n", 
client
, 
server
));

658 
len
 = 
MAXSECRETLEN
;

661 
	`BCOPY
(
ppp_settings
.
passwd
, 
secret
, 
len
);

662 *
secret_len
 = 
len
;

666 int 
ret
 = 0, 
len
;

667 struct 
wordlist
 *
addrs
;

668 char 
secbuf
[
MAXWORDLEN
];

670 
addrs
 = 
NULL
;

671 
secbuf
[0] = 0;

674 if (
ret
 < 0) {

678 if (
save_addrs
) {

679 
	`set_allowed_addrs
(
unit
, 
addrs
);

682 
len
 = 
	`strlen
(
secbuf
);

683 if (
len
 > 
MAXSECRETLEN
) {

684 
	`AUTHDEBUG
((
LOG_ERR
, "Secret for %s on %s is too long\n", 
client
, 
server
));

685 
len
 = 
MAXSECRETLEN
;

688 
	`BCOPY
(
secbuf
, 
secret
, 
len
);

689 
	`BZERO
(
secbuf
, sizeof(secbuf));

690 *
secret_len
 = 
len
;

694 
	}
}

703 
	$auth_check_options
(void)

705 
lcp_options
 *
wo
 = &
lcp_wantoptions
[0];

706 int 
can_auth
;

707 
ipcp_options
 *
ipwo
 = &
ipcp_wantoptions
[0];

708 
u32_t
 
remote
;

711 if (
ppp_settings
.
our_name
[0] == 0 || ppp_settings.
usehostname
) {

712 
	`strcpy
(
ppp_settings
.
our_name
, ppp_settings.
hostname
);

715 if (
ppp_settings
.
user
[0] == 0) {

716 
	`strcpy
(
ppp_settings
.
user
, ppp_settings.
our_name
);

720 if (
ppp_settings
.
auth_required
 && !
wo
->
neg_chap
 && !wo->
neg_upap
) {

721 
wo
->
neg_chap
 = 1;

722 
wo
->
neg_upap
 = 1;

729 
can_auth
 = 
wo
->
neg_upap
 && 
	`have_pap_secret
();

730 if (!
can_auth
 && 
wo
->
neg_chap
) {

731 
remote
 = 
ipwo
->
accept_remote
? 0: ipwo->
hisaddr
;

732 
can_auth
 = 
	`have_chap_secret
(
ppp_settings
.
remote_name
, ppp_settings.
our_name
, 
remote
);

735 if (
ppp_settings
.
auth_required
 && !
can_auth
) {

736 
	`ppp_panic
("No auth secret");

738 
	}
}

749 
	$network_phase
(int 
unit
)

751 int 
i
;

752 struct 
protent
 *
protp
;

753 
lcp_options
 *
go
 = &
lcp_gotoptions
[
unit
];

758 if ((
go
->
neg_chap
 || go->
neg_upap
) && !
did_authup
) {

760 
did_authup
 = 1;

763 #if 
CBCP_SUPPORT


767 if (
go
->
neg_cbcp
) {

768 
lcp_phase
[
unit
] = 
PHASE_CALLBACK
;

769 (*
cbcp_protent
.
open
)(
unit
);

774 
lcp_phase
[
unit
] = 
PHASE_NETWORK
;

775 for (
i
 = 0; (
protp
 = 
ppp_protocols
[i]) != 
NULL
; ++i) {

776 if (
protp
->
protocol
 < 0xC000 && protp->
enabled_flag
 && protp->
open
 != 
NULL
) {

777 (*
protp
->
open
)(
unit
);

778 if (
protp
->
protocol
 != 
PPP_CCP
) {

779 ++
num_np_open
;

784 if (
num_np_open
 == 0) {

786 
	`lcp_close
(0, "No network protocols running");

788 
	}
}

795 
	$check_idle
(void *
arg
)

797 struct 
ppp_idle
 
idle
;

798 
u_short
 
itime
;

800 
	`LWIP_UNUSED_ARG
(
arg
);

801 if (!
	`get_idle_time
(0, &
idle
)) {

804 
itime
 = 
	`LWIP_MIN
(
idle
.
xmit_idle
, idle.
recv_idle
);

805 if (
itime
 >= 
ppp_settings
.
idle_time_limit
) {

807 
	`AUTHDEBUG
((
LOG_INFO
, "Terminating connection due to lack of activity.\n"));

808 
	`lcp_close
(0, "Link inactive");

810 
	`TIMEOUT
(
check_idle
, 
NULL
, 
ppp_settings
.
idle_time_limit
 - 
itime
);

812 
	}
}

818 
	$connect_time_expired
(void *
arg
)

820 
	`LWIP_UNUSED_ARG
(
arg
);

822 
	`AUTHDEBUG
((
LOG_INFO
, "Connect time expired\n"));

823 
	`lcp_close
(0, "Connect time expired");

824 
	}
}

837 
	$login
(char *
user
, char *
passwd
, char **
msg
, int *
msglen
)

840 return (
UPAP_AUTHNAK
);

841 
	}
}

848 
	$logout
(void)

850 
logged_in
 = 0;

851 
	}
}

859 
	$null_login
(int 
unit
)

861 
	`LWIP_UNUSED_ARG
(
unit
);

864 
	}
}

872 
	$get_pap_passwd
(int 
unit
, char *
user
, char *
passwd
)

874 
	`LWIP_UNUSED_ARG
(
unit
);

880 if(
user
) {

881 
	`strcpy
(
user
, "none");

883 if(
passwd
) {

884 
	`strcpy
(
passwd
, "none");

887 
	}
}

894 
	$have_pap_secret
(void)

898 
	}
}

907 
	$have_chap_secret
(char *
client
, char *
server
, 
u32_t
 
remote
)

909 
	`LWIP_UNUSED_ARG
(
client
);

910 
	`LWIP_UNUSED_ARG
(
server
);

911 
	`LWIP_UNUSED_ARG
(
remote
);

914 
	}
}

921 
	$set_allowed_addrs
(int 
unit
, struct 
wordlist
 *
addrs
)

923 if (
addresses
[
unit
] != 
NULL
) {

924 
	`free_wordlist
(
addresses
[
unit
]);

926 
addresses
[
unit
] = 
addrs
;

933 if (
addrs
 != 
NULL
 && addrs->
next
 == NULL) {

934 char *
p
 = 
addrs
->
word
;

935 struct 
ipcp_options
 *
wo
 = &
ipcp_wantoptions
[
unit
];

936 
u32_t
 
a
;

937 struct 
hostent
 *
hp
;

939 if (
wo
->
hisaddr
 == 0 && *
p
 != '!' && *p != '-' && 
	`strchr
(p, '/') == 
NULL
) {

940 
hp
 = 
	`gethostbyname
(
p
);

941 if (
hp
 != 
NULL
 && hp->
h_addrtype
 == 
AF_INET
) {

942 
a
 = *(
u32_t
 *)
hp
->
h_addr
;

944 
a
 = 
	`inet_addr
(
p
);

946 if (
a
 != (
u32_t
) -1) {

947 
wo
->
hisaddr
 = 
a
;

952 
	}
}

956 
	$ip_addr_check
(
u32_t
 
addr
, struct 
wordlist
 *
addrs
)

959 if (
	`bad_ip_adrs
(
addr
)) {

963 if (
addrs
 == 
NULL
) {

964 return !
ppp_settings
.
auth_required
;

969 
	}
}

976 
	$free_wordlist
(struct 
wordlist
 *
wp
)

978 struct 
wordlist
 *
next
;

980 while (
wp
 != 
NULL
) {

981 
next
 = 
wp
->next;

982 
	`free
(
wp
);

983 
wp
 = 
next
;

985 
	}
}

	@/root/Robux/net/lwip/netif/ppp/auth.h

53 #ifndef 
AUTH_H


54 #define 
	#AUTH_H


	)

61 void 
link_required
 (int);

64 void 
link_terminated
 (int);

67 void 
link_down
 (int);

70 void 
link_established
 (int);

73 void 
np_up
 (int, 
u16_t
);

76 void 
np_down
 (int, 
u16_t
);

79 void 
np_finished
 (int, 
u16_t
);

82 void 
auth_peer_fail
 (int, 
u16_t
);

85 void 
auth_peer_success
 (int, 
u16_t
, char *, int);

88 void 
auth_withpeer_fail
 (int, 
u16_t
);

91 void 
auth_withpeer_success
 (int, 
u16_t
);

94 void 
auth_check_options
 (void);

97 void 
auth_reset
 (int);

100 int 
check_passwd
 (int, char *, int, char *, int, char **, int *);

103 int 
get_secret
 (int, char *, char *, char *, int *, int);

106 int 
auth_ip_addr
 (int, 
u32_t
);

109 int 
bad_ip_adrs
 (
u32_t
);

	@/root/Robux/net/lwip/netif/ppp/chap.c

69 #include 
	~"lwip/opt.h
"

71 #if 
PPP_SUPPORT


73 #if 
CHAP_SUPPORT


75 #include 
	~"ppp.h
"

76 #include 
	~"pppdebug.h
"

78 #include 
	~"magic.h
"

79 #include 
	~"randm.h
"

80 #include 
	~"auth.h
"

81 #include 
	~"md5.h
"

82 #include 
	~"chap.h
"

83 #include 
	~"chpms.h
"

102 static void 
ChapInit
 (int);

103 static void 
ChapLowerUp
 (int);

104 static void 
ChapLowerDown
 (int);

105 static void 
ChapInput
 (int, 
u_char
 *, int);

106 static void 
ChapProtocolReject
 (int);

108 static int 
ChapPrintPkt
 (
u_char
 *, int, void (*) (void *, char *, ...), void *);

111 static void 
	`ChapChallengeTimeout
 (void *);

112 static void 
	`ChapResponseTimeout
 (void *);

113 static void 
	`ChapReceiveChallenge
 (
chap_state
 *, 
u_char
 *, int, int);

114 static void 
	`ChapRechallenge
 (void *);

115 static void 
	`ChapReceiveResponse
 (
chap_state
 *, 
u_char
 *, int, int);

116 static void 
	`ChapReceiveSuccess
(
chap_state
 *
cstate
, 
u_char
 *
inp
, u_char 
id
, int 
len
);

117 static void 
	`ChapReceiveFailure
(
chap_state
 *
cstate
, 
u_char
 *
inp
, u_char 
id
, int 
len
);

118 static void 
	`ChapSendStatus
 (
chap_state
 *, int);

119 static void 
	`ChapSendChallenge
 (
chap_state
 *);

120 static void 
	`ChapSendResponse
 (
chap_state
 *);

121 static void 
	`ChapGenChallenge
 (
chap_state
 *);

127 
chap_state
 
chap
[
NUM_PPP
];

129 struct 
protent
 
chap_protent
 = {

130 
PPP_CHAP
,

131 
ChapInit
,

132 
ChapInput
,

133 
ChapProtocolReject
,

134 
ChapLowerUp
,

135 
ChapLowerDown
,

136 
NULL
,

137 
NULL
,

139 
ChapPrintPkt
,

140 
NULL
,

145 
NULL
,

146 
NULL
,

147 
NULL


149 
	}
};

160 
	$ChapAuthWithPeer
(int 
unit
, char *
our_name
, int 
digest
)

162 
chap_state
 *
cstate
 = &
chap
[
unit
];

164 
cstate
->
resp_name
 = 
our_name
;

165 
cstate
->
resp_type
 = 
digest
;

167 if (
cstate
->
clientstate
 == 
CHAPCS_INITIAL
 ||

168 
cstate
->
clientstate
 == 
CHAPCS_PENDING
) {

170 
cstate
->
clientstate
 = 
CHAPCS_PENDING
;

179 
cstate
->
clientstate
 = 
CHAPCS_LISTEN
;

180 
	}
}

187 
	$ChapAuthPeer
(int 
unit
, char *
our_name
, int 
digest
)

189 
chap_state
 *
cstate
 = &
chap
[
unit
];

191 
cstate
->
chal_name
 = 
our_name
;

192 
cstate
->
chal_type
 = 
digest
;

194 if (
cstate
->
serverstate
 == 
CHAPSS_INITIAL
 ||

195 
cstate
->
serverstate
 == 
CHAPSS_PENDING
) {

197 
cstate
->
serverstate
 = 
CHAPSS_PENDING
;

201 
	`ChapGenChallenge
(
cstate
);

202 
	`ChapSendChallenge
(
cstate
);

203 
cstate
->
serverstate
 = 
CHAPSS_INITIAL_CHAL
;

204 
	}
}

214 
	$ChapInit
(int 
unit
)

216 
chap_state
 *
cstate
 = &
chap
[
unit
];

218 
	`BZERO
(
cstate
, sizeof(*cstate));

219 
cstate
->
unit
 = unit;

220 
cstate
->
clientstate
 = 
CHAPCS_INITIAL
;

221 
cstate
->
serverstate
 = 
CHAPSS_INITIAL
;

222 
cstate
->
timeouttime
 = 
CHAP_DEFTIMEOUT
;

223 
cstate
->
max_transmits
 = 
CHAP_DEFTRANSMITS
;

225 
	}
}

232 
	$ChapChallengeTimeout
(void *
arg
)

234 
chap_state
 *
cstate
 = (chap_state *) 
arg
;

238 if (
cstate
->
serverstate
 != 
CHAPSS_INITIAL_CHAL
 &&

239 
cstate
->
serverstate
 != 
CHAPSS_RECHALLENGE
) {

243 if (
cstate
->
chal_transmits
 >= cstate->
max_transmits
) {

245 
	`CHAPDEBUG
((
LOG_ERR
, "Peer failed to respond to CHAP challenge\n"));

246 
cstate
->
serverstate
 = 
CHAPSS_BADAUTH
;

247 
	`auth_peer_fail
(
cstate
->
unit
, 
PPP_CHAP
);

251 
	`ChapSendChallenge
(
cstate
);

252 
	}
}

259 
	$ChapResponseTimeout
(void *
arg
)

261 
chap_state
 *
cstate
 = (chap_state *) 
arg
;

264 if (
cstate
->
clientstate
 != 
CHAPCS_RESPONSE
) {

268 
	`ChapSendResponse
(
cstate
);

269 
	}
}

276 
	$ChapRechallenge
(void *
arg
)

278 
chap_state
 *
cstate
 = (chap_state *) 
arg
;

281 if (
cstate
->
serverstate
 != 
CHAPSS_OPEN
) {

285 
	`ChapGenChallenge
(
cstate
);

286 
	`ChapSendChallenge
(
cstate
);

287 
cstate
->
serverstate
 = 
CHAPSS_RECHALLENGE
;

288 
	}
}

297 
	$ChapLowerUp
(int 
unit
)

299 
chap_state
 *
cstate
 = &
chap
[
unit
];

301 if (
cstate
->
clientstate
 == 
CHAPCS_INITIAL
) {

302 
cstate
->
clientstate
 = 
CHAPCS_CLOSED
;

303 } else if (
cstate
->
clientstate
 == 
CHAPCS_PENDING
) {

304 
cstate
->
clientstate
 = 
CHAPCS_LISTEN
;

307 if (
cstate
->
serverstate
 == 
CHAPSS_INITIAL
) {

308 
cstate
->
serverstate
 = 
CHAPSS_CLOSED
;

309 } else if (
cstate
->
serverstate
 == 
CHAPSS_PENDING
) {

310 
	`ChapGenChallenge
(
cstate
);

311 
	`ChapSendChallenge
(
cstate
);

312 
cstate
->
serverstate
 = 
CHAPSS_INITIAL_CHAL
;

314 
	}
}

323 
	$ChapLowerDown
(int 
unit
)

325 
chap_state
 *
cstate
 = &
chap
[
unit
];

328 if (
cstate
->
serverstate
 == 
CHAPSS_INITIAL_CHAL
 ||

329 
cstate
->
serverstate
 == 
CHAPSS_RECHALLENGE
) {

330 
	`UNTIMEOUT
(
ChapChallengeTimeout
, 
cstate
);

331 } else if (
cstate
->
serverstate
 == 
CHAPSS_OPEN


332 && 
cstate
->
chal_interval
 != 0) {

333 
	`UNTIMEOUT
(
ChapRechallenge
, 
cstate
);

335 if (
cstate
->
clientstate
 == 
CHAPCS_RESPONSE
) {

336 
	`UNTIMEOUT
(
ChapResponseTimeout
, 
cstate
);

338 
cstate
->
clientstate
 = 
CHAPCS_INITIAL
;

339 
cstate
->
serverstate
 = 
CHAPSS_INITIAL
;

340 
	}
}

347 
	$ChapProtocolReject
(int 
unit
)

349 
chap_state
 *
cstate
 = &
chap
[
unit
];

351 if (
cstate
->
serverstate
 != 
CHAPSS_INITIAL
 &&

352 
cstate
->
serverstate
 != 
CHAPSS_CLOSED
) {

353 
	`auth_peer_fail
(
unit
, 
PPP_CHAP
);

355 if (
cstate
->
clientstate
 != 
CHAPCS_INITIAL
 &&

356 
cstate
->
clientstate
 != 
CHAPCS_CLOSED
) {

357 
	`auth_withpeer_fail
(
unit
, 
PPP_CHAP
);

359 
	`ChapLowerDown
(
unit
);

360 
	}
}

367 
	$ChapInput
(int 
unit
, 
u_char
 *
inpacket
, int 
packet_len
)

369 
chap_state
 *
cstate
 = &
chap
[
unit
];

370 
u_char
 *
inp
;

371 
u_char
 
code
, 
id
;

372 int 
len
;

378 
inp
 = 
inpacket
;

379 if (
packet_len
 < 
CHAP_HEADERLEN
) {

380 
	`CHAPDEBUG
((
LOG_INFO
, "ChapInput: rcvd short header.\n"));

383 
	`GETCHAR
(
code
, 
inp
);

384 
	`GETCHAR
(
id
, 
inp
);

385 
	`GETSHORT
(
len
, 
inp
);

386 if (
len
 < 
CHAP_HEADERLEN
) {

387 
	`CHAPDEBUG
((
LOG_INFO
, "ChapInput: rcvd illegal length.\n"));

390 if (
len
 > 
packet_len
) {

391 
	`CHAPDEBUG
((
LOG_INFO
, "ChapInput: rcvd short packet.\n"));

394 
len
 -= 
CHAP_HEADERLEN
;

399 switch (
code
) {

400 case 
CHAP_CHALLENGE
:

401 
	`ChapReceiveChallenge
(
cstate
, 
inp
, 
id
, 
len
);

404 case 
CHAP_RESPONSE
:

405 
	`ChapReceiveResponse
(
cstate
, 
inp
, 
id
, 
len
);

408 case 
CHAP_FAILURE
:

409 
	`ChapReceiveFailure
(
cstate
, 
inp
, 
id
, 
len
);

412 case 
CHAP_SUCCESS
:

413 
	`ChapReceiveSuccess
(
cstate
, 
inp
, 
id
, 
len
);

417 
	`CHAPDEBUG
((
LOG_WARNING
, "Unknown CHAP code (%d) received.\n", 
code
));

420 
	}
}

427 
	$ChapReceiveChallenge
(
chap_state
 *
cstate
, 
u_char
 *
inp
, int 
id
, int 
len
)

429 int 
rchallenge_len
;

430 
u_char
 *
rchallenge
;

431 int 
secret_len
;

432 char 
secret
[
MAXSECRETLEN
];

433 char 
rhostname
[256];

434 
MD5_CTX
 
mdContext
;

435 
u_char
 
hash
[
MD5_SIGNATURE_SIZE
];

437 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveChallenge: Rcvd id %d.\n", 
id
));

438 if (
cstate
->
clientstate
 == 
CHAPCS_CLOSED
 ||

439 
cstate
->
clientstate
 == 
CHAPCS_PENDING
) {

440 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveChallenge: in state %d\n",

441 
cstate
->
clientstate
));

445 if (
len
 < 2) {

446 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveChallenge: rcvd short packet.\n"));

450 
	`GETCHAR
(
rchallenge_len
, 
inp
);

451 
len
 -= sizeof (
u_char
) + 
rchallenge_len
;

452 if (
len
 < 0) {

453 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveChallenge: rcvd short packet.\n"));

456 
rchallenge
 = 
inp
;

457 
	`INCPTR
(
rchallenge_len
, 
inp
);

459 if (
len
 >= sizeof(
rhostname
)) {

460 
len
 = sizeof(
rhostname
) - 1;

462 
	`BCOPY
(
inp
, 
rhostname
, 
len
);

463 
rhostname
[
len
] = '\000';

465 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveChallenge: received name field '%s'\n", 
rhostname
));

468 if (
ppp_settings
.
remote_name
[0] != 0 && (ppp_settings.
explicit_remote
 || 
rhostname
[0] == 0)) {

469 
	`strncpy
(
rhostname
, 
ppp_settings
.
remote_name
, sizeof(rhostname));

470 
rhostname
[sizeof(rhostname) - 1] = 0;

471 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveChallenge: using '%s' as remote name\n", 
rhostname
));

475 if (!
	`get_secret
(
cstate
->
unit
, cstate->
resp_name
, 
rhostname
, 
secret
, &
secret_len
, 0)) {

476 
secret_len
 = 0;

477 
	`CHAPDEBUG
((
LOG_WARNING
, "No CHAP secret found for authenticating us to %s\n", 
rhostname
));

481 if (
cstate
->
clientstate
 == 
CHAPCS_RESPONSE
) {

482 
	`UNTIMEOUT
(
ChapResponseTimeout
, 
cstate
);

485 
cstate
->
resp_id
 = 
id
;

486 
cstate
->
resp_transmits
 = 0;

489 switch (
cstate
->
resp_type
) {

491 case 
CHAP_DIGEST_MD5
:

492 
	`MD5Init
(&
mdContext
);

493 
	`MD5Update
(&
mdContext
, &
cstate
->
resp_id
, 1);

494 
	`MD5Update
(&
mdContext
, (
u_char
*)
secret
, 
secret_len
);

495 
	`MD5Update
(&
mdContext
, 
rchallenge
, 
rchallenge_len
);

496 
	`MD5Final
(
hash
, &
mdContext
);

497 
	`BCOPY
(
hash
, 
cstate
->
response
, 
MD5_SIGNATURE_SIZE
);

498 
cstate
->
resp_length
 = 
MD5_SIGNATURE_SIZE
;

501 #ifdef 
CHAPMS


502 case 
CHAP_MICROSOFT
:

503 
	`ChapMS
(
cstate
, 
rchallenge
, 
rchallenge_len
, 
secret
, 
secret_len
);

508 
	`CHAPDEBUG
((
LOG_INFO
, "unknown digest type %d\n", 
cstate
->
resp_type
));

512 
	`BZERO
(
secret
, sizeof(secret));

513 
	`ChapSendResponse
(
cstate
);

514 
	}
}

521 
	$ChapReceiveResponse
(
chap_state
 *
cstate
, 
u_char
 *
inp
, int 
id
, int 
len
)

523 
u_char
 *
remmd
, 
remmd_len
;

524 int 
secret_len
, 
old_state
;

525 int 
code
;

526 char 
rhostname
[256];

527 
MD5_CTX
 
mdContext
;

528 char 
secret
[
MAXSECRETLEN
];

529 
u_char
 
hash
[
MD5_SIGNATURE_SIZE
];

531 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveResponse: Rcvd id %d.\n", 
id
));

533 if (
cstate
->
serverstate
 == 
CHAPSS_CLOSED
 ||

534 
cstate
->
serverstate
 == 
CHAPSS_PENDING
) {

535 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveResponse: in state %d\n",

536 
cstate
->
serverstate
));

540 if (
id
 != 
cstate
->
chal_id
) {

549 if (
cstate
->
serverstate
 == 
CHAPSS_OPEN
) {

550 
	`ChapSendStatus
(
cstate
, 
CHAP_SUCCESS
);

553 if (
cstate
->
serverstate
 == 
CHAPSS_BADAUTH
) {

554 
	`ChapSendStatus
(
cstate
, 
CHAP_FAILURE
);

558 if (
len
 < 2) {

559 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveResponse: rcvd short packet.\n"));

562 
	`GETCHAR
(
remmd_len
, 
inp
);

563 
remmd
 = 
inp
;

564 
	`INCPTR
(
remmd_len
, 
inp
);

566 
len
 -= sizeof (
u_char
) + 
remmd_len
;

567 if (
len
 < 0) {

568 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveResponse: rcvd short packet.\n"));

572 
	`UNTIMEOUT
(
ChapChallengeTimeout
, 
cstate
);

574 if (
len
 >= sizeof(
rhostname
)) {

575 
len
 = sizeof(
rhostname
) - 1;

577 
	`BCOPY
(
inp
, 
rhostname
, 
len
);

578 
rhostname
[
len
] = '\000';

580 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveResponse: received name field: %s\n", 
rhostname
));

586 
code
 = 
CHAP_FAILURE
;

587 if (!
	`get_secret
(
cstate
->
unit
, 
rhostname
, cstate->
chal_name
, 
secret
, &
secret_len
, 1)) {

589 
	`CHAPDEBUG
((
LOG_WARNING
, "No CHAP secret found for authenticating %s\n",

590 
rhostname
));

593 switch (
cstate
->
chal_type
) {

595 case 
CHAP_DIGEST_MD5
:

596 if (
remmd_len
 != 
MD5_SIGNATURE_SIZE
) {

599 
	`MD5Init
(&
mdContext
);

600 
	`MD5Update
(&
mdContext
, &
cstate
->
chal_id
, 1);

601 
	`MD5Update
(&
mdContext
, (
u_char
*)
secret
, 
secret_len
);

602 
	`MD5Update
(&
mdContext
, 
cstate
->
challenge
, cstate->
chal_len
);

603 
	`MD5Final
(
hash
, &
mdContext
);

606 if (
	`memcmp
 (
hash
, 
remmd
, 
MD5_SIGNATURE_SIZE
) == 0) {

607 
code
 = 
CHAP_SUCCESS
;

612 
	`CHAPDEBUG
((
LOG_INFO
, "unknown digest type %d\n", 
cstate
->
chal_type
));

616 
	`BZERO
(
secret
, sizeof(secret));

617 
	`ChapSendStatus
(
cstate
, 
code
);

619 if (
code
 == 
CHAP_SUCCESS
) {

620 
old_state
 = 
cstate
->
serverstate
;

621 
cstate
->
serverstate
 = 
CHAPSS_OPEN
;

622 if (
old_state
 == 
CHAPSS_INITIAL_CHAL
) {

623 
	`auth_peer_success
(
cstate
->
unit
, 
PPP_CHAP
, 
rhostname
, 
len
);

625 if (
cstate
->
chal_interval
 != 0) {

626 
	`TIMEOUT
(
ChapRechallenge
, 
cstate
, cstate->
chal_interval
);

629 
	`CHAPDEBUG
((
LOG_ERR
, "CHAP peer authentication failed\n"));

630 
cstate
->
serverstate
 = 
CHAPSS_BADAUTH
;

631 
	`auth_peer_fail
(
cstate
->
unit
, 
PPP_CHAP
);

633 
	}
}

639 
	$ChapReceiveSuccess
(
chap_state
 *
cstate
, 
u_char
 *
inp
, u_char 
id
, int 
len
)

641 
	`LWIP_UNUSED_ARG
(
id
);

642 
	`LWIP_UNUSED_ARG
(
inp
);

644 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveSuccess: Rcvd id %d.\n", 
id
));

646 if (
cstate
->
clientstate
 == 
CHAPCS_OPEN
) {

651 if (
cstate
->
clientstate
 != 
CHAPCS_RESPONSE
) {

653 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveSuccess: in state %d\n", 
cstate
->
clientstate
));

657 
	`UNTIMEOUT
(
ChapResponseTimeout
, 
cstate
);

662 if (
len
 > 0) {

663 
	`PRINTMSG
(
inp
, 
len
);

666 
cstate
->
clientstate
 = 
CHAPCS_OPEN
;

668 
	`auth_withpeer_success
(
cstate
->
unit
, 
PPP_CHAP
);

669 
	}
}

676 
	$ChapReceiveFailure
(
chap_state
 *
cstate
, 
u_char
 *
inp
, u_char 
id
, int 
len
)

678 
	`LWIP_UNUSED_ARG
(
id
);

679 
	`LWIP_UNUSED_ARG
(
inp
);

681 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveFailure: Rcvd id %d.\n", 
id
));

683 if (
cstate
->
clientstate
 != 
CHAPCS_RESPONSE
) {

685 
	`CHAPDEBUG
((
LOG_INFO
, "ChapReceiveFailure: in state %d\n", 
cstate
->
clientstate
));

689 
	`UNTIMEOUT
(
ChapResponseTimeout
, 
cstate
);

694 if (
len
 > 0) {

695 
	`PRINTMSG
(
inp
, 
len
);

698 
	`CHAPDEBUG
((
LOG_ERR
, "CHAP authentication failed\n"));

699 
	`auth_withpeer_fail
(
cstate
->
unit
, 
PPP_CHAP
);

700 
	}
}

707 
	$ChapSendChallenge
(
chap_state
 *
cstate
)

709 
u_char
 *
outp
;

710 int 
chal_len
, 
name_len
;

711 int 
outlen
;

713 
chal_len
 = 
cstate
->chal_len;

714 
name_len
 = 
	`strlen
(
cstate
->
chal_name
);

715 
outlen
 = 
CHAP_HEADERLEN
 + sizeof (
u_char
) + 
chal_len
 + 
name_len
;

716 
outp
 = 
outpacket_buf
[
cstate
->
unit
];

718 
	`MAKEHEADER
(
outp
, 
PPP_CHAP
);

720 
	`PUTCHAR
(
CHAP_CHALLENGE
, 
outp
);

721 
	`PUTCHAR
(
cstate
->
chal_id
, 
outp
);

722 
	`PUTSHORT
(
outlen
, 
outp
);

724 
	`PUTCHAR
(
chal_len
, 
outp
);

725 
	`BCOPY
(
cstate
->
challenge
, 
outp
, 
chal_len
);

726 
	`INCPTR
(
chal_len
, 
outp
);

728 
	`BCOPY
(
cstate
->
chal_name
, 
outp
, 
name_len
);

730 
	`pppWrite
(
cstate
->
unit
, 
outpacket_buf
[cstate->unit], 
outlen
 + 
PPP_HDRLEN
);

732 
	`CHAPDEBUG
((
LOG_INFO
, "ChapSendChallenge: Sent id %d.\n", 
cstate
->
chal_id
));

734 
	`TIMEOUT
(
ChapChallengeTimeout
, 
cstate
, cstate->
timeouttime
);

735 ++
cstate
->
chal_transmits
;

736 
	}
}

743 
	$ChapSendStatus
(
chap_state
 *
cstate
, int 
code
)

745 
u_char
 *
outp
;

746 int 
outlen
, 
msglen
;

747 char 
msg
[256];

749 if (
code
 == 
CHAP_SUCCESS
) {

750 
	`strcpy
(
msg
, "Welcome!");

752 
	`strcpy
(
msg
, "I don't like you. Go 'way.");

754 
msglen
 = 
	`strlen
(
msg
);

756 
outlen
 = 
CHAP_HEADERLEN
 + 
msglen
;

757 
outp
 = 
outpacket_buf
[
cstate
->
unit
];

759 
	`MAKEHEADER
(
outp
, 
PPP_CHAP
);

761 
	`PUTCHAR
(
code
, 
outp
);

762 
	`PUTCHAR
(
cstate
->
chal_id
, 
outp
);

763 
	`PUTSHORT
(
outlen
, 
outp
);

764 
	`BCOPY
(
msg
, 
outp
, 
msglen
);

765 
	`pppWrite
(
cstate
->
unit
, 
outpacket_buf
[cstate->unit], 
outlen
 + 
PPP_HDRLEN
);

767 
	`CHAPDEBUG
((
LOG_INFO
, "ChapSendStatus: Sent code %d, id %d.\n", 
code
, 
cstate
->
chal_id
));

768 
	}
}

778 
	$ChapGenChallenge
(
chap_state
 *
cstate
)

780 int 
chal_len
;

781 
u_char
 *
ptr
 = 
cstate
->
challenge
;

782 int 
i
;

786 
chal_len
 = (unsigned)

787 ((((
	`magic
() >> 16) *

788 (
MAX_CHALLENGE_LENGTH
 - 
MIN_CHALLENGE_LENGTH
)) >> 16)

789 + 
MIN_CHALLENGE_LENGTH
);

790 
cstate
->
chal_len
 = chal_len;

791 
cstate
->
chal_id
 = ++cstate->
id
;

792 
cstate
->
chal_transmits
 = 0;

795 for (
i
 = 0; i < 
chal_len
; i++ ) {

796 *
ptr
++ = (char) (
	`magic
() & 0xff);

798 
	}
}

806 
	$ChapSendResponse
(
chap_state
 *
cstate
)

808 
u_char
 *
outp
;

809 int 
outlen
, 
md_len
, 
name_len
;

811 
md_len
 = 
cstate
->
resp_length
;

812 
name_len
 = 
	`strlen
(
cstate
->
resp_name
);

813 
outlen
 = 
CHAP_HEADERLEN
 + sizeof (
u_char
) + 
md_len
 + 
name_len
;

814 
outp
 = 
outpacket_buf
[
cstate
->
unit
];

816 
	`MAKEHEADER
(
outp
, 
PPP_CHAP
);

818 
	`PUTCHAR
(
CHAP_RESPONSE
, 
outp
);

819 
	`PUTCHAR
(
cstate
->
resp_id
, 
outp
);

820 
	`PUTSHORT
(
outlen
, 
outp
);

822 
	`PUTCHAR
(
md_len
, 
outp
);

823 
	`BCOPY
(
cstate
->
response
, 
outp
, 
md_len
);

824 
	`INCPTR
(
md_len
, 
outp
);

826 
	`BCOPY
(
cstate
->
resp_name
, 
outp
, 
name_len
);

829 
	`pppWrite
(
cstate
->
unit
, 
outpacket_buf
[cstate->unit], 
outlen
 + 
PPP_HDRLEN
);

831 
cstate
->
clientstate
 = 
CHAPCS_RESPONSE
;

832 
	`TIMEOUT
(
ChapResponseTimeout
, 
cstate
, cstate->
timeouttime
);

833 ++
cstate
->
resp_transmits
;

834 
	}
}

837 static char *
	gChapCodenames
[] = {

844 
ChapPrintPkt
( 
u_char
 *
p
, int 
plen
, void (*
printer
) (void *, char *, ...), void *
arg
)

846 int 
code
, 
id
, 
len
;

847 int 
clen
, 
nlen
;

848 
u_char
 
x
;

850 if (
plen
 < 
CHAP_HEADERLEN
) {

853 
	`GETCHAR
(
code
, 
p
);

854 
	`GETCHAR
(
id
, 
p
);

855 
	`GETSHORT
(
len
, 
p
);

856 if (
len
 < 
CHAP_HEADERLEN
 || len > 
plen
) {

859 if (
code
 >= 1 && code <= sizeof(
ChapCodenames
) / sizeof(char *)) {

860 
	`printer
(
arg
, " %s", 
ChapCodenames
[
code
-1]);

862 
	`printer
(
arg
, " code=0x%x", 
code
);

864 
	`printer
(
arg
, " id=0x%x", 
id
);

865 
len
 -= 
CHAP_HEADERLEN
;

866 switch (
code
) {

867 case 
CHAP_CHALLENGE
:

868 case 
CHAP_RESPONSE
:

869 if (
len
 < 1) {

872 
clen
 = 
p
[0];

873 if (
len
 < 
clen
 + 1) {

876 ++
p
;

877 
nlen
 = 
len
 - 
clen
 - 1;

878 
	`printer
(
arg
, " <");

879 for (; 
clen
 > 0; --clen) {

880 
	`GETCHAR
(
x
, 
p
);

881 
	`printer
(
arg
, "%.2x", 
x
);

883 
	`printer
(
arg
, ">, name = %.*Z", 
nlen
, 
p
);

885 case 
CHAP_FAILURE
:

886 case 
CHAP_SUCCESS
:

887 
	`printer
(
arg
, " %.*Z", 
len
, 
p
);

890 for (
clen
 = 
len
; clen > 0; --clen) {

891 
	`GETCHAR
(
x
, 
p
);

892 
	`printer
(
arg
, " %.2x", 
x
);

896 return 
len
 + 
CHAP_HEADERLEN
;

897 
	}
}

	@/root/Robux/net/lwip/netif/ppp/chap.h

68 #ifndef 
CHAP_H


69 #define 
	#CHAP_H


	)

76 #define 
	#CHAP_HEADERLEN
 4

	)

82 #define 
	#CHAP_DIGEST_MD5
 5

	)

83 #define 
	#MD5_SIGNATURE_SIZE
 16

	)

84 #define 
	#CHAP_MICROSOFT
 0x80

	)

85 #define 
	#MS_CHAP_RESPONSE_LEN
 49

	)

87 #define 
	#CHAP_CHALLENGE
 1

	)

88 #define 
	#CHAP_RESPONSE
 2

	)

89 #define 
	#CHAP_SUCCESS
 3

	)

90 #define 
	#CHAP_FAILURE
 4

	)

95 #define 
	#MIN_CHALLENGE_LENGTH
 32

	)

96 #define 
	#MAX_CHALLENGE_LENGTH
 64

	)

97 #define 
	#MAX_RESPONSE_LENGTH
 64

	)

102 #define 
	#CHAPCS_INITIAL
 0

	)

103 #define 
	#CHAPCS_CLOSED
 1

	)

104 #define 
	#CHAPCS_PENDING
 2

	)

105 #define 
	#CHAPCS_LISTEN
 3

	)

106 #define 
	#CHAPCS_RESPONSE
 4

	)

107 #define 
	#CHAPCS_OPEN
 5

	)

112 #define 
	#CHAPSS_INITIAL
 0

	)

113 #define 
	#CHAPSS_CLOSED
 1

	)

114 #define 
	#CHAPSS_PENDING
 2

	)

115 #define 
	#CHAPSS_INITIAL_CHAL
 3

	)

116 #define 
	#CHAPSS_OPEN
 4

	)

117 #define 
	#CHAPSS_RECHALLENGE
 5

	)

118 #define 
	#CHAPSS_BADAUTH
 6

	)

128 typedef struct 
	schap_state
 {

129 int 
	munit
;

130 int 
	mclientstate
;

131 int 
	mserverstate
;

132 
u_char
 
	mchallenge
[
MAX_CHALLENGE_LENGTH
];

133 
u_char
 
	mchal_len
;

134 
u_char
 
	mchal_id
;

135 
u_char
 
	mchal_type
;

136 
u_char
 
	mid
;

137 char *
	mchal_name
;

138 int 
	mchal_interval
;

139 int 
	mtimeouttime
;

140 int 
	mmax_transmits
;

141 int 
	mchal_transmits
;

142 int 
	mresp_transmits
;

143 
u_char
 
	mresponse
[
MAX_RESPONSE_LENGTH
];

144 
u_char
 
	mresp_length
;

145 
u_char
 
	mresp_id
;

146 
u_char
 
	mresp_type
;

147 char *
	mresp_name
;

148 } 
	tchap_state
;

154 extern 
chap_state
 
chap
[];

156 extern struct 
protent
 
chap_protent
;

163 void 
ChapAuthWithPeer
 (int, char *, int);

164 void 
ChapAuthPeer
 (int, char *, int);

	@/root/Robux/net/lwip/netif/ppp/chpms.c

67 #define 
	#USE_CRYPT


	)

69 #include 
	~"lwip/opt.h
"

71 #if 
PPP_SUPPORT


73 #if 
MSCHAP_SUPPORT


75 #include 
	~"ppp.h
"

76 #include 
	~"pppdebug.h
"

78 #include 
	~"md4.h
"

79 #ifndef 
USE_CRYPT


80 #include 
	~"des.h
"

82 #include 
	~"chap.h
"

83 #include 
	~"chpms.h
"

95 
u_char
 
	mLANManResp
[24];

96 
u_char
 
	mNTResp
[24];

97 
u_char
 
	mUseNT
;

98 } 
	tMS_ChapResponse
;

109 extern void 
setkey
(const char *);

110 extern void 
encrypt
(char *, int);

112 static void 
DesEncrypt
 (
u_char
 *, u_char *, u_char *);

113 static void 
MakeKey
 (
u_char
 *, u_char *);

115 #ifdef 
USE_CRYPT


116 static void 
Expand
 (
u_char
 *, u_char *);

117 static void 
Collapse
 (
u_char
 *, u_char *);

120 static void 
ChallengeResponse
(

121 
u_char
 *
challenge
,

122 
u_char
 *
pwHash
,

123 
u_char
 *
response


125 static void 
ChapMS_NT
(

126 char *
rchallenge
,

127 int 
rchallenge_len
,

128 char *
secret
,

129 int 
secret_len
,

130 
MS_ChapResponse
 *
response


132 static 
u_char
 
Get7Bits
(

133 
u_char
 *
input
,

134 int 
startBit


142 
	$ChapMS
( 
chap_state
 *
cstate
, char *
rchallenge
, int 
rchallenge_len
, char *
secret
, int 
secret_len
)

144 
MS_ChapResponse
 
response
;

145 #ifdef 
MSLANMAN


146 extern int 
ms_lanman
;

150 
	`CHAPDEBUG
((
LOG_INFO
, "ChapMS: secret is '%.*s'\n", 
secret_len
, 
secret
));

152 
	`BZERO
(&
response
, sizeof(response));

155 
	`ChapMS_NT
(
rchallenge
, 
rchallenge_len
, 
secret
, 
secret_len
, &
response
);

157 #ifdef 
MSLANMAN


158 
	`ChapMS_LANMan
(
rchallenge
, 
rchallenge_len
, 
secret
, 
secret_len
, &
response
);

161 
response
.
UseNT
 = !
ms_lanman
;

163 
response
.
UseNT
 = 1;

166 
	`BCOPY
(&
response
, 
cstate
->response, 
MS_CHAP_RESPONSE_LEN
);

167 
cstate
->
resp_length
 = 
MS_CHAP_RESPONSE_LEN
;

168 
	}
}

175 
	$ChallengeResponse
( 
u_char
 *
challenge
,

176 
u_char
 *
pwHash
,

177 
u_char
 *
response
 )

179 char 
ZPasswordHash
[21];

181 
	`BZERO
(
ZPasswordHash
, sizeof(ZPasswordHash));

182 
	`BCOPY
(
pwHash
, 
ZPasswordHash
, 16);

185 
	`log_packet
(
ZPasswordHash
, sizeof(ZPasswordHash), "ChallengeResponse - ZPasswordHash", 
LOG_DEBUG
);

188 
	`DesEncrypt
(
challenge
, 
ZPasswordHash
 + 0, 
response
 + 0);

189 
	`DesEncrypt
(
challenge
, 
ZPasswordHash
 + 7, 
response
 + 8);

190 
	`DesEncrypt
(
challenge
, 
ZPasswordHash
 + 14, 
response
 + 16);

193 
	`log_packet
(
response
, 24, "ChallengeResponse - response", 
LOG_DEBUG
);

195 
	}
}

198 #ifdef 
USE_CRYPT


200 
	$DesEncrypt
( 
u_char
 *
clear
,

201 
u_char
 *
key
,

202 
u_char
 *
cipher
 )

204 
u_char
 
des_key
[8];

205 
u_char
 
crypt_key
[66];

206 
u_char
 
des_input
[66];

208 
	`MakeKey
(
key
, 
des_key
);

210 
	`Expand
(
des_key
, 
crypt_key
);

211 
	`setkey
(
crypt_key
);

214 
	`CHAPDEBUG
((
LOG_INFO
, "DesEncrypt: 8 octet input : %02X%02X%02X%02X%02X%02X%02X%02X\n",

215 
clear
[0], clear[1], clear[2], clear[3], clear[4], clear[5], clear[6], clear[7]));

218 
	`Expand
(
clear
, 
des_input
);

219 
	`encrypt
(
des_input
, 0);

220 
	`Collapse
(
des_input
, 
cipher
);

223 
	`CHAPDEBUG
((
LOG_INFO
, "DesEncrypt: 8 octet output: %02X%02X%02X%02X%02X%02X%02X%02X\n",

224 
cipher
[0], cipher[1], cipher[2], cipher[3], cipher[4], cipher[5], cipher[6], cipher[7]));

226 
	}
}

231 
	$DesEncrypt
( 
u_char
 *
clear
,

232 
u_char
 *
key
,

233 
u_char
 *
cipher
 )

235 
des_cblock
 
des_key
;

236 
des_key_schedule
 
key_schedule
;

238 
	`MakeKey
(
key
, 
des_key
);

240 
	`des_set_key
(&
des_key
, 
key_schedule
);

243 
	`CHAPDEBUG
((
LOG_INFO
, "DesEncrypt: 8 octet input : %02X%02X%02X%02X%02X%02X%02X%02X\n",

244 
clear
[0], clear[1], clear[2], clear[3], clear[4], clear[5], clear[6], clear[7]));

247 
	`des_ecb_encrypt
((
des_cblock
 *)
clear
, (des_cblock *)
cipher
, 
key_schedule
, 1);

250 
	`CHAPDEBUG
((
LOG_INFO
, "DesEncrypt: 8 octet output: %02X%02X%02X%02X%02X%02X%02X%02X\n",

251 
cipher
[0], cipher[1], cipher[2], cipher[3], cipher[4], cipher[5], cipher[6], cipher[7]));

253 
	}
}

258 static 
u_char


259 
	$Get7Bits
( 
u_char
 *
input
, int 
startBit
)

261 register unsigned int 
word
;

263 
word
 = (unsigned)
input
[
startBit
 / 8] << 8;

264 
word
 |= (unsigned)
input
[
startBit
 / 8 + 1];

266 
word
 >>= 15 - (
startBit
 % 8 + 7);

268 return 
word
 & 0xFE;

269 
	}
}

271 #ifdef 
USE_CRYPT


278 
	$Expand
(
u_char
 *
in
, u_char *
out
)

280 int 
j
, 
c
;

281 int 
i
;

283 for(
i
 = 0; i < 64; 
in
++){

284 
c
 = *
in
;

285 for(
j
 = 7; j >= 0; j--) {

286 *
out
++ = (
c
 >> 
j
) & 01;

288 
i
 += 8;

290 
	}
}

295 
	$Collapse
(
u_char
 *
in
, u_char *
out
)

297 int 
j
;

298 int 
i
;

299 unsigned int 
c
;

301 for (
i
 = 0; i < 64; i += 8, 
out
++) {

302 
c
 = 0;

303 for (
j
 = 7; j >= 0; j--, 
in
++) {

304 
c
 |= *
in
 << 
j
;

306 *
out
 = 
c
 & 0xff;

308 
	}
}

312 
	$MakeKey
( 
u_char
 *
key
,

313 
u_char
 *
des_key
 )

315 
des_key
[0] = 
	`Get7Bits
(
key
, 0);

316 
des_key
[1] = 
	`Get7Bits
(
key
, 7);

317 
des_key
[2] = 
	`Get7Bits
(
key
, 14);

318 
des_key
[3] = 
	`Get7Bits
(
key
, 21);

319 
des_key
[4] = 
	`Get7Bits
(
key
, 28);

320 
des_key
[5] = 
	`Get7Bits
(
key
, 35);

321 
des_key
[6] = 
	`Get7Bits
(
key
, 42);

322 
des_key
[7] = 
	`Get7Bits
(
key
, 49);

324 #ifndef 
USE_CRYPT


325 
	`des_set_odd_parity
((
des_cblock
 *)
des_key
);

329 
	`CHAPDEBUG
((
LOG_INFO
, "MakeKey: 56-bit input : %02X%02X%02X%02X%02X%02X%02X\n",

330 
key
[0], key[1], key[2], key[3], key[4], key[5], key[6]));

331 
	`CHAPDEBUG
((
LOG_INFO
, "MakeKey: 64-bit output: %02X%02X%02X%02X%02X%02X%02X%02X\n",

332 
des_key
[0], des_key[1], des_key[2], des_key[3], des_key[4], des_key[5], des_key[6], des_key[7]));

334 
	}
}

337 
	$ChapMS_NT
( char *
rchallenge
,

338 int 
rchallenge_len
,

339 char *
secret
,

340 int 
secret_len
,

341 
MS_ChapResponse
 *
response
)

343 int 
i
;

344 
MDstruct
 
md4Context
;

345 
u_char
 
unicodePassword
[
MAX_NT_PASSWORD
 * 2];

346 static int 
low_byte_first
 = -1;

350 
	`BZERO
(
unicodePassword
, sizeof(unicodePassword));

351 for (
i
 = 0; i < 
secret_len
; i++) {

352 
unicodePassword
[
i
 * 2] = (
u_char
)
secret
[i];

354 
	`MDbegin
(&
md4Context
);

355 
	`MDupdate
(&
md4Context
, 
unicodePassword
, 
secret_len
 * 2 * 8);

357 if (
low_byte_first
 == -1) {

358 
low_byte_first
 = (
	`htons
((unsigned short int)1) != 1);

360 if (
low_byte_first
 == 0) {

361 
	`MDreverse
((
u_long
 *)&
md4Context
);

364 
	`MDupdate
(&
md4Context
, 
NULL
, 0);

366 
	`ChallengeResponse
(
rchallenge
, (char *)
md4Context
.
buffer
, 
response
->
NTResp
);

367 
	}
}

369 #ifdef 
MSLANMAN


370 static 
u_char
 *
	gStdText
 = (u_char *)"KGS!@#$%";

373 
	$ChapMS_LANMan
( char *
rchallenge
,

374 int 
rchallenge_len
,

375 char *
secret
,

376 int 
secret_len
,

377 
MS_ChapResponse
 *
response
)

379 int 
i
;

380 
u_char
 
UcasePassword
[
MAX_NT_PASSWORD
];

381 
u_char
 
PasswordHash
[16];

384 
	`BZERO
(
UcasePassword
, sizeof(UcasePassword));

385 for (
i
 = 0; i < 
secret_len
; i++) {

386 
UcasePassword
[
i
] = (
u_char
)
	`toupper
(
secret
[i]);

388 
	`DesEncrypt
( 
StdText
, 
UcasePassword
 + 0, 
PasswordHash
 + 0 );

389 
	`DesEncrypt
( 
StdText
, 
UcasePassword
 + 7, 
PasswordHash
 + 8 );

390 
	`ChallengeResponse
(
rchallenge
, 
PasswordHash
, 
response
->
LANManResp
);

391 
	}
}

	@/root/Robux/net/lwip/netif/ppp/chpms.h

57 #ifndef 
CHPMS_H


58 #define 
	#CHPMS_H


	)

60 #define 
	#MAX_NT_PASSWORD
 256

	)

62 void 
ChapMS
 (
chap_state
 *, char *, int, char *, int);

	@/root/Robux/net/lwip/netif/ppp/fsm.c

58 #include 
	~"lwip/opt.h
"

60 #if 
PPP_SUPPORT


62 #include 
	~"ppp.h
"

63 #include 
	~"pppdebug.h
"

65 #include 
	~"fsm.h
"

72 #if 
PPP_DEBUG


74 static const char *
	gppperr_strerr
[] = {

97 static void 
fsm_timeout
 (void *);

98 static void 
fsm_rconfreq
 (
fsm
 *, 
u_char
, u_char *, int);

99 static void 
fsm_rconfack
 (
fsm
 *, int, 
u_char
 *, int);

100 static void 
fsm_rconfnakrej
 (
fsm
 *, int, int, 
u_char
 *, int);

101 static void 
fsm_rtermreq
 (
fsm
 *, int, 
u_char
 *, int);

102 static void 
fsm_rtermack
 (
fsm
 *);

103 static void 
fsm_rcoderej
 (
fsm
 *, 
u_char
 *, int);

104 static void 
fsm_sconfreq
 (
fsm
 *, int);

106 #define 
	#PROTO_NAME
(
f
) ((f)->
callbacks
->
proto_name
)

	)

117 int 
	gpeer_mru
[
NUM_PPP
];

130 
	$fsm_init
(
fsm
 *
f
)

132 
f
->
state
 = 
LS_INITIAL
;

133 
f
->
flags
 = 0;

134 
f
->
id
 = 0;

135 
f
->
timeouttime
 = 
FSM_DEFTIMEOUT
;

136 
f
->
maxconfreqtransmits
 = 
FSM_DEFMAXCONFREQS
;

137 
f
->
maxtermtransmits
 = 
FSM_DEFMAXTERMREQS
;

138 
f
->
maxnakloops
 = 
FSM_DEFMAXNAKLOOPS
;

139 
f
->
term_reason_len
 = 0;

140 
	}
}

147 
	$fsm_lowerup
(
fsm
 *
f
)

149 int 
oldState
 = 
f
->
state
;

151 
	`LWIP_UNUSED_ARG
(
oldState
);

153 switch( 
f
->
state
 ) {

154 case 
LS_INITIAL
:

155 
f
->
state
 = 
LS_CLOSED
;

158 case 
LS_STARTING
:

159 if( 
f
->
flags
 & 
OPT_SILENT
 ) {

160 
f
->
state
 = 
LS_STOPPED
;

163 
	`fsm_sconfreq
(
f
, 0);

164 
f
->
state
 = 
LS_REQSENT
;

169 
	`FSMDEBUG
((
LOG_INFO
, "%s: Up event in state %d (%s)!\n",

170 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

173 
	`FSMDEBUG
((
LOG_INFO
, "%s: lowerup state %d (%s) -> %d (%s)\n",

174 
	`PROTO_NAME
(
f
), 
oldState
, 
ppperr_strerr
[oldState], f->
state
, ppperr_strerr[f->state]));

175 
	}
}

184 
	$fsm_lowerdown
(
fsm
 *
f
)

186 int 
oldState
 = 
f
->
state
;

188 
	`LWIP_UNUSED_ARG
(
oldState
);

190 switch( 
f
->
state
 ) {

191 case 
LS_CLOSED
:

192 
f
->
state
 = 
LS_INITIAL
;

195 case 
LS_STOPPED
:

196 
f
->
state
 = 
LS_STARTING
;

197 if( 
f
->
callbacks
->
starting
 ) {

198 (*
f
->
callbacks
->
starting
)(f);

202 case 
LS_CLOSING
:

203 
f
->
state
 = 
LS_INITIAL
;

204 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

207 case 
LS_STOPPING
:

208 case 
LS_REQSENT
:

209 case 
LS_ACKRCVD
:

210 case 
LS_ACKSENT
:

211 
f
->
state
 = 
LS_STARTING
;

212 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

215 case 
LS_OPENED
:

216 if( 
f
->
callbacks
->
down
 ) {

217 (*
f
->
callbacks
->
down
)(f);

219 
f
->
state
 = 
LS_STARTING
;

223 
	`FSMDEBUG
((
LOG_INFO
, "%s: Down event in state %d (%s)!\n",

224 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

227 
	`FSMDEBUG
((
LOG_INFO
, "%s: lowerdown state %d (%s) -> %d (%s)\n",

228 
	`PROTO_NAME
(
f
), 
oldState
, 
ppperr_strerr
[oldState], f->
state
, ppperr_strerr[f->state]));

229 
	}
}

236 
	$fsm_open
(
fsm
 *
f
)

238 int 
oldState
 = 
f
->
state
;

240 
	`LWIP_UNUSED_ARG
(
oldState
);

242 switch( 
f
->
state
 ) {

243 case 
LS_INITIAL
:

244 
f
->
state
 = 
LS_STARTING
;

245 if( 
f
->
callbacks
->
starting
 ) {

246 (*
f
->
callbacks
->
starting
)(f);

250 case 
LS_CLOSED
:

251 if( 
f
->
flags
 & 
OPT_SILENT
 ) {

252 
f
->
state
 = 
LS_STOPPED
;

255 
	`fsm_sconfreq
(
f
, 0);

256 
f
->
state
 = 
LS_REQSENT
;

260 case 
LS_CLOSING
:

261 
f
->
state
 = 
LS_STOPPING
;

263 case 
LS_STOPPED
:

264 case 
LS_OPENED
:

265 if( 
f
->
flags
 & 
OPT_RESTART
 ) {

266 
	`fsm_lowerdown
(
f
);

267 
	`fsm_lowerup
(
f
);

272 
	`FSMDEBUG
((
LOG_INFO
, "%s: open state %d (%s) -> %d (%s)\n",

273 
	`PROTO_NAME
(
f
), 
oldState
, 
ppperr_strerr
[oldState], f->
state
, ppperr_strerr[f->state]));

274 
	}
}

284 
	$fsm_close
(
fsm
 *
f
, char *
reason
)

286 int 
oldState
 = 
f
->
state
;

288 
	`LWIP_UNUSED_ARG
(
oldState
);

290 
f
->
term_reason
 = 
reason
;

291 
f
->
term_reason_len
 = (
reason
 == 
NULL
? 0: 
	`strlen
(reason));

292 switch( 
f
->
state
 ) {

293 case 
LS_STARTING
:

294 
f
->
state
 = 
LS_INITIAL
;

296 case 
LS_STOPPED
:

297 
f
->
state
 = 
LS_CLOSED
;

299 case 
LS_STOPPING
:

300 
f
->
state
 = 
LS_CLOSING
;

303 case 
LS_REQSENT
:

304 case 
LS_ACKRCVD
:

305 case 
LS_ACKSENT
:

306 case 
LS_OPENED
:

307 if( 
f
->
state
 != 
LS_OPENED
 ) {

308 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

309 } else if( 
f
->
callbacks
->
down
 ) {

310 (*
f
->
callbacks
->
down
)(f);

313 
f
->
retransmits
 = f->
maxtermtransmits
;

314 
	`fsm_sdata
(
f
, 
TERMREQ
, f->
reqid
 = ++f->
id
,

315 (
u_char
 *) 
f
->
term_reason
, f->
term_reason_len
);

316 
	`TIMEOUT
(
fsm_timeout
, 
f
, f->
timeouttime
);

317 --
f
->
retransmits
;

319 
f
->
state
 = 
LS_CLOSING
;

323 
	`FSMDEBUG
((
LOG_INFO
, "%s: close reason=%s state %d (%s) -> %d (%s)\n",

324 
	`PROTO_NAME
(
f
), 
reason
, 
oldState
, 
ppperr_strerr
[oldState], f->
state
, ppperr_strerr[f->state]));

325 
	}
}

334 
	$fsm_sdata
( 
fsm
 *
f
, 
u_char
 
code
, u_char 
id
, u_char *
data
, int 
datalen
)

336 
u_char
 *
outp
;

337 int 
outlen
;

340 
outp
 = 
outpacket_buf
[
f
->
unit
];

341 if (
datalen
 > 
peer_mru
[
f
->
unit
] - (int)
HEADERLEN
) {

342 
datalen
 = 
peer_mru
[
f
->
unit
] - 
HEADERLEN
;

344 if (
datalen
 && 
data
 != 
outp
 + 
PPP_HDRLEN
 + 
HEADERLEN
) {

345 
	`BCOPY
(
data
, 
outp
 + 
PPP_HDRLEN
 + 
HEADERLEN
, 
datalen
);

347 
outlen
 = 
datalen
 + 
HEADERLEN
;

348 
	`MAKEHEADER
(
outp
, 
f
->
protocol
);

349 
	`PUTCHAR
(
code
, 
outp
);

350 
	`PUTCHAR
(
id
, 
outp
);

351 
	`PUTSHORT
(
outlen
, 
outp
);

352 
	`pppWrite
(
f
->
unit
, 
outpacket_buf
[f->unit], 
outlen
 + 
PPP_HDRLEN
);

353 
	`FSMDEBUG
((
LOG_INFO
, "fsm_sdata(%s): Sent code %d,%d,%d.\n",

354 
	`PROTO_NAME
(
f
), 
code
, 
id
, 
outlen
));

355 
	}
}

362 
	$fsm_input
(
fsm
 *
f
, 
u_char
 *
inpacket
, int 
l
)

364 
u_char
 *
inp
 = 
inpacket
;

365 
u_char
 
code
, 
id
;

366 int 
len
;

372 if (
l
 < 
HEADERLEN
) {

373 
	`FSMDEBUG
((
LOG_WARNING
, "fsm_input(%x): Rcvd short header.\n",

374 
f
->
protocol
));

377 
	`GETCHAR
(
code
, 
inp
);

378 
	`GETCHAR
(
id
, 
inp
);

379 
	`GETSHORT
(
len
, 
inp
);

380 if (
len
 < 
HEADERLEN
) {

381 
	`FSMDEBUG
((
LOG_INFO
, "fsm_input(%x): Rcvd illegal length.\n",

382 
f
->
protocol
));

385 if (
len
 > 
l
) {

386 
	`FSMDEBUG
((
LOG_INFO
, "fsm_input(%x): Rcvd short packet.\n",

387 
f
->
protocol
));

390 
len
 -= 
HEADERLEN
;

392 if( 
f
->
state
 == 
LS_INITIAL
 || f->state == 
LS_STARTING
 ) {

393 
	`FSMDEBUG
((
LOG_INFO
, "fsm_input(%x): Rcvd packet in state %d (%s).\n",

394 
f
->
protocol
, f->
state
, 
ppperr_strerr
[f->state]));

397 
	`FSMDEBUG
((
LOG_INFO
, "fsm_input(%s):%d,%d,%d\n", 
	`PROTO_NAME
(
f
), 
code
, 
id
, 
l
));

401 switch (
code
) {

402 case 
CONFREQ
:

403 
	`fsm_rconfreq
(
f
, 
id
, 
inp
, 
len
);

406 case 
CONFACK
:

407 
	`fsm_rconfack
(
f
, 
id
, 
inp
, 
len
);

410 case 
CONFNAK
:

411 case 
CONFREJ
:

412 
	`fsm_rconfnakrej
(
f
, 
code
, 
id
, 
inp
, 
len
);

415 case 
TERMREQ
:

416 
	`fsm_rtermreq
(
f
, 
id
, 
inp
, 
len
);

419 case 
TERMACK
:

420 
	`fsm_rtermack
(
f
);

423 case 
CODEREJ
:

424 
	`fsm_rcoderej
(
f
, 
inp
, 
len
);

428 if( !
f
->
callbacks
->
extcode
 ||

429 !(*
f
->
callbacks
->
extcode
)(f, 
code
, 
id
, 
inp
, 
len
) ) {

430 
	`fsm_sdata
(
f
, 
CODEREJ
, ++f->
id
, 
inpacket
, 
len
 + 
HEADERLEN
);

434 
	}
}

443 
	$fsm_protreject
(
fsm
 *
f
)

445 switch( 
f
->
state
 ) {

446 case 
LS_CLOSING
:

447 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

449 case 
LS_CLOSED
:

450 
f
->
state
 = 
LS_CLOSED
;

451 if( 
f
->
callbacks
->
finished
 ) {

452 (*
f
->
callbacks
->
finished
)(f);

456 case 
LS_STOPPING
:

457 case 
LS_REQSENT
:

458 case 
LS_ACKRCVD
:

459 case 
LS_ACKSENT
:

460 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

462 case 
LS_STOPPED
:

463 
f
->
state
 = 
LS_STOPPED
;

464 if( 
f
->
callbacks
->
finished
 ) {

465 (*
f
->
callbacks
->
finished
)(f);

469 case 
LS_OPENED
:

470 if( 
f
->
callbacks
->
down
 ) {

471 (*
f
->
callbacks
->
down
)(f);

474 
f
->
retransmits
 = f->
maxtermtransmits
;

475 
	`fsm_sdata
(
f
, 
TERMREQ
, f->
reqid
 = ++f->
id
,

476 (
u_char
 *) 
f
->
term_reason
, f->
term_reason_len
);

477 
	`TIMEOUT
(
fsm_timeout
, 
f
, f->
timeouttime
);

478 --
f
->
retransmits
;

480 
f
->
state
 = 
LS_STOPPING
;

484 
	`FSMDEBUG
((
LOG_INFO
, "%s: Protocol-reject event in state %d (%s)!\n",

485 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

487 
	}
}

501 
	$fsm_timeout
(void *
arg
)

503 
fsm
 *
f
 = (fsm *) 
arg
;

505 switch (
f
->
state
) {

506 case 
LS_CLOSING
:

507 case 
LS_STOPPING
:

508 if( 
f
->
retransmits
 <= 0 ) {

509 
	`FSMDEBUG
((
LOG_WARNING
, "%s: timeout sending Terminate-Request state=%d (%s)\n",

510 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

514 
f
->
state
 = (f->state == 
LS_CLOSING
)? 
LS_CLOSED
: 
LS_STOPPED
;

515 if( 
f
->
callbacks
->
finished
 ) {

516 (*
f
->
callbacks
->
finished
)(f);

519 
	`FSMDEBUG
((
LOG_WARNING
, "%s: timeout resending Terminate-Requests state=%d (%s)\n",

520 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

522 
	`fsm_sdata
(
f
, 
TERMREQ
, f->
reqid
 = ++f->
id
,

523 (
u_char
 *) 
f
->
term_reason
, f->
term_reason_len
);

524 
	`TIMEOUT
(
fsm_timeout
, 
f
, f->
timeouttime
);

525 --
f
->
retransmits
;

529 case 
LS_REQSENT
:

530 case 
LS_ACKRCVD
:

531 case 
LS_ACKSENT
:

532 if (
f
->
retransmits
 <= 0) {

533 
	`FSMDEBUG
((
LOG_WARNING
, "%s: timeout sending Config-Requests state=%d (%s)\n",

534 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

535 
f
->
state
 = 
LS_STOPPED
;

536 if( (
f
->
flags
 & 
OPT_PASSIVE
) == 0 && f->
callbacks
->
finished
 ) {

537 (*
f
->
callbacks
->
finished
)(f);

540 
	`FSMDEBUG
((
LOG_WARNING
, "%s: timeout resending Config-Request state=%d (%s)\n",

541 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

543 if (
f
->
callbacks
->
retransmit
) {

544 (*
f
->
callbacks
->
retransmit
)(f);

546 
	`fsm_sconfreq
(
f
, 1);

547 if( 
f
->
state
 == 
LS_ACKRCVD
 ) {

548 
f
->
state
 = 
LS_REQSENT
;

554 
	`FSMDEBUG
((
LOG_INFO
, "%s: Timeout event in state %d (%s)!\n",

555 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

557 
	}
}

564 
	$fsm_rconfreq
(
fsm
 *
f
, 
u_char
 
id
, u_char *
inp
, int 
len
)

566 int 
code
, 
reject_if_disagree
;

568 
	`FSMDEBUG
((
LOG_INFO
, "fsm_rconfreq(%s): Rcvd id %d state=%d (%s)\n",

569 
	`PROTO_NAME
(
f
), 
id
, f->
state
, 
ppperr_strerr
[f->state]));

570 switch( 
f
->
state
 ) {

571 case 
LS_CLOSED
:

573 
	`fsm_sdata
(
f
, 
TERMACK
, 
id
, 
NULL
, 0);

575 case 
LS_CLOSING
:

576 case 
LS_STOPPING
:

579 case 
LS_OPENED
:

581 if( 
f
->
callbacks
->
down
 ) {

582 (*
f
->
callbacks
->
down
)(f);

584 
	`fsm_sconfreq
(
f
, 0);

587 case 
LS_STOPPED
:

589 
	`fsm_sconfreq
(
f
, 0);

590 
f
->
state
 = 
LS_REQSENT
;

598 if (
f
->
callbacks
->
reqci
) {

599 
reject_if_disagree
 = (
f
->
nakloops
 >= f->
maxnakloops
);

600 
code
 = (*
f
->
callbacks
->
reqci
)(f, 
inp
, &
len
, 
reject_if_disagree
);

601 } else if (
len
) {

602 
code
 = 
CONFREJ
;

604 
code
 = 
CONFACK
;

608 
	`fsm_sdata
(
f
, (
u_char
)
code
, 
id
, 
inp
, 
len
);

610 if (
code
 == 
CONFACK
) {

611 if (
f
->
state
 == 
LS_ACKRCVD
) {

612 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

613 
f
->
state
 = 
LS_OPENED
;

614 if (
f
->
callbacks
->
up
) {

615 (*
f
->
callbacks
->
up
)(f);

618 
f
->
state
 = 
LS_ACKSENT
;

620 
f
->
nakloops
 = 0;

623 if (
f
->
state
 != 
LS_ACKRCVD
) {

624 
f
->
state
 = 
LS_REQSENT
;

626 if( 
code
 == 
CONFNAK
 ) {

627 ++
f
->
nakloops
;

630 
	}
}

637 
	$fsm_rconfack
(
fsm
 *
f
, int 
id
, 
u_char
 *
inp
, int 
len
)

639 
	`FSMDEBUG
((
LOG_INFO
, "fsm_rconfack(%s): Rcvd id %d state=%d (%s)\n",

640 
	`PROTO_NAME
(
f
), 
id
, f->
state
, 
ppperr_strerr
[f->state]));

642 if (
id
 != 
f
->
reqid
 || f->
seen_ack
) {

645 if( !(
f
->
callbacks
->
ackci
? (*f->callbacks->ackci)(f, 
inp
, 
len
): (len == 0)) ) {

647 
	`FSMDEBUG
((
LOG_INFO
, "%s: received bad Ack (length %d)\n",

648 
	`PROTO_NAME
(
f
), 
len
));

651 
f
->
seen_ack
 = 1;

653 switch (
f
->
state
) {

654 case 
LS_CLOSED
:

655 case 
LS_STOPPED
:

656 
	`fsm_sdata
(
f
, 
TERMACK
, (
u_char
)
id
, 
NULL
, 0);

659 case 
LS_REQSENT
:

660 
f
->
state
 = 
LS_ACKRCVD
;

661 
f
->
retransmits
 = f->
maxconfreqtransmits
;

664 case 
LS_ACKRCVD
:

666 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

667 
	`fsm_sconfreq
(
f
, 0);

668 
f
->
state
 = 
LS_REQSENT
;

671 case 
LS_ACKSENT
:

672 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

673 
f
->
state
 = 
LS_OPENED
;

674 
f
->
retransmits
 = f->
maxconfreqtransmits
;

675 if (
f
->
callbacks
->
up
) {

676 (*
f
->
callbacks
->
up
)(f);

680 case 
LS_OPENED
:

682 if (
f
->
callbacks
->
down
) {

683 (*
f
->
callbacks
->
down
)(f);

685 
	`fsm_sconfreq
(
f
, 0);

686 
f
->
state
 = 
LS_REQSENT
;

689 
	}
}

696 
	$fsm_rconfnakrej
(
fsm
 *
f
, int 
code
, int 
id
, 
u_char
 *
inp
, int 
len
)

698 int (*
proc
) (
fsm
 *, 
u_char
 *, int);

699 int 
ret
;

701 
	`FSMDEBUG
((
LOG_INFO
, "fsm_rconfnakrej(%s): Rcvd id %d state=%d (%s)\n",

702 
	`PROTO_NAME
(
f
), 
id
, f->
state
, 
ppperr_strerr
[f->state]));

704 if (
id
 != 
f
->
reqid
 || f->
seen_ack
) {

707 
proc
 = (
code
 == 
CONFNAK
)? 
f
->
callbacks
->
nakci
: f->callbacks->
rejci
;

708 if (!
proc
 || !((
ret
 = 
	`proc
(
f
, 
inp
, 
len
)))) {

710 
	`FSMDEBUG
((
LOG_INFO
, "%s: received bad %s (length %d)\n",

711 
	`PROTO_NAME
(
f
), (
code
==
CONFNAK
? "Nak": "reject"), 
len
));

714 
f
->
seen_ack
 = 1;

716 switch (
f
->
state
) {

717 case 
LS_CLOSED
:

718 case 
LS_STOPPED
:

719 
	`fsm_sdata
(
f
, 
TERMACK
, (
u_char
)
id
, 
NULL
, 0);

722 case 
LS_REQSENT
:

723 case 
LS_ACKSENT
:

725 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

726 if (
ret
 < 0) {

727 
f
->
state
 = 
LS_STOPPED
;

729 
	`fsm_sconfreq
(
f
, 0);

733 case 
LS_ACKRCVD
:

735 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

736 
	`fsm_sconfreq
(
f
, 0);

737 
f
->
state
 = 
LS_REQSENT
;

740 case 
LS_OPENED
:

742 if (
f
->
callbacks
->
down
) {

743 (*
f
->
callbacks
->
down
)(f);

745 
	`fsm_sconfreq
(
f
, 0);

746 
f
->
state
 = 
LS_REQSENT
;

749 
	}
}

756 
	$fsm_rtermreq
(
fsm
 *
f
, int 
id
, 
u_char
 *
p
, int 
len
)

758 
	`LWIP_UNUSED_ARG
(
p
);

760 
	`FSMDEBUG
((
LOG_INFO
, "fsm_rtermreq(%s): Rcvd id %d state=%d (%s)\n",

761 
	`PROTO_NAME
(
f
), 
id
, f->
state
, 
ppperr_strerr
[f->state]));

763 switch (
f
->
state
) {

764 case 
LS_ACKRCVD
:

765 case 
LS_ACKSENT
:

766 
f
->
state
 = 
LS_REQSENT
;

769 case 
LS_OPENED
:

770 if (
len
 > 0) {

771 
	`FSMDEBUG
((
LOG_INFO
, "%s terminated by peer (%x)\n", 
	`PROTO_NAME
(
f
), 
p
));

773 
	`FSMDEBUG
((
LOG_INFO
, "%s terminated by peer\n", 
	`PROTO_NAME
(
f
)));

775 if (
f
->
callbacks
->
down
) {

776 (*
f
->
callbacks
->
down
)(f);

778 
f
->
retransmits
 = 0;

779 
f
->
state
 = 
LS_STOPPING
;

780 
	`TIMEOUT
(
fsm_timeout
, 
f
, f->
timeouttime
);

784 
	`fsm_sdata
(
f
, 
TERMACK
, (
u_char
)
id
, 
NULL
, 0);

785 
	}
}

792 
	$fsm_rtermack
(
fsm
 *
f
)

794 
	`FSMDEBUG
((
LOG_INFO
, "fsm_rtermack(%s): state=%d (%s)\n",

795 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

797 switch (
f
->
state
) {

798 case 
LS_CLOSING
:

799 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

800 
f
->
state
 = 
LS_CLOSED
;

801 if( 
f
->
callbacks
->
finished
 ) {

802 (*
f
->
callbacks
->
finished
)(f);

806 case 
LS_STOPPING
:

807 
	`UNTIMEOUT
(
fsm_timeout
, 
f
);

808 
f
->
state
 = 
LS_STOPPED
;

809 if( 
f
->
callbacks
->
finished
 ) {

810 (*
f
->
callbacks
->
finished
)(f);

814 case 
LS_ACKRCVD
:

815 
f
->
state
 = 
LS_REQSENT
;

818 case 
LS_OPENED
:

819 if (
f
->
callbacks
->
down
) {

820 (*
f
->
callbacks
->
down
)(f);

822 
	`fsm_sconfreq
(
f
, 0);

825 
	}
}

832 
	$fsm_rcoderej
(
fsm
 *
f
, 
u_char
 *
inp
, int 
len
)

834 
u_char
 
code
, 
id
;

836 
	`FSMDEBUG
((
LOG_INFO
, "fsm_rcoderej(%s): state=%d (%s)\n",

837 
	`PROTO_NAME
(
f
), f->
state
, 
ppperr_strerr
[f->state]));

839 if (
len
 < 
HEADERLEN
) {

840 
	`FSMDEBUG
((
LOG_INFO
, "fsm_rcoderej: Rcvd short Code-Reject packet!\n"));

843 
	`GETCHAR
(
code
, 
inp
);

844 
	`GETCHAR
(
id
, 
inp
);

845 
	`FSMDEBUG
((
LOG_WARNING
, "%s: Rcvd Code-Reject for code %d, id %d\n",

846 
	`PROTO_NAME
(
f
), 
code
, 
id
));

848 if( 
f
->
state
 == 
LS_ACKRCVD
 ) {

849 
f
->
state
 = 
LS_REQSENT
;

851 
	}
}

858 
	$fsm_sconfreq
(
fsm
 *
f
, int 
retransmit
)

860 
u_char
 *
outp
;

861 int 
cilen
;

863 if( 
f
->
state
 != 
LS_REQSENT
 && f->state != 
LS_ACKRCVD
 && f->state != 
LS_ACKSENT
 ) {

865 if( 
f
->
callbacks
->
resetci
 ) {

866 (*
f
->
callbacks
->
resetci
)(f);

868 
f
->
nakloops
 = 0;

871 if( !
retransmit
 ) {

873 
f
->
retransmits
 = f->
maxconfreqtransmits
;

874 
f
->
reqid
 = ++f->
id
;

877 
f
->
seen_ack
 = 0;

882 
outp
 = 
outpacket_buf
[
f
->
unit
] + 
PPP_HDRLEN
 + 
HEADERLEN
;

883 if( 
f
->
callbacks
->
cilen
 && f->callbacks->
addci
 ) {

884 
cilen
 = (*
f
->
callbacks
->cilen)(f);

885 if( 
cilen
 > 
peer_mru
[
f
->
unit
] - (int)
HEADERLEN
 ) {

886 
cilen
 = 
peer_mru
[
f
->
unit
] - 
HEADERLEN
;

888 if (
f
->
callbacks
->
addci
) {

889 (*
f
->
callbacks
->
addci
)(f, 
outp
, &
cilen
);

892 
cilen
 = 0;

896 
	`fsm_sdata
(
f
, 
CONFREQ
, f->
reqid
, 
outp
, 
cilen
);

899 --
f
->
retransmits
;

900 
	`TIMEOUT
(
fsm_timeout
, 
f
, f->
timeouttime
);

902 
	`FSMDEBUG
((
LOG_INFO
, "%s: sending Configure-Request, id %d\n",

903 
	`PROTO_NAME
(
f
), f->
reqid
));

904 
	}
}

	@/root/Robux/net/lwip/netif/ppp/fsm.h

54 #ifndef 
FSM_H


55 #define 
	#FSM_H


	)

63 #define 
	#HEADERLEN
 (sizeof (
u_char
) + sizeof (u_char) + sizeof (
u_short
))

	)

69 #define 
	#CONFREQ
 1

	)

70 #define 
	#CONFACK
 2

	)

71 #define 
	#CONFNAK
 3

	)

72 #define 
	#CONFREJ
 4

	)

73 #define 
	#TERMREQ
 5

	)

74 #define 
	#TERMACK
 6

	)

75 #define 
	#CODEREJ
 7

	)

80 #define 
	#LS_INITIAL
 0

	)

81 #define 
	#LS_STARTING
 1

	)

82 #define 
	#LS_CLOSED
 2

	)

83 #define 
	#LS_STOPPED
 3

	)

84 #define 
	#LS_CLOSING
 4

	)

85 #define 
	#LS_STOPPING
 5

	)

86 #define 
	#LS_REQSENT
 6

	)

87 #define 
	#LS_ACKRCVD
 7

	)

88 #define 
	#LS_ACKSENT
 8

	)

89 #define 
	#LS_OPENED
 9

	)

94 #define 
	#OPT_PASSIVE
 1

	)

95 #define 
	#OPT_RESTART
 2

	)

96 #define 
	#OPT_SILENT
 4

	)

105 typedef struct 
	sfsm
 {

106 int 
	munit
;

107 
u_short
 
	mprotocol
;

108 int 
	mstate
;

109 int 
	mflags
;

110 
u_char
 
	mid
;

111 
u_char
 
	mreqid
;

112 
u_char
 
	mseen_ack
;

113 int 
	mtimeouttime
;

114 int 
	mmaxconfreqtransmits
;

115 int 
	mretransmits
;

116 int 
	mmaxtermtransmits
;

117 int 
	mnakloops
;

118 int 
	mmaxnakloops
;

119 struct 
fsm_callbacks
* 
	mcallbacks
;

120 char* 
	mterm_reason
;

121 int 
	mterm_reason_len
;

122 } 
	tfsm
;

125 typedef struct 
	sfsm_callbacks
 {

126 void (*
	mresetci
)(
	mfsm
*);

127 int (*
	mcilen
)(
	mfsm
*);

128 void (*
	maddci
)(
	mfsm
*, 
	mu_char
*, int*);

129 int (*
	mackci
)(
	mfsm
*, 
	mu_char
*, int);

130 int (*
	mnakci
)(
	mfsm
*, 
	mu_char
*, int);

131 int (*
	mrejci
)(
	mfsm
*, 
	mu_char
*, int);

132 int (*
	mreqci
)(
	mfsm
*, 
	mu_char
*, int*, int);

133 void (*
	mup
)(
	mfsm
*);

134 void (*
	mdown
)(
	mfsm
*);

135 void (*
	mstarting
)(
	mfsm
*);

136 void (*
	mfinished
)(
	mfsm
*);

137 void (*
	mprotreject
)(int);

138 void (*
	mretransmit
)(
	mfsm
*);

139 int (*
	mextcode
)(
	mfsm
*, int, 
	mu_char
, u_char*, int);

140 char *
	mproto_name
;

141 } 
	tfsm_callbacks
;

150 extern int 
peer_mru
[];

160 void 
fsm_init
 (
fsm
*);

161 void 
fsm_lowerup
 (
fsm
*);

162 void 
fsm_lowerdown
 (
fsm
*);

163 void 
fsm_open
 (
fsm
*);

164 void 
fsm_close
 (
fsm
*, char*);

165 void 
fsm_input
 (
fsm
*, 
u_char
*, int);

166 void 
fsm_protreject
 (
fsm
*);

167 void 
fsm_sdata
 (
fsm
*, 
u_char
, u_char, u_char*, int);

	@/root/Robux/net/lwip/netif/ppp/ipcp.c

52 #include 
	~"lwip/opt.h
"

54 #if 
PPP_SUPPORT


56 #include 
	~"ppp.h
"

57 #include 
	~"pppdebug.h
"

59 #include 
	~"auth.h
"

60 #include 
	~"fsm.h
"

61 #include 
	~"vj.h
"

62 #include 
	~"ipcp.h
"

64 #include 
	~<string.h
>

74 #define 
	#CILEN_VOID
 2

	)

75 #define 
	#CILEN_COMPRESS
 4

	)

76 #define 
	#CILEN_VJ
 6

	)

77 #define 
	#CILEN_ADDR
 6

	)

78 #define 
	#CILEN_ADDRS
 10

	)

88 static void 
ipcp_resetci
 (
fsm
 *);

89 static int 
ipcp_cilen
 (
fsm
 *);

90 static void 
ipcp_addci
 (
fsm
 *, 
u_char
 *, int *);

91 static int 
ipcp_ackci
 (
fsm
 *, 
u_char
 *, int);

92 static int 
ipcp_nakci
 (
fsm
 *, 
u_char
 *, int);

93 static int 
ipcp_rejci
 (
fsm
 *, 
u_char
 *, int);

94 static int 
ipcp_reqci
 (
fsm
 *, 
u_char
 *, int *, int);

95 static void 
ipcp_up
 (
fsm
 *);

96 static void 
ipcp_down
 (
fsm
 *);

98 static void 
ipcp_script
 (
fsm
 *, char *);

100 static void 
ipcp_finished
 (
fsm
 *);

105 static void 
ipcp_init
 (int);

106 static void 
ipcp_open
 (int);

107 static void 
ipcp_close
 (int, char *);

108 static void 
ipcp_lowerup
 (int);

109 static void 
ipcp_lowerdown
 (int);

110 static void 
ipcp_input
 (int, 
u_char
 *, int);

111 static void 
ipcp_protrej
 (int);

113 static void 
ipcp_clear_addrs
 (int);

115 #define 
	#CODENAME
(
x
) ((x) == 
CONFACK
 ? "ACK" : \

116 (
x
) == 
CONFNAK
 ? "NAK" : "REJ")

	)

124 
ipcp_options
 
	gipcp_wantoptions
[
NUM_PPP
];

125 
ipcp_options
 
	gipcp_gotoptions
[
NUM_PPP
];

126 
ipcp_options
 
	gipcp_allowoptions
[
NUM_PPP
];

127 
ipcp_options
 
	gipcp_hisoptions
[
NUM_PPP
];

129 
fsm
 
	gipcp_fsm
[
NUM_PPP
];

131 struct 
protent
 
	gipcp_protent
 = {

132 
PPP_IPCP
,

133 
ipcp_init
,

134 
ipcp_input
,

135 
ipcp_protrej
,

136 
ipcp_lowerup
,

137 
ipcp_lowerdown
,

138 
ipcp_open
,

139 
ipcp_close
,

141 
ipcp_printpkt
,

142 
NULL
,

147 
ip_check_options
,

148 
NULL
,

149 
ip_active_pkt


159 static int 
	gcis_received
[
NUM_PPP
];

160 static int 
	gdefault_route_set
[
NUM_PPP
];

162 static 
fsm_callbacks
 
	gipcp_callbacks
 = {

163 
ipcp_resetci
,

164 
ipcp_cilen
,

165 
ipcp_addci
,

166 
ipcp_ackci
,

167 
ipcp_nakci
,

168 
ipcp_rejci
,

169 
ipcp_reqci
,

170 
ipcp_up
,

171 
ipcp_down
,

172 
NULL
,

173 
ipcp_finished
,

174 
NULL
,

175 
NULL
,

176 
NULL
,

192 
	$_inet_ntoa
(
u32_t
 
n
)

194 struct 
in_addr
 
ia
;

195 
ia
.
s_addr
 = 
n
;

196 return 
	`inet_ntoa
(
ia
);

197 
	}
}

199 #define 
	#inet_ntoa
 
_inet_ntoa


	)

205 
	$ipcp_init
(int 
unit
)

207 
fsm
 *
f
 = &
ipcp_fsm
[
unit
];

208 
ipcp_options
 *
wo
 = &
ipcp_wantoptions
[
unit
];

209 
ipcp_options
 *
ao
 = &
ipcp_allowoptions
[
unit
];

211 
f
->
unit
 = unit;

212 
f
->
protocol
 = 
PPP_IPCP
;

213 
f
->
callbacks
 = &
ipcp_callbacks
;

214 
	`fsm_init
(&
ipcp_fsm
[
unit
]);

216 
	`memset
(
wo
, 0, sizeof(*wo));

217 
	`memset
(
ao
, 0, sizeof(*ao));

219 
wo
->
neg_addr
 = 1;

220 
wo
->
ouraddr
 = 0;

221 #if 
VJ_SUPPORT


222 
wo
->
neg_vj
 = 1;

224 
wo
->
neg_vj
 = 0;

226 
wo
->
vj_protocol
 = 
IPCP_VJ_COMP
;

227 
wo
->
maxslotindex
 = 
MAX_SLOTS
 - 1;

228 
wo
->
cflag
 = 0;

229 
wo
->
default_route
 = 1;

231 
ao
->
neg_addr
 = 1;

232 #if 
VJ_SUPPORT


233 
ao
->
neg_vj
 = 1;

235 
ao
->
neg_vj
 = 0;

237 
ao
->
maxslotindex
 = 
MAX_SLOTS
 - 1;

238 
ao
->
cflag
 = 1;

239 
ao
->
default_route
 = 1;

240 
	}
}

247 
	$ipcp_open
(int 
unit
)

249 
	`fsm_open
(&
ipcp_fsm
[
unit
]);

250 
	}
}

257 
	$ipcp_close
(int 
unit
, char *
reason
)

259 
	`fsm_close
(&
ipcp_fsm
[
unit
], 
reason
);

260 
	}
}

267 
	$ipcp_lowerup
(int 
unit
)

269 
	`fsm_lowerup
(&
ipcp_fsm
[
unit
]);

270 
	}
}

277 
	$ipcp_lowerdown
(int 
unit
)

279 
	`fsm_lowerdown
(&
ipcp_fsm
[
unit
]);

280 
	}
}

287 
	$ipcp_input
(int 
unit
, 
u_char
 *
p
, int 
len
)

289 
	`fsm_input
(&
ipcp_fsm
[
unit
], 
p
, 
len
);

290 
	}
}

299 
	$ipcp_protrej
(int 
unit
)

301 
	`fsm_lowerdown
(&
ipcp_fsm
[
unit
]);

302 
	}
}

309 
	$ipcp_resetci
(
fsm
 *
f
)

311 
ipcp_options
 *
wo
 = &
ipcp_wantoptions
[
f
->
unit
];

313 
wo
->
req_addr
 = wo->
neg_addr
 && 
ipcp_allowoptions
[
f
->
unit
].neg_addr;

314 if (
wo
->
ouraddr
 == 0) {

315 
wo
->
accept_local
 = 1;

317 if (
wo
->
hisaddr
 == 0) {

318 
wo
->
accept_remote
 = 1;

321 
wo
->
req_dns1
 = 
ppp_settings
.
usepeerdns
;

322 
wo
->
req_dns2
 = 
ppp_settings
.
usepeerdns
;

323 
ipcp_gotoptions
[
f
->
unit
] = *
wo
;

324 
cis_received
[
f
->
unit
] = 0;

325 
	}
}

332 
	$ipcp_cilen
(
fsm
 *
f
)

334 
ipcp_options
 *
go
 = &
ipcp_gotoptions
[
f
->
unit
];

335 
ipcp_options
 *
wo
 = &
ipcp_wantoptions
[
f
->
unit
];

336 
ipcp_options
 *
ho
 = &
ipcp_hisoptions
[
f
->
unit
];

338 #define 
	#LENCIVJ
(
neg
, 
old
) (neg ? (old? 
CILEN_COMPRESS
 : 
CILEN_VJ
) : 0)

	)

339 #define 
	#LENCIADDR
(
neg
, 
old
) (neg ? (old? 
CILEN_ADDRS
 : 
CILEN_ADDR
) : 0)

	)

340 #define 
	#LENCIDNS
(
neg
) (neg ? (
CILEN_ADDR
) : 0)

	)

346 if (
wo
->
neg_addr
 && !
go
->neg_addr && !go->
old_addrs
) {

348 
go
->
neg_addr
 = 1;

349 
go
->
old_addrs
 = 1;

351 if (
wo
->
neg_vj
 && !
go
->neg_vj && !go->
old_vj
) {

353 if (
cis_received
[
f
->
unit
] == 0) {

355 
go
->
neg_vj
 = 1;

358 if (
ho
->
neg_vj
 && ho->
old_vj
) {

359 
go
->
neg_vj
 = 1;

360 
go
->
old_vj
 = 1;

361 
go
->
vj_protocol
 = 
ho
->vj_protocol;

366 return (
	`LENCIADDR
(
go
->
neg_addr
, go->
old_addrs
) +

367 
	`LENCIVJ
(
go
->
neg_vj
, go->
old_vj
) +

368 
	`LENCIDNS
(
go
->
req_dns1
) +

369 
	`LENCIDNS
(
go
->
req_dns2
));

370 
	}
}

377 
	$ipcp_addci
(
fsm
 *
f
, 
u_char
 *
ucp
, int *
lenp
)

379 
ipcp_options
 *
go
 = &
ipcp_gotoptions
[
f
->
unit
];

380 int 
len
 = *
lenp
;

382 #define 
	#ADDCIVJ
(
opt
, 
neg
, 
val
, 
old
, 
maxslotindex
, 
cflag
) \

383 if (
neg
) { \

384 int 
vjlen
 = 
old
? 
CILEN_COMPRESS
 : 
CILEN_VJ
; \

385 if (
len
 >= 
vjlen
) { \

386 
	`PUTCHAR
(
opt
, 
ucp
); \

387 
	`PUTCHAR
(
vjlen
, 
ucp
); \

388 
	`PUTSHORT
(
val
, 
ucp
); \

389 if (!
old
) { \

390 
	`PUTCHAR
(
maxslotindex
, 
ucp
); \

391 
	`PUTCHAR
(
cflag
, 
ucp
); \

393 
len
 -= 
vjlen
; \

395 
neg
 = 0; \

397 }

	)

399 #define 
	#ADDCIADDR
(
opt
, 
neg
, 
old
, 
val1
, 
val2
) \

400 if (
neg
) { \

401 int 
addrlen
 = (
old
? 
CILEN_ADDRS
: 
CILEN_ADDR
); \

402 if (
len
 >= 
addrlen
) { \

403 
u32_t
 
l
; \

404 
	`PUTCHAR
(
opt
, 
ucp
); \

405 
	`PUTCHAR
(
addrlen
, 
ucp
); \

406 
l
 = 
	`ntohl
(
val1
); \

407 
	`PUTLONG
(
l
, 
ucp
); \

408 if (
old
) { \

409 
l
 = 
	`ntohl
(
val2
); \

410 
	`PUTLONG
(
l
, 
ucp
); \

412 
len
 -= 
addrlen
; \

414 
neg
 = 0; \

416 }

	)

418 #define 
	#ADDCIDNS
(
opt
, 
neg
, 
addr
) \

419 if (
neg
) { \

420 if (
len
 >= 
CILEN_ADDR
) { \

421 
u32_t
 
l
; \

422 
	`PUTCHAR
(
opt
, 
ucp
); \

423 
	`PUTCHAR
(
CILEN_ADDR
, 
ucp
); \

424 
l
 = 
	`ntohl
(
addr
); \

425 
	`PUTLONG
(
l
, 
ucp
); \

426 
len
 -= 
CILEN_ADDR
; \

428 
neg
 = 0; \

430 }

	)

432 
	`ADDCIADDR
((
go
->
old_addrs
? 
CI_ADDRS
: 
CI_ADDR
), go->
neg_addr
,

433 
go
->
old_addrs
, go->
ouraddr
, go->
hisaddr
);

435 
	`ADDCIVJ
(
CI_COMPRESSTYPE
, 
go
->
neg_vj
, go->
vj_protocol
, go->
old_vj
,

436 
go
->
maxslotindex
, go->
cflag
);

438 
	`ADDCIDNS
(
CI_MS_DNS1
, 
go
->
req_dns1
, go->
dnsaddr
[0]);

440 
	`ADDCIDNS
(
CI_MS_DNS2
, 
go
->
req_dns2
, go->
dnsaddr
[1]);

442 *
lenp
 -= 
len
;

443 
	}
}

454 
	$ipcp_ackci
(
fsm
 *
f
, 
u_char
 *
p
, int 
len
)

456 
ipcp_options
 *
go
 = &
ipcp_gotoptions
[
f
->
unit
];

457 
u_short
 
cilen
, 
citype
, 
cishort
;

458 
u32_t
 
cilong
;

459 
u_char
 
cimaxslotindex
, 
cicflag
;

467 #define 
	#ACKCIVJ
(
opt
, 
neg
, 
val
, 
old
, 
maxslotindex
, 
cflag
) \

468 if (
neg
) { \

469 int 
vjlen
 = 
old
? 
CILEN_COMPRESS
 : 
CILEN_VJ
; \

470 if ((
len
 -= 
vjlen
) < 0) { \

471 goto 
bad
; \

473 
	`GETCHAR
(
citype
, 
p
); \

474 
	`GETCHAR
(
cilen
, 
p
); \

475 if (
cilen
 != 
vjlen
 || \

476 
citype
 != 
opt
) { \

477 goto 
bad
; \

479 
	`GETSHORT
(
cishort
, 
p
); \

480 if (
cishort
 != 
val
) { \

481 goto 
bad
; \

483 if (!
old
) { \

484 
	`GETCHAR
(
cimaxslotindex
, 
p
); \

485 if (
cimaxslotindex
 != 
maxslotindex
) { \

486 goto 
bad
; \

488 
	`GETCHAR
(
cicflag
, 
p
); \

489 if (
cicflag
 != 
cflag
) { \

490 goto 
bad
; \

493 }

	)

495 #define 
	#ACKCIADDR
(
opt
, 
neg
, 
old
, 
val1
, 
val2
) \

496 if (
neg
) { \

497 int 
addrlen
 = (
old
? 
CILEN_ADDRS
: 
CILEN_ADDR
); \

498 
u32_t
 
l
; \

499 if ((
len
 -= 
addrlen
) < 0) { \

500 goto 
bad
; \

502 
	`GETCHAR
(
citype
, 
p
); \

503 
	`GETCHAR
(
cilen
, 
p
); \

504 if (
cilen
 != 
addrlen
 || \

505 
citype
 != 
opt
) { \

506 goto 
bad
; \

508 
	`GETLONG
(
l
, 
p
); \

509 
cilong
 = 
	`htonl
(
l
); \

510 if (
val1
 != 
cilong
) { \

511 goto 
bad
; \

513 if (
old
) { \

514 
	`GETLONG
(
l
, 
p
); \

515 
cilong
 = 
	`htonl
(
l
); \

516 if (
val2
 != 
cilong
) { \

517 goto 
bad
; \

520 }

	)

522 #define 
	#ACKCIDNS
(
opt
, 
neg
, 
addr
) \

523 if (
neg
) { \

524 
u32_t
 
l
; \

525 if ((
len
 -= 
CILEN_ADDR
) < 0) { \

526 goto 
bad
; \

528 
	`GETCHAR
(
citype
, 
p
); \

529 
	`GETCHAR
(
cilen
, 
p
); \

530 if (
cilen
 != 
CILEN_ADDR
 || \

531 
citype
 != 
opt
) { \

532 goto 
bad
; \

534 
	`GETLONG
(
l
, 
p
); \

535 
cilong
 = 
	`htonl
(
l
); \

536 if (
addr
 != 
cilong
) { \

537 goto 
bad
; \

539 }

	)

541 
	`ACKCIADDR
((
go
->
old_addrs
? 
CI_ADDRS
: 
CI_ADDR
), go->
neg_addr
,

542 
go
->
old_addrs
, go->
ouraddr
, go->
hisaddr
);

544 
	`ACKCIVJ
(
CI_COMPRESSTYPE
, 
go
->
neg_vj
, go->
vj_protocol
, go->
old_vj
,

545 
go
->
maxslotindex
, go->
cflag
);

547 
	`ACKCIDNS
(
CI_MS_DNS1
, 
go
->
req_dns1
, go->
dnsaddr
[0]);

549 
	`ACKCIDNS
(
CI_MS_DNS2
, 
go
->
req_dns2
, go->
dnsaddr
[1]);

554 if (
len
 != 0) {

555 goto 
bad
;

559 
bad
:

560 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_ackci: received bad Ack!\n"));

562 
	}
}

574 
	$ipcp_nakci
(
fsm
 *
f
, 
u_char
 *
p
, int 
len
)

576 
ipcp_options
 *
go
 = &
ipcp_gotoptions
[
f
->
unit
];

577 
u_char
 
cimaxslotindex
, 
cicflag
;

578 
u_char
 
citype
, 
cilen
, *
next
;

579 
u_short
 
cishort
;

580 
u32_t
 
ciaddr1
, 
ciaddr2
, 
l
, 
cidnsaddr
;

581 
ipcp_options
 
no
;

582 
ipcp_options
 
try
;

584 
	`BZERO
(&
no
, sizeof(no));

585 
try
 = *
go
;

592 #define 
	#NAKCIADDR
(
opt
, 
neg
, 
old
, 
code
) \

593 if (
go
->
neg
 && \

594 
len
 >= (
cilen
 = (
old
? 
CILEN_ADDRS
: 
CILEN_ADDR
)) && \

595 
p
[1] == 
cilen
 && \

596 
p
[0] == 
opt
) { \

597 
len
 -= 
cilen
; \

598 
	`INCPTR
(2, 
p
); \

599 
	`GETLONG
(
l
, 
p
); \

600 
ciaddr1
 = 
	`htonl
(
l
); \

601 if (
old
) { \

602 
	`GETLONG
(
l
, 
p
); \

603 
ciaddr2
 = 
	`htonl
(
l
); \

604 
no
.
old_addrs
 = 1; \

606 
ciaddr2
 = 0; \

608 
no
.
neg
 = 1; \

609 
code
 \

610 }

	)

612 #define 
	#NAKCIVJ
(
opt
, 
neg
, 
code
) \

613 if (
go
->
neg
 && \

614 ((
cilen
 = 
p
[1]) == 
CILEN_COMPRESS
 || cilen == 
CILEN_VJ
) && \

615 
len
 >= 
cilen
 && \

616 
p
[0] == 
opt
) { \

617 
len
 -= 
cilen
; \

618 
	`INCPTR
(2, 
p
); \

619 
	`GETSHORT
(
cishort
, 
p
); \

620 
no
.
neg
 = 1; \

621 
code
 \

622 }

	)

624 #define 
	#NAKCIDNS
(
opt
, 
neg
, 
code
) \

625 if (
go
->
neg
 && \

626 ((
cilen
 = 
p
[1]) == 
CILEN_ADDR
) && \

627 
len
 >= 
cilen
 && \

628 
p
[0] == 
opt
) { \

629 
len
 -= 
cilen
; \

630 
	`INCPTR
(2, 
p
); \

631 
	`GETLONG
(
l
, 
p
); \

632 
cidnsaddr
 = 
	`htonl
(
l
); \

633 
no
.
neg
 = 1; \

634 
code
 \

635 }

	)

641 
	`NAKCIADDR
((
go
->
old_addrs
? 
CI_ADDRS
: 
CI_ADDR
), 
neg_addr
, go->old_addrs,

642 if (
go
->
accept_local
 && 
ciaddr1
) {

643 
try
.
ouraddr
 = 
ciaddr1
;

644 
	`IPCPDEBUG
((
LOG_INFO
, "local IP address %s\n",

645 
	`inet_ntoa
(
ciaddr1
)));

647 if (
go
->
accept_remote
 && 
ciaddr2
) {

648 
try
.
hisaddr
 = 
ciaddr2
;

649 
	`IPCPDEBUG
((
LOG_INFO
, "remote IP address %s\n",

650 
	`inet_ntoa
(
ciaddr2
)));

660 
	`NAKCIVJ
(
CI_COMPRESSTYPE
, 
neg_vj
,

661 if (
cilen
 == 
CILEN_VJ
) {

662 
	`GETCHAR
(
cimaxslotindex
, 
p
);

663 
	`GETCHAR
(
cicflag
, 
p
);

664 if (
cishort
 == 
IPCP_VJ_COMP
) {

665 
try
.
old_vj
 = 0;

666 if (
cimaxslotindex
 < 
go
->
maxslotindex
) {

667 
try
.
maxslotindex
 = 
cimaxslotindex
;

669 if (!
cicflag
) {

670 
try
.
cflag
 = 0;

673 
try
.
neg_vj
 = 0;

676 if (
cishort
 == 
IPCP_VJ_COMP
 || cishort == 
IPCP_VJ_COMP_OLD
) {

677 
try
.
old_vj
 = 1;

678 
try
.
vj_protocol
 = 
cishort
;

680 
try
.
neg_vj
 = 0;

685 
	`NAKCIDNS
(
CI_MS_DNS1
, 
req_dns1
,

686 
try
.
dnsaddr
[0] = 
cidnsaddr
;

687 
	`IPCPDEBUG
((
LOG_INFO
, "primary DNS address %s\n", 
	`inet_ntoa
(
cidnsaddr
)));

690 
	`NAKCIDNS
(
CI_MS_DNS2
, 
req_dns2
,

691 
try
.
dnsaddr
[1] = 
cidnsaddr
;

692 
	`IPCPDEBUG
((
LOG_INFO
, "secondary DNS address %s\n", 
	`inet_ntoa
(
cidnsaddr
)));

701 while (
len
 > 
CILEN_VOID
) {

702 
	`GETCHAR
(
citype
, 
p
);

703 
	`GETCHAR
(
cilen
, 
p
);

704 if( (
len
 -= 
cilen
) < 0 ) {

705 goto 
bad
;

707 
next
 = 
p
 + 
cilen
 - 2;

709 switch (
citype
) {

710 case 
CI_COMPRESSTYPE
:

711 if (
go
->
neg_vj
 || 
no
.neg_vj ||

712 (
cilen
 != 
CILEN_VJ
 && cilen != 
CILEN_COMPRESS
)) {

713 goto 
bad
;

715 
no
.
neg_vj
 = 1;

717 case 
CI_ADDRS
:

718 if ((
go
->
neg_addr
 && go->
old_addrs
) || 
no
.old_addrs

719 || 
cilen
 != 
CILEN_ADDRS
) {

720 goto 
bad
;

722 
try
.
neg_addr
 = 1;

723 
try
.
old_addrs
 = 1;

724 
	`GETLONG
(
l
, 
p
);

725 
ciaddr1
 = 
	`htonl
(
l
);

726 if (
ciaddr1
 && 
go
->
accept_local
) {

727 
try
.
ouraddr
 = 
ciaddr1
;

729 
	`GETLONG
(
l
, 
p
);

730 
ciaddr2
 = 
	`htonl
(
l
);

731 if (
ciaddr2
 && 
go
->
accept_remote
) {

732 
try
.
hisaddr
 = 
ciaddr2
;

734 
no
.
old_addrs
 = 1;

736 case 
CI_ADDR
:

737 if (
go
->
neg_addr
 || 
no
.neg_addr || 
cilen
 != 
CILEN_ADDR
) {

738 goto 
bad
;

740 
try
.
old_addrs
 = 0;

741 
	`GETLONG
(
l
, 
p
);

742 
ciaddr1
 = 
	`htonl
(
l
);

743 if (
ciaddr1
 && 
go
->
accept_local
) {

744 
try
.
ouraddr
 = 
ciaddr1
;

746 if (
try
.
ouraddr
 != 0) {

747 
try
.
neg_addr
 = 1;

749 
no
.
neg_addr
 = 1;

752 
p
 = 
next
;

756 if (
len
 != 0) {

757 goto 
bad
;

763 if (
f
->
state
 != 
LS_OPENED
) {

764 *
go
 = 
try
;

769 
bad
:

770 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_nakci: received bad Nak!\n"));

772 
	}
}

779 
	$ipcp_rejci
(
fsm
 *
f
, 
u_char
 *
p
, int 
len
)

781 
ipcp_options
 *
go
 = &
ipcp_gotoptions
[
f
->
unit
];

782 
u_char
 
cimaxslotindex
, 
ciflag
, 
cilen
;

783 
u_short
 
cishort
;

784 
u32_t
 
cilong
;

785 
ipcp_options
 
try
;

787 
try
 = *
go
;

793 #define 
	#REJCIADDR
(
opt
, 
neg
, 
old
, 
val1
, 
val2
) \

794 if (
go
->
neg
 && \

795 
len
 >= (
cilen
 = 
old
? 
CILEN_ADDRS
: 
CILEN_ADDR
) && \

796 
p
[1] == 
cilen
 && \

797 
p
[0] == 
opt
) { \

798 
u32_t
 
l
; \

799 
len
 -= 
cilen
; \

800 
	`INCPTR
(2, 
p
); \

801 
	`GETLONG
(
l
, 
p
); \

802 
cilong
 = 
	`htonl
(
l
); \

804 if (
cilong
 != 
val1
) { \

805 goto 
bad
; \

807 if (
old
) { \

808 
	`GETLONG
(
l
, 
p
); \

809 
cilong
 = 
	`htonl
(
l
); \

811 if (
cilong
 != 
val2
) { \

812 goto 
bad
; \

815 
try
.
neg
 = 0; \

816 }

	)

818 #define 
	#REJCIVJ
(
opt
, 
neg
, 
val
, 
old
, 
maxslot
, 
cflag
) \

819 if (
go
->
neg
 && \

820 
p
[1] == (
old
? 
CILEN_COMPRESS
 : 
CILEN_VJ
) && \

821 
len
 >= 
p
[1] && \

822 
p
[0] == 
opt
) { \

823 
len
 -= 
p
[1]; \

824 
	`INCPTR
(2, 
p
); \

825 
	`GETSHORT
(
cishort
, 
p
); \

827 if (
cishort
 != 
val
) { \

828 goto 
bad
; \

830 if (!
old
) { \

831 
	`GETCHAR
(
cimaxslotindex
, 
p
); \

832 if (
cimaxslotindex
 != 
maxslot
) { \

833 goto 
bad
; \

835 
	`GETCHAR
(
ciflag
, 
p
); \

836 if (
ciflag
 != 
cflag
) { \

837 goto 
bad
; \

840 
try
.
neg
 = 0; \

841 }

	)

843 #define 
	#REJCIDNS
(
opt
, 
neg
, 
dnsaddr
) \

844 if (
go
->
neg
 && \

845 ((
cilen
 = 
p
[1]) == 
CILEN_ADDR
) && \

846 
len
 >= 
cilen
 && \

847 
p
[0] == 
opt
) { \

848 
u32_t
 
l
; \

849 
len
 -= 
cilen
; \

850 
	`INCPTR
(2, 
p
); \

851 
	`GETLONG
(
l
, 
p
); \

852 
cilong
 = 
	`htonl
(
l
); \

854 if (
cilong
 != 
dnsaddr
) { \

855 goto 
bad
; \

857 
try
.
neg
 = 0; \

858 }

	)

860 
	`REJCIADDR
((
go
->
old_addrs
? 
CI_ADDRS
: 
CI_ADDR
), 
neg_addr
,

861 
go
->
old_addrs
, go->
ouraddr
, go->
hisaddr
);

863 
	`REJCIVJ
(
CI_COMPRESSTYPE
, 
neg_vj
, 
go
->
vj_protocol
, go->
old_vj
,

864 
go
->
maxslotindex
, go->
cflag
);

866 
	`REJCIDNS
(
CI_MS_DNS1
, 
req_dns1
, 
go
->
dnsaddr
[0]);

868 
	`REJCIDNS
(
CI_MS_DNS2
, 
req_dns2
, 
go
->
dnsaddr
[1]);

873 if (
len
 != 0) {

874 goto 
bad
;

879 if (
f
->
state
 != 
LS_OPENED
) {

880 *
go
 = 
try
;

884 
bad
:

885 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_rejci: received bad Reject!\n"));

887 
	}
}

898 
	$ipcp_reqci
(
fsm
 *
f
, 
u_char
 *
inp
 ,int *
len
 ,int 
reject_if_disagree
)

900 
ipcp_options
 *
wo
 = &
ipcp_wantoptions
[
f
->
unit
];

901 
ipcp_options
 *
ho
 = &
ipcp_hisoptions
[
f
->
unit
];

902 
ipcp_options
 *
ao
 = &
ipcp_allowoptions
[
f
->
unit
];

903 #ifdef 
OLD_CI_ADDRS


904 
ipcp_options
 *
go
 = &
ipcp_gotoptions
[
f
->
unit
];

906 
u_char
 *
cip
, *
next
;

907 
u_short
 
cilen
, 
citype
;

908 
u_short
 
cishort
;

909 
u32_t
 
tl
, 
ciaddr1
;

910 #ifdef 
OLD_CI_ADDRS


911 
u32_t
 
ciaddr2
;

913 int 
rc
 = 
CONFACK
;

914 int 
orc
;

915 
u_char
 *
p
;

916 
u_char
 *
ucp
 = 
inp
;

917 int 
l
 = *
len
;

918 
u_char
 
maxslotindex
, 
cflag
;

919 int 
d
;

921 
cis_received
[
f
->
unit
] = 1;

926 
	`BZERO
(
ho
, sizeof(*ho));

931 
next
 = 
inp
;

932 while (
l
) {

933 
orc
 = 
CONFACK
;

934 
cip
 = 
p
 = 
next
;

935 if (
l
 < 2 ||

936 
p
[1] < 2 ||

937 
p
[1] > 
l
) {

938 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: bad CI length!\n"));

939 
orc
 = 
CONFREJ
;

940 
cilen
 = 
l
;

941 
l
 = 0;

942 goto 
endswitch
;

944 
	`GETCHAR
(
citype
, 
p
);

945 
	`GETCHAR
(
cilen
, 
p
);

946 
l
 -= 
cilen
;

947 
next
 += 
cilen
;

949 switch (
citype
) {

950 #ifdef 
OLD_CI_ADDRS


951 case 
CI_ADDRS
:

952 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: received ADDRS\n"));

953 if (!
ao
->
neg_addr
 ||

954 
cilen
 != 
CILEN_ADDRS
) {

955 
orc
 = 
CONFREJ
;

965 
	`GETLONG
(
tl
, 
p
);

966 
ciaddr1
 = 
	`htonl
(
tl
);

967 
	`IPCPDEBUG
((
LOG_INFO
, "his addr %s\n", 
	`inet_ntoa
(
ciaddr1
)));

968 if (
ciaddr1
 != 
wo
->
hisaddr


969 && (
ciaddr1
 == 0 || !
wo
->
accept_remote
)) {

970 
orc
 = 
CONFNAK
;

971 if (!
reject_if_disagree
) {

972 
	`DECPTR
(sizeof(
u32_t
), 
p
);

973 
tl
 = 
	`ntohl
(
wo
->
hisaddr
);

974 
	`PUTLONG
(
tl
, 
p
);

976 } else if (
ciaddr1
 == 0 && 
wo
->
hisaddr
 == 0) {

980 
orc
 = 
CONFREJ
;

981 
wo
->
req_addr
 = 0;

989 
	`GETLONG
(
tl
, 
p
);

990 
ciaddr2
 = 
	`htonl
(
tl
);

991 
	`IPCPDEBUG
((
LOG_INFO
, "our addr %s\n", 
	`inet_ntoa
(
ciaddr2
)));

992 if (
ciaddr2
 != 
wo
->
ouraddr
) {

993 if (
ciaddr2
 == 0 || !
wo
->
accept_local
) {

994 
orc
 = 
CONFNAK
;

995 if (!
reject_if_disagree
) {

996 
	`DECPTR
(sizeof(
u32_t
), 
p
);

997 
tl
 = 
	`ntohl
(
wo
->
ouraddr
);

998 
	`PUTLONG
(
tl
, 
p
);

1001 
go
->
ouraddr
 = 
ciaddr2
;

1005 
ho
->
neg_addr
 = 1;

1006 
ho
->
old_addrs
 = 1;

1007 
ho
->
hisaddr
 = 
ciaddr1
;

1008 
ho
->
ouraddr
 = 
ciaddr2
;

1012 case 
CI_ADDR
:

1013 if (!
ao
->
neg_addr
) {

1014 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Reject ADDR not allowed\n"));

1015 
orc
 = 
CONFREJ
;

1017 } else if (
cilen
 != 
CILEN_ADDR
) {

1018 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Reject ADDR bad len\n"));

1019 
orc
 = 
CONFREJ
;

1029 
	`GETLONG
(
tl
, 
p
);

1030 
ciaddr1
 = 
	`htonl
(
tl
);

1031 if (
ciaddr1
 != 
wo
->
hisaddr


1032 && (
ciaddr1
 == 0 || !
wo
->
accept_remote
)) {

1033 
orc
 = 
CONFNAK
;

1034 if (!
reject_if_disagree
) {

1035 
	`DECPTR
(sizeof(
u32_t
), 
p
);

1036 
tl
 = 
	`ntohl
(
wo
->
hisaddr
);

1037 
	`PUTLONG
(
tl
, 
p
);

1039 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Nak ADDR %s\n", 
	`inet_ntoa
(
ciaddr1
)));

1040 } else if (
ciaddr1
 == 0 && 
wo
->
hisaddr
 == 0) {

1044 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Reject ADDR %s\n", 
	`inet_ntoa
(
ciaddr1
)));

1045 
orc
 = 
CONFREJ
;

1046 
wo
->
req_addr
 = 0;

1050 
ho
->
neg_addr
 = 1;

1051 
ho
->
hisaddr
 = 
ciaddr1
;

1052 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: ADDR %s\n", 
	`inet_ntoa
(
ciaddr1
)));

1055 case 
CI_MS_DNS1
:

1056 case 
CI_MS_DNS2
:

1058 
d
 = 
citype
 == 
CI_MS_DNS2
;

1061 if (
ao
->
dnsaddr
[
d
] == 0 ||

1062 
cilen
 != 
CILEN_ADDR
) {

1063 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Rejecting DNS%d Request\n", 
d
+1));

1064 
orc
 = 
CONFREJ
;

1067 
	`GETLONG
(
tl
, 
p
);

1068 if (
	`htonl
(
tl
) != 
ao
->
dnsaddr
[
d
]) {

1069 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Naking DNS%d Request %d\n",

1070 
d
+1, 
	`inet_ntoa
(
tl
)));

1071 
	`DECPTR
(sizeof(
u32_t
), 
p
);

1072 
tl
 = 
	`ntohl
(
ao
->
dnsaddr
[
d
]);

1073 
	`PUTLONG
(
tl
, 
p
);

1074 
orc
 = 
CONFNAK
;

1076 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: received DNS%d Request\n", 
d
+1));

1079 case 
CI_MS_WINS1
:

1080 case 
CI_MS_WINS2
:

1082 
d
 = 
citype
 == 
CI_MS_WINS2
;

1083 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: received WINS%d Request\n", 
d
+1));

1086 if (
ao
->
winsaddr
[
d
] == 0 ||

1087 
cilen
 != 
CILEN_ADDR
) {

1088 
orc
 = 
CONFREJ
;

1091 
	`GETLONG
(
tl
, 
p
);

1092 if (
	`htonl
(
tl
) != 
ao
->
winsaddr
[
d
]) {

1093 
	`DECPTR
(sizeof(
u32_t
), 
p
);

1094 
tl
 = 
	`ntohl
(
ao
->
winsaddr
[
d
]);

1095 
	`PUTLONG
(
tl
, 
p
);

1096 
orc
 = 
CONFNAK
;

1100 case 
CI_COMPRESSTYPE
:

1101 if (!
ao
->
neg_vj
) {

1102 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Rejecting COMPRESSTYPE not allowed\n"));

1103 
orc
 = 
CONFREJ
;

1105 } else if (
cilen
 != 
CILEN_VJ
 && cilen != 
CILEN_COMPRESS
) {

1106 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Rejecting COMPRESSTYPE len=%d\n", 
cilen
));

1107 
orc
 = 
CONFREJ
;

1110 
	`GETSHORT
(
cishort
, 
p
);

1112 if (!(
cishort
 == 
IPCP_VJ_COMP
 ||

1113 (
cishort
 == 
IPCP_VJ_COMP_OLD
 && 
cilen
 == 
CILEN_COMPRESS
))) {

1114 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Rejecting COMPRESSTYPE %d\n", 
cishort
));

1115 
orc
 = 
CONFREJ
;

1119 
ho
->
neg_vj
 = 1;

1120 
ho
->
vj_protocol
 = 
cishort
;

1121 if (
cilen
 == 
CILEN_VJ
) {

1122 
	`GETCHAR
(
maxslotindex
, 
p
);

1123 if (
maxslotindex
 > 
ao
->maxslotindex) {

1124 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Naking VJ max slot %d\n", 
maxslotindex
));

1125 
orc
 = 
CONFNAK
;

1126 if (!
reject_if_disagree
) {

1127 
	`DECPTR
(1, 
p
);

1128 
	`PUTCHAR
(
ao
->
maxslotindex
, 
p
);

1131 
	`GETCHAR
(
cflag
, 
p
);

1132 if (
cflag
 && !
ao
->cflag) {

1133 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Naking VJ cflag %d\n", 
cflag
));

1134 
orc
 = 
CONFNAK
;

1135 if (!
reject_if_disagree
) {

1136 
	`DECPTR
(1, 
p
);

1137 
	`PUTCHAR
(
wo
->
cflag
, 
p
);

1140 
ho
->
maxslotindex
 = maxslotindex;

1141 
ho
->
cflag
 = cflag;

1143 
ho
->
old_vj
 = 1;

1144 
ho
->
maxslotindex
 = 
MAX_SLOTS
 - 1;

1145 
ho
->
cflag
 = 1;

1147 
	`IPCPDEBUG
((
LOG_INFO
,

1149 
ho
->
vj_protocol
, ho->
old_vj
, ho->
maxslotindex
, ho->
cflag
));

1153 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Rejecting unknown CI type %d\n", 
citype
));

1154 
orc
 = 
CONFREJ
;

1158 
endswitch
:

1159 if (
orc
 == 
CONFACK
 &&

1160 
rc
 != 
CONFACK
) {

1164 if (
orc
 == 
CONFNAK
) {

1165 if (
reject_if_disagree
) {

1166 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Rejecting too many naks\n"));

1167 
orc
 = 
CONFREJ
;

1169 if (
rc
 == 
CONFREJ
) {

1172 if (
rc
 == 
CONFACK
) {

1173 
rc
 = 
CONFNAK
;

1174 
ucp
 = 
inp
;

1179 if (
orc
 == 
CONFREJ
 &&

1180 
rc
 != 
CONFREJ
) {

1181 
rc
 = 
CONFREJ
;

1182 
ucp
 = 
inp
;

1186 if (
ucp
 != 
cip
) {

1187 
	`BCOPY
(
cip
, 
ucp
, 
cilen
);

1191 
	`INCPTR
(
cilen
, 
ucp
);

1201 if (
rc
 != 
CONFREJ
 && !
ho
->
neg_addr
 &&

1202 
wo
->
req_addr
 && !
reject_if_disagree
) {

1203 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: Requesting peer address\n"));

1204 if (
rc
 == 
CONFACK
) {

1205 
rc
 = 
CONFNAK
;

1206 
ucp
 = 
inp
;

1207 
wo
->
req_addr
 = 0;

1209 
	`PUTCHAR
(
CI_ADDR
, 
ucp
);

1210 
	`PUTCHAR
(
CILEN_ADDR
, 
ucp
);

1211 
tl
 = 
	`ntohl
(
wo
->
hisaddr
);

1212 
	`PUTLONG
(
tl
, 
ucp
);

1215 *
len
 = (int)(
ucp
 - 
inp
);

1216 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp_reqci: returning Configure-%s\n", 
	`CODENAME
(
rc
)));

1217 return (
rc
);

1218 
	}
}

1227 
	$ip_check_options
(
u_long
 
localAddr
)

1229 
ipcp_options
 *
wo
 = &
ipcp_wantoptions
[0];

1235 if (
wo
->
ouraddr
 == 0 && !
ppp_settings
.
disable_defaultip
) {

1236 
wo
->
accept_local
 = 1;

1237 
wo
->
ouraddr
 = 
	`htonl
(
localAddr
);

1239 
	}
}

1249 
	$ipcp_up
(
fsm
 *
f
)

1251 
u32_t
 
mask
;

1252 
ipcp_options
 *
ho
 = &
ipcp_hisoptions
[
f
->
unit
];

1253 
ipcp_options
 *
go
 = &
ipcp_gotoptions
[
f
->
unit
];

1254 
ipcp_options
 *
wo
 = &
ipcp_wantoptions
[
f
->
unit
];

1256 
	`np_up
(
f
->
unit
, 
PPP_IP
);

1257 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp: up\n"));

1262 if (!
ho
->
neg_addr
) {

1263 
ho
->
hisaddr
 = 
wo
->hisaddr;

1266 if (
ho
->
hisaddr
 == 0) {

1267 
	`IPCPDEBUG
((
LOG_ERR
, "Could not determine remote IP address\n"));

1268 
	`ipcp_close
(
f
->
unit
, "Could not determine remote IP address");

1271 if (
go
->
ouraddr
 == 0) {

1272 
	`IPCPDEBUG
((
LOG_ERR
, "Could not determine local IP address\n"));

1273 
	`ipcp_close
(
f
->
unit
, "Could not determine local IP address");

1277 if (
ppp_settings
.
usepeerdns
 && (
go
->
dnsaddr
[0] || go->dnsaddr[1])) {

1284 if (!
	`auth_ip_addr
(
f
->
unit
, 
ho
->
hisaddr
)) {

1285 
	`IPCPDEBUG
((
LOG_ERR
, "Peer is not authorized to use remote address %s\n",

1286 
	`inet_ntoa
(
ho
->
hisaddr
)));

1287 
	`ipcp_close
(
f
->
unit
, "Unauthorized remote IP address");

1292 
	`sifvjcomp
(
f
->
unit
, 
ho
->
neg_vj
, ho->
cflag
, ho->
maxslotindex
);

1297 
mask
 = 
	`GetMask
(
go
->
ouraddr
);

1299 if (!
	`sifaddr
(
f
->
unit
, 
go
->
ouraddr
, 
ho
->
hisaddr
, 
mask
, go->
dnsaddr
[0], go->dnsaddr[1])) {

1300 
	`IPCPDEBUG
((
LOG_WARNING
, "sifaddr failed\n"));

1301 
	`ipcp_close
(
f
->
unit
, "Interface configuration failed");

1306 if (!
	`sifup
(
f
->
unit
)) {

1307 
	`IPCPDEBUG
((
LOG_WARNING
, "sifup failed\n"));

1308 
	`ipcp_close
(
f
->
unit
, "Interface configuration failed");

1312 
	`sifnpmode
(
f
->
unit
, 
PPP_IP
, 
NPMODE_PASS
);

1315 if (
ipcp_wantoptions
[
f
->
unit
].
default_route
) {

1316 if (
	`sifdefaultroute
(
f
->
unit
, 
go
->
ouraddr
, 
ho
->
hisaddr
)) {

1317 
default_route_set
[
f
->
unit
] = 1;

1321 
	`IPCPDEBUG
((
LOG_NOTICE
, "local IP address %s\n", 
	`inet_ntoa
(
go
->
ouraddr
)));

1322 
	`IPCPDEBUG
((
LOG_NOTICE
, "remote IP address %s\n", 
	`inet_ntoa
(
ho
->
hisaddr
)));

1323 if (
go
->
dnsaddr
[0]) {

1324 
	`IPCPDEBUG
((
LOG_NOTICE
, "primary DNS address %s\n", 
	`inet_ntoa
(
go
->
dnsaddr
[0])));

1326 if (
go
->
dnsaddr
[1]) {

1327 
	`IPCPDEBUG
((
LOG_NOTICE
, "secondary DNS address %s\n", 
	`inet_ntoa
(
go
->
dnsaddr
[1])));

1329 
	}
}

1339 
	$ipcp_down
(
fsm
 *
f
)

1341 
	`IPCPDEBUG
((
LOG_INFO
, "ipcp: down\n"));

1342 
	`np_down
(
f
->
unit
, 
PPP_IP
);

1343 
	`sifvjcomp
(
f
->
unit
, 0, 0, 0);

1345 
	`sifdown
(
f
->
unit
);

1346 
	`ipcp_clear_addrs
(
f
->
unit
);

1347 
	}
}

1354 
	$ipcp_clear_addrs
(int 
unit
)

1356 
u32_t
 
ouraddr
, 
hisaddr
;

1358 
ouraddr
 = 
ipcp_gotoptions
[
unit
].ouraddr;

1359 
hisaddr
 = 
ipcp_hisoptions
[
unit
].hisaddr;

1360 if (
default_route_set
[
unit
]) {

1361 
	`cifdefaultroute
(
unit
, 
ouraddr
, 
hisaddr
);

1362 
default_route_set
[
unit
] = 0;

1364 
	`cifaddr
(
unit
, 
ouraddr
, 
hisaddr
);

1365 
	}
}

1372 
	$ipcp_finished
(
fsm
 *
f
)

1374 
	`np_finished
(
f
->
unit
, 
PPP_IP
);

1375 
	}
}

1379 
ipcp_printpkt
(
u_char
 *
p
, int 
plen
, void (*
printer
) (void *, char *, ...), void *
arg
)

1381 
	`LWIP_UNUSED_ARG
(
p
);

1382 
	`LWIP_UNUSED_ARG
(
plen
);

1383 
	`LWIP_UNUSED_ARG
(
printer
);

1384 
	`LWIP_UNUSED_ARG
(
arg
);

1386 
	}
}

1393 #define 
	#IP_HDRLEN
 20

	)

1394 #define 
	#IP_OFFMASK
 0x1fff

	)

1395 #define 
	#IPPROTO_TCP
 6

	)

1396 #define 
	#TCP_HDRLEN
 20

	)

1397 #define 
	#TH_FIN
 0x01

	)

1404 #define 
	#net_short
(
x
) (((x)[0] << 8) + (x)[1])

	)

1405 #define 
	#get_iphl
(
x
) (((unsigned char *)(x))[0] & 0xF)

	)

1406 #define 
	#get_ipoff
(
x
) 
	`net_short
((unsigned char *)(x) + 6)

	)

1407 #define 
	#get_ipproto
(
x
) (((unsigned char *)(x))[9])

	)

1408 #define 
	#get_tcpoff
(
x
) (((unsigned char *)(x))[12] >> 4)

	)

1409 #define 
	#get_tcpflags
(
x
) (((unsigned char *)(x))[13])

	)

1412 
	$ip_active_pkt
(
u_char
 *
pkt
, int 
len
)

1414 
u_char
 *
tcp
;

1415 int 
hlen
;

1417 
len
 -= 
PPP_HDRLEN
;

1418 
pkt
 += 
PPP_HDRLEN
;

1419 if (
len
 < 
IP_HDRLEN
) {

1422 if ((
	`get_ipoff
(
pkt
) & 
IP_OFFMASK
) != 0) {

1425 if (
	`get_ipproto
(
pkt
) != 
IPPROTO_TCP
) {

1428 
hlen
 = 
	`get_iphl
(
pkt
) * 4;

1429 if (
len
 < 
hlen
 + 
TCP_HDRLEN
) {

1432 
tcp
 = 
pkt
 + 
hlen
;

1433 if ((
	`get_tcpflags
(
tcp
) & 
TH_FIN
) != 0 && 
len
 == 
hlen
 + 
	`get_tcpoff
(tcp) * 4) {

1437 
	}
}

	@/root/Robux/net/lwip/netif/ppp/ipcp.h

54 #ifndef 
IPCP_H


55 #define 
	#IPCP_H


	)

63 #define 
	#CI_ADDRS
 1

	)

64 #define 
	#CI_COMPRESSTYPE
 2

	)

65 #define 
	#CI_ADDR
 3

	)

67 #define 
	#CI_MS_WINS1
 128

	)

68 #define 
	#CI_MS_DNS1
 129

	)

69 #define 
	#CI_MS_WINS2
 130

	)

70 #define 
	#CI_MS_DNS2
 131

	)

72 #define 
	#IPCP_VJMODE_OLD
 1

	)

73 #define 
	#IPCP_VJMODE_RFC1172
 2

	)

74 #define 
	#IPCP_VJMODE_RFC1332
 3

	)

77 #define 
	#IPCP_VJ_COMP
 0x002d

	)

78 #define 
	#IPCP_VJ_COMP_OLD
 0x0037

	)

86 typedef struct 
	sipcp_options
 {

87 
u_int
 
	mneg_addr
 : 1;

88 
u_int
 
	mold_addrs
 : 1;

89 
u_int
 
	mreq_addr
 : 1;

90 
u_int
 
	mdefault_route
 : 1;

91 
u_int
 
	mproxy_arp
 : 1;

92 
u_int
 
	mneg_vj
 : 1;

93 
u_int
 
	mold_vj
 : 1;

94 
u_int
 
	maccept_local
 : 1;

95 
u_int
 
	maccept_remote
 : 1;

96 
u_int
 
	mreq_dns1
 : 1;

97 
u_int
 
	mreq_dns2
 : 1;

98 
u_short
 
	mvj_protocol
;

99 
u_char
 
	mmaxslotindex
;

100 
u_char
 
	mcflag
;

101 
u32_t
 
	mouraddr
, 
	mhisaddr
;

102 
u32_t
 
	mdnsaddr
[2];

103 
u32_t
 
	mwinsaddr
[2];

104 } 
	tipcp_options
;

111 extern 
fsm
 
ipcp_fsm
[];

112 extern 
ipcp_options
 
ipcp_wantoptions
[];

113 extern 
ipcp_options
 
ipcp_gotoptions
[];

114 extern 
ipcp_options
 
ipcp_allowoptions
[];

115 extern 
ipcp_options
 
ipcp_hisoptions
[];

117 extern struct 
protent
 
ipcp_protent
;

	@/root/Robux/net/lwip/netif/ppp/lcp.c

54 #include 
	~"lwip/opt.h
"

56 #if 
PPP_SUPPORT


58 #include 
	~"ppp.h
"

59 #include 
	~"pppdebug.h
"

61 #include 
	~"fsm.h
"

62 #include 
	~"chap.h
"

63 #include 
	~"magic.h
"

64 #include 
	~"auth.h
"

65 #include 
	~"lcp.h
"

67 #include 
	~<string.h
>

69 #if 
PPPOE_SUPPORT


70 #include 
	~"netif/ppp_oe.h
"

72 #define 
	#PPPOE_MAXMTU
 
PPP_MAXMRU


	)

82 #define 
	#CILEN_VOID
 2

	)

83 #define 
	#CILEN_CHAR
 3

	)

84 #define 
	#CILEN_SHORT
 4

	)

85 #define 
	#CILEN_CHAP
 5

	)

86 #define 
	#CILEN_LONG
 6

	)

87 #define 
	#CILEN_LQR
 8

	)

88 #define 
	#CILEN_CBCP
 3

	)

97 static void 
lcp_resetci
 (
fsm
*);

98 static int 
lcp_cilen
 (
fsm
*);

99 static void 
lcp_addci
 (
fsm
*, 
u_char
*, int*);

100 static int 
lcp_ackci
 (
fsm
*, 
u_char
*, int);

101 static int 
lcp_nakci
 (
fsm
*, 
u_char
*, int);

102 static int 
lcp_rejci
 (
fsm
*, 
u_char
*, int);

103 static int 
lcp_reqci
 (
fsm
*, 
u_char
*, int*, int);

104 static void 
lcp_up
 (
fsm
*);

105 static void 
lcp_down
 (
fsm
*);

106 static void 
lcp_starting
 (
fsm
*);

107 static void 
lcp_finished
 (
fsm
*);

108 static int 
lcp_extcode
 (
fsm
*, int, 
u_char
, u_char*, int);

110 static void 
lcp_rprotrej
 (
fsm
*, 
u_char
*, int);

115 static void 
lcp_echo_lowerup
 (int);

116 static void 
lcp_echo_lowerdown
 (int);

117 static void 
LcpEchoTimeout
 (void*);

118 static void 
lcp_received_echo_reply
 (
fsm
*, int, 
u_char
*, int);

119 static void 
LcpSendEchoRequest
 (
fsm
*);

120 static void 
LcpLinkFailure
 (
fsm
*);

121 static void 
LcpEchoCheck
 (
fsm
*);

127 static void 
lcp_input
 (int, 
u_char
 *, int);

128 static void 
lcp_protrej
 (int);

130 #define 
	#CODENAME
(
x
) ((x) == 
CONFACK
 ? "ACK" : (x) == 
CONFNAK
 ? "NAK" : "REJ")

	)

137 
LinkPhase
 
	glcp_phase
[
NUM_PPP
];

138 
lcp_options
 
	glcp_wantoptions
[
NUM_PPP
];

139 
lcp_options
 
	glcp_gotoptions
[
NUM_PPP
];

140 
lcp_options
 
	glcp_allowoptions
[
NUM_PPP
];

141 
lcp_options
 
	glcp_hisoptions
[
NUM_PPP
];

142 
ext_accm
 
	gxmit_accm
[
NUM_PPP
];

149 static 
fsm
 
	glcp_fsm
[
NUM_PPP
];

150 static 
u_int
 
	glcp_echo_interval
 = 
LCP_ECHOINTERVAL
;

151 static 
u_int
 
	glcp_echo_fails
 = 
LCP_MAXECHOFAILS
;

152 static 
u32_t
 
	glcp_echos_pending
 = 0;

153 static 
u32_t
 
	glcp_echo_number
 = 0;

154 static 
u32_t
 
	glcp_echo_timer_running
 = 0;

156 static 
u_char
 
	gnak_buffer
[
PPP_MRU
];

158 static 
fsm_callbacks
 
	glcp_callbacks
 = {

159 
lcp_resetci
,

160 
lcp_cilen
,

161 
lcp_addci
,

162 
lcp_ackci
,

163 
lcp_nakci
,

164 
lcp_rejci
,

165 
lcp_reqci
,

166 
lcp_up
,

167 
lcp_down
,

168 
lcp_starting
,

169 
lcp_finished
,

170 
NULL
,

171 
NULL
,

172 
lcp_extcode
,

176 struct 
protent
 
	glcp_protent
 = {

177 
PPP_LCP
,

178 
lcp_init
,

179 
lcp_input
,

180 
lcp_protrej
,

181 
lcp_lowerup
,

182 
lcp_lowerdown
,

183 
lcp_open
,

184 
lcp_close
,

186 
lcp_printpkt
,

187 
NULL
,

192 
NULL
,

193 
NULL
,

194 
NULL


198 int 
	glcp_loopbackfail
 = 
DEFLOOPBACKFAIL
;

209 
	$lcp_init
(int 
unit
)

211 
fsm
 *
f
 = &
lcp_fsm
[
unit
];

212 
lcp_options
 *
wo
 = &
lcp_wantoptions
[
unit
];

213 
lcp_options
 *
ao
 = &
lcp_allowoptions
[
unit
];

215 
f
->
unit
 = unit;

216 
f
->
protocol
 = 
PPP_LCP
;

217 
f
->
callbacks
 = &
lcp_callbacks
;

219 
	`fsm_init
(
f
);

221 
wo
->
passive
 = 0;

222 
wo
->
silent
 = 0;

223 
wo
->
restart
 = 0;

224 
wo
->
neg_mru
 = 1;

225 
wo
->
mru
 = 
PPP_DEFMRU
;

226 
wo
->
neg_asyncmap
 = 1;

227 
wo
->
asyncmap
 = 0x00000000l;

228 
wo
->
neg_chap
 = 0;

229 
wo
->
neg_upap
 = 0;

230 
wo
->
chap_mdtype
 = 
CHAP_DIGEST_MD5
;

231 
wo
->
neg_magicnumber
 = 1;

232 
wo
->
neg_pcompression
 = 1;

233 
wo
->
neg_accompression
 = 1;

234 
wo
->
neg_lqr
 = 0;

235 
wo
->
neg_cbcp
 = 0;

237 
ao
->
neg_mru
 = 1;

238 
ao
->
mru
 = 
PPP_MAXMRU
;

239 
ao
->
neg_asyncmap
 = 1;

240 
ao
->
asyncmap
 = 0x00000000l;

241 
ao
->
neg_chap
 = (
CHAP_SUPPORT
 != 0);

242 
ao
->
chap_mdtype
 = 
CHAP_DIGEST_MD5
;

243 
ao
->
neg_upap
 = (
PAP_SUPPORT
 != 0);

244 
ao
->
neg_magicnumber
 = 1;

245 
ao
->
neg_pcompression
 = 1;

246 
ao
->
neg_accompression
 = 1;

247 
ao
->
neg_lqr
 = 0;

248 
ao
->
neg_cbcp
 = (
CBCP_SUPPORT
 != 0);

254 
	`memset
(
xmit_accm
[
unit
], 0, sizeof(xmit_accm[0]));

255 
xmit_accm
[
unit
][15] = 0x60;

256 
xmit_accm
[
unit
][0] = (
u_char
)((
ao
->
asyncmap
 & 0xFF));

257 
xmit_accm
[
unit
][1] = (
u_char
)((
ao
->
asyncmap
 >> 8) & 0xFF);

258 
xmit_accm
[
unit
][2] = (
u_char
)((
ao
->
asyncmap
 >> 16) & 0xFF);

259 
xmit_accm
[
unit
][3] = (
u_char
)((
ao
->
asyncmap
 >> 24) & 0xFF);

260 
	`LCPDEBUG
((
LOG_INFO
, "lcp_init: xmit_accm=%X %X %X %X\n",

261 
xmit_accm
[
unit
][0],

262 
xmit_accm
[
unit
][1],

263 
xmit_accm
[
unit
][2],

264 
xmit_accm
[
unit
][3]));

266 
lcp_phase
[
unit
] = 
PHASE_INITIALIZE
;

267 
	}
}

274 
	$lcp_open
(int 
unit
)

276 
fsm
 *
f
 = &
lcp_fsm
[
unit
];

277 
lcp_options
 *
wo
 = &
lcp_wantoptions
[
unit
];

279 
f
->
flags
 = 0;

280 if (
wo
->
passive
) {

281 
f
->
flags
 |= 
OPT_PASSIVE
;

283 if (
wo
->
silent
) {

284 
f
->
flags
 |= 
OPT_SILENT
;

286 
	`fsm_open
(
f
);

288 
lcp_phase
[
unit
] = 
PHASE_ESTABLISH
;

289 
	}
}

296 
	$lcp_close
(int 
unit
, char *
reason
)

298 
fsm
 *
f
 = &
lcp_fsm
[
unit
];

300 if (
lcp_phase
[
unit
] != 
PHASE_DEAD
) {

301 
lcp_phase
[
unit
] = 
PHASE_TERMINATE
;

303 if (
f
->
state
 == 
LS_STOPPED
 && f->
flags
 & (
OPT_PASSIVE
|
OPT_SILENT
)) {

310 
f
->
state
 = 
LS_CLOSED
;

311 
	`lcp_finished
(
f
);

313 
	`fsm_close
(&
lcp_fsm
[
unit
], 
reason
);

315 
	}
}

322 
	$lcp_lowerup
(int 
unit
)

324 
lcp_options
 *
wo
 = &
lcp_wantoptions
[
unit
];

331 
	`ppp_set_xaccm
(
unit
, &
xmit_accm
[unit]);

332 
	`ppp_send_config
(
unit
, 
PPP_MRU
, 0xffffffffl, 0, 0);

333 
	`ppp_recv_config
(
unit
, 
PPP_MRU
, 0x00000000l,

334 
wo
->
neg_pcompression
, wo->
neg_accompression
);

335 
peer_mru
[
unit
] = 
PPP_MRU
;

336 
lcp_allowoptions
[
unit
].
asyncmap
 = (
u_long
)
xmit_accm
[unit][0]

337 | ((
u_long
)
xmit_accm
[
unit
][1] << 8)

338 | ((
u_long
)
xmit_accm
[
unit
][2] << 16)

339 | ((
u_long
)
xmit_accm
[
unit
][3] << 24);

340 
	`LCPDEBUG
((
LOG_INFO
, "lcp_lowerup: asyncmap=%X %X %X %X\n",

341 
xmit_accm
[
unit
][3],

342 
xmit_accm
[
unit
][2],

343 
xmit_accm
[
unit
][1],

344 
xmit_accm
[
unit
][0]));

346 
	`fsm_lowerup
(&
lcp_fsm
[
unit
]);

347 
	}
}

354 
	$lcp_lowerdown
(int 
unit
)

356 
	`fsm_lowerdown
(&
lcp_fsm
[
unit
]);

357 
	}
}

363 
	$lcp_sprotrej
(int 
unit
, 
u_char
 *
p
, int 
len
)

370 
	`fsm_sdata
(&
lcp_fsm
[
unit
], 
PROTREJ
, ++lcp_fsm[unit].
id
, 
p
, 
len
);

371 
	}
}

382 
	$lcp_input
(int 
unit
, 
u_char
 *
p
, int 
len
)

384 
fsm
 *
f
 = &
lcp_fsm
[
unit
];

386 
	`fsm_input
(
f
, 
p
, 
len
);

387 
	}
}

394 
	$lcp_extcode
(
fsm
 *
f
, int 
code
, 
u_char
 
id
, u_char *
inp
, int 
len
)

396 
u_char
 *
magp
;

398 switch( 
code
 ){

399 case 
PROTREJ
:

400 
	`lcp_rprotrej
(
f
, 
inp
, 
len
);

403 case 
ECHOREQ
:

404 if (
f
->
state
 != 
LS_OPENED
) {

407 
	`LCPDEBUG
((
LOG_INFO
, "lcp: Echo-Request, Rcvd id %d\n", 
id
));

408 
magp
 = 
inp
;

409 
	`PUTLONG
(
lcp_gotoptions
[
f
->
unit
].
magicnumber
, 
magp
);

410 
	`fsm_sdata
(
f
, 
ECHOREP
, 
id
, 
inp
, 
len
);

413 case 
ECHOREP
:

414 
	`lcp_received_echo_reply
(
f
, 
id
, 
inp
, 
len
);

417 case 
DISCREQ
:

424 
	}
}

433 
	$lcp_rprotrej
(
fsm
 *
f
, 
u_char
 *
inp
, int 
len
)

435 int 
i
;

436 struct 
protent
 *
protp
;

437 
u_short
 
prot
;

439 if (
len
 < sizeof (
u_short
)) {

440 
	`LCPDEBUG
((
LOG_INFO
, "lcp_rprotrej: Rcvd short Protocol-Reject packet!\n"));

444 
	`GETSHORT
(
prot
, 
inp
);

446 
	`LCPDEBUG
((
LOG_INFO
, "lcp_rprotrej: Rcvd Protocol-Reject packet for %x!\n", 
prot
));

452 if( 
f
->
state
 != 
LS_OPENED
 ) {

453 
	`LCPDEBUG
((
LOG_INFO
, "Protocol-Reject discarded: LCP in state %d\n", 
f
->
state
));

460 for (
i
 = 0; (
protp
 = 
ppp_protocols
[i]) != 
NULL
; ++i) {

461 if (
protp
->
protocol
 == 
prot
 && protp->
enabled_flag
) {

462 (*
protp
->
protrej
)(
f
->
unit
);

467 
	`LCPDEBUG
((
LOG_WARNING
, "Protocol-Reject for unsupported protocol 0x%x\n", 
prot
));

468 
	}
}

475 
	$lcp_protrej
(int 
unit
)

477 
	`LWIP_UNUSED_ARG
(
unit
);

481 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_protrej: Received Protocol-Reject for LCP!\n"));

482 
	`fsm_protreject
(&
lcp_fsm
[
unit
]);

483 
	}
}

490 
	$lcp_resetci
(
fsm
 *
f
)

492 
lcp_wantoptions
[
f
->
unit
].
magicnumber
 = 
	`magic
();

493 
lcp_wantoptions
[
f
->
unit
].
numloops
 = 0;

494 
lcp_gotoptions
[
f
->
unit
] = 
lcp_wantoptions
[f->unit];

495 
peer_mru
[
f
->
unit
] = 
PPP_MRU
;

496 
	`auth_reset
(
f
->
unit
);

497 
	}
}

503 static int 
	$lcp_cilen
(
fsm
 *
f
)

505 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

507 #define 
	#LENCIVOID
(
neg
) ((neg) ? 
CILEN_VOID
 : 0)

	)

508 #define 
	#LENCICHAP
(
neg
) ((neg) ? 
CILEN_CHAP
 : 0)

	)

509 #define 
	#LENCISHORT
(
neg
) ((neg) ? 
CILEN_SHORT
 : 0)

	)

510 #define 
	#LENCILONG
(
neg
) ((neg) ? 
CILEN_LONG
 : 0)

	)

511 #define 
	#LENCILQR
(
neg
) ((neg) ? 
CILEN_LQR
: 0)

	)

512 #define 
	#LENCICBCP
(
neg
) ((neg) ? 
CILEN_CBCP
: 0)

	)

517 return (
	`LENCISHORT
(
go
->
neg_mru
 && go->
mru
 != 
PPP_DEFMRU
) +

518 
	`LENCILONG
(
go
->
neg_asyncmap
 && go->
asyncmap
 != 0xFFFFFFFFl) +

519 
	`LENCICHAP
(
go
->
neg_chap
) +

520 
	`LENCISHORT
(!
go
->
neg_chap
 && go->
neg_upap
) +

521 
	`LENCILQR
(
go
->
neg_lqr
) +

522 
	`LENCICBCP
(
go
->
neg_cbcp
) +

523 
	`LENCILONG
(
go
->
neg_magicnumber
) +

524 
	`LENCIVOID
(
go
->
neg_pcompression
) +

525 
	`LENCIVOID
(
go
->
neg_accompression
));

526 
	}
}

533 
	$lcp_addci
(
fsm
 *
f
, 
u_char
 *
ucp
, int *
lenp
)

535 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

536 
u_char
 *
start_ucp
 = 
ucp
;

538 #define 
	#ADDCIVOID
(
opt
, 
neg
) \

539 if (
neg
) { \

540 
	`LCPDEBUG
((
LOG_INFO
, "lcp_addci: opt=%d\n", 
opt
)); \

541 
	`PUTCHAR
(
opt
, 
ucp
); \

542 
	`PUTCHAR
(
CILEN_VOID
, 
ucp
); \

543 }

	)

544 #define 
	#ADDCISHORT
(
opt
, 
neg
, 
val
) \

545 if (
neg
) { \

546 
	`LCPDEBUG
((
LOG_INFO
, "lcp_addci: INT opt=%d %X\n", 
opt
, 
val
)); \

547 
	`PUTCHAR
(
opt
, 
ucp
); \

548 
	`PUTCHAR
(
CILEN_SHORT
, 
ucp
); \

549 
	`PUTSHORT
(
val
, 
ucp
); \

550 }

	)

551 #define 
	#ADDCICHAP
(
opt
, 
neg
, 
val
, 
digest
) \

552 if (
neg
) { \

553 
	`LCPDEBUG
((
LOG_INFO
, "lcp_addci: CHAP opt=%d %X\n", 
opt
, 
val
)); \

554 
	`PUTCHAR
(
opt
, 
ucp
); \

555 
	`PUTCHAR
(
CILEN_CHAP
, 
ucp
); \

556 
	`PUTSHORT
(
val
, 
ucp
); \

557 
	`PUTCHAR
(
digest
, 
ucp
); \

558 }

	)

559 #define 
	#ADDCILONG
(
opt
, 
neg
, 
val
) \

560 if (
neg
) { \

561 
	`LCPDEBUG
((
LOG_INFO
, "lcp_addci: L opt=%d %lX\n", 
opt
, 
val
)); \

562 
	`PUTCHAR
(
opt
, 
ucp
); \

563 
	`PUTCHAR
(
CILEN_LONG
, 
ucp
); \

564 
	`PUTLONG
(
val
, 
ucp
); \

565 }

	)

566 #define 
	#ADDCILQR
(
opt
, 
neg
, 
val
) \

567 if (
neg
) { \

568 
	`LCPDEBUG
((
LOG_INFO
, "lcp_addci: LQR opt=%d %lX\n", 
opt
, 
val
)); \

569 
	`PUTCHAR
(
opt
, 
ucp
); \

570 
	`PUTCHAR
(
CILEN_LQR
, 
ucp
); \

571 
	`PUTSHORT
(
PPP_LQR
, 
ucp
); \

572 
	`PUTLONG
(
val
, 
ucp
); \

573 }

	)

574 #define 
	#ADDCICHAR
(
opt
, 
neg
, 
val
) \

575 if (
neg
) { \

576 
	`LCPDEBUG
((
LOG_INFO
, "lcp_addci: CHAR opt=%d %X '%z'\n", 
opt
, 
val
, val)); \

577 
	`PUTCHAR
(
opt
, 
ucp
); \

578 
	`PUTCHAR
(
CILEN_CHAR
, 
ucp
); \

579 
	`PUTCHAR
(
val
, 
ucp
); \

580 }

	)

582 
	`ADDCISHORT
(
CI_MRU
, 
go
->
neg_mru
 && go->
mru
 != 
PPP_DEFMRU
, go->mru);

583 
	`ADDCILONG
(
CI_ASYNCMAP
, 
go
->
neg_asyncmap
 && go->
asyncmap
 != 0xFFFFFFFFl, go->asyncmap);

584 
	`ADDCICHAP
(
CI_AUTHTYPE
, 
go
->
neg_chap
, 
PPP_CHAP
, go->
chap_mdtype
);

585 
	`ADDCISHORT
(
CI_AUTHTYPE
, !
go
->
neg_chap
 && go->
neg_upap
, 
PPP_PAP
);

586 
	`ADDCILQR
(
CI_QUALITY
, 
go
->
neg_lqr
, go->
lqr_period
);

587 
	`ADDCICHAR
(
CI_CALLBACK
, 
go
->
neg_cbcp
, 
CBCP_OPT
);

588 
	`ADDCILONG
(
CI_MAGICNUMBER
, 
go
->
neg_magicnumber
, go->
magicnumber
);

589 
	`ADDCIVOID
(
CI_PCOMPRESSION
, 
go
->
neg_pcompression
);

590 
	`ADDCIVOID
(
CI_ACCOMPRESSION
, 
go
->
neg_accompression
);

592 if (
ucp
 - 
start_ucp
 != *
lenp
) {

594 
	`LCPDEBUG
((
LOG_ERR
, "Bug in lcp_addci: wrong length\n"));

596 
	}
}

608 
	$lcp_ackci
(
fsm
 *
f
, 
u_char
 *
p
, int 
len
)

610 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

611 
u_char
 
cilen
, 
citype
, 
cichar
;

612 
u_short
 
cishort
;

613 
u32_t
 
cilong
;

620 #define 
	#ACKCIVOID
(
opt
, 
neg
) \

621 if (
neg
) { \

622 if ((
len
 -= 
CILEN_VOID
) < 0) \

623 goto 
bad
; \

624 
	`GETCHAR
(
citype
, 
p
); \

625 
	`GETCHAR
(
cilen
, 
p
); \

626 if (
cilen
 != 
CILEN_VOID
 || 
citype
 != 
opt
) \

627 goto 
bad
; \

628 }

	)

629 #define 
	#ACKCISHORT
(
opt
, 
neg
, 
val
) \

630 if (
neg
) { \

631 if ((
len
 -= 
CILEN_SHORT
) < 0) \

632 goto 
bad
; \

633 
	`GETCHAR
(
citype
, 
p
); \

634 
	`GETCHAR
(
cilen
, 
p
); \

635 if (
cilen
 != 
CILEN_SHORT
 || 
citype
 != 
opt
) \

636 goto 
bad
; \

637 
	`GETSHORT
(
cishort
, 
p
); \

638 if (
cishort
 != 
val
) \

639 goto 
bad
; \

640 }

	)

641 #define 
	#ACKCICHAR
(
opt
, 
neg
, 
val
) \

642 if (
neg
) { \

643 if ((
len
 -= 
CILEN_CHAR
) < 0) \

644 goto 
bad
; \

645 
	`GETCHAR
(
citype
, 
p
); \

646 
	`GETCHAR
(
cilen
, 
p
); \

647 if (
cilen
 != 
CILEN_CHAR
 || 
citype
 != 
opt
) \

648 goto 
bad
; \

649 
	`GETCHAR
(
cichar
, 
p
); \

650 if (
cichar
 != 
val
) \

651 goto 
bad
; \

652 }

	)

653 #define 
	#ACKCICHAP
(
opt
, 
neg
, 
val
, 
digest
) \

654 if (
neg
) { \

655 if ((
len
 -= 
CILEN_CHAP
) < 0) \

656 goto 
bad
; \

657 
	`GETCHAR
(
citype
, 
p
); \

658 
	`GETCHAR
(
cilen
, 
p
); \

659 if (
cilen
 != 
CILEN_CHAP
 || 
citype
 != 
opt
) \

660 goto 
bad
; \

661 
	`GETSHORT
(
cishort
, 
p
); \

662 if (
cishort
 != 
val
) \

663 goto 
bad
; \

664 
	`GETCHAR
(
cichar
, 
p
); \

665 if (
cichar
 != 
digest
) \

666 goto 
bad
; \

667 }

	)

668 #define 
	#ACKCILONG
(
opt
, 
neg
, 
val
) \

669 if (
neg
) { \

670 if ((
len
 -= 
CILEN_LONG
) < 0) \

671 goto 
bad
; \

672 
	`GETCHAR
(
citype
, 
p
); \

673 
	`GETCHAR
(
cilen
, 
p
); \

674 if (
cilen
 != 
CILEN_LONG
 || 
citype
 != 
opt
) \

675 goto 
bad
; \

676 
	`GETLONG
(
cilong
, 
p
); \

677 if (
cilong
 != 
val
) \

678 goto 
bad
; \

679 }

	)

680 #define 
	#ACKCILQR
(
opt
, 
neg
, 
val
) \

681 if (
neg
) { \

682 if ((
len
 -= 
CILEN_LQR
) < 0) \

683 goto 
bad
; \

684 
	`GETCHAR
(
citype
, 
p
); \

685 
	`GETCHAR
(
cilen
, 
p
); \

686 if (
cilen
 != 
CILEN_LQR
 || 
citype
 != 
opt
) \

687 goto 
bad
; \

688 
	`GETSHORT
(
cishort
, 
p
); \

689 if (
cishort
 != 
PPP_LQR
) \

690 goto 
bad
; \

691 
	`GETLONG
(
cilong
, 
p
); \

692 if (
cilong
 != 
val
) \

693 goto 
bad
; \

694 }

	)

696 
	`ACKCISHORT
(
CI_MRU
, 
go
->
neg_mru
 && go->
mru
 != 
PPP_DEFMRU
, go->mru);

697 
	`ACKCILONG
(
CI_ASYNCMAP
, 
go
->
neg_asyncmap
 && go->
asyncmap
 != 0xFFFFFFFFl, go->asyncmap);

698 
	`ACKCICHAP
(
CI_AUTHTYPE
, 
go
->
neg_chap
, 
PPP_CHAP
, go->
chap_mdtype
);

699 
	`ACKCISHORT
(
CI_AUTHTYPE
, !
go
->
neg_chap
 && go->
neg_upap
, 
PPP_PAP
);

700 
	`ACKCILQR
(
CI_QUALITY
, 
go
->
neg_lqr
, go->
lqr_period
);

701 
	`ACKCICHAR
(
CI_CALLBACK
, 
go
->
neg_cbcp
, 
CBCP_OPT
);

702 
	`ACKCILONG
(
CI_MAGICNUMBER
, 
go
->
neg_magicnumber
, go->
magicnumber
);

703 
	`ACKCIVOID
(
CI_PCOMPRESSION
, 
go
->
neg_pcompression
);

704 
	`ACKCIVOID
(
CI_ACCOMPRESSION
, 
go
->
neg_accompression
);

709 if (
len
 != 0) {

710 goto 
bad
;

712 
	`LCPDEBUG
((
LOG_INFO
, "lcp_acki: Ack\n"));

714 
bad
:

715 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_acki: received bad Ack!\n"));

717 
	}
}

730 
	$lcp_nakci
(
fsm
 *
f
, 
u_char
 *
p
, int 
len
)

732 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

733 
lcp_options
 *
wo
 = &
lcp_wantoptions
[
f
->
unit
];

734 
u_char
 
citype
, 
cichar
, *
next
;

735 
u_short
 
cishort
;

736 
u32_t
 
cilong
;

737 
lcp_options
 
no
;

738 
lcp_options
 
try
;

739 int 
looped_back
 = 0;

740 int 
cilen
;

742 
	`BZERO
(&
no
, sizeof(no));

743 
try
 = *
go
;

750 #define 
	#NAKCIVOID
(
opt
, 
neg
, 
code
) \

751 if (
go
->
neg
 && \

752 
len
 >= 
CILEN_VOID
 && \

753 
p
[1] == 
CILEN_VOID
 && \

754 
p
[0] == 
opt
) { \

755 
len
 -= 
CILEN_VOID
; \

756 
	`INCPTR
(
CILEN_VOID
, 
p
); \

757 
no
.
neg
 = 1; \

758 
code
 \

759 }

	)

760 #define 
	#NAKCICHAP
(
opt
, 
neg
, 
code
) \

761 if (
go
->
neg
 && \

762 
len
 >= 
CILEN_CHAP
 && \

763 
p
[1] == 
CILEN_CHAP
 && \

764 
p
[0] == 
opt
) { \

765 
len
 -= 
CILEN_CHAP
; \

766 
	`INCPTR
(2, 
p
); \

767 
	`GETSHORT
(
cishort
, 
p
); \

768 
	`GETCHAR
(
cichar
, 
p
); \

769 
no
.
neg
 = 1; \

770 
code
 \

771 }

	)

772 #define 
	#NAKCICHAR
(
opt
, 
neg
, 
code
) \

773 if (
go
->
neg
 && \

774 
len
 >= 
CILEN_CHAR
 && \

775 
p
[1] == 
CILEN_CHAR
 && \

776 
p
[0] == 
opt
) { \

777 
len
 -= 
CILEN_CHAR
; \

778 
	`INCPTR
(2, 
p
); \

779 
	`GETCHAR
(
cichar
, 
p
); \

780 
no
.
neg
 = 1; \

781 
code
 \

782 }

	)

783 #define 
	#NAKCISHORT
(
opt
, 
neg
, 
code
) \

784 if (
go
->
neg
 && \

785 
len
 >= 
CILEN_SHORT
 && \

786 
p
[1] == 
CILEN_SHORT
 && \

787 
p
[0] == 
opt
) { \

788 
len
 -= 
CILEN_SHORT
; \

789 
	`INCPTR
(2, 
p
); \

790 
	`GETSHORT
(
cishort
, 
p
); \

791 
no
.
neg
 = 1; \

792 
code
 \

793 }

	)

794 #define 
	#NAKCILONG
(
opt
, 
neg
, 
code
) \

795 if (
go
->
neg
 && \

796 
len
 >= 
CILEN_LONG
 && \

797 
p
[1] == 
CILEN_LONG
 && \

798 
p
[0] == 
opt
) { \

799 
len
 -= 
CILEN_LONG
; \

800 
	`INCPTR
(2, 
p
); \

801 
	`GETLONG
(
cilong
, 
p
); \

802 
no
.
neg
 = 1; \

803 
code
 \

804 }

	)

805 #define 
	#NAKCILQR
(
opt
, 
neg
, 
code
) \

806 if (
go
->
neg
 && \

807 
len
 >= 
CILEN_LQR
 && \

808 
p
[1] == 
CILEN_LQR
 && \

809 
p
[0] == 
opt
) { \

810 
len
 -= 
CILEN_LQR
; \

811 
	`INCPTR
(2, 
p
); \

812 
	`GETSHORT
(
cishort
, 
p
); \

813 
	`GETLONG
(
cilong
, 
p
); \

814 
no
.
neg
 = 1; \

815 
code
 \

816 }

	)

825 if (
go
->
neg_mru
 && go->
mru
 != 
PPP_DEFMRU
) {

826 
	`NAKCISHORT
(
CI_MRU
, 
neg_mru
,

827 if (
cishort
 <= 
wo
->
mru
 || cishort < 
PPP_DEFMRU
) {

828 
try
.
mru
 = 
cishort
;

836 if (
go
->
neg_asyncmap
 && go->
asyncmap
 != 0xFFFFFFFFl) {

837 
	`NAKCILONG
(
CI_ASYNCMAP
, 
neg_asyncmap
,

838 
try
.
asyncmap
 = 
go
->asyncmap | 
cilong
;

847 if ((
go
->
neg_chap
 || go->
neg_upap
)

848 && 
len
 >= 
CILEN_SHORT


849 && 
p
[0] == 
CI_AUTHTYPE
 && p[1] >= 
CILEN_SHORT
 && p[1] <= 
len
) {

850 
cilen
 = 
p
[1];

851 
len
 -= 
cilen
;

852 
no
.
neg_chap
 = 
go
->neg_chap;

853 
no
.
neg_upap
 = 
go
->neg_upap;

854 
	`INCPTR
(2, 
p
);

855 
	`GETSHORT
(
cishort
, 
p
);

856 if (
cishort
 == 
PPP_PAP
 && 
cilen
 == 
CILEN_SHORT
) {

862 if (!
go
->
neg_chap
) {

863 goto 
bad
;

865 
try
.
neg_chap
 = 0;

867 } else if (
cishort
 == 
PPP_CHAP
 && 
cilen
 == 
CILEN_CHAP
) {

868 
	`GETCHAR
(
cichar
, 
p
);

869 if (
go
->
neg_chap
) {

875 if (
cichar
 != 
go
->
chap_mdtype
) {

876 
try
.
neg_chap
 = 0;

882 
try
.
neg_upap
 = 0;

890 if (
go
->
neg_chap
) {

891 
try
.
neg_chap
 = 0;

893 
try
.
neg_upap
 = 0;

895 
p
 += 
cilen
 - 
CILEN_SHORT
;

904 
	`NAKCILQR
(
CI_QUALITY
, 
neg_lqr
,

905 if (
cishort
 != 
PPP_LQR
) {

906 
try
.
neg_lqr
 = 0;

908 
try
.
lqr_period
 = 
cilong
;

915 
	`NAKCICHAR
(
CI_CALLBACK
, 
neg_cbcp
,

916 
try
.
neg_cbcp
 = 0;

922 
	`NAKCILONG
(
CI_MAGICNUMBER
, 
neg_magicnumber
,

923 
try
.
magicnumber
 = 
	`magic
();

924 
looped_back
 = 1;

932 
	`NAKCIVOID
(
CI_PCOMPRESSION
, 
neg_pcompression
,

933 
try
.
neg_pcompression
 = 0;

935 
	`NAKCIVOID
(
CI_ACCOMPRESSION
, 
neg_accompression
,

936 
try
.
neg_accompression
 = 0;

955 while (
len
 > 
CILEN_VOID
) {

956 
	`GETCHAR
(
citype
, 
p
);

957 
	`GETCHAR
(
cilen
, 
p
);

958 if (
cilen
 < 
CILEN_VOID
 || (
len
 -= cilen) < 0) {

959 goto 
bad
;

961 
next
 = 
p
 + 
cilen
 - 2;

963 switch (
citype
) {

964 case 
CI_MRU
:

965 if ((
go
->
neg_mru
 && go->
mru
 != 
PPP_DEFMRU
)

966 || 
no
.
neg_mru
 || 
cilen
 != 
CILEN_SHORT
) {

967 goto 
bad
;

969 
	`GETSHORT
(
cishort
, 
p
);

970 if (
cishort
 < 
PPP_DEFMRU
) {

971 
try
.
mru
 = 
cishort
;

974 case 
CI_ASYNCMAP
:

975 if ((
go
->
neg_asyncmap
 && go->
asyncmap
 != 0xFFFFFFFFl)

976 || 
no
.
neg_asyncmap
 || 
cilen
 != 
CILEN_LONG
) {

977 goto 
bad
;

980 case 
CI_AUTHTYPE
:

981 if (
go
->
neg_chap
 || 
no
.neg_chap || go->
neg_upap
 || no.neg_upap) {

982 goto 
bad
;

985 case 
CI_MAGICNUMBER
:

986 if (
go
->
neg_magicnumber
 || 
no
.neg_magicnumber ||

987 
cilen
 != 
CILEN_LONG
) {

988 goto 
bad
;

991 case 
CI_PCOMPRESSION
:

992 if (
go
->
neg_pcompression
 || 
no
.neg_pcompression

993 || 
cilen
 != 
CILEN_VOID
) {

994 goto 
bad
;

997 case 
CI_ACCOMPRESSION
:

998 if (
go
->
neg_accompression
 || 
no
.neg_accompression

999 || 
cilen
 != 
CILEN_VOID
) {

1000 goto 
bad
;

1003 case 
CI_QUALITY
:

1004 if (
go
->
neg_lqr
 || 
no
.neg_lqr || 
cilen
 != 
CILEN_LQR
) {

1005 goto 
bad
;

1009 
p
 = 
next
;

1013 if (
len
 != 0) {

1014 goto 
bad
;

1020 if (
f
->
state
 != 
LS_OPENED
) {

1021 if (
looped_back
) {

1022 if (++
try
.
numloops
 >= 
lcp_loopbackfail
) {

1023 
	`LCPDEBUG
((
LOG_NOTICE
, "Serial line is looped back.\n"));

1024 
	`lcp_close
(
f
->
unit
, "Loopback detected");

1027 
try
.
numloops
 = 0;

1029 *
go
 = 
try
;

1034 
bad
:

1035 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_nakci: received bad Nak!\n"));

1037 
	}
}

1050 
	$lcp_rejci
(
fsm
 *
f
, 
u_char
 *
p
, int 
len
)

1052 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

1053 
u_char
 
cichar
;

1054 
u_short
 
cishort
;

1055 
u32_t
 
cilong
;

1056 
lcp_options
 
try
;

1058 
try
 = *
go
;

1065 #define 
	#REJCIVOID
(
opt
, 
neg
) \

1066 if (
go
->
neg
 && \

1067 
len
 >= 
CILEN_VOID
 && \

1068 
p
[1] == 
CILEN_VOID
 && \

1069 
p
[0] == 
opt
) { \

1070 
len
 -= 
CILEN_VOID
; \

1071 
	`INCPTR
(
CILEN_VOID
, 
p
); \

1072 
try
.
neg
 = 0; \

1073 
	`LCPDEBUG
((
LOG_INFO
, "lcp_rejci: void opt %d rejected\n", 
opt
)); \

1074 }

	)

1075 #define 
	#REJCISHORT
(
opt
, 
neg
, 
val
) \

1076 if (
go
->
neg
 && \

1077 
len
 >= 
CILEN_SHORT
 && \

1078 
p
[1] == 
CILEN_SHORT
 && \

1079 
p
[0] == 
opt
) { \

1080 
len
 -= 
CILEN_SHORT
; \

1081 
	`INCPTR
(2, 
p
); \

1082 
	`GETSHORT
(
cishort
, 
p
); \

1084 if (
cishort
 != 
val
) { \

1085 goto 
bad
; \

1087 
try
.
neg
 = 0; \

1088 
	`LCPDEBUG
((
LOG_INFO
,"lcp_rejci: short opt %d rejected\n", 
opt
)); \

1089 }

	)

1090 #define 
	#REJCICHAP
(
opt
, 
neg
, 
val
, 
digest
) \

1091 if (
go
->
neg
 && \

1092 
len
 >= 
CILEN_CHAP
 && \

1093 
p
[1] == 
CILEN_CHAP
 && \

1094 
p
[0] == 
opt
) { \

1095 
len
 -= 
CILEN_CHAP
; \

1096 
	`INCPTR
(2, 
p
); \

1097 
	`GETSHORT
(
cishort
, 
p
); \

1098 
	`GETCHAR
(
cichar
, 
p
); \

1100 if (
cishort
 != 
val
 || 
cichar
 != 
digest
) { \

1101 goto 
bad
; \

1103 
try
.
neg
 = 0; \

1104 
try
.
neg_upap
 = 0; \

1105 
	`LCPDEBUG
((
LOG_INFO
,"lcp_rejci: chap opt %d rejected\n", 
opt
)); \

1106 }

	)

1107 #define 
	#REJCILONG
(
opt
, 
neg
, 
val
) \

1108 if (
go
->
neg
 && \

1109 
len
 >= 
CILEN_LONG
 && \

1110 
p
[1] == 
CILEN_LONG
 && \

1111 
p
[0] == 
opt
) { \

1112 
len
 -= 
CILEN_LONG
; \

1113 
	`INCPTR
(2, 
p
); \

1114 
	`GETLONG
(
cilong
, 
p
); \

1116 if (
cilong
 != 
val
) { \

1117 goto 
bad
; \

1119 
try
.
neg
 = 0; \

1120 
	`LCPDEBUG
((
LOG_INFO
,"lcp_rejci: long opt %d rejected\n", 
opt
)); \

1121 }

	)

1122 #define 
	#REJCILQR
(
opt
, 
neg
, 
val
) \

1123 if (
go
->
neg
 && \

1124 
len
 >= 
CILEN_LQR
 && \

1125 
p
[1] == 
CILEN_LQR
 && \

1126 
p
[0] == 
opt
) { \

1127 
len
 -= 
CILEN_LQR
; \

1128 
	`INCPTR
(2, 
p
); \

1129 
	`GETSHORT
(
cishort
, 
p
); \

1130 
	`GETLONG
(
cilong
, 
p
); \

1132 if (
cishort
 != 
PPP_LQR
 || 
cilong
 != 
val
) { \

1133 goto 
bad
; \

1135 
try
.
neg
 = 0; \

1136 
	`LCPDEBUG
((
LOG_INFO
,"lcp_rejci: LQR opt %d rejected\n", 
opt
)); \

1137 }

	)

1138 #define 
	#REJCICBCP
(
opt
, 
neg
, 
val
) \

1139 if (
go
->
neg
 && \

1140 
len
 >= 
CILEN_CBCP
 && \

1141 
p
[1] == 
CILEN_CBCP
 && \

1142 
p
[0] == 
opt
) { \

1143 
len
 -= 
CILEN_CBCP
; \

1144 
	`INCPTR
(2, 
p
); \

1145 
	`GETCHAR
(
cichar
, 
p
); \

1147 if (
cichar
 != 
val
) { \

1148 goto 
bad
; \

1150 
try
.
neg
 = 0; \

1151 
	`LCPDEBUG
((
LOG_INFO
,"lcp_rejci: Callback opt %d rejected\n", 
opt
)); \

1152 }

	)

1154 
	`REJCISHORT
(
CI_MRU
, 
neg_mru
, 
go
->
mru
);

1155 
	`REJCILONG
(
CI_ASYNCMAP
, 
neg_asyncmap
, 
go
->
asyncmap
);

1156 
	`REJCICHAP
(
CI_AUTHTYPE
, 
neg_chap
, 
PPP_CHAP
, 
go
->
chap_mdtype
);

1157 if (!
go
->
neg_chap
) {

1158 
	`REJCISHORT
(
CI_AUTHTYPE
, 
neg_upap
, 
PPP_PAP
);

1160 
	`REJCILQR
(
CI_QUALITY
, 
neg_lqr
, 
go
->
lqr_period
);

1161 
	`REJCICBCP
(
CI_CALLBACK
, 
neg_cbcp
, 
CBCP_OPT
);

1162 
	`REJCILONG
(
CI_MAGICNUMBER
, 
neg_magicnumber
, 
go
->
magicnumber
);

1163 
	`REJCIVOID
(
CI_PCOMPRESSION
, 
neg_pcompression
);

1164 
	`REJCIVOID
(
CI_ACCOMPRESSION
, 
neg_accompression
);

1169 if (
len
 != 0) {

1170 goto 
bad
;

1175 if (
f
->
state
 != 
LS_OPENED
) {

1176 *
go
 = 
try
;

1180 
bad
:

1181 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_rejci: received bad Reject!\n"));

1183 
	}
}

1194 
	$lcp_reqci
(
fsm
 *
f
,

1195 
u_char
 *
inp
,

1196 int *
lenp
,

1197 int 
reject_if_disagree
)

1199 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

1200 
lcp_options
 *
ho
 = &
lcp_hisoptions
[
f
->
unit
];

1201 
lcp_options
 *
ao
 = &
lcp_allowoptions
[
f
->
unit
];

1202 
u_char
 *
cip
, *
next
;

1203 int 
cilen
, 
citype
, 
cichar
;

1204 
u_short
 
cishort
;

1205 
u32_t
 
cilong
;

1206 int 
rc
 = 
CONFACK
;

1207 int 
orc
;

1208 
u_char
 *
p
;

1209 
u_char
 *
rejp
;

1210 
u_char
 *
nakp
;

1211 int 
l
 = *
lenp
;

1212 #if 
TRACELCP
 > 0

1213 char 
traceBuf
[80];

1214 int 
traceNdx
 = 0;

1220 
	`BZERO
(
ho
, sizeof(*ho));

1225 
next
 = 
inp
;

1226 
nakp
 = 
nak_buffer
;

1227 
rejp
 = 
inp
;

1228 while (
l
) {

1229 
orc
 = 
CONFACK
;

1230 
cip
 = 
p
 = 
next
;

1231 if (
l
 < 2 ||

1232 
p
[1] < 2 ||

1233 
p
[1] > 
l
) {

1234 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: bad CI length!\n"));

1235 
orc
 = 
CONFREJ
;

1236 
cilen
 = 
l
;

1237 
l
 = 0;

1238 
citype
 = 0;

1239 goto 
endswitch
;

1241 
	`GETCHAR
(
citype
, 
p
);

1242 
	`GETCHAR
(
cilen
, 
p
);

1243 
l
 -= 
cilen
;

1244 
next
 += 
cilen
;

1246 switch (
citype
) {

1247 case 
CI_MRU
:

1248 if (!
ao
->
neg_mru
) {

1249 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Reject MRU - not allowed\n"));

1250 
orc
 = 
CONFREJ
;

1252 } else if (
cilen
 != 
CILEN_SHORT
) {

1253 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Reject MRU - bad length\n"));

1254 
orc
 = 
CONFREJ
;

1257 
	`GETSHORT
(
cishort
, 
p
);

1264 if (
cishort
 < 
PPP_MINMRU
) {

1265 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Nak - MRU too small\n"));

1266 
orc
 = 
CONFNAK
;

1267 
	`PUTCHAR
(
CI_MRU
, 
nakp
);

1268 
	`PUTCHAR
(
CILEN_SHORT
, 
nakp
);

1269 
	`PUTSHORT
(
PPP_MINMRU
, 
nakp
);

1272 
ho
->
neg_mru
 = 1;

1273 
ho
->
mru
 = 
cishort
;

1274 #if 
TRACELCP
 > 0

1275 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " MRU %d", 
cishort
);

1276 
traceNdx
 = 
	`strlen
(
traceBuf
);

1280 case 
CI_ASYNCMAP
:

1281 if (!
ao
->
neg_asyncmap
) {

1282 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Reject ASYNCMAP not allowed\n"));

1283 
orc
 = 
CONFREJ
;

1285 } else if (
cilen
 != 
CILEN_LONG
) {

1286 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Reject ASYNCMAP bad length\n"));

1287 
orc
 = 
CONFREJ
;

1290 
	`GETLONG
(
cilong
, 
p
);

1296 if ((
ao
->
asyncmap
 & ~
cilong
) != 0) {

1297 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Nak ASYNCMAP %lX missing %lX\n",

1298 
cilong
, 
ao
->
asyncmap
));

1299 
orc
 = 
CONFNAK
;

1300 
	`PUTCHAR
(
CI_ASYNCMAP
, 
nakp
);

1301 
	`PUTCHAR
(
CILEN_LONG
, 
nakp
);

1302 
	`PUTLONG
(
ao
->
asyncmap
 | 
cilong
, 
nakp
);

1305 
ho
->
neg_asyncmap
 = 1;

1306 
ho
->
asyncmap
 = 
cilong
;

1307 #if 
TRACELCP
 > 0

1308 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " ASYNCMAP=%lX", 
cilong
);

1309 
traceNdx
 = 
	`strlen
(
traceBuf
);

1313 case 
CI_AUTHTYPE
:

1314 if (
cilen
 < 
CILEN_SHORT
) {

1315 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Reject AUTHTYPE missing arg\n"));

1316 
orc
 = 
CONFREJ
;

1318 } else if (!(
ao
->
neg_upap
 || ao->
neg_chap
)) {

1322 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: Reject AUTHTYPE not allowed\n"));

1323 
orc
 = 
CONFREJ
;

1326 
	`GETSHORT
(
cishort
, 
p
);

1339 if (
cishort
 == 
PPP_PAP
) {

1340 if (
ho
->
neg_chap
) {

1341 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Reject AUTHTYPE PAP already accepted\n"));

1342 
orc
 = 
CONFREJ
;

1344 } else if (
cilen
 != 
CILEN_SHORT
) {

1345 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Reject AUTHTYPE PAP bad len\n"));

1346 
orc
 = 
CONFREJ
;

1349 if (!
ao
->
neg_upap
) {

1350 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Nak AUTHTYPE PAP not allowed\n"));

1351 
orc
 = 
CONFNAK
;

1352 
	`PUTCHAR
(
CI_AUTHTYPE
, 
nakp
);

1353 
	`PUTCHAR
(
CILEN_CHAP
, 
nakp
);

1354 
	`PUTSHORT
(
PPP_CHAP
, 
nakp
);

1355 
	`PUTCHAR
(
ao
->
chap_mdtype
, 
nakp
);

1358 
ho
->
neg_upap
 = 1;

1359 #if 
TRACELCP
 > 0

1360 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " PAP (%X)", 
cishort
);

1361 
traceNdx
 = 
	`strlen
(
traceBuf
);

1365 if (
cishort
 == 
PPP_CHAP
) {

1366 if (
ho
->
neg_upap
) {

1367 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Reject AUTHTYPE CHAP accepted PAP\n"));

1368 
orc
 = 
CONFREJ
;

1370 } else if (
cilen
 != 
CILEN_CHAP
) {

1371 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Reject AUTHTYPE CHAP bad len\n"));

1372 
orc
 = 
CONFREJ
;

1375 if (!
ao
->
neg_chap
) {

1376 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Nak AUTHTYPE CHAP not allowed\n"));

1377 
orc
 = 
CONFNAK
;

1378 
	`PUTCHAR
(
CI_AUTHTYPE
, 
nakp
);

1379 
	`PUTCHAR
(
CILEN_SHORT
, 
nakp
);

1380 
	`PUTSHORT
(
PPP_PAP
, 
nakp
);

1383 
	`GETCHAR
(
cichar
, 
p
);

1384 if (
cichar
 != 
CHAP_DIGEST_MD5


1385 #ifdef 
CHAPMS


1386 && 
cichar
 != 
CHAP_MICROSOFT


1389 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Nak AUTHTYPE CHAP digest=%d\n", 
cichar
));

1390 
orc
 = 
CONFNAK
;

1391 
	`PUTCHAR
(
CI_AUTHTYPE
, 
nakp
);

1392 
	`PUTCHAR
(
CILEN_CHAP
, 
nakp
);

1393 
	`PUTSHORT
(
PPP_CHAP
, 
nakp
);

1394 
	`PUTCHAR
(
ao
->
chap_mdtype
, 
nakp
);

1397 #if 
TRACELCP
 > 0

1398 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " CHAP %X,%d", 
cishort
, 
cichar
);

1399 
traceNdx
 = 
	`strlen
(
traceBuf
);

1401 
ho
->
chap_mdtype
 = 
cichar
;

1402 
ho
->
neg_chap
 = 1;

1411 
orc
 = 
CONFNAK
;

1412 
	`PUTCHAR
(
CI_AUTHTYPE
, 
nakp
);

1413 if (
ao
->
neg_chap
) {

1414 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Nak AUTHTYPE %d req CHAP\n", 
cishort
));

1415 
	`PUTCHAR
(
CILEN_CHAP
, 
nakp
);

1416 
	`PUTSHORT
(
PPP_CHAP
, 
nakp
);

1417 
	`PUTCHAR
(
ao
->
chap_mdtype
, 
nakp
);

1419 
	`LCPDEBUG
((
LOG_WARNING
, "lcp_reqci: Nak AUTHTYPE %d req PAP\n", 
cishort
));

1420 
	`PUTCHAR
(
CILEN_SHORT
, 
nakp
);

1421 
	`PUTSHORT
(
PPP_PAP
, 
nakp
);

1425 case 
CI_QUALITY
:

1426 
	`GETSHORT
(
cishort
, 
p
);

1427 
	`GETLONG
(
cilong
, 
p
);

1428 #if 
TRACELCP
 > 0

1429 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " QUALITY (%x %x)", 
cishort
, (unsigned int) 
cilong
);

1430 
traceNdx
 = 
	`strlen
(
traceBuf
);

1433 if (!
ao
->
neg_lqr
 ||

1434 
cilen
 != 
CILEN_LQR
) {

1435 
orc
 = 
CONFREJ
;

1443 if (
cishort
 != 
PPP_LQR
) {

1444 
orc
 = 
CONFNAK
;

1445 
	`PUTCHAR
(
CI_QUALITY
, 
nakp
);

1446 
	`PUTCHAR
(
CILEN_LQR
, 
nakp
);

1447 
	`PUTSHORT
(
PPP_LQR
, 
nakp
);

1448 
	`PUTLONG
(
ao
->
lqr_period
, 
nakp
);

1453 case 
CI_MAGICNUMBER
:

1454 if (!(
ao
->
neg_magicnumber
 || 
go
->neg_magicnumber) ||

1455 
cilen
 != 
CILEN_LONG
) {

1456 
orc
 = 
CONFREJ
;

1459 
	`GETLONG
(
cilong
, 
p
);

1460 #if 
TRACELCP
 > 0

1461 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " MAGICNUMBER (%lX)", 
cilong
);

1462 
traceNdx
 = 
	`strlen
(
traceBuf
);

1468 if (
go
->
neg_magicnumber
 &&

1469 
cilong
 == 
go
->
magicnumber
) {

1470 
cilong
 = 
	`magic
();

1471 
orc
 = 
CONFNAK
;

1472 
	`PUTCHAR
(
CI_MAGICNUMBER
, 
nakp
);

1473 
	`PUTCHAR
(
CILEN_LONG
, 
nakp
);

1474 
	`PUTLONG
(
cilong
, 
nakp
);

1477 
ho
->
neg_magicnumber
 = 1;

1478 
ho
->
magicnumber
 = 
cilong
;

1482 case 
CI_PCOMPRESSION
:

1483 #if 
TRACELCP
 > 0

1484 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " PCOMPRESSION");

1485 
traceNdx
 = 
	`strlen
(
traceBuf
);

1487 if (!
ao
->
neg_pcompression
 ||

1488 
cilen
 != 
CILEN_VOID
) {

1489 
orc
 = 
CONFREJ
;

1492 
ho
->
neg_pcompression
 = 1;

1495 case 
CI_ACCOMPRESSION
:

1496 #if 
TRACELCP
 > 0

1497 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " ACCOMPRESSION");

1498 
traceNdx
 = 
	`strlen
(
traceBuf
);

1500 if (!
ao
->
neg_accompression
 ||

1501 
cilen
 != 
CILEN_VOID
) {

1502 
orc
 = 
CONFREJ
;

1505 
ho
->
neg_accompression
 = 1;

1508 case 
CI_MRRU
:

1509 #if 
TRACELCP
 > 0

1510 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " CI_MRRU");

1511 
traceNdx
 = 
	`strlen
(
traceBuf
);

1513 
orc
 = 
CONFREJ
;

1516 case 
CI_SSNHF
:

1517 #if 
TRACELCP
 > 0

1518 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " CI_SSNHF");

1519 
traceNdx
 = 
	`strlen
(
traceBuf
);

1521 
orc
 = 
CONFREJ
;

1524 case 
CI_EPDISC
:

1525 #if 
TRACELCP
 > 0

1526 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " CI_EPDISC");

1527 
traceNdx
 = 
	`strlen
(
traceBuf
);

1529 
orc
 = 
CONFREJ
;

1533 #if 
TRACELCP


1534 
	`snprintf
(&
traceBuf
[
traceNdx
], sizeof(traceBuf), " unknown %d", 
citype
);

1535 
traceNdx
 = 
	`strlen
(
traceBuf
);

1537 
orc
 = 
CONFREJ
;

1541 
endswitch
:

1542 #if 
TRACELCP


1543 if (
traceNdx
 >= 80 - 32) {

1544 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: rcvd%s\n", 
traceBuf
));

1545 
traceNdx
 = 0;

1548 if (
orc
 == 
CONFACK
 &&

1549 
rc
 != 
CONFACK
) {

1553 if (
orc
 == 
CONFNAK
) {

1554 if (
reject_if_disagree


1555 && 
citype
 != 
CI_MAGICNUMBER
) {

1556 
orc
 = 
CONFREJ
;

1558 if (
rc
 == 
CONFREJ
) {

1561 
rc
 = 
CONFNAK
;

1564 if (
orc
 == 
CONFREJ
) {

1565 
rc
 = 
CONFREJ
;

1566 if (
cip
 != 
rejp
) {

1567 
	`BCOPY
(
cip
, 
rejp
, 
cilen
);

1569 
	`INCPTR
(
cilen
, 
rejp
);

1580 switch (
rc
) {

1581 case 
CONFACK
:

1582 *
lenp
 = (int)(
next
 - 
inp
);

1584 case 
CONFNAK
:

1588 *
lenp
 = (int)(
nakp
 - 
nak_buffer
);

1589 
	`BCOPY
(
nak_buffer
, 
inp
, *
lenp
);

1591 case 
CONFREJ
:

1592 *
lenp
 = (int)(
rejp
 - 
inp
);

1596 #if 
TRACELCP
 > 0

1597 if (
traceNdx
 > 0) {

1598 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: %s\n", 
traceBuf
));

1601 
	`LCPDEBUG
((
LOG_INFO
, "lcp_reqci: returning CONF%s.\n", 
	`CODENAME
(
rc
)));

1602 return (
rc
);

1603 
	}
}

1610 
	$lcp_up
(
fsm
 *
f
)

1612 
lcp_options
 *
wo
 = &
lcp_wantoptions
[
f
->
unit
];

1613 
lcp_options
 *
ho
 = &
lcp_hisoptions
[
f
->
unit
];

1614 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

1615 
lcp_options
 *
ao
 = &
lcp_allowoptions
[
f
->
unit
];

1617 if (!
go
->
neg_magicnumber
) {

1618 
go
->
magicnumber
 = 0;

1620 if (!
ho
->
neg_magicnumber
) {

1621 
ho
->
magicnumber
 = 0;

1630 
	`ppp_send_config
(
f
->
unit
, 
	`LWIP_MIN
(
ao
->
mru
, (
ho
->
neg_mru
? ho->mru: 
PPP_MRU
)),

1631 (
ho
->
neg_asyncmap
? ho->
asyncmap
: 0xffffffffl),

1632 
ho
->
neg_pcompression
, ho->
neg_accompression
);

1638 
	`ppp_recv_config
(
f
->
unit
, (
go
->
neg_mru
? 
	`LWIP_MAX
(
wo
->
mru
, go->mru): 
PPP_MRU
),

1639 (
go
->
neg_asyncmap
? go->
asyncmap
: 0x00000000),

1640 
go
->
neg_pcompression
, go->
neg_accompression
);

1642 if (
ho
->
neg_mru
) {

1643 
peer_mru
[
f
->
unit
] = 
ho
->
mru
;

1646 
	`lcp_echo_lowerup
(
f
->
unit
);

1648 
	`link_established
(
f
->
unit
);

1649 
	}
}

1658 
	$lcp_down
(
fsm
 *
f
)

1660 
lcp_options
 *
go
 = &
lcp_gotoptions
[
f
->
unit
];

1662 
	`lcp_echo_lowerdown
(
f
->
unit
);

1664 
	`link_down
(
f
->
unit
);

1666 
	`ppp_send_config
(
f
->
unit
, 
PPP_MRU
, 0xffffffffl, 0, 0);

1667 
	`ppp_recv_config
(
f
->
unit
, 
PPP_MRU
,

1668 (
go
->
neg_asyncmap
? go->
asyncmap
: 0x00000000),

1669 
go
->
neg_pcompression
, go->
neg_accompression
);

1670 
peer_mru
[
f
->
unit
] = 
PPP_MRU
;

1671 
	}
}

1678 
	$lcp_starting
(
fsm
 *
f
)

1680 
	`link_required
(
f
->
unit
);

1681 
	}
}

1688 
	$lcp_finished
(
fsm
 *
f
)

1690 
	`link_terminated
(
f
->
unit
);

1691 
	}
}

1700 
print_string
( char *
p
, int 
len
, void (*
printer
) (void *, char *, ...), void *
arg
)

1702 int 
c
;

1704 
	`printer
(
arg
, "\"");

1705 for (; 
len
 > 0; --len) {

1706 
c
 = *
p
++;

1707 if (' ' <= 
c
 && c <= '~') {

1708 if (
c
 == '\\' || c == '"') {

1709 
	`printer
(
arg
, "\\");

1711 
	`printer
(
arg
, "%c", 
c
);

1713 switch (
c
) {

1715 
	`printer
(
arg
, "\\n");

1718 
	`printer
(
arg
, "\\r");

1721 
	`printer
(
arg
, "\\t");

1724 
	`printer
(
arg
, "\\%.3o", 
c
);

1728 
	`printer
(
arg
, "\"");

1729 
	}
}

1735 static char *
	glcp_codenames
[] = {

1742 
lcp_printpkt
( 
u_char
 *
p
, int 
plen
, void (*
printer
) (void *, char *, ...), void *
arg
)

1744 int 
code
, 
id
, 
len
, 
olen
;

1745 
u_char
 *
pstart
, *
optend
;

1746 
u_short
 
cishort
;

1747 
u32_t
 
cilong
;

1749 if (
plen
 < 
HEADERLEN
) {

1752 
pstart
 = 
p
;

1753 
	`GETCHAR
(
code
, 
p
);

1754 
	`GETCHAR
(
id
, 
p
);

1755 
	`GETSHORT
(
len
, 
p
);

1756 if (
len
 < 
HEADERLEN
 || len > 
plen
) {

1760 if (
code
 >= 1 && code <= sizeof(
lcp_codenames
) / sizeof(char *)) {

1761 
	`printer
(
arg
, " %s", 
lcp_codenames
[
code
-1]);

1763 
	`printer
(
arg
, " code=0x%x", 
code
);

1765 
	`printer
(
arg
, " id=0x%x", 
id
);

1766 
len
 -= 
HEADERLEN
;

1767 switch (
code
) {

1768 case 
CONFREQ
:

1769 case 
CONFACK
:

1770 case 
CONFNAK
:

1771 case 
CONFREJ
:

1773 while (
len
 >= 2) {

1774 
	`GETCHAR
(
code
, 
p
);

1775 
	`GETCHAR
(
olen
, 
p
);

1776 
p
 -= 2;

1777 if (
olen
 < 2 || olen > 
len
) {

1780 
	`printer
(
arg
, " <");

1781 
len
 -= 
olen
;

1782 
optend
 = 
p
 + 
olen
;

1783 switch (
code
) {

1784 case 
CI_MRU
:

1785 if (
olen
 == 
CILEN_SHORT
) {

1786 
p
 += 2;

1787 
	`GETSHORT
(
cishort
, 
p
);

1788 
	`printer
(
arg
, "mru %d", 
cishort
);

1791 case 
CI_ASYNCMAP
:

1792 if (
olen
 == 
CILEN_LONG
) {

1793 
p
 += 2;

1794 
	`GETLONG
(
cilong
, 
p
);

1795 
	`printer
(
arg
, "asyncmap 0x%lx", 
cilong
);

1798 case 
CI_AUTHTYPE
:

1799 if (
olen
 >= 
CILEN_SHORT
) {

1800 
p
 += 2;

1801 
	`printer
(
arg
, "auth ");

1802 
	`GETSHORT
(
cishort
, 
p
);

1803 switch (
cishort
) {

1804 case 
PPP_PAP
:

1805 
	`printer
(
arg
, "pap");

1807 case 
PPP_CHAP
:

1808 
	`printer
(
arg
, "chap");

1811 
	`printer
(
arg
, "0x%x", 
cishort
);

1815 case 
CI_QUALITY
:

1816 if (
olen
 >= 
CILEN_SHORT
) {

1817 
p
 += 2;

1818 
	`printer
(
arg
, "quality ");

1819 
	`GETSHORT
(
cishort
, 
p
);

1820 switch (
cishort
) {

1821 case 
PPP_LQR
:

1822 
	`printer
(
arg
, "lqr");

1825 
	`printer
(
arg
, "0x%x", 
cishort
);

1829 case 
CI_CALLBACK
:

1830 if (
olen
 >= 
CILEN_CHAR
) {

1831 
p
 += 2;

1832 
	`printer
(
arg
, "callback ");

1833 
	`GETSHORT
(
cishort
, 
p
);

1834 switch (
cishort
) {

1835 case 
CBCP_OPT
:

1836 
	`printer
(
arg
, "CBCP");

1839 
	`printer
(
arg
, "0x%x", 
cishort
);

1843 case 
CI_MAGICNUMBER
:

1844 if (
olen
 == 
CILEN_LONG
) {

1845 
p
 += 2;

1846 
	`GETLONG
(
cilong
, 
p
);

1847 
	`printer
(
arg
, "magic 0x%x", 
cilong
);

1850 case 
CI_PCOMPRESSION
:

1851 if (
olen
 == 
CILEN_VOID
) {

1852 
p
 += 2;

1853 
	`printer
(
arg
, "pcomp");

1856 case 
CI_ACCOMPRESSION
:

1857 if (
olen
 == 
CILEN_VOID
) {

1858 
p
 += 2;

1859 
	`printer
(
arg
, "accomp");

1863 while (
p
 < 
optend
) {

1864 
	`GETCHAR
(
code
, 
p
);

1865 
	`printer
(
arg
, " %.2x", 
code
);

1867 
	`printer
(
arg
, ">");

1871 case 
TERMACK
:

1872 case 
TERMREQ
:

1873 if (
len
 > 0 && *
p
 >= ' ' && *p < 0x7f) {

1874 
	`printer
(
arg
, " ");

1875 
	`print_string
((char*)
p
, 
len
, 
printer
, 
arg
);

1876 
p
 += 
len
;

1877 
len
 = 0;

1881 case 
ECHOREQ
:

1882 case 
ECHOREP
:

1883 case 
DISCREQ
:

1884 if (
len
 >= 4) {

1885 
	`GETLONG
(
cilong
, 
p
);

1886 
	`printer
(
arg
, " magic=0x%x", 
cilong
);

1887 
p
 += 4;

1888 
len
 -= 4;

1894 for (; 
len
 > 0; --len) {

1895 
	`GETCHAR
(
code
, 
p
);

1896 
	`printer
(
arg
, " %.2x", 
code
);

1899 return (int)(
p
 - 
pstart
);

1900 
	}
}

1907 
	$LcpLinkFailure
 (
fsm
 *
f
)

1909 if (
f
->
state
 == 
LS_OPENED
) {

1910 
	`LCPDEBUG
((
LOG_INFO
, "No response to %d echo-requests\n", 
lcp_echos_pending
));

1911 
	`LCPDEBUG
((
LOG_NOTICE
, "Serial link appears to be disconnected.\n"));

1912 
	`lcp_close
(
f
->
unit
, "Peer not responding");

1914 
	}
}

1920 
	$LcpEchoCheck
 (
fsm
 *
f
)

1922 
	`LcpSendEchoRequest
 (
f
);

1927 
	`LWIP_ASSERT
("lcp_echo_timer_running == 0", 
lcp_echo_timer_running
 == 0);

1929 
	`TIMEOUT
 (
LcpEchoTimeout
, 
f
, 
lcp_echo_interval
);

1930 
lcp_echo_timer_running
 = 1;

1931 
	}
}

1937 
	$LcpEchoTimeout
 (void *
arg
)

1939 if (
lcp_echo_timer_running
 != 0) {

1940 
lcp_echo_timer_running
 = 0;

1941 
	`LcpEchoCheck
 ((
fsm
 *) 
arg
);

1943 
	}
}

1949 
	$lcp_received_echo_reply
 (
fsm
 *
f
, int 
id
, 
u_char
 *
inp
, int 
len
)

1951 
u32_t
 
magic
;

1953 
	`LWIP_UNUSED_ARG
(
id
);

1956 if (
len
 < 4) {

1957 
	`LCPDEBUG
((
LOG_WARNING
, "lcp: received short Echo-Reply, length %d\n", 
len
));

1960 
	`GETLONG
(
magic
, 
inp
);

1961 if (
lcp_gotoptions
[
f
->
unit
].
neg_magicnumber
 && 
magic
 == lcp_gotoptions[f->unit].
magicnumber
) {

1962 
	`LCPDEBUG
((
LOG_WARNING
, "appear to have received our own echo-reply!\n"));

1967 
lcp_echos_pending
 = 0;

1968 
	}
}

1974 
	$LcpSendEchoRequest
 (
fsm
 *
f
)

1976 
u32_t
 
lcp_magic
;

1977 
u_char
 
pkt
[4], *
pktp
;

1982 if (
lcp_echo_fails
 != 0) {

1983 if (
lcp_echos_pending
++ >= 
lcp_echo_fails
) {

1984 
	`LcpLinkFailure
(
f
);

1985 
lcp_echos_pending
 = 0;

1992 if (
f
->
state
 == 
LS_OPENED
) {

1993 
lcp_magic
 = 
lcp_gotoptions
[
f
->
unit
].
magicnumber
;

1994 
pktp
 = 
pkt
;

1995 
	`PUTLONG
(
lcp_magic
, 
pktp
);

1996 
	`fsm_sdata
(
f
, 
ECHOREQ
, (
u_char
)(
lcp_echo_number
++ & 0xFF), 
pkt
, (int)(
pktp
 - pkt));

1998 
	}
}

2005 
	$lcp_echo_lowerup
 (int 
unit
)

2007 
fsm
 *
f
 = &
lcp_fsm
[
unit
];

2010 
lcp_echos_pending
 = 0;

2011 
lcp_echo_number
 = 0;

2012 
lcp_echo_timer_running
 = 0;

2015 if (
lcp_echo_interval
 != 0) {

2016 
	`LcpEchoCheck
 (
f
);

2018 
	}
}

2025 
	$lcp_echo_lowerdown
 (int 
unit
)

2027 
fsm
 *
f
 = &
lcp_fsm
[
unit
];

2029 if (
lcp_echo_timer_running
 != 0) {

2030 
	`UNTIMEOUT
 (
LcpEchoTimeout
, 
f
);

2031 
lcp_echo_timer_running
 = 0;

2033 
	}
}

	@/root/Robux/net/lwip/netif/ppp/lcp.h

54 #ifndef 
LCP_H


55 #define 
	#LCP_H


	)

63 #define 
	#CI_MRU
 1

	)

64 #define 
	#CI_ASYNCMAP
 2

	)

65 #define 
	#CI_AUTHTYPE
 3

	)

66 #define 
	#CI_QUALITY
 4

	)

67 #define 
	#CI_MAGICNUMBER
 5

	)

68 #define 
	#CI_PCOMPRESSION
 7

	)

69 #define 
	#CI_ACCOMPRESSION
 8

	)

70 #define 
	#CI_CALLBACK
 13

	)

71 #define 
	#CI_MRRU
 17

	)

72 #define 
	#CI_SSNHF
 18

	)

73 #define 
	#CI_EPDISC
 19

	)

78 #define 
	#PROTREJ
 8

	)

79 #define 
	#ECHOREQ
 9

	)

80 #define 
	#ECHOREP
 10

	)

81 #define 
	#DISCREQ
 11

	)

82 #define 
	#CBCP_OPT
 6

	)

92 typedef struct 
	slcp_options
 {

93 
u_int
 
	mpassive
 : 1;

94 
u_int
 
	msilent
 : 1;

95 
u_int
 
	mrestart
 : 1;

96 
u_int
 
	mneg_mru
 : 1;

97 
u_int
 
	mneg_asyncmap
 : 1;

98 
u_int
 
	mneg_upap
 : 1;

99 
u_int
 
	mneg_chap
 : 1;

100 
u_int
 
	mneg_magicnumber
 : 1;

101 
u_int
 
	mneg_pcompression
 : 1;

102 
u_int
 
	mneg_accompression
 : 1;

103 
u_int
 
	mneg_lqr
 : 1;

104 
u_int
 
	mneg_cbcp
 : 1;

105 #ifdef 
PPP_MULTILINK


106 
u_int
 
	mneg_mrru
 : 1;

107 
u_int
 
	mneg_ssnhf
 : 1;

108 
u_int
 
	mneg_endpoint
 : 1;

110 
u_short
 
	mmru
;

111 #ifdef 
PPP_MULTILINK


112 
u_short
 
	mmrru
;

114 
u_char
 
	mchap_mdtype
;

115 
u32_t
 
	masyncmap
;

116 
u32_t
 
	mmagicnumber
;

117 int 
	mnumloops
;

118 
u32_t
 
	mlqr_period
;

119 #ifdef 
PPP_MULTILINK


120 struct 
epdisc
 
	mendpoint
;

122 } 
	tlcp_options
;

128 
	mPHASE_DEAD
 = 0,

129 
	mPHASE_INITIALIZE
,

130 
	mPHASE_ESTABLISH
,

131 
	mPHASE_AUTHENTICATE
,

132 
	mPHASE_CALLBACK
,

133 
	mPHASE_NETWORK
,

134 
	mPHASE_TERMINATE


135 } 
	tLinkPhase
;

142 extern 
LinkPhase
 
lcp_phase
[
NUM_PPP
];

143 extern 
lcp_options
 
lcp_wantoptions
[];

144 extern 
lcp_options
 
lcp_gotoptions
[];

145 extern 
lcp_options
 
lcp_allowoptions
[];

146 extern 
lcp_options
 
lcp_hisoptions
[];

147 extern 
ext_accm
 
xmit_accm
[];

154 void 
lcp_init
 (int);

155 void 
lcp_open
 (int);

156 void 
lcp_close
 (int, char *);

157 void 
lcp_lowerup
 (int);

158 void 
lcp_lowerdown
(int);

159 void 
lcp_sprotrej
 (int, 
u_char
 *, int);

161 extern struct 
protent
 
lcp_protent
;

165 #define 
	#DEFLOOPBACKFAIL
 10

	)

	@/root/Robux/net/lwip/netif/ppp/magic.c

52 #include 
	~"lwip/opt.h
"

54 #if 
PPP_SUPPORT


56 #include 
	~"ppp.h
"

57 #include 
	~"randm.h
"

58 #include 
	~"magic.h
"

69 void 
	$magicInit
()

72 
	}
}

77 
u32_t
 
	$magic
()

79 return 
	`avRandom
();

80 
	}
}

	@/root/Robux/net/lwip/netif/ppp/magic.h

54 #ifndef 
MAGIC_H


55 #define 
	#MAGIC_H


	)

62 void 
magicInit
(void);

65 
u32_t
 
magic
(void);

	@/root/Robux/net/lwip/netif/ppp/md5.c

34 #include 
	~"lwip/opt.h
"

36 #if 
PPP_SUPPORT


38 #if 
CHAP_SUPPORT
 || 
MD5_SUPPORT


40 #include 
	~"ppp.h
"

41 #include 
	~"pppdebug.h
"

43 #include 
	~"md5.h
"

57 static void 
Transform
 (
u32_t
 *
buf
, u32_t *
in
);

59 static unsigned char 
	gPADDING
[64] = {

71 #define 
	#F
(
x
, 
y
, 
z
) (((x) & (y)) | ((~x) & (z)))

	)

72 #define 
	#G
(
x
, 
y
, 
z
) (((x) & (z)) | ((y) & (~z)))

	)

73 #define 
	#H
(
x
, 
y
, 
z
) ((x) ^ (y) ^ (z))

	)

74 #define 
	#I
(
x
, 
y
, 
z
) ((y) ^ ((x) | (~z)))

	)

77 #define 
	#ROTATE_LEFT
(
x
, 
n
) (((x) << (n)) | ((x) >> (32-(n))))

	)

81 #define 
	#FF
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

82 {(
a
) += 
	`F
 ((
b
), (
c
), (
d
)) + (
x
) + (
u32_t
)(
ac
); \

83 (
a
) = 
	`ROTATE_LEFT
 ((a), (
s
)); \

84 (
a
) += (
b
); \

85 }

	)

86 #define 
	#GG
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

87 {(
a
) += 
	`G
 ((
b
), (
c
), (
d
)) + (
x
) + (
u32_t
)(
ac
); \

88 (
a
) = 
	`ROTATE_LEFT
 ((a), (
s
)); \

89 (
a
) += (
b
); \

90 }

	)

91 #define 
	#HH
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

92 {(
a
) += 
	`H
 ((
b
), (
c
), (
d
)) + (
x
) + (
u32_t
)(
ac
); \

93 (
a
) = 
	`ROTATE_LEFT
 ((a), (
s
)); \

94 (
a
) += (
b
); \

95 }

	)

96 #define 
	#II
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

97 {(
a
) += 
	`I
 ((
b
), (
c
), (
d
)) + (
x
) + (
u32_t
)(
ac
); \

98 (
a
) = 
	`ROTATE_LEFT
 ((a), (
s
)); \

99 (
a
) += (
b
); \

100 }

	)

102 #ifdef 
__STDC__


103 #define 
	#UL
(
x
) x##
UL


	)

105 #ifdef 
WIN32


106 #define 
	#UL
(
x
) x##
UL


	)

108 #define 
	#UL
(
x
) 
	)
x

116 
	$MD5Init
 (
MD5_CTX
 *
mdContext
)

118 
mdContext
->
i
[0] = mdContext->i[1] = (
u32_t
)0;

121 
mdContext
->
buf
[0] = (
u32_t
)0x67452301UL;

122 
mdContext
->
buf
[1] = (
u32_t
)0xefcdab89UL;

123 
mdContext
->
buf
[2] = (
u32_t
)0x98badcfeUL;

124 
mdContext
->
buf
[3] = (
u32_t
)0x10325476UL;

125 
	}
}

132 
	$MD5Update
(
MD5_CTX
 *
mdContext
, unsigned char *
inBuf
, unsigned int 
inLen
)

134 
u32_t
 
in
[16];

135 int 
mdi
;

136 unsigned int 
i
, 
ii
;

139 
	`ppp_trace
(
LOG_INFO
, "MD5Update: %u:%.*H\n", 
inLen
, 
	`MIN
(inLen, 20) * 2, 
inBuf
);

140 
	`ppp_trace
(
LOG_INFO
, "MD5Update: %u:%s\n", 
inLen
, 
inBuf
);

144 
mdi
 = (int)((
mdContext
->
i
[0] >> 3) & 0x3F);

147 if ((
mdContext
->
i
[0] + ((
u32_t
)
inLen
 << 3)) < mdContext->i[0]) {

148 
mdContext
->
i
[1]++;

150 
mdContext
->
i
[0] += ((
u32_t
)
inLen
 << 3);

151 
mdContext
->
i
[1] += ((
u32_t
)
inLen
 >> 29);

153 while (
inLen
--) {

155 
mdContext
->
in
[
mdi
++] = *
inBuf
++;

158 if (
mdi
 == 0x40) {

159 for (
i
 = 0, 
ii
 = 0; i < 16; i++, ii += 4) {

160 
in
[
i
] = (((
u32_t
)
mdContext
->in[
ii
+3]) << 24) |

161 (((
u32_t
)
mdContext
->
in
[
ii
+2]) << 16) |

162 (((
u32_t
)
mdContext
->
in
[
ii
+1]) << 8) |

163 ((
u32_t
)
mdContext
->
in
[
ii
]);

165 
	`Transform
 (
mdContext
->
buf
, 
in
);

166 
mdi
 = 0;

169 
	}
}

175 
	$MD5Final
 (unsigned char 
hash
[], 
MD5_CTX
 *
mdContext
)

177 
u32_t
 
in
[16];

178 int 
mdi
;

179 unsigned int 
i
, 
ii
;

180 unsigned int 
padLen
;

183 
in
[14] = 
mdContext
->
i
[0];

184 
in
[15] = 
mdContext
->
i
[1];

187 
mdi
 = (int)((
mdContext
->
i
[0] >> 3) & 0x3F);

190 
padLen
 = (
mdi
 < 56) ? (56 - mdi) : (120 - mdi);

191 
	`MD5Update
 (
mdContext
, 
PADDING
, 
padLen
);

194 for (
i
 = 0, 
ii
 = 0; i < 14; i++, ii += 4) {

195 
in
[
i
] = (((
u32_t
)
mdContext
->in[
ii
+3]) << 24) |

196 (((
u32_t
)
mdContext
->
in
[
ii
+2]) << 16) |

197 (((
u32_t
)
mdContext
->
in
[
ii
+1]) << 8) |

198 ((
u32_t
)
mdContext
->
in
[
ii
]);

200 
	`Transform
 (
mdContext
->
buf
, 
in
);

203 for (
i
 = 0, 
ii
 = 0; i < 4; i++, ii += 4) {

204 
mdContext
->
digest
[
ii
] = (unsigned char)(mdContext->
buf
[
i
] & 0xFF);

205 
mdContext
->
digest
[
ii
+1] =

206 (unsigned char)((
mdContext
->
buf
[
i
] >> 8) & 0xFF);

207 
mdContext
->
digest
[
ii
+2] =

208 (unsigned char)((
mdContext
->
buf
[
i
] >> 16) & 0xFF);

209 
mdContext
->
digest
[
ii
+3] =

210 (unsigned char)((
mdContext
->
buf
[
i
] >> 24) & 0xFF);

212 
	`SMEMCPY
(
hash
, 
mdContext
->
digest
, 16);

213 
	}
}

218 
	$Transform
 (
u32_t
 *
buf
, u32_t *
in
)

220 
u32_t
 
a
 = 
buf
[0], 
b
 = buf[1], 
c
 = buf[2], 
d
 = buf[3];

223 #define 
	#S11
 7

	)

224 #define 
	#S12
 12

	)

225 #define 
	#S13
 17

	)

226 #define 
	#S14
 22

	)

227 
	`FF
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 0], 
S11
, 
	`UL
(3614090360));

228 
	`FF
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 1], 
S12
, 
	`UL
(3905402710));

229 
	`FF
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 2], 
S13
, 
	`UL
( 606105819));

230 
	`FF
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 3], 
S14
, 
	`UL
(3250441966));

231 
	`FF
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 4], 
S11
, 
	`UL
(4118548399));

232 
	`FF
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 5], 
S12
, 
	`UL
(1200080426));

233 
	`FF
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 6], 
S13
, 
	`UL
(2821735955));

234 
	`FF
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 7], 
S14
, 
	`UL
(4249261313));

235 
	`FF
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 8], 
S11
, 
	`UL
(1770035416));

236 
	`FF
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 9], 
S12
, 
	`UL
(2336552879));

237 
	`FF
 ( 
c
, 
d
, 
a
, 
b
, 
in
[10], 
S13
, 
	`UL
(4294925233));

238 
	`FF
 ( 
b
, 
c
, 
d
, 
a
, 
in
[11], 
S14
, 
	`UL
(2304563134));

239 
	`FF
 ( 
a
, 
b
, 
c
, 
d
, 
in
[12], 
S11
, 
	`UL
(1804603682));

240 
	`FF
 ( 
d
, 
a
, 
b
, 
c
, 
in
[13], 
S12
, 
	`UL
(4254626195));

241 
	`FF
 ( 
c
, 
d
, 
a
, 
b
, 
in
[14], 
S13
, 
	`UL
(2792965006));

242 
	`FF
 ( 
b
, 
c
, 
d
, 
a
, 
in
[15], 
S14
, 
	`UL
(1236535329));

245 #define 
	#S21
 5

	)

246 #define 
	#S22
 9

	)

247 #define 
	#S23
 14

	)

248 #define 
	#S24
 20

	)

249 
	`GG
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 1], 
S21
, 
	`UL
(4129170786));

250 
	`GG
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 6], 
S22
, 
	`UL
(3225465664));

251 
	`GG
 ( 
c
, 
d
, 
a
, 
b
, 
in
[11], 
S23
, 
	`UL
( 643717713));

252 
	`GG
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 0], 
S24
, 
	`UL
(3921069994));

253 
	`GG
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 5], 
S21
, 
	`UL
(3593408605));

254 
	`GG
 ( 
d
, 
a
, 
b
, 
c
, 
in
[10], 
S22
, 
	`UL
( 38016083));

255 
	`GG
 ( 
c
, 
d
, 
a
, 
b
, 
in
[15], 
S23
, 
	`UL
(3634488961));

256 
	`GG
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 4], 
S24
, 
	`UL
(3889429448));

257 
	`GG
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 9], 
S21
, 
	`UL
( 568446438));

258 
	`GG
 ( 
d
, 
a
, 
b
, 
c
, 
in
[14], 
S22
, 
	`UL
(3275163606));

259 
	`GG
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 3], 
S23
, 
	`UL
(4107603335));

260 
	`GG
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 8], 
S24
, 
	`UL
(1163531501));

261 
	`GG
 ( 
a
, 
b
, 
c
, 
d
, 
in
[13], 
S21
, 
	`UL
(2850285829));

262 
	`GG
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 2], 
S22
, 
	`UL
(4243563512));

263 
	`GG
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 7], 
S23
, 
	`UL
(1735328473));

264 
	`GG
 ( 
b
, 
c
, 
d
, 
a
, 
in
[12], 
S24
, 
	`UL
(2368359562));

267 #define 
	#S31
 4

	)

268 #define 
	#S32
 11

	)

269 #define 
	#S33
 16

	)

270 #define 
	#S34
 23

	)

271 
	`HH
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 5], 
S31
, 
	`UL
(4294588738));

272 
	`HH
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 8], 
S32
, 
	`UL
(2272392833));

273 
	`HH
 ( 
c
, 
d
, 
a
, 
b
, 
in
[11], 
S33
, 
	`UL
(1839030562));

274 
	`HH
 ( 
b
, 
c
, 
d
, 
a
, 
in
[14], 
S34
, 
	`UL
(4259657740));

275 
	`HH
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 1], 
S31
, 
	`UL
(2763975236));

276 
	`HH
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 4], 
S32
, 
	`UL
(1272893353));

277 
	`HH
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 7], 
S33
, 
	`UL
(4139469664));

278 
	`HH
 ( 
b
, 
c
, 
d
, 
a
, 
in
[10], 
S34
, 
	`UL
(3200236656));

279 
	`HH
 ( 
a
, 
b
, 
c
, 
d
, 
in
[13], 
S31
, 
	`UL
( 681279174));

280 
	`HH
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 0], 
S32
, 
	`UL
(3936430074));

281 
	`HH
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 3], 
S33
, 
	`UL
(3572445317));

282 
	`HH
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 6], 
S34
, 
	`UL
( 76029189));

283 
	`HH
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 9], 
S31
, 
	`UL
(3654602809));

284 
	`HH
 ( 
d
, 
a
, 
b
, 
c
, 
in
[12], 
S32
, 
	`UL
(3873151461));

285 
	`HH
 ( 
c
, 
d
, 
a
, 
b
, 
in
[15], 
S33
, 
	`UL
( 530742520));

286 
	`HH
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 2], 
S34
, 
	`UL
(3299628645));

289 #define 
	#S41
 6

	)

290 #define 
	#S42
 10

	)

291 #define 
	#S43
 15

	)

292 #define 
	#S44
 21

	)

293 
	`II
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 0], 
S41
, 
	`UL
(4096336452));

294 
	`II
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 7], 
S42
, 
	`UL
(1126891415));

295 
	`II
 ( 
c
, 
d
, 
a
, 
b
, 
in
[14], 
S43
, 
	`UL
(2878612391));

296 
	`II
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 5], 
S44
, 
	`UL
(4237533241));

297 
	`II
 ( 
a
, 
b
, 
c
, 
d
, 
in
[12], 
S41
, 
	`UL
(1700485571));

298 
	`II
 ( 
d
, 
a
, 
b
, 
c
, 
in
[ 3], 
S42
, 
	`UL
(2399980690));

299 
	`II
 ( 
c
, 
d
, 
a
, 
b
, 
in
[10], 
S43
, 
	`UL
(4293915773));

300 
	`II
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 1], 
S44
, 
	`UL
(2240044497));

301 
	`II
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 8], 
S41
, 
	`UL
(1873313359));

302 
	`II
 ( 
d
, 
a
, 
b
, 
c
, 
in
[15], 
S42
, 
	`UL
(4264355552));

303 
	`II
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 6], 
S43
, 
	`UL
(2734768916));

304 
	`II
 ( 
b
, 
c
, 
d
, 
a
, 
in
[13], 
S44
, 
	`UL
(1309151649));

305 
	`II
 ( 
a
, 
b
, 
c
, 
d
, 
in
[ 4], 
S41
, 
	`UL
(4149444226));

306 
	`II
 ( 
d
, 
a
, 
b
, 
c
, 
in
[11], 
S42
, 
	`UL
(3174756917));

307 
	`II
 ( 
c
, 
d
, 
a
, 
b
, 
in
[ 2], 
S43
, 
	`UL
( 718787259));

308 
	`II
 ( 
b
, 
c
, 
d
, 
a
, 
in
[ 9], 
S44
, 
	`UL
(3951481745));

310 
buf
[0] += 
a
;

311 
buf
[1] += 
b
;

312 
buf
[2] += 
c
;

313 
buf
[3] += 
d
;

314 
	}
}

	@/root/Robux/net/lwip/netif/ppp/md5.h

40 #ifndef 
MD5_H


41 #define 
	#MD5_H


	)

45 
u32_t
 
	mi
[2];

46 
u32_t
 
	mbuf
[4];

47 unsigned char 
	min
[64];

48 unsigned char 
	mdigest
[16];

49 } 
	tMD5_CTX
;

51 void 
MD5Init
 ( 
MD5_CTX
 *
mdContext
);

52 void 
MD5Update
( 
MD5_CTX
 *
mdContext
, unsigned char *
inBuf
, unsigned int 
inLen
);

53 void 
MD5Final
 ( unsigned char 
hash
[], 
MD5_CTX
 *
mdContext
);

	@/root/Robux/net/lwip/netif/ppp/pap.c

52 #include 
	~"lwip/opt.h
"

54 #if 
PPP_SUPPORT


56 #if 
PAP_SUPPORT


58 #include 
	~"ppp.h
"

59 #include 
	~"pppdebug.h
"

61 #include 
	~"auth.h
"

62 #include 
	~"pap.h
"

70 static void 
upap_init
 (int);

71 static void 
upap_lowerup
 (int);

72 static void 
upap_lowerdown
 (int);

73 static void 
upap_input
 (int, 
u_char
 *, int);

74 static void 
upap_protrej
 (int);

76 static void 
upap_timeout
 (void *);

77 static void 
upap_reqtimeout
(void *);

78 static void 
upap_rauthreq
 (
upap_state
 *, 
u_char
 *, int, int);

79 static void 
upap_rauthack
 (
upap_state
 *, 
u_char
 *, int, int);

80 static void 
upap_rauthnak
 (
upap_state
 *, 
u_char
 *, int, int);

81 static void 
upap_sauthreq
 (
upap_state
 *);

82 static void 
upap_sresp
 (
upap_state
 *, 
u_char
, u_char, char *, int);

88 struct 
protent
 
	gpap_protent
 = {

89 
PPP_PAP
,

90 
upap_init
,

91 
upap_input
,

92 
upap_protrej
,

93 
upap_lowerup
,

94 
upap_lowerdown
,

95 
NULL
,

96 
NULL
,

98 
upap_printpkt
,

99 
NULL
,

104 
NULL
,

105 
NULL
,

106 
NULL


110 
upap_state
 
	gupap
[
NUM_PPP
];

121 
	$upap_setloginpasswd
(int 
unit
, const char *
luser
, const char *
lpassword
)

123 
upap_state
 *
u
 = &
upap
[
unit
];

126 
u
->
us_user
 = 
luser
;

127 
u
->
us_userlen
 = 
	`strlen
(
luser
);

128 
u
->
us_passwd
 = 
lpassword
;

129 
u
->
us_passwdlen
 = 
	`strlen
(
lpassword
);

130 
	}
}

139 
	$upap_authwithpeer
(int 
unit
, char *
user
, char *
password
)

141 
upap_state
 *
u
 = &
upap
[
unit
];

143 
	`UPAPDEBUG
((
LOG_INFO
, "upap_authwithpeer: %d user=%s password=%s s=%d\n",

144 
unit
, 
user
, 
password
, 
u
->
us_clientstate
));

146 
	`upap_setloginpasswd
(
unit
, 
user
, 
password
);

148 
u
->
us_transmits
 = 0;

151 if (
u
->
us_clientstate
 == 
UPAPCS_INITIAL
 ||

152 
u
->
us_clientstate
 == 
UPAPCS_PENDING
) {

153 
u
->
us_clientstate
 = 
UPAPCS_PENDING
;

157 
	`upap_sauthreq
(
u
);

158 
	}
}

167 
	$upap_authpeer
(int 
unit
)

169 
upap_state
 *
u
 = &
upap
[
unit
];

172 if (
u
->
us_serverstate
 == 
UPAPSS_INITIAL
 ||

173 
u
->
us_serverstate
 == 
UPAPSS_PENDING
) {

174 
u
->
us_serverstate
 = 
UPAPSS_PENDING
;

178 
u
->
us_serverstate
 = 
UPAPSS_LISTEN
;

179 if (
u
->
us_reqtimeout
 > 0) {

180 
	`TIMEOUT
(
upap_reqtimeout
, 
u
, u->
us_reqtimeout
);

182 
	}
}

193 
	$upap_init
(int 
unit
)

195 
upap_state
 *
u
 = &
upap
[
unit
];

197 
	`UPAPDEBUG
((
LOG_INFO
, "upap_init: %d\n", 
unit
));

198 
u
->
us_unit
 = 
unit
;

199 
u
->
us_user
 = 
NULL
;

200 
u
->
us_userlen
 = 0;

201 
u
->
us_passwd
 = 
NULL
;

202 
u
->
us_passwdlen
 = 0;

203 
u
->
us_clientstate
 = 
UPAPCS_INITIAL
;

204 
u
->
us_serverstate
 = 
UPAPSS_INITIAL
;

205 
u
->
us_id
 = 0;

206 
u
->
us_timeouttime
 = 
UPAP_DEFTIMEOUT
;

207 
u
->
us_maxtransmits
 = 10;

208 
u
->
us_reqtimeout
 = 
UPAP_DEFREQTIME
;

209 
	}
}

215 
	$upap_timeout
(void *
arg
)

217 
upap_state
 *
u
 = (upap_state *) 
arg
;

219 
	`UPAPDEBUG
((
LOG_INFO
, "upap_timeout: %d timeout %d expired s=%d\n",

220 
u
->
us_unit
, u->
us_timeouttime
, u->
us_clientstate
));

222 if (
u
->
us_clientstate
 != 
UPAPCS_AUTHREQ
) {

226 if (
u
->
us_transmits
 >= u->
us_maxtransmits
) {

228 
	`UPAPDEBUG
((
LOG_ERR
, "No response to PAP authenticate-requests\n"));

229 
u
->
us_clientstate
 = 
UPAPCS_BADAUTH
;

230 
	`auth_withpeer_fail
(
u
->
us_unit
, 
PPP_PAP
);

234 
	`upap_sauthreq
(
u
);

235 
	}
}

242 
	$upap_reqtimeout
(void *
arg
)

244 
upap_state
 *
u
 = (upap_state *) 
arg
;

246 if (
u
->
us_serverstate
 != 
UPAPSS_LISTEN
) {

250 
	`auth_peer_fail
(
u
->
us_unit
, 
PPP_PAP
);

251 
u
->
us_serverstate
 = 
UPAPSS_BADAUTH
;

252 
	}
}

261 
	$upap_lowerup
(int 
unit
)

263 
upap_state
 *
u
 = &
upap
[
unit
];

265 
	`UPAPDEBUG
((
LOG_INFO
, "upap_lowerup: %d s=%d\n", 
unit
, 
u
->
us_clientstate
));

267 if (
u
->
us_clientstate
 == 
UPAPCS_INITIAL
) {

268 
u
->
us_clientstate
 = 
UPAPCS_CLOSED
;

269 } else if (
u
->
us_clientstate
 == 
UPAPCS_PENDING
) {

270 
	`upap_sauthreq
(
u
);

273 if (
u
->
us_serverstate
 == 
UPAPSS_INITIAL
) {

274 
u
->
us_serverstate
 = 
UPAPSS_CLOSED
;

275 } else if (
u
->
us_serverstate
 == 
UPAPSS_PENDING
) {

276 
u
->
us_serverstate
 = 
UPAPSS_LISTEN
;

277 if (
u
->
us_reqtimeout
 > 0) {

278 
	`TIMEOUT
(
upap_reqtimeout
, 
u
, u->
us_reqtimeout
);

281 
	}
}

290 
	$upap_lowerdown
(int 
unit
)

292 
upap_state
 *
u
 = &
upap
[
unit
];

294 
	`UPAPDEBUG
((
LOG_INFO
, "upap_lowerdown: %d s=%d\n", 
unit
, 
u
->
us_clientstate
));

296 if (
u
->
us_clientstate
 == 
UPAPCS_AUTHREQ
) {

297 
	`UNTIMEOUT
(
upap_timeout
, 
u
);

299 if (
u
->
us_serverstate
 == 
UPAPSS_LISTEN
 && u->
us_reqtimeout
 > 0) {

300 
	`UNTIMEOUT
(
upap_reqtimeout
, 
u
);

303 
u
->
us_clientstate
 = 
UPAPCS_INITIAL
;

304 
u
->
us_serverstate
 = 
UPAPSS_INITIAL
;

305 
	}
}

314 
	$upap_protrej
(int 
unit
)

316 
upap_state
 *
u
 = &
upap
[
unit
];

318 if (
u
->
us_clientstate
 == 
UPAPCS_AUTHREQ
) {

319 
	`UPAPDEBUG
((
LOG_ERR
, "PAP authentication failed due to protocol-reject\n"));

320 
	`auth_withpeer_fail
(
unit
, 
PPP_PAP
);

322 if (
u
->
us_serverstate
 == 
UPAPSS_LISTEN
) {

323 
	`UPAPDEBUG
((
LOG_ERR
, "PAP authentication of peer failed (protocol-reject)\n"));

324 
	`auth_peer_fail
(
unit
, 
PPP_PAP
);

326 
	`upap_lowerdown
(
unit
);

327 
	}
}

334 
	$upap_input
(int 
unit
, 
u_char
 *
inpacket
, int 
l
)

336 
upap_state
 *
u
 = &
upap
[
unit
];

337 
u_char
 *
inp
;

338 
u_char
 
code
, 
id
;

339 int 
len
;

345 
inp
 = 
inpacket
;

346 if (
l
 < 
UPAP_HEADERLEN
) {

347 
	`UPAPDEBUG
((
LOG_INFO
, "pap_input: rcvd short header.\n"));

350 
	`GETCHAR
(
code
, 
inp
);

351 
	`GETCHAR
(
id
, 
inp
);

352 
	`GETSHORT
(
len
, 
inp
);

353 if (
len
 < 
UPAP_HEADERLEN
) {

354 
	`UPAPDEBUG
((
LOG_INFO
, "pap_input: rcvd illegal length.\n"));

357 if (
len
 > 
l
) {

358 
	`UPAPDEBUG
((
LOG_INFO
, "pap_input: rcvd short packet.\n"));

361 
len
 -= 
UPAP_HEADERLEN
;

366 switch (
code
) {

367 case 
UPAP_AUTHREQ
:

368 
	`upap_rauthreq
(
u
, 
inp
, 
id
, 
len
);

371 case 
UPAP_AUTHACK
:

372 
	`upap_rauthack
(
u
, 
inp
, 
id
, 
len
);

375 case 
UPAP_AUTHNAK
:

376 
	`upap_rauthnak
(
u
, 
inp
, 
id
, 
len
);

382 
	}
}

389 
	$upap_rauthreq
(
upap_state
 *
u
, 
u_char
 *
inp
, int 
id
, int 
len
)

391 
u_char
 
ruserlen
, 
rpasswdlen
;

392 char *
ruser
, *
rpasswd
;

393 int 
retcode
;

394 char *
msg
;

395 int 
msglen
;

397 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauth: Rcvd id %d.\n", 
id
));

399 if (
u
->
us_serverstate
 < 
UPAPSS_LISTEN
) {

407 if (
u
->
us_serverstate
 == 
UPAPSS_OPEN
) {

408 
	`upap_sresp
(
u
, 
UPAP_AUTHACK
, 
id
, "", 0);

411 if (
u
->
us_serverstate
 == 
UPAPSS_BADAUTH
) {

412 
	`upap_sresp
(
u
, 
UPAP_AUTHNAK
, 
id
, "", 0);

419 if (
len
 < sizeof (
u_char
)) {

420 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauth: rcvd short packet.\n"));

423 
	`GETCHAR
(
ruserlen
, 
inp
);

424 
len
 -= sizeof (
u_char
) + 
ruserlen
 + sizeof (u_char);

425 if (
len
 < 0) {

426 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauth: rcvd short packet.\n"));

429 
ruser
 = (char *) 
inp
;

430 
	`INCPTR
(
ruserlen
, 
inp
);

431 
	`GETCHAR
(
rpasswdlen
, 
inp
);

432 if (
len
 < 
rpasswdlen
) {

433 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauth: rcvd short packet.\n"));

436 
rpasswd
 = (char *) 
inp
;

441 
retcode
 = 
	`check_passwd
(
u
->
us_unit
, 
ruser
, 
ruserlen
, 
rpasswd
, 
rpasswdlen
, &
msg
, &
msglen
);

442 
	`BZERO
(
rpasswd
, 
rpasswdlen
);

444 
	`upap_sresp
(
u
, 
retcode
, 
id
, 
msg
, 
msglen
);

446 if (
retcode
 == 
UPAP_AUTHACK
) {

447 
u
->
us_serverstate
 = 
UPAPSS_OPEN
;

448 
	`auth_peer_success
(
u
->
us_unit
, 
PPP_PAP
, 
ruser
, 
ruserlen
);

450 
u
->
us_serverstate
 = 
UPAPSS_BADAUTH
;

451 
	`auth_peer_fail
(
u
->
us_unit
, 
PPP_PAP
);

454 if (
u
->
us_reqtimeout
 > 0) {

455 
	`UNTIMEOUT
(
upap_reqtimeout
, 
u
);

457 
	}
}

464 
	$upap_rauthack
(
upap_state
 *
u
, 
u_char
 *
inp
, int 
id
, int 
len
)

466 
u_char
 
msglen
;

467 char *
msg
;

469 
	`LWIP_UNUSED_ARG
(
id
);

471 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauthack: Rcvd id %d s=%d\n", 
id
, 
u
->
us_clientstate
));

473 if (
u
->
us_clientstate
 != 
UPAPCS_AUTHREQ
) {

480 if (
len
 < sizeof (
u_char
)) {

481 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauthack: rcvd short packet.\n"));

484 
	`GETCHAR
(
msglen
, 
inp
);

485 
len
 -= sizeof (
u_char
);

486 if (
len
 < 
msglen
) {

487 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauthack: rcvd short packet.\n"));

490 
msg
 = (char *) 
inp
;

491 
	`PRINTMSG
(
msg
, 
msglen
);

493 
u
->
us_clientstate
 = 
UPAPCS_OPEN
;

495 
	`auth_withpeer_success
(
u
->
us_unit
, 
PPP_PAP
);

496 
	}
}

503 
	$upap_rauthnak
(
upap_state
 *
u
, 
u_char
 *
inp
, int 
id
, int 
len
)

505 
u_char
 
msglen
;

506 char *
msg
;

508 
	`LWIP_UNUSED_ARG
(
id
);

510 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauthnak: Rcvd id %d s=%d\n", 
id
, 
u
->
us_clientstate
));

512 if (
u
->
us_clientstate
 != 
UPAPCS_AUTHREQ
) {

519 if (
len
 < sizeof (
u_char
)) {

520 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauthnak: rcvd short packet.\n"));

523 
	`GETCHAR
(
msglen
, 
inp
);

524 
len
 -= sizeof (
u_char
);

525 if (
len
 < 
msglen
) {

526 
	`UPAPDEBUG
((
LOG_INFO
, "pap_rauthnak: rcvd short packet.\n"));

529 
msg
 = (char *) 
inp
;

530 
	`PRINTMSG
(
msg
, 
msglen
);

532 
u
->
us_clientstate
 = 
UPAPCS_BADAUTH
;

534 
	`UPAPDEBUG
((
LOG_ERR
, "PAP authentication failed\n"));

535 
	`auth_withpeer_fail
(
u
->
us_unit
, 
PPP_PAP
);

536 
	}
}

543 
	$upap_sauthreq
(
upap_state
 *
u
)

545 
u_char
 *
outp
;

546 int 
outlen
;

548 
outlen
 = 
UPAP_HEADERLEN
 + 2 * sizeof (
u_char
)

549 + 
u
->
us_userlen
 + u->
us_passwdlen
;

550 
outp
 = 
outpacket_buf
[
u
->
us_unit
];

552 
	`MAKEHEADER
(
outp
, 
PPP_PAP
);

554 
	`PUTCHAR
(
UPAP_AUTHREQ
, 
outp
);

555 
	`PUTCHAR
(++
u
->
us_id
, 
outp
);

556 
	`PUTSHORT
(
outlen
, 
outp
);

557 
	`PUTCHAR
(
u
->
us_userlen
, 
outp
);

558 
	`BCOPY
(
u
->
us_user
, 
outp
, u->
us_userlen
);

559 
	`INCPTR
(
u
->
us_userlen
, 
outp
);

560 
	`PUTCHAR
(
u
->
us_passwdlen
, 
outp
);

561 
	`BCOPY
(
u
->
us_passwd
, 
outp
, u->
us_passwdlen
);

563 
	`pppWrite
(
u
->
us_unit
, 
outpacket_buf
[u->us_unit], 
outlen
 + 
PPP_HDRLEN
);

565 
	`UPAPDEBUG
((
LOG_INFO
, "pap_sauth: Sent id %d\n", 
u
->
us_id
));

567 
	`TIMEOUT
(
upap_timeout
, 
u
, u->
us_timeouttime
);

568 ++
u
->
us_transmits
;

569 
u
->
us_clientstate
 = 
UPAPCS_AUTHREQ
;

570 
	}
}

577 
	$upap_sresp
(
upap_state
 *
u
, 
u_char
 
code
, u_char 
id
, char *
msg
, int 
msglen
)

579 
u_char
 *
outp
;

580 int 
outlen
;

582 
outlen
 = 
UPAP_HEADERLEN
 + sizeof (
u_char
) + 
msglen
;

583 
outp
 = 
outpacket_buf
[
u
->
us_unit
];

584 
	`MAKEHEADER
(
outp
, 
PPP_PAP
);

586 
	`PUTCHAR
(
code
, 
outp
);

587 
	`PUTCHAR
(
id
, 
outp
);

588 
	`PUTSHORT
(
outlen
, 
outp
);

589 
	`PUTCHAR
(
msglen
, 
outp
);

590 
	`BCOPY
(
msg
, 
outp
, 
msglen
);

591 
	`pppWrite
(
u
->
us_unit
, 
outpacket_buf
[u->us_unit], 
outlen
 + 
PPP_HDRLEN
);

593 
	`UPAPDEBUG
((
LOG_INFO
, "pap_sresp: Sent code %d, id %d s=%d\n", 
code
, 
id
, 
u
->
us_clientstate
));

594 
	}
}

600 static int 
upap_printpkt
(

601 
u_char
 *
p
,

602 int 
plen
,

603 void (*
printer
) (void *, char *, ...),

604 void *
arg


607 
	`LWIP_UNUSED_ARG
(
p
);

608 
	`LWIP_UNUSED_ARG
(
plen
);

609 
	`LWIP_UNUSED_ARG
(
printer
);

610 
	`LWIP_UNUSED_ARG
(
arg
);

612 
	}
}

	@/root/Robux/net/lwip/netif/ppp/pap.h

52 #ifndef 
PAP_H


53 #define 
	#PAP_H


	)

55 #if 
PAP_SUPPORT


63 #define 
	#UPAP_HEADERLEN
 (sizeof (
u_char
) + sizeof (u_char) + sizeof (
u_short
))

	)

69 #define 
	#UPAP_AUTHREQ
 1

	)

70 #define 
	#UPAP_AUTHACK
 2

	)

71 #define 
	#UPAP_AUTHNAK
 3

	)

76 #define 
	#UPAPCS_INITIAL
 0

	)

77 #define 
	#UPAPCS_CLOSED
 1

	)

78 #define 
	#UPAPCS_PENDING
 2

	)

79 #define 
	#UPAPCS_AUTHREQ
 3

	)

80 #define 
	#UPAPCS_OPEN
 4

	)

81 #define 
	#UPAPCS_BADAUTH
 5

	)

86 #define 
	#UPAPSS_INITIAL
 0

	)

87 #define 
	#UPAPSS_CLOSED
 1

	)

88 #define 
	#UPAPSS_PENDING
 2

	)

89 #define 
	#UPAPSS_LISTEN
 3

	)

90 #define 
	#UPAPSS_OPEN
 4

	)

91 #define 
	#UPAPSS_BADAUTH
 5

	)

101 typedef struct 
	supap_state
 {

102 int 
	mus_unit
;

103 const char *
	mus_user
;

104 int 
	mus_userlen
;

105 const char *
	mus_passwd
;

106 int 
	mus_passwdlen
;

107 int 
	mus_clientstate
;

108 int 
	mus_serverstate
;

109 
u_char
 
	mus_id
;

110 int 
	mus_timeouttime
;

111 int 
	mus_transmits
;

112 int 
	mus_maxtransmits
;

113 int 
	mus_reqtimeout
;

114 } 
	tupap_state
;

121 extern 
upap_state
 
upap
[];

123 void 
upap_setloginpasswd
(int 
unit
, const char *
luser
, const char *
lpassword
);

124 void 
upap_authwithpeer
 (int, char *, char *);

125 void 
upap_authpeer
 (int);

127 extern struct 
protent
 
pap_protent
;

	@/root/Robux/net/lwip/netif/ppp/ppp.c

82 #include 
	~"lwip/opt.h
"

84 #if 
PPP_SUPPORT


86 #include 
	~"lwip/ip.h
"

88 #include 
	~"ppp.h
"

89 #include 
	~"pppdebug.h
"

91 #include 
	~"randm.h
"

92 #include 
	~"fsm.h
"

93 #if 
PAP_SUPPORT


94 #include 
	~"pap.h
"

96 #if 
CHAP_SUPPORT


97 #include 
	~"chap.h
"

99 #include 
	~"ipcp.h
"

100 #include 
	~"lcp.h
"

101 #include 
	~"magic.h
"

102 #include 
	~"auth.h
"

103 #if 
VJ_SUPPORT


104 #include 
	~"vj.h
"

106 #if 
PPPOE_SUPPORT


107 #include 
	~"netif/ppp_oe.h
"

110 #include 
	~<string.h
>

119 #define 
	#PPP_ADDRESS
(
p
) (((
u_char
 *)(p))[0])

	)

120 #define 
	#PPP_CONTROL
(
p
) (((
u_char
 *)(p))[1])

	)

121 #define 
	#PPP_PROTOCOL
(
p
) ((((
u_char
 *)(p))[2] << 8) + ((u_char *)(p))[3])

	)

126 
	mPDIDLE
 = 0,

127 
	mPDSTART
,

128 
	mPDADDRESS
,

129 
	mPDCONTROL
,

130 
	mPDPROTOCOL1
,

131 
	mPDPROTOCOL2
,

132 
	mPDDATA


133 } 
	tPPPDevStates
;

135 #define 
	#ESCAPE_P
(
accm
, 
c
) ((accm)[(c) >> 3] & 
pppACCMMask
[c & 0x07])

	)

143 typedef struct 
	sPPPControl_s
 {

144 char 
	mopenFlag
;

145 #if 
PPPOE_SUPPORT


146 struct 
netif
 *
	methif
;

147 struct 
pppoe_softc
 *
	mpppoe_sc
;

149 int 
	mif_up
;

150 int 
	merrCode
;

151 #if 
PPPOS_SUPPORT


152 
sio_fd_t
 
	mfd
;

153 int 
	mkill_link
;

154 int 
	msig_hup
;

155 struct 
pbuf
 *
	minHead
, *
	minTail
;

156 
PPPDevStates
 
	minState
;

157 char 
	minEscaped
;

158 
u16_t
 
	minProtocol
;

159 
u16_t
 
	minFCS
;

161 int 
	mmtu
;

162 int 
	mpcomp
;

163 int 
	maccomp
;

164 
u_long
 
	mlastXMit
;

165 
ext_accm
 
	minACCM
;

166 
ext_accm
 
	moutACCM
;

167 #if 
PPPOS_SUPPORT
 && 
VJ_SUPPORT


168 int 
	mvjEnabled
;

169 struct 
vjcompress
 
	mvjComp
;

172 struct 
netif
 
	mnetif
;

174 struct 
ppp_addrs
 
	maddrs
;

176 void (*
	mlinkStatusCB
)(void *
	mctx
, int 
	merrCode
, void *
	marg
);

177 void *
	mlinkStatusCtx
;

179 } 
	tPPPControl
;

186 struct 
	snpioctl
 {

187 int 
	mprotocol
;

188 enum 
NPmode
 
	mmode
;

196 #if 
PPPOS_SUPPORT


197 static void 
pppMain
(void *
pd
);

198 static void 
pppDrop
(
PPPControl
 *
pc
);

199 static void 
pppInProc
(int 
pd
, 
u_char
 *
s
, int 
l
);

206 
u_long
 
	gsubnetMask
;

208 static 
PPPControl
 
	gpppControl
[
NUM_PPP
];

215 struct 
protent
 *
	gppp_protocols
[] = {

216 &
lcp_protent
,

217 #if 
PAP_SUPPORT


218 &
pap_protent
,

220 #if 
CHAP_SUPPORT


221 &
chap_protent
,

223 #if 
CBCP_SUPPORT


224 &
cbcp_protent
,

226 &
ipcp_protent
,

227 #if 
CCP_SUPPORT


228 &
ccp_protent
,

230 
NULL


238 
u_char
 *
	goutpacket_buf
[
NUM_PPP
];

245 #if 
PPPOS_SUPPORT


249 static const 
u_short
 
	gfcstab
[256] = {

286 static 
u_char
 
	gpppACCMMask
[] = {

299 
	$pppMainWakeup
(int 
pd
)

301 
	`PPPDEBUG
((
LOG_DEBUG
, "pppMainWakeup: unit %d\n", 
pd
));

302 
	`sio_read_abort
(
pppControl
[
pd
].
fd
);

303 
	}
}

307 
	$pppLinkTerminated
(int 
pd
)

309 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

311 
	`PPPDEBUG
((
LOG_DEBUG
, "pppLinkTerminated: unit %d\n", 
pd
));

313 #if 
PPPOE_SUPPORT


314 if(
pc
->
ethif
) {

315 
	`pppoe_disconnect
(
pc
->
pppoe_sc
);

319 #if 
PPPOS_SUPPORT


320 
	`pppMainWakeup
(
pd
);

323 
	}
}

326 
	$pppLinkDown
(int 
pd
)

328 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

330 
	`PPPDEBUG
((
LOG_DEBUG
, "pppLinkDown: unit %d\n", 
pd
));

332 #if 
PPPOE_SUPPORT


333 if(
pc
->
ethif
) {

334 
	`pppoe_disconnect
(
pc
->
pppoe_sc
);

338 #if 
PPPOS_SUPPORT


339 
	`pppMainWakeup
(
pd
);

342 
	}
}

351 
	$pppStartCB
(void *
arg
)

353 int 
pd
 = (int)
arg
;

355 
	`PPPDEBUG
((
LOG_DEBUG
, "pppStartCB: unit %d\n", 
pd
));

356 
	`lcp_lowerup
(
pd
);

357 
	`lcp_open
(
pd
);

358 
	}
}

361 
	$pppStopCB
(void *
arg
)

363 int 
pd
 = (int)
arg
;

365 
	`PPPDEBUG
((
LOG_DEBUG
, "pppStopCB: unit %d\n", 
pd
));

366 
	`lcp_close
(
pd
, "User request");

367 
	}
}

370 
	$pppHupCB
(void *
arg
)

372 int 
pd
 = (int)
arg
;

374 
	`PPPDEBUG
((
LOG_DEBUG
, "pppHupCB: unit %d\n", 
pd
));

375 
	`lcp_lowerdown
(
pd
);

376 
	`link_terminated
(
pd
);

377 
	}
}

384 struct 
ppp_settings
 
	gppp_settings
;

386 
err_t


387 
	$pppInit
(void)

389 struct 
protent
 *
protp
;

390 int 
i
, 
j
;

392 
	`memset
(&
ppp_settings
, 0, sizeof(ppp_settings));

393 
ppp_settings
.
usepeerdns
 = 1;

394 
	`pppSetAuth
(
PPPAUTHTYPE_NONE
, 
NULL
, NULL);

396 
	`magicInit
();

398 for (
i
 = 0; i < 
NUM_PPP
; i++) {

399 
pppControl
[
i
].
openFlag
 = 0;

401 
subnetMask
 = 
	`htonl
(0xffffff00);

403 
outpacket_buf
[
i
] = (
u_char
 *)
	`mem_malloc
(
PPP_MRU
+
PPP_HDRLEN
);

404 if(!
outpacket_buf
[
i
]) {

405 return 
ERR_MEM
;

411 for (
j
 = 0; (
protp
 = 
ppp_protocols
[j]) != 
NULL
; ++j) {

412 (*
protp
->
init
)(
i
);

416 #if 
LINK_STATS


419 
	`memset
(&
lwip_stats
.
link
, 0, sizeof(lwip_stats.link));

422 #if 
PPPOE_SUPPORT


423 
	`pppoe_init
();

426 return 
ERR_OK
;

427 
	}
}

430 
	$pppSetAuth
(enum 
pppAuthType
 
authType
, const char *
user
, const char *
passwd
)

432 switch(
authType
) {

433 case 
PPPAUTHTYPE_NONE
:

435 #ifdef 
LWIP_PPP_STRICT_PAP_REJECT


436 
ppp_settings
.
refuse_pap
 = 1;

439 
ppp_settings
.
refuse_pap
 = 0;

441 
ppp_settings
.
refuse_chap
 = 1;

444 case 
PPPAUTHTYPE_ANY
:

464 
ppp_settings
.
refuse_pap
 = 0;

465 
ppp_settings
.
refuse_chap
 = 0;

468 case 
PPPAUTHTYPE_PAP
:

469 
ppp_settings
.
refuse_pap
 = 0;

470 
ppp_settings
.
refuse_chap
 = 1;

473 case 
PPPAUTHTYPE_CHAP
:

474 
ppp_settings
.
refuse_pap
 = 1;

475 
ppp_settings
.
refuse_chap
 = 0;

479 if(
user
) {

480 
	`strncpy
(
ppp_settings
.
user
, user, sizeof(ppp_settings.user)-1);

481 
ppp_settings
.
user
[sizeof(ppp_settings.user)-1] = '\0';

483 
ppp_settings
.
user
[0] = '\0';

486 if(
passwd
) {

487 
	`strncpy
(
ppp_settings
.
passwd
, passwd, sizeof(ppp_settings.passwd)-1);

488 
ppp_settings
.
passwd
[sizeof(ppp_settings.passwd)-1] = '\0';

490 
ppp_settings
.
passwd
[0] = '\0';

492 
	}
}

494 #if 
PPPOS_SUPPORT


503 
pppOverSerialOpen
(
sio_fd_t
 
fd
, void (*
linkStatusCB
)(void *
ctx
, int 
errCode
, void *
arg
), void *
linkStatusCtx
)

505 
PPPControl
 *
pc
;

506 int 
pd
;

509 for (
pd
 = 0; pd < 
NUM_PPP
 && 
pppControl
[pd].
openFlag
 != 0; pd++);

511 if (
pd
 >= 
NUM_PPP
) {

512 
pd
 = 
PPPERR_OPEN
;

514 
pppControl
[
pd
].
openFlag
 = !0;

518 if (
pd
 >= 0) {

519 
pppControl
[
pd
].
openFlag
 = 1;

521 
	`lcp_init
(
pd
);

522 
pc
 = &
pppControl
[
pd
];

523 
pc
->
fd
 = fd;

524 #if 
PPPOE_SUPPORT


525 
pc
->
ethif
= 
NULL
;

527 
pc
->
kill_link
 = 0;

528 
pc
->
sig_hup
 = 0;

529 
pc
->
if_up
 = 0;

530 
pc
->
errCode
 = 0;

531 
pc
->
inState
 = 
PDIDLE
;

532 
pc
->
inHead
 = 
NULL
;

533 
pc
->
inTail
 = 
NULL
;

534 
pc
->
inEscaped
 = 0;

535 
pc
->
lastXMit
 = 0;

537 #if 
VJ_SUPPORT


538 
pc
->
vjEnabled
 = 0;

539 
	`vj_compress_init
(&
pc
->
vjComp
);

546 
	`memset
(
pc
->
inACCM
, 0, sizeof(
ext_accm
));

547 
pc
->
inACCM
[15] = 0x60;

548 
	`memset
(
pc
->
outACCM
, 0, sizeof(
ext_accm
));

549 
pc
->
outACCM
[15] = 0x60;

551 
pc
->
linkStatusCB
 = linkStatusCB;

552 
pc
->
linkStatusCtx
 = linkStatusCtx;

554 
	`sys_thread_new
(
PPP_THREAD_NAME
, 
pppMain
, (void*)
pd
, 
PPP_THREAD_STACKSIZE
, 
PPP_THREAD_PRIO
);

555 if(!
linkStatusCB
) {

556 while(
pd
 >= 0 && !
pc
->
if_up
) {

557 
	`sys_msleep
(500);

558 if (
lcp_phase
[
pd
] == 
PHASE_DEAD
) {

559 
	`pppClose
(
pd
);

560 if (
pc
->
errCode
) {

561 
pd
 = 
pc
->
errCode
;

563 
pd
 = 
PPPERR_CONNECT
;

570 return 
pd
;

571 
	}
}

574 #if 
PPPOE_SUPPORT


575 static void 
pppOverEthernetLinkStatusCB
(int 
pd
, int 
up
);

578 
	$pppOverEthernetClose
(int 
pd
)

580 
PPPControl
* 
pc
 = &
pppControl
[
pd
];

583 
	`lcp_close
(
pd
, 
NULL
);

585 
	`pppoe_destroy
(&
pc
->
netif
);

586 
	}
}

588 int 
pppOverEthernetOpen
(struct 
netif
 *
ethif
, const char *
service_name
, const char *
concentrator_name
, void (*
linkStatusCB
)(void *
ctx
, int 
errCode
, void *
arg
), void *
linkStatusCtx
)

590 
PPPControl
 *
pc
;

591 int 
pd
;

593 
	`LWIP_UNUSED_ARG
(
service_name
);

594 
	`LWIP_UNUSED_ARG
(
concentrator_name
);

597 for (
pd
 = 0; pd < 
NUM_PPP
 && 
pppControl
[pd].
openFlag
 != 0; pd++);

598 if (
pd
 >= 
NUM_PPP
) {

599 
pd
 = 
PPPERR_OPEN
;

601 
pppControl
[
pd
].
openFlag
 = !0;

605 if (
pd
 >= 0) {

607 
pppControl
[
pd
].
openFlag
 = 1;

609 
	`lcp_init
(
pd
);

611 
lcp_wantoptions
[
pd
].
mru
 = 
PPPOE_MAXMTU
;

612 
lcp_wantoptions
[
pd
].
neg_asyncmap
 = 0;

613 
lcp_wantoptions
[
pd
].
neg_pcompression
 = 0;

614 
lcp_wantoptions
[
pd
].
neg_accompression
 = 0;

616 
lcp_allowoptions
[
pd
].
mru
 = 
PPPOE_MAXMTU
;

617 
lcp_allowoptions
[
pd
].
neg_asyncmap
 = 0;

618 
lcp_allowoptions
[
pd
].
neg_pcompression
 = 0;

619 
lcp_allowoptions
[
pd
].
neg_accompression
 = 0;

621 
pc
 = &
pppControl
[
pd
];

622 
pc
->
if_up
 = 0;

623 
pc
->
errCode
 = 0;

624 
pc
->
lastXMit
 = 0;

625 #if 
PPPOS_SUPPORT


626 
pc
->
kill_link
 = 0;

627 
pc
->
sig_hup
 = 0;

628 
pc
->
inState
 = 
PDIDLE
;

629 
pc
->
inHead
 = 
NULL
;

630 
pc
->
inTail
 = 
NULL
;

631 
pc
->
inEscaped
 = 0;

632 #if 
VJ_SUPPORT


633 
pc
->
vjEnabled
 = 0;

636 
pc
->
ethif
= ethif;

638 
	`memset
(
pc
->
inACCM
, 0, sizeof(
ext_accm
));

639 
	`memset
(
pc
->
outACCM
, 0, sizeof(
ext_accm
));

641 
pc
->
linkStatusCB
 = linkStatusCB;

642 
pc
->
linkStatusCtx
 = linkStatusCtx;

644 if(
	`pppoe_create
(
ethif
, 
pd
, 
pppOverEthernetLinkStatusCB
, &
pc
->
pppoe_sc
) != 
ERR_OK
) {

645 
pc
->
openFlag
 = 0;

646 return 
PPPERR_OPEN
;

649 
	`pppoe_connect
(
pc
->
pppoe_sc
);

651 if(!
linkStatusCB
) {

652 while(
pd
 >= 0 && !
pc
->
if_up
) {

653 
	`sys_msleep
(500);

654 if (
lcp_phase
[
pd
] == 
PHASE_DEAD
) {

655 
	`pppClose
(
pd
);

656 if (
pc
->
errCode
) {

657 
pd
 = 
pc
->
errCode
;

659 
pd
 = 
PPPERR_CONNECT
;

666 return 
pd
;

667 
	}
}

675 
	$pppClose
(int 
pd
)

677 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

678 int 
st
 = 0;

681 #if 
PPPOE_SUPPORT


682 if(
pc
->
ethif
) {

683 
	`PPPDEBUG
((
LOG_DEBUG
, "pppClose: unit %d kill_link -> pppStopCB\n", 
pd
));

684 
pc
->
errCode
 = 
PPPERR_USER
;

686 
	`tcpip_callback
(
pppStopCB
, (void*)
pd
);

690 #if 
PPPOS_SUPPORT


691 
pc
->
kill_link
 = !0;

692 
	`pppMainWakeup
(
pd
);

696 if(!
pc
->
linkStatusCB
) {

697 while(
st
 >= 0 && 
lcp_phase
[
pd
] != 
PHASE_DEAD
) {

698 
	`sys_msleep
(500);

703 return 
st
;

704 
	}
}

708 
	$pppSigHUP
(int 
pd
)

710 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

712 #if 
PPPOE_SUPPORT


713 if(
pc
->
ethif
) {

714 
	`PPPDEBUG
((
LOG_DEBUG
, "pppSigHUP: unit %d sig_hup -> pppHupCB\n", 
pd
));

715 
	`tcpip_callback
(
pppHupCB
, (void*)
pd
);

719 #if 
PPPOS_SUPPORT


720 
pc
->
sig_hup
 = 1;

721 
	`pppMainWakeup
(
pd
);

724 
	}
}

726 #if 
PPPOS_SUPPORT


728 
	$nPut
(
PPPControl
 *
pc
, struct 
pbuf
 *
nb
)

730 struct 
pbuf
 *
b
;

731 int 
c
;

733 for(
b
 = 
nb
; b != 
NULL
; b = b->
next
) {

734 if((
c
 = 
	`sio_write
(
pc
->
fd
, 
b
->
payload
, b->
len
)) != b->len) {

735 
	`PPPDEBUG
((
LOG_WARNING
,

736 "PPP nPut: incomplete sio_write(%d,, %u) = %d\n", 
pc
->
fd
, 
b
->
len
, 
c
));

737 
	`LINK_STATS_INC
(
link
.
err
);

738 
pc
->
lastXMit
 = 0;

743 
	`pbuf_free
(
nb
);

744 
	`LINK_STATS_INC
(
link
.
xmit
);

745 
	}
}

753 static struct 
pbuf
 *

754 
	$pppAppend
(
u_char
 
c
, struct 
pbuf
 *
nb
, 
ext_accm
 *
outACCM
)

756 struct 
pbuf
 *
tb
 = 
nb
;

762 if (
nb
 && (
PBUF_POOL_BUFSIZE
 - nb->
len
) < 2) {

763 
tb
 = 
	`pbuf_alloc
(
PBUF_RAW
, 0, 
PBUF_POOL
);

764 if (
tb
) {

765 
nb
->
next
 = 
tb
;

767 
	`LINK_STATS_INC
(
link
.
memerr
);

769 
nb
 = 
tb
;

772 if (
nb
) {

773 if (
outACCM
 && 
	`ESCAPE_P
(*outACCM, 
c
)) {

774 *((
u_char
*)
nb
->
payload
 + nb->
len
++) = 
PPP_ESCAPE
;

775 *((
u_char
*)
nb
->
payload
 + nb->
len
++) = 
c
 ^ 
PPP_TRANS
;

777 *((
u_char
*)
nb
->
payload
 + nb->
len
++) = 
c
;

781 return 
tb
;

782 
	}
}

785 #if 
PPPOE_SUPPORT


786 static 
err_t


787 
	$pppifOutputOverEthernet
(int 
pd
, struct 
pbuf
 *
p
)

789 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

790 struct 
pbuf
 *
pb
;

791 
u_short
 
protocol
 = 
PPP_IP
;

792 int 
i
=0;

794 
pb
 = 
	`pbuf_alloc
(
PBUF_LINK
, 
pppoe_hdrlen
 + sizeof(
protocol
), 
PBUF_RAM
);

795 if(!
pb
) {

796 
	`LINK_STATS_INC
(
link
.
memerr
);

797 
	`LINK_STATS_INC
(
link
.
proterr
);

798 return 
ERR_MEM
;

801 
	`pbuf_header
(
pb
, -
pppoe_hdrlen
);

803 
pc
->
lastXMit
 = 
	`sys_jiffies
();

805 if (!
pc
->
pcomp
 || 
protocol
 > 0xFF) {

806 *((
u_char
*)
pb
->
payload
 + 
i
++) = (
protocol
 >> 8) & 0xFF;

808 *((
u_char
*)
pb
->
payload
 + 
i
) = 
protocol
 & 0xFF;

810 
	`pbuf_chain
(
pb
, 
p
);

812 if(
	`pppoe_xmit
(
pc
->
pppoe_sc
, 
pb
) != 
ERR_OK
) {

813 
	`LINK_STATS_INC
(
link
.
err
);

814 return 
PPPERR_DEVICE
;

817 
	`LINK_STATS_INC
(
link
.
xmit
);

818 return 
ERR_OK
;

819 
	}
}

823 static 
err_t


824 
	$pppifOutput
(struct 
netif
 *netif, struct 
pbuf
 *
pb
, struct 
ip_addr
 *
ipaddr
)

826 int 
pd
 = (int)
netif
->
state
;

827 
u_short
 
protocol
 = 
PPP_IP
;

828 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

829 #if 
PPPOS_SUPPORT


830 
u_int
 
fcsOut
 = 
PPP_INITFCS
;

831 struct 
pbuf
 *
headMB
 = 
NULL
, *
tailMB
 = NULL, *
p
;

832 
u_char
 
c
;

835 
	`LWIP_UNUSED_ARG
(
ipaddr
);

840 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
 || !
pb
) {

841 
	`PPPDEBUG
((
LOG_WARNING
, "pppifOutput[%d]: bad parms prot=%d pb=%p\n",

842 
pd
, 
protocol
, 
pb
));

843 
	`LINK_STATS_INC
(
link
.
opterr
);

844 
	`LINK_STATS_INC
(
link
.
drop
);

845 return 
ERR_ARG
;

849 if (
lcp_phase
[
pd
] == 
PHASE_DEAD
) {

850 
	`PPPDEBUG
((
LOG_ERR
, "pppifOutput[%d]: link not up\n", 
pd
));

851 
	`LINK_STATS_INC
(
link
.
rterr
);

852 
	`LINK_STATS_INC
(
link
.
drop
);

853 return 
ERR_RTE
;

856 #if 
PPPOE_SUPPORT


857 if(
pc
->
ethif
) {

858 return 
	`pppifOutputOverEthernet
(
pd
, 
pb
);

862 #if 
PPPOS_SUPPORT


864 
headMB
 = 
	`pbuf_alloc
(
PBUF_RAW
, 0, 
PBUF_POOL
);

865 if (
headMB
 == 
NULL
) {

866 
	`PPPDEBUG
((
LOG_WARNING
, "pppifOutput[%d]: first alloc fail\n", 
pd
));

867 
	`LINK_STATS_INC
(
link
.
memerr
);

868 
	`LINK_STATS_INC
(
link
.
drop
);

869 return 
ERR_MEM
;

872 #if 
VJ_SUPPORT


877 if (
protocol
 == 
PPP_IP
 && 
pc
->
vjEnabled
) {

878 switch (
	`vj_compress_tcp
(&
pc
->
vjComp
, 
pb
)) {

879 case 
TYPE_IP
:

883 case 
TYPE_COMPRESSED_TCP
:

884 
protocol
 = 
PPP_VJC_COMP
;

886 case 
TYPE_UNCOMPRESSED_TCP
:

887 
protocol
 = 
PPP_VJC_UNCOMP
;

890 
	`PPPDEBUG
((
LOG_WARNING
, "pppifOutput[%d]: bad IP packet\n", 
pd
));

891 
	`LINK_STATS_INC
(
link
.
proterr
);

892 
	`LINK_STATS_INC
(
link
.
drop
);

893 
	`pbuf_free
(
headMB
);

894 return 
ERR_VAL
;

899 
tailMB
 = 
headMB
;

902 if ((
	`sys_jiffies
() - 
pc
->
lastXMit
) >= 
PPP_MAXIDLEFLAG
) {

903 
tailMB
 = 
	`pppAppend
(
PPP_FLAG
, tailMB, 
NULL
);

906 
pc
->
lastXMit
 = 
	`sys_jiffies
();

907 if (!
pc
->
accomp
) {

908 
fcsOut
 = 
	`PPP_FCS
(fcsOut, 
PPP_ALLSTATIONS
);

909 
tailMB
 = 
	`pppAppend
(
PPP_ALLSTATIONS
, tailMB, &
pc
->
outACCM
);

910 
fcsOut
 = 
	`PPP_FCS
(fcsOut, 
PPP_UI
);

911 
tailMB
 = 
	`pppAppend
(
PPP_UI
, tailMB, &
pc
->
outACCM
);

913 if (!
pc
->
pcomp
 || 
protocol
 > 0xFF) {

914 
c
 = (
protocol
 >> 8) & 0xFF;

915 
fcsOut
 = 
	`PPP_FCS
(fcsOut, 
c
);

916 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

918 
c
 = 
protocol
 & 0xFF;

919 
fcsOut
 = 
	`PPP_FCS
(fcsOut, 
c
);

920 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

923 for(
p
 = 
pb
; p; p = p->
next
) {

924 int 
n
;

925 
u_char
 *
sPtr
;

927 
sPtr
 = (
u_char
*)
p
->
payload
;

928 
n
 = 
p
->
len
;

929 while (
n
-- > 0) {

930 
c
 = *
sPtr
++;

933 
fcsOut
 = 
	`PPP_FCS
(fcsOut, 
c
);

936 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

941 
c
 = ~
fcsOut
 & 0xFF;

942 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

943 
c
 = (~
fcsOut
 >> 8) & 0xFF;

944 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

945 
tailMB
 = 
	`pppAppend
(
PPP_FLAG
, tailMB, 
NULL
);

948 if (!
tailMB
) {

949 
	`PPPDEBUG
((
LOG_WARNING
,

951 
pd
, 
protocol
));

952 
	`pbuf_free
(
headMB
);

953 
	`LINK_STATS_INC
(
link
.
memerr
);

954 
	`LINK_STATS_INC
(
link
.
drop
);

955 return 
ERR_MEM
;

959 
	`PPPDEBUG
((
LOG_INFO
, "pppifOutput[%d]: proto=0x%04X\n", 
pd
, 
protocol
));

961 
	`nPut
(
pc
, 
headMB
);

964 return 
ERR_OK
;

965 
	}
}

970 
	$pppIOCtl
(int 
pd
, int 
cmd
, void *
arg
)

972 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

973 int 
st
 = 0;

975 if (
pd
 < 0 || pd >= 
NUM_PPP
) {

976 
st
 = 
PPPERR_PARAM
;

978 switch(
cmd
) {

979 case 
PPPCTLG_UPSTATUS
:

980 if (
arg
) {

981 *(int *)
arg
 = (int)(
pc
->
if_up
);

983 
st
 = 
PPPERR_PARAM
;

986 case 
PPPCTLS_ERRCODE
:

987 if (
arg
) {

988 
pc
->
errCode
 = *(int *)
arg
;

990 
st
 = 
PPPERR_PARAM
;

993 case 
PPPCTLG_ERRCODE
:

994 if (
arg
) {

995 *(int *)
arg
 = (int)(
pc
->
errCode
);

997 
st
 = 
PPPERR_PARAM
;

1000 #if 
PPPOS_SUPPORT


1001 case 
PPPCTLG_FD
:

1002 if (
arg
) {

1003 *(
sio_fd_t
 *)
arg
 = 
pc
->
fd
;

1005 
st
 = 
PPPERR_PARAM
;

1010 
st
 = 
PPPERR_PARAM
;

1015 return 
st
;

1016 
	}
}

1021 
u_int


1022 
	$pppMTU
(int 
pd
)

1024 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1025 
u_int
 
st
;

1028 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
) {

1029 
st
 = 0;

1031 
st
 = 
pc
->
mtu
;

1034 return 
st
;

1035 
	}
}

1037 #if 
PPPOE_SUPPORT


1039 
	$pppWriteOverEthernet
(int 
pd
, const 
u_char
 *
s
, int 
n
)

1041 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1042 struct 
pbuf
 *
pb
;

1045 
s
 += 2;

1046 
n
 -= 2;

1048 
pb
 = 
	`pbuf_alloc
(
PBUF_LINK
, 
pppoe_hdrlen
 + 
n
, 
PBUF_RAM
);

1049 if(!
pb
) {

1050 
	`LINK_STATS_INC
(
link
.
memerr
);

1051 
	`LINK_STATS_INC
(
link
.
proterr
);

1052 return 
PPPERR_ALLOC
;

1055 
	`pbuf_header
(
pb
, -
pppoe_hdrlen
);

1057 
pc
->
lastXMit
 = 
	`sys_jiffies
();

1059 
	`SMEMCPY
(
pb
->
payload
, 
s
, 
n
);

1061 if(
	`pppoe_xmit
(
pc
->
pppoe_sc
, 
pb
) != 
ERR_OK
) {

1062 
	`LINK_STATS_INC
(
link
.
err
);

1063 return 
PPPERR_DEVICE
;

1066 
	`LINK_STATS_INC
(
link
.
xmit
);

1067 return 
PPPERR_NONE
;

1068 
	}
}

1077 
	$pppWrite
(int 
pd
, const 
u_char
 *
s
, int 
n
)

1079 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1080 #if 
PPPOS_SUPPORT


1081 
u_char
 
c
;

1082 
u_int
 
fcsOut
;

1083 struct 
pbuf
 *
headMB
, *
tailMB
;

1086 #if 
PPPOE_SUPPORT


1087 if(
pc
->
ethif
) {

1088 return 
	`pppWriteOverEthernet
(
pd
, 
s
, 
n
);

1092 #if 
PPPOS_SUPPORT


1093 
headMB
 = 
	`pbuf_alloc
(
PBUF_RAW
, 0, 
PBUF_POOL
);

1094 if (
headMB
 == 
NULL
) {

1095 
	`LINK_STATS_INC
(
link
.
memerr
);

1096 
	`LINK_STATS_INC
(
link
.
proterr
);

1097 return 
PPPERR_ALLOC
;

1100 
tailMB
 = 
headMB
;

1104 if ((
	`sys_jiffies
() - 
pc
->
lastXMit
) >= 
PPP_MAXIDLEFLAG
) {

1105 
tailMB
 = 
	`pppAppend
(
PPP_FLAG
, tailMB, 
NULL
);

1107 
pc
->
lastXMit
 = 
	`sys_jiffies
();

1109 
fcsOut
 = 
PPP_INITFCS
;

1111 while (
n
-- > 0) {

1112 
c
 = *
s
++;

1115 
fcsOut
 = 
	`PPP_FCS
(fcsOut, 
c
);

1118 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

1122 
c
 = ~
fcsOut
 & 0xFF;

1123 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

1124 
c
 = (~
fcsOut
 >> 8) & 0xFF;

1125 
tailMB
 = 
	`pppAppend
(
c
, tailMB, &
pc
->
outACCM
);

1126 
tailMB
 = 
	`pppAppend
(
PPP_FLAG
, tailMB, 
NULL
);

1130 if (!
tailMB
) {

1131 
	`PPPDEBUG
((
LOG_WARNING
,

1132 "pppWrite[%d]: Alloc err - dropping pbuf len=%d\n", 
pd
, 
headMB
->
len
));

1134 
	`pbuf_free
(
headMB
);

1135 
	`LINK_STATS_INC
(
link
.
memerr
);

1136 
	`LINK_STATS_INC
(
link
.
proterr
);

1137 return 
PPPERR_ALLOC
;

1140 
	`PPPDEBUG
((
LOG_INFO
, "pppWrite[%d]: len=%d\n", 
pd
, 
headMB
->
len
));

1142 
	`nPut
(
pc
, 
headMB
);

1145 return 
PPPERR_NONE
;

1146 
	}
}

1153 
	$ppp_send_config
( int 
unit
, int 
mtu
, 
u32_t
 
asyncmap
, int 
pcomp
, int 
accomp
)

1155 
PPPControl
 *
pc
 = &
pppControl
[
unit
];

1156 int 
i
;

1158 
pc
->
mtu
 = mtu;

1159 
pc
->
pcomp
 = pcomp;

1160 
pc
->
accomp
 = accomp;

1163 for (
i
 = 0; i < 32/8; i++) {

1164 
pc
->
outACCM
[
i
] = (
u_char
)((
asyncmap
 >> (8 * i)) & 0xFF);

1166 
	`PPPDEBUG
((
LOG_INFO
, "ppp_send_config[%d]: outACCM=%X %X %X %X\n",

1167 
unit
,

1168 
pc
->
outACCM
[0], pc->outACCM[1], pc->outACCM[2], pc->outACCM[3]));

1169 
	}
}

1176 
	$ppp_set_xaccm
(int 
unit
, 
ext_accm
 *
accm
)

1178 
	`SMEMCPY
(
pppControl
[
unit
].
outACCM
, 
accm
, sizeof(
ext_accm
));

1179 
	`PPPDEBUG
((
LOG_INFO
, "ppp_set_xaccm[%d]: outACCM=%X %X %X %X\n",

1180 
unit
,

1181 
pppControl
[
unit
].
outACCM
[0],

1182 
pppControl
[
unit
].
outACCM
[1],

1183 
pppControl
[
unit
].
outACCM
[2],

1184 
pppControl
[
unit
].
outACCM
[3]));

1185 
	}
}

1193 
	$ppp_recv_config
( int 
unit
, int 
mru
, 
u32_t
 
asyncmap
, int 
pcomp
, int 
accomp
)

1195 
PPPControl
 *
pc
 = &
pppControl
[
unit
];

1196 int 
i
;

1198 
	`LWIP_UNUSED_ARG
(
accomp
);

1199 
	`LWIP_UNUSED_ARG
(
pcomp
);

1200 
	`LWIP_UNUSED_ARG
(
mru
);

1203 for (
i
 = 0; i < 32 / 8; i++) {

1204 
pc
->
inACCM
[
i
] = (
u_char
)(
asyncmap
 >> (i * 8));

1206 
	`PPPDEBUG
((
LOG_INFO
, "ppp_recv_config[%d]: inACCM=%X %X %X %X\n",

1207 
unit
,

1208 
pc
->
inACCM
[0], pc->inACCM[1], pc->inACCM[2], pc->inACCM[3]));

1209 
	}
}

1219 
	$ccp_test
( int 
unit
, int 
opt_len
, int 
for_transmit
, 
u_char
 *
opt_ptr
)

1222 
	}
}

1228 
	$ccp_flags_set
(int 
unit
, int 
isopen
, int 
isup
)

1231 
	}
}

1239 
	$ccp_fatal_error
(int 
unit
)

1243 
	}
}

1250 
	$get_idle_time
(int 
u
, struct 
ppp_idle
 *
ip
)

1253 
	`LWIP_UNUSED_ARG
(
u
);

1254 
	`LWIP_UNUSED_ARG
(
ip
);

1257 
	}
}

1268 
u32_t


1269 
	$GetMask
(
u32_t
 
addr
)

1271 
u32_t
 
mask
, 
nmask
;

1273 
	`htonl
(
addr
);

1274 if (
	`IN_CLASSA
(
addr
)) {

1275 
nmask
 = 
IN_CLASSA_NET
;

1276 } else if (
	`IN_CLASSB
(
addr
)) {

1277 
nmask
 = 
IN_CLASSB_NET
;

1279 
nmask
 = 
IN_CLASSC_NET
;

1283 
mask
 = 
subnetMask
 | 
	`htonl
(
nmask
);

1290 return 
mask
;

1291 
	}
}

1297 
	$sifvjcomp
( int 
pd
, int 
vjcomp
, int 
cidcomp
, int 
maxcid
)

1299 #if 
PPPOS_SUPPORT
 && 
VJ_SUPPORT


1300 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1302 
pc
->
vjEnabled
 = 
vjcomp
;

1303 
pc
->
vjComp
.
compressSlot
 = 
cidcomp
;

1304 
pc
->
vjComp
.
maxSlotIndex
 = 
maxcid
;

1305 
	`PPPDEBUG
((
LOG_INFO
, "sifvjcomp: VJ compress enable=%d slot=%d max slot=%d\n",

1306 
vjcomp
, 
cidcomp
, 
maxcid
));

1310 
	}
}

1315 static 
err_t


1316 
	$pppifNetifInit
(struct 
netif
 *netif)

1318 
netif
->
name
[0] = 'p';

1319 
netif
->
name
[1] = 'p';

1320 
netif
->
output
 = 
pppifOutput
;

1321 
netif
->
mtu
 = 
	`pppMTU
((int)netif->
state
);

1322 return 
ERR_OK
;

1323 
	}
}

1330 
	$sifup
(int 
pd
)

1332 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1333 int 
st
 = 1;

1335 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
) {

1336 
st
 = 0;

1337 
	`PPPDEBUG
((
LOG_WARNING
, "sifup[%d]: bad parms\n", 
pd
));

1339 
	`netif_remove
(&
pc
->
netif
);

1340 if (
	`netif_add
(&
pc
->
netif
, &pc->
addrs
.
our_ipaddr
, &pc->addrs.
netmask
, &pc->addrs.
his_ipaddr
, (void *)
pd
, 
pppifNetifInit
, 
ip_input
)) {

1341 
	`netif_set_up
(&
pc
->
netif
);

1342 #if 
LWIP_DHCP


1344 
pc
->
netif
.
dhcp
 = (struct dhcp *) &pc->
addrs
;

1346 
pc
->
if_up
 = 1;

1347 
pc
->
errCode
 = 
PPPERR_NONE
;

1349 
	`PPPDEBUG
((
LOG_DEBUG
, "sifup: unit %d: linkStatusCB=%lx errCode=%d\n", 
pd
, 
pc
->
linkStatusCB
, pc->
errCode
));

1350 if(
pc
->
linkStatusCB
) {

1351 
pc
->
	`linkStatusCB
(pc->
linkStatusCtx
, pc->
errCode
, &pc->
addrs
);

1354 
st
 = 0;

1355 
	`PPPDEBUG
((
LOG_ERR
, "sifup[%d]: netif_add failed\n", 
pd
));

1359 return 
st
;

1360 
	}
}

1366 
	$sifnpmode
(int 
u
, int 
proto
, enum 
NPmode
 
mode
)

1368 
	`LWIP_UNUSED_ARG
(
u
);

1369 
	`LWIP_UNUSED_ARG
(
proto
);

1370 
	`LWIP_UNUSED_ARG
(
mode
);

1372 
	}
}

1378 
	$sifdown
(int 
pd
)

1380 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1381 int 
st
 = 1;

1383 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
) {

1384 
st
 = 0;

1385 
	`PPPDEBUG
((
LOG_WARNING
, "sifdown[%d]: bad parms\n", 
pd
));

1387 
pc
->
if_up
 = 0;

1388 
	`netif_remove
(&
pc
->
netif
);

1389 
	`PPPDEBUG
((
LOG_DEBUG
, "sifdown: unit %d: linkStatusCB=%lx errCode=%d\n", 
pd
, 
pc
->
linkStatusCB
, pc->
errCode
));

1390 if(
pc
->
linkStatusCB
) {

1391 
pc
->
	`linkStatusCB
(pc->
linkStatusCtx
, 
PPPERR_CONNECT
, 
NULL
);

1394 return 
st
;

1395 
	}
}

1407 
	$sifaddr
( int 
pd
, 
u32_t
 
o
, u32_t 
h
, u32_t 
m
, u32_t 
ns1
, u32_t 
ns2
)

1409 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1410 int 
st
 = 1;

1412 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
) {

1413 
st
 = 0;

1414 
	`PPPDEBUG
((
LOG_WARNING
, "sifup[%d]: bad parms\n", 
pd
));

1416 
	`SMEMCPY
(&
pc
->
addrs
.
our_ipaddr
, &
o
, sizeof(o));

1417 
	`SMEMCPY
(&
pc
->
addrs
.
his_ipaddr
, &
h
, sizeof(h));

1418 
	`SMEMCPY
(&
pc
->
addrs
.
netmask
, &
m
, sizeof(m));

1419 
	`SMEMCPY
(&
pc
->
addrs
.
dns1
, &
ns1
, sizeof(ns1));

1420 
	`SMEMCPY
(&
pc
->
addrs
.
dns2
, &
ns2
, sizeof(ns2));

1422 return 
st
;

1423 
	}
}

1433 
	$cifaddr
( int 
pd
, 
u32_t
 
o
, u32_t 
h
)

1435 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1436 int 
st
 = 1;

1438 
	`LWIP_UNUSED_ARG
(
o
);

1439 
	`LWIP_UNUSED_ARG
(
h
);

1440 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
) {

1441 
st
 = 0;

1442 
	`PPPDEBUG
((
LOG_WARNING
, "sifup[%d]: bad parms\n", 
pd
));

1444 
	`IP4_ADDR
(&
pc
->
addrs
.
our_ipaddr
, 0,0,0,0);

1445 
	`IP4_ADDR
(&
pc
->
addrs
.
his_ipaddr
, 0,0,0,0);

1446 
	`IP4_ADDR
(&
pc
->
addrs
.
netmask
, 255,255,255,0);

1447 
	`IP4_ADDR
(&
pc
->
addrs
.
dns1
, 0,0,0,0);

1448 
	`IP4_ADDR
(&
pc
->
addrs
.
dns2
, 0,0,0,0);

1450 return 
st
;

1451 
	}
}

1457 
	$sifdefaultroute
(int 
pd
, 
u32_t
 
l
, u32_t 
g
)

1459 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1460 int 
st
 = 1;

1462 
	`LWIP_UNUSED_ARG
(
l
);

1463 
	`LWIP_UNUSED_ARG
(
g
);

1465 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
) {

1466 
st
 = 0;

1467 
	`PPPDEBUG
((
LOG_WARNING
, "sifup[%d]: bad parms\n", 
pd
));

1469 
	`netif_set_default
(&
pc
->
netif
);

1474 return 
st
;

1475 
	}
}

1481 
	$cifdefaultroute
(int 
pd
, 
u32_t
 
l
, u32_t 
g
)

1483 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1484 int 
st
 = 1;

1486 
	`LWIP_UNUSED_ARG
(
l
);

1487 
	`LWIP_UNUSED_ARG
(
g
);

1489 if (
pd
 < 0 || pd >= 
NUM_PPP
 || !
pc
->
openFlag
) {

1490 
st
 = 0;

1491 
	`PPPDEBUG
((
LOG_WARNING
, "sifup[%d]: bad parms\n", 
pd
));

1493 
	`netif_set_default
(
NULL
);

1496 return 
st
;

1497 
	}
}

1503 #if 
PPPOS_SUPPORT


1507 
	$pppMain
(void *
arg
)

1509 int 
pd
 = (int)
arg
;

1510 struct 
pbuf
 *
p
;

1511 
PPPControl
* 
pc
;

1512 int 
c
;

1514 
pc
 = &
pppControl
[
pd
];

1516 
p
 = 
	`pbuf_alloc
(
PBUF_RAW
, 
PPP_MRU
+
PPP_HDRLEN
, 
PBUF_RAM
);

1517 if (!
p
) {

1518 
	`LWIP_ASSERT
("p != NULL", 
p
);

1519 
pc
->
errCode
 = 
PPPERR_ALLOC
;

1520 goto 
out
;

1526 
	`PPPDEBUG
((
LOG_INFO
, "pppMain: unit %d: Connecting\n", 
pd
));

1527 
	`tcpip_callback
(
pppStartCB
, 
arg
);

1528 while (
lcp_phase
[
pd
] != 
PHASE_DEAD
) {

1529 if (
pc
->
kill_link
) {

1530 
	`PPPDEBUG
((
LOG_DEBUG
, "pppMain: unit %d kill_link -> pppStopCB\n", 
pd
));

1531 
pc
->
errCode
 = 
PPPERR_USER
;

1533 
	`tcpip_callback
(
pppStopCB
, 
arg
);

1534 
pc
->
kill_link
 = 0;

1535 } else if (
pc
->
sig_hup
) {

1536 
	`PPPDEBUG
((
LOG_DEBUG
, "pppMain: unit %d sig_hup -> pppHupCB\n", 
pd
));

1537 
pc
->
sig_hup
 = 0;

1538 
	`tcpip_callback
(
pppHupCB
, 
arg
);

1540 
c
 = 
	`sio_read
(
pc
->
fd
, 
p
->
payload
, p->
len
);

1541 if(
c
 > 0) {

1542 
	`pppInProc
(
pd
, 
p
->
payload
, 
c
);

1544 
	`PPPDEBUG
((
LOG_DEBUG
, "pppMain: unit %d sio_read len=%d returned %d\n", 
pd
, 
p
->
len
, 
c
));

1545 
	`sys_msleep
(1);

1549 
	`PPPDEBUG
((
LOG_INFO
, "pppMain: unit %d: PHASE_DEAD\n", 
pd
));

1550 
	`pppDrop
(
pc
);

1551 
	`pbuf_free
(
p
);

1553 
out
:

1554 
	`PPPDEBUG
((
LOG_DEBUG
, "pppMain: unit %d: linkStatusCB=%lx errCode=%d\n", 
pd
, 
pc
->
linkStatusCB
, pc->
errCode
));

1555 if(
pc
->
linkStatusCB
) {

1556 
pc
->
	`linkStatusCB
(pc->
linkStatusCtx
, pc->
errCode
 ? pc->errCode : 
PPPERR_PROTOCOL
, 
NULL
);

1559 
pc
->
openFlag
 = 0;

1560 
	}
}

1563 #if 
PPPOE_SUPPORT


1566 
	$pppOverEthernetInitFailed
(void* 
arg
)

1568 
PPPControl
* 
pc
;

1569 int 
pd
 = (int)
arg
;

1571 
	`pppHupCB
(
arg
);

1572 
	`pppStopCB
(
arg
);

1574 
pc
 = &
pppControl
[
pd
];

1575 
	`pppoe_destroy
(&
pc
->
netif
);

1576 
pc
->
openFlag
 = 0;

1578 if(
pc
->
linkStatusCB
) {

1579 
pc
->
	`linkStatusCB
(pc->
linkStatusCtx
, pc->
errCode
 ? pc->errCode : 
PPPERR_PROTOCOL
, 
NULL
);

1581 
	}
}

1584 
	$pppOverEthernetLinkStatusCB
(int 
pd
, int 
up
)

1586 if(
up
) {

1587 
	`PPPDEBUG
((
LOG_INFO
, "pppMain: unit %d: Connecting\n", 
pd
));

1588 
	`tcpip_callback
(
pppStartCB
, (void*)
pd
);

1590 
PPPControl
* 
pc
;

1591 
pc
 = &
pppControl
[
pd
];

1592 
	`tcpip_callback
(
pppOverEthernetInitFailed
, (void*)
pd
);

1594 
	}
}

1597 struct 
pbuf
 *

1598 
	$pppSingleBuf
(struct 
pbuf
 *
p
)

1600 struct 
pbuf
 *
q
, *
b
;

1601 
u_char
 *
pl
;

1603 if(
p
->
tot_len
 == p->
len
) {

1604 return 
p
;

1607 
q
 = 
	`pbuf_alloc
(
PBUF_RAW
, 
p
->
tot_len
, 
PBUF_RAM
);

1608 if(!
q
) {

1609 
	`PPPDEBUG
((
LOG_ERR
,

1610 "pppSingleBuf: unable to alloc new buf (%d)\n", 
p
->
tot_len
));

1611 return 
p
;

1614 for(
b
 = 
p
, 
pl
 = 
q
->
payload
; b != 
NULL
; b = b->
next
) {

1615 
	`MEMCPY
(
pl
, 
b
->
payload
, b->
len
);

1616 
pl
 += 
b
->
len
;

1619 
	`pbuf_free
(
p
);

1621 return 
q
;

1622 
	}
}

1624 struct 
	spppInputHeader
 {

1625 int 
	munit
;

1626 
u16_t
 
	mproto
;

1634 
	$pppInput
(void *
arg
)

1636 struct 
pbuf
 *
nb
 = (struct pbuf *)
arg
;

1637 
u16_t
 
protocol
;

1638 int 
pd
;

1640 
pd
 = ((struct 
pppInputHeader
 *)
nb
->
payload
)->
unit
;

1641 
protocol
 = ((struct 
pppInputHeader
 *)
nb
->
payload
)->
proto
;

1643 if(
	`pbuf_header
(
nb
, -(int)sizeof(struct 
pppInputHeader
))) {

1644 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

1645 goto 
drop
;

1648 
	`LINK_STATS_INC
(
link
.
recv
);

1655 if((
lcp_phase
[
pd
] <= 
PHASE_AUTHENTICATE
) && (
protocol
 != 
PPP_LCP
)) {

1656 if(!((
protocol
 == 
PPP_LQR
) || (protocol == 
PPP_PAP
) || (protocol == 
PPP_CHAP
)) ||

1657 (
lcp_phase
[
pd
] != 
PHASE_AUTHENTICATE
)) {

1658 
	`PPPDEBUG
((
LOG_INFO
, "pppInput: discarding proto 0x%04X in phase %d\n", 
protocol
, 
lcp_phase
[
pd
]));

1659 goto 
drop
;

1663 switch(
protocol
) {

1664 case 
PPP_VJC_COMP
:

1665 #if 
VJ_SUPPORT


1666 
	`PPPDEBUG
((
LOG_INFO
, "pppInput[%d]: vj_comp in pbuf len=%d\n", 
pd
, 
nb
->
len
));

1671 if ((
	`vj_uncompress_tcp
(&
nb
, &
pppControl
[
pd
].
vjComp
) >= 0) && (pppControl[pd].
netif
.
input
)) {

1672 
pppControl
[
pd
].
netif
.
	`input
(
nb
, &pppControl[pd].netif);

1676 
	`PPPDEBUG
((
LOG_WARNING
, "pppInput[%d]: Dropping VJ compressed\n", 
pd
));

1679 
	`PPPDEBUG
((
LOG_INFO
, "pppInput[%d]: drop VJ Comp in %d:%s\n", 
pd
, 
nb
->
len
, nb->
payload
));

1683 case 
PPP_VJC_UNCOMP
:

1684 #if 
VJ_SUPPORT


1685 
	`PPPDEBUG
((
LOG_INFO
, "pppInput[%d]: vj_un in pbuf len=%d\n", 
pd
, 
nb
->
len
));

1690 if ((
	`vj_uncompress_uncomp
(
nb
, &
pppControl
[
pd
].
vjComp
) >= 0) && pppControl[pd].
netif
.
input
) {

1691 
pppControl
[
pd
].
netif
.
	`input
(
nb
, &pppControl[pd].netif);

1695 
	`PPPDEBUG
((
LOG_WARNING
, "pppInput[%d]: Dropping VJ uncompressed\n", 
pd
));

1698 
	`PPPDEBUG
((
LOG_INFO
,

1700 
pd
, 
nb
->
len
, 
	`LWIP_MIN
(nb->len * 2, 40), nb->
payload
));

1704 case 
PPP_IP
:

1705 
	`PPPDEBUG
((
LOG_INFO
, "pppInput[%d]: ip in pbuf len=%d\n", 
pd
, 
nb
->
len
));

1706 if (
pppControl
[
pd
].
netif
.
input
) {

1707 
pppControl
[
pd
].
netif
.
	`input
(
nb
, &pppControl[pd].netif);

1713 struct 
protent
 *
protp
;

1714 int 
i
;

1719 for (
i
 = 0; (
protp
 = 
ppp_protocols
[i]) != 
NULL
; ++i) {

1720 if (
protp
->
protocol
 == protocol && protp->
enabled_flag
) {

1721 
	`PPPDEBUG
((
LOG_INFO
, "pppInput[%d]: %s len=%d\n", 
pd
, 
protp
->
name
, 
nb
->
len
));

1722 
nb
 = 
	`pppSingleBuf
(nb);

1723 (*
protp
->
input
)(
pd
, 
nb
->
payload
, nb->
len
);

1724 goto 
out
;

1729 
	`PPPDEBUG
((
LOG_INFO
, "pppInput[%d]: rejecting unsupported proto 0x%04X len=%d\n", 
pd
, 
protocol
, 
nb
->
len
));

1730 if (
	`pbuf_header
(
nb
, sizeof(
protocol
))) {

1731 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

1732 goto 
drop
;

1734 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


1735 
protocol
 = 
	`htons
(protocol);

1736 
	`SMEMCPY
(
nb
->
payload
, &
protocol
, sizeof(protocol));

1738 
	`lcp_sprotrej
(
pd
, 
nb
->
payload
, nb->
len
);

1743 
drop
:

1744 
	`LINK_STATS_INC
(
link
.
drop
);

1746 
out
:

1747 
	`pbuf_free
(
nb
);

1749 
	}
}

1751 #if 
PPPOS_SUPPORT


1756 
	$pppDrop
(
PPPControl
 *
pc
)

1758 if (
pc
->
inHead
 != 
NULL
) {

1760 
	`PPPDEBUG
((
LOG_INFO
, "pppDrop: %d:%.*H\n", 
pc
->
inHead
->
len
, 
	`min
(60, pc->inHead->len * 2), pc->inHead->
payload
));

1762 
	`PPPDEBUG
((
LOG_INFO
, "pppDrop: pbuf len=%d\n", 
pc
->
inHead
->
len
));

1763 if (
pc
->
inTail
 && (pc->inTail != pc->
inHead
)) {

1764 
	`pbuf_free
(
pc
->
inTail
);

1766 
	`pbuf_free
(
pc
->
inHead
);

1767 
pc
->
inHead
 = 
NULL
;

1768 
pc
->
inTail
 = 
NULL
;

1770 #if 
VJ_SUPPORT


1771 
	`vj_uncompress_err
(&
pc
->
vjComp
);

1774 
	`LINK_STATS_INC
(
link
.
drop
);

1775 
	}
}

1781 
	$pppInProc
(int 
pd
, 
u_char
 *
s
, int 
l
)

1783 
PPPControl
 *
pc
 = &
pppControl
[
pd
];

1784 struct 
pbuf
 *
nextNBuf
;

1785 
u_char
 
curChar
;

1787 
	`PPPDEBUG
((
LOG_DEBUG
, "pppInProc[%d]: got %d bytes\n", 
pd
, 
l
));

1788 while (
l
-- > 0) {

1789 
curChar
 = *
s
++;

1792 if (
	`ESCAPE_P
(
pc
->
inACCM
, 
curChar
)) {

1798 if (
curChar
 == 
PPP_ESCAPE
) {

1799 
pc
->
inEscaped
 = 1;

1801 } else if (
curChar
 == 
PPP_FLAG
) {

1803 if (
pc
->
inState
 <= 
PDADDRESS
) {

1806 } else if (
pc
->
inState
 < 
PDDATA
) {

1807 
	`PPPDEBUG
((
LOG_WARNING
,

1809 
pd
, 
pc
->
inState
));

1810 
	`LINK_STATS_INC
(
link
.
lenerr
);

1811 
	`pppDrop
(
pc
);

1813 } else if (
pc
->
inFCS
 != 
PPP_GOODFCS
) {

1814 
	`PPPDEBUG
((
LOG_INFO
,

1816 
pd
, 
pc
->
inFCS
, pc->
inProtocol
));

1817 
	`LINK_STATS_INC
(
link
.
chkerr
);

1818 
	`pppDrop
(
pc
);

1822 if(
pc
->
inTail
->
len
 >= 2) {

1823 
pc
->
inTail
->
len
 -= 2;

1825 
pc
->
inTail
->
tot_len
 = pc->inTail->
len
;

1826 if (
pc
->
inTail
 != pc->
inHead
) {

1827 
	`pbuf_cat
(
pc
->
inHead
, pc->
inTail
);

1830 
pc
->
inTail
->
tot_len
 = pc->inTail->
len
;

1831 if (
pc
->
inTail
 != pc->
inHead
) {

1832 
	`pbuf_cat
(
pc
->
inHead
, pc->
inTail
);

1835 
	`pbuf_realloc
(
pc
->
inHead
, pc->inHead->
tot_len
 - 2);

1839 if(
	`tcpip_callback
(
pppInput
, 
pc
->
inHead
) != 
ERR_OK
) {

1840 
	`PPPDEBUG
((
LOG_ERR
, "pppInProc[%d]: tcpip_callback() failed, dropping packet\n", 
pd
));

1841 
	`pbuf_free
(
pc
->
inHead
);

1842 
	`LINK_STATS_INC
(
link
.
drop
);

1844 
pc
->
inHead
 = 
NULL
;

1845 
pc
->
inTail
 = 
NULL
;

1849 
pc
->
inFCS
 = 
PPP_INITFCS
;

1850 
pc
->
inState
 = 
PDADDRESS
;

1851 
pc
->
inEscaped
 = 0;

1855 
	`PPPDEBUG
((
LOG_WARNING
,

1856 "pppInProc[%d]: Dropping ACCM char <%d>\n", 
pd
, 
curChar
));

1861 if (
pc
->
inEscaped
) {

1862 
pc
->
inEscaped
 = 0;

1863 
curChar
 ^= 
PPP_TRANS
;

1867 switch(
pc
->
inState
) {

1868 case 
PDIDLE
:

1871 if (
curChar
 != 
PPP_ALLSTATIONS
) {

1876 case 
PDSTART
:

1878 
pc
->
inFCS
 = 
PPP_INITFCS
;

1881 case 
PDADDRESS
:

1882 if (
curChar
 == 
PPP_ALLSTATIONS
) {

1883 
pc
->
inState
 = 
PDCONTROL
;

1888 case 
PDCONTROL
:

1890 if (
curChar
 == 
PPP_UI
) {

1891 
pc
->
inState
 = 
PDPROTOCOL1
;

1896 
	`PPPDEBUG
((
LOG_WARNING
,

1897 "pppInProc[%d]: Invalid control <%d>\n", 
pd
, 
curChar
));

1898 
pc
->
inState
 = 
PDSTART
;

1901 case 
PDPROTOCOL1
:

1904 if (
curChar
 & 1) {

1905 
pc
->
inProtocol
 = 
curChar
;

1906 
pc
->
inState
 = 
PDDATA
;

1908 
pc
->
inProtocol
 = (
u_int
)
curChar
 << 8;

1909 
pc
->
inState
 = 
PDPROTOCOL2
;

1912 case 
PDPROTOCOL2
:

1913 
pc
->
inProtocol
 |= 
curChar
;

1914 
pc
->
inState
 = 
PDDATA
;

1916 case 
PDDATA
:

1918 if (
pc
->
inTail
 == 
NULL
 || pc->inTail->
len
 == 
PBUF_POOL_BUFSIZE
) {

1919 if(
pc
->
inTail
) {

1920 
pc
->
inTail
->
tot_len
 = pc->inTail->
len
;

1921 if (
pc
->
inTail
 != pc->
inHead
) {

1922 
	`pbuf_cat
(
pc
->
inHead
, pc->
inTail
);

1926 
nextNBuf
 = 
	`pbuf_alloc
(
PBUF_RAW
, 0, 
PBUF_POOL
);

1927 if (
nextNBuf
 == 
NULL
) {

1931 
	`PPPDEBUG
((
LOG_ERR
, "pppInProc[%d]: NO FREE MBUFS!\n", 
pd
));

1932 
	`LINK_STATS_INC
(
link
.
memerr
);

1933 
	`pppDrop
(
pc
);

1934 
pc
->
inState
 = 
PDSTART
;

1937 if (
pc
->
inHead
 == 
NULL
) {

1938 struct 
pppInputHeader
 *
pih
 = 
nextNBuf
->
payload
;

1940 
pih
->
unit
 = 
pd
;

1941 
pih
->
proto
 = 
pc
->
inProtocol
;

1943 
nextNBuf
->
len
 += sizeof(*
pih
);

1945 
pc
->
inHead
 = 
nextNBuf
;

1947 
pc
->
inTail
 = 
nextNBuf
;

1950 ((
u_char
*)
pc
->
inTail
->
payload
)[pc->inTail->
len
++] = 
curChar
;

1955 
pc
->
inFCS
 = 
	`PPP_FCS
(pc->inFCS, 
curChar
);

1959 
	`avRandomize
();

1960 
	}
}

1963 #if 
PPPOE_SUPPORT


1965 
	$pppInProcOverEthernet
(int 
pd
, struct 
pbuf
 *
pb
)

1967 struct 
pppInputHeader
 *
pih
;

1968 
u16_t
 
inProtocol
;

1970 if(
pb
->
len
 < sizeof(
inProtocol
)) {

1971 
	`PPPDEBUG
((
LOG_ERR
, "pppInProcOverEthernet: too small for protocol field\n"));

1972 goto 
drop
;

1975 
inProtocol
 = (((
u8_t
 *)
pb
->
payload
)[0] << 8) | ((u8_t*)pb->payload)[1];

1978 if (
	`pbuf_header
(
pb
, sizeof(*
pih
) - sizeof(
inProtocol
)) != 0) {

1979 
	`PPPDEBUG
((
LOG_ERR
, "pppInProcOverEthernet: could not allocate room for header\n"));

1980 goto 
drop
;

1983 
pih
 = 
pb
->
payload
;

1985 
pih
->
unit
 = 
pd
;

1986 
pih
->
proto
 = 
inProtocol
;

1989 if(
	`tcpip_callback
(
pppInput
, 
pb
) != 
ERR_OK
) {

1990 
	`PPPDEBUG
((
LOG_ERR
, "pppInProcOverEthernet[%d]: tcpip_callback() failed, dropping packet\n", 
pd
));

1991 goto 
drop
;

1996 
drop
:

1997 
	`LINK_STATS_INC
(
link
.
drop
);

1998 
	`pbuf_free
(
pb
);

2000 
	}
}

	@/root/Robux/net/lwip/netif/ppp/ppp.h

34 #ifndef 
PPP_H


35 #define 
	#PPP_H


	)

37 #include 
	~"lwip/opt.h
"

39 #if 
PPP_SUPPORT


41 #include 
	~"lwip/def.h
"

42 #include 
	~"lwip/sio.h
"

43 #include 
	~"lwip/api.h
"

44 #include 
	~"lwip/sockets.h
"

45 #include 
	~"lwip/stats.h
"

46 #include 
	~"lwip/mem.h
"

47 #include 
	~"lwip/tcpip.h
"

48 #include 
	~"lwip/netif.h
"

96 #define 
	#TIMEOUT
(
f
, 
a
, 
t
) 
	`sys_untimeout
((f), (a)), 
	`sys_timeout
((t)*1000, (f), (a))

	)

97 #define 
	#UNTIMEOUT
(
f
, 
a
) 
	`sys_untimeout
((f), (a))

	)

100 #ifndef 
__u_char_defined


103 typedef unsigned long 
	tu_long
;

104 typedef unsigned int 
	tu_int
;

105 typedef unsigned short 
	tu_short
;

106 typedef unsigned char 
	tu_char
;

118 #define 
	#PPP_HDRLEN
 4

	)

119 #define 
	#PPP_FCSLEN
 2

	)

125 #define 
	#PPP_ALLSTATIONS
 0xff

	)

126 #define 
	#PPP_UI
 0x03

	)

127 #define 
	#PPP_FLAG
 0x7e

	)

128 #define 
	#PPP_ESCAPE
 0x7d

	)

129 #define 
	#PPP_TRANS
 0x20

	)

134 #define 
	#PPP_IP
 0x21

	)

135 #define 
	#PPP_AT
 0x29

	)

136 #define 
	#PPP_VJC_COMP
 0x2d

	)

137 #define 
	#PPP_VJC_UNCOMP
 0x2f

	)

138 #define 
	#PPP_COMP
 0xfd

	)

139 #define 
	#PPP_IPCP
 0x8021

	)

140 #define 
	#PPP_ATCP
 0x8029

	)

141 #define 
	#PPP_CCP
 0x80fd

	)

142 #define 
	#PPP_LCP
 0xc021

	)

143 #define 
	#PPP_PAP
 0xc023

	)

144 #define 
	#PPP_LQR
 0xc025

	)

145 #define 
	#PPP_CHAP
 0xc223

	)

146 #define 
	#PPP_CBCP
 0xc029

	)

151 #define 
	#PPP_INITFCS
 0xffff

	)

152 #define 
	#PPP_GOODFCS
 0xf0b8

	)

153 #define 
	#PPP_FCS
(
fcs
, 
c
) (((fcs) >> 8) ^ 
fcstab
[((fcs) ^ (c)) & 0xff])

	)

158 typedef 
u_char
 
	text_accm
[32];

163 enum 
	eNPmode
 {

164 
	mNPMODE_PASS
,

165 
	mNPMODE_DROP
,

166 
	mNPMODE_ERROR
,

167 
	mNPMODE_QUEUE


176 #define 
	#GETCHAR
(
c
, 
cp
) { \

177 (
c
) = *(
cp
)++; \

178 }

	)

179 #define 
	#PUTCHAR
(
c
, 
cp
) { \

180 *(
cp
)++ = (
u_char
) (
c
); \

181 }

	)

184 #define 
	#GETSHORT
(
s
, 
cp
) { \

185 (
s
) = *(
cp
); (cp)++; (s) <<= 8; \

186 (
s
) |= *(
cp
); (cp)++; \

187 }

	)

188 #define 
	#PUTSHORT
(
s
, 
cp
) { \

189 *(
cp
)++ = (
u_char
) ((
s
) >> 8); \

190 *(
cp
)++ = (
u_char
) (
s
 & 0xff); \

191 }

	)

193 #define 
	#GETLONG
(
l
, 
cp
) { \

194 (
l
) = *(
cp
); (cp)++; (l) <<= 8; \

195 (
l
) |= *(
cp
); (cp)++; (l) <<= 8; \

196 (
l
) |= *(
cp
); (cp)++; (l) <<= 8; \

197 (
l
) |= *(
cp
); (cp)++; \

198 }

	)

199 #define 
	#PUTLONG
(
l
, 
cp
) { \

200 *(
cp
)++ = (
u_char
) ((
l
) >> 24); \

201 *(
cp
)++ = (
u_char
) ((
l
) >> 16); \

202 *(
cp
)++ = (
u_char
) ((
l
) >> 8); \

203 *(
cp
)++ = (
u_char
) (
l
); \

204 }

	)

207 #define 
	#INCPTR
(
n
, 
cp
) ((cp) += (n))

	)

208 #define 
	#DECPTR
(
n
, 
cp
) ((cp) -= (n))

	)

210 #define 
	#BCMP
(
s0
, 
s1
, 
l
) 
	`memcmp
((
u_char
 *)(s0), (u_char *)(s1), (l))

	)

211 #define 
	#BCOPY
(
s
, 
d
, 
l
) 
	`MEMCPY
((d), (s), (l))

	)

212 #define 
	#BZERO
(
s
, 
n
) 
	`memset
(s, 0, n)

	)

214 #if 
PPP_DEBUG


215 #define 
	#PRINTMSG
(
m
, 
l
) { m[l] = '\0'; 
	`ppp_trace
(
LOG_INFO
, "Remote message: %s\n", m); }

	)

217 #define 
	#PRINTMSG
(
m
, 
l
)

	)

223 #define 
	#MAKEHEADER
(
p
, 
t
) { \

224 
	`PUTCHAR
(
PPP_ALLSTATIONS
, 
p
); \

225 
	`PUTCHAR
(
PPP_UI
, 
p
); \

226 
	`PUTSHORT
(
t
, 
p
); }

	)

233 #define 
	#PPPERR_NONE
 0

	)

234 #define 
	#PPPERR_PARAM
 -1

	)

235 #define 
	#PPPERR_OPEN
 -2

	)

236 #define 
	#PPPERR_DEVICE
 -3

	)

237 #define 
	#PPPERR_ALLOC
 -4

	)

238 #define 
	#PPPERR_USER
 -5

	)

239 #define 
	#PPPERR_CONNECT
 -6

	)

240 #define 
	#PPPERR_AUTHFAIL
 -7

	)

241 #define 
	#PPPERR_PROTOCOL
 -8

	)

250 #define 
	#PPPCTLG_UPSTATUS
 100

	)

251 #define 
	#PPPCTLS_ERRCODE
 101

	)

252 #define 
	#PPPCTLG_ERRCODE
 102

	)

253 #define 
	#PPPCTLG_FD
 103

	)

263 struct 
	sprotent
 {

264 
u_short
 
	mprotocol
;

266 void (*
	minit
) (int 
	munit
);

268 void (*
	minput
) (int 
	munit
, 
u_char
 *
	mpkt
, int 
	mlen
);

270 void (*
	mprotrej
) (int 
	munit
);

272 void (*
	mlowerup
) (int 
	munit
);

274 void (*
	mlowerdown
) (int 
	munit
);

276 void (*
	mopen
) (int 
	munit
);

278 void (*
	mclose
) (int 
	munit
, char *
	mreason
);

281 int (*
	mprintpkt
) (
u_char
 *
	mpkt
, int 
	mlen
,

282 void (*
	mprinter
) (void *, char *, ...),

283 void *
	marg
);

285 void (*
	mdatainput
) (int 
	munit
, 
u_char
 *
	mpkt
, int 
	mlen
);

287 int 
	menabled_flag
;

288 char *
	mname
;

291 void (*
	mcheck_options
) (
	mu_long
);

293 int (*
	mdemand_conf
) (int 
	munit
);

295 int (*
	mactive_pkt
) (
u_char
 *
	mpkt
, int 
	mlen
);

303 struct 
	sppp_idle
 {

304 
u_short
 
	mxmit_idle
;

305 
u_short
 
	mrecv_idle
;

308 struct 
	sppp_settings
 {

310 
u_int
 
	mdisable_defaultip
 : 1;

311 
u_int
 
	mauth_required
 : 1;

312 
u_int
 
	mexplicit_remote
 : 1;

313 
u_int
 
	mrefuse_pap
 : 1;

314 
u_int
 
	mrefuse_chap
 : 1;

315 
u_int
 
	musehostname
 : 1;

316 
u_int
 
	musepeerdns
 : 1;

318 
u_short
 
	midle_time_limit
;

319 int 
	mmaxconnect
;

321 char 
	muser
 [
MAXNAMELEN
 + 1];

322 char 
	mpasswd
 [
MAXSECRETLEN
 + 1];

323 char 
	mour_name
 [
MAXNAMELEN
 + 1];

324 char 
	mremote_name
[
MAXNAMELEN
 + 1];

327 struct 
	sppp_addrs
 {

328 struct 
ip_addr
 
	mour_ipaddr
, 
	mhis_ipaddr
, 
	mnetmask
, 
	mdns1
, 
	mdns2
;

336 extern 
u_char
 *
outpacket_buf
[
NUM_PPP
];

338 extern struct 
ppp_settings
 ppp_settings;

340 extern struct 
protent
 *
ppp_protocols
[];

348 
err_t
 
pppInit
(void);

369 enum 
	epppAuthType
 {

370 
	mPPPAUTHTYPE_NONE
,

371 
	mPPPAUTHTYPE_ANY
,

372 
	mPPPAUTHTYPE_PAP
,

373 
	mPPPAUTHTYPE_CHAP


376 void 
pppSetAuth
(enum 
pppAuthType
 
authType
, const char *
user
, const char *
passwd
);

385 int 
pppOverSerialOpen
(
sio_fd_t
 
fd
, void (*
linkStatusCB
)(void *
ctx
, int 
errCode
, void *
arg
), void *
linkStatusCtx
);

390 int 
	`pppOverEthernetOpen
(struct 
netif
 *
ethif
, const char *
service_name
, const char *
concentrator_name
, void (*
linkStatusCB
)(void *
ctx
, int 
errCode
, void *
arg
), void *
linkStatusCtx
);

393 #define 
	#pppOpen
(
fd
,
cb
,
ls
) 
	`pppOverSerialOpen
(fd,cb,ls)

	)

400 int 
	`pppClose
(int 
pd
);

405 void 
	`pppSigHUP
(int 
pd
);

411 int 
	`pppIOCtl
(int 
pd
, int 
cmd
, void *
arg
);

416 
u_int
 
	`pppMTU
(int 
pd
);

422 int 
	`pppWrite
(int 
pd
, const 
u_char
 *
s
, int 
n
);

424 void 
	`pppInProcOverEthernet
(int 
pd
, struct 
pbuf
 *
pb
);

426 struct 
pbuf
 *
	`pppSingleBuf
(struct pbuf *
p
);

428 void 
	`pppLinkTerminated
(int 
pd
);

430 void 
	`pppLinkDown
(int 
pd
);

432 void 
	`pppMainWakeup
(int 
pd
);

435 void 
	`ppp_send_config
 (int, int, 
u32_t
, int, int);

437 void 
	`ppp_set_xaccm
 (int, 
ext_accm
 *);

439 void 
	`ppp_recv_config
 (int, int, 
u32_t
, int, int);

441 int 
	`get_idle_time
 (int, struct 
ppp_idle
 *);

444 int 
	`sifvjcomp
 (int, int, int, int);

446 int 
	`sifup
 (int);

448 int 
	`sifnpmode
 (int 
u
, int 
proto
, enum 
NPmode
 
mode
);

450 int 
	`sifdown
 (int);

452 int 
	`sifaddr
 (int, 
u32_t
, u32_t, u32_t, u32_t, u32_t);

454 int 
	`cifaddr
 (int, 
u32_t
, u32_t);

456 int 
	`sifdefaultroute
 (int, 
u32_t
, u32_t);

458 int 
	`cifdefaultroute
 (int, 
u32_t
, u32_t);

461 
u32_t
 
	`GetMask
 (u32_t);

	@/root/Robux/net/lwip/netif/ppp/ppp_oe.c

71 #include 
	~"lwip/opt.h
"

73 #if 
PPPOE_SUPPORT


75 #include 
	~"ppp.h
"

76 #include 
	~"pppdebug.h
"

78 #include 
	~"lwip/sys.h
"

80 #include 
	~"netif/ppp_oe.h
"

81 #include 
	~"netif/etharp.h
"

83 #include 
	~<string.h
>

84 #include 
	~<stdio.h
>

87 #ifndef 
_SYS_QUEUE_H_


88 #define 
	#_SYS_QUEUE_H_


	)

104 #define 
	#LIST_HEAD
(
name
, 
type
) \

105 struct 
	sname
 { \

106 struct 
type
 *
lh_first
; \

107 }

	)

109 #define 
	#LIST_HEAD_INITIALIZER
(
head
) \

110 { 
NULL
 }

	)

112 #define 
	#LIST_ENTRY
(
type
) \

114 struct 
type
 *
le_next
; \

115 struct 
type
 **
le_prev
; \

116 }

	)

122 #define 
	#LIST_EMPTY
(
head
) ((head)->
lh_first
 == 
NULL
)

	)

124 #define 
	#LIST_FIRST
(
head
) ((head)->
lh_first
)

	)

126 #define 
	#LIST_FOREACH
(
var
, 
head
, 
field
) \

127 for ((
var
) = 
	`LIST_FIRST
((
head
)); \

128 (
var
); \

129 (
var
) = 
	`LIST_NEXT
((var), 
field
))

	)

131 #define 
	#LIST_INIT
(
head
) do { \

132 
	`LIST_FIRST
((
head
)) = 
NULL
; \

133 } while (0)

	)

135 #define 
	#LIST_INSERT_AFTER
(
listelm
, 
elm
, 
field
) do { \

136 if ((
	`LIST_NEXT
((
elm
), 
field
) = LIST_NEXT((
listelm
), field)) != 
NULL
) \

137 
	`LIST_NEXT
((
listelm
), 
field
)->field.
le_prev
 = \

138 &
	`LIST_NEXT
((
elm
), 
field
); \

139 
	`LIST_NEXT
((
listelm
), 
field
) = (
elm
); \

140 (
elm
)->
field
.
le_prev
 = &
	`LIST_NEXT
((
listelm
), field); \

141 } while (0)

	)

143 #define 
	#LIST_INSERT_BEFORE
(
listelm
, 
elm
, 
field
) do { \

144 (
elm
)->
field
.
le_prev
 = (
listelm
)->field.le_prev; \

145 
	`LIST_NEXT
((
elm
), 
field
) = (
listelm
); \

146 *(
listelm
)->
field
.
le_prev
 = (
elm
); \

147 (
listelm
)->
field
.
le_prev
 = &
	`LIST_NEXT
((
elm
), field); \

148 } while (0)

	)

150 #define 
	#LIST_INSERT_HEAD
(
head
, 
elm
, 
field
) do { \

151 if ((
	`LIST_NEXT
((
elm
), 
field
) = 
	`LIST_FIRST
((
head
))) != 
NULL
) \

152 
	`LIST_FIRST
((
head
))->
field
.
le_prev
 = &
	`LIST_NEXT
((
elm
), field); \

153 
	`LIST_FIRST
((
head
)) = (
elm
); \

154 (
elm
)->
field
.
le_prev
 = &
	`LIST_FIRST
((
head
)); \

155 } while (0)

	)

157 #define 
	#LIST_NEXT
(
elm
, 
field
) ((elm)->field.
le_next
)

	)

159 #define 
	#LIST_REMOVE
(
elm
, 
field
) do { \

160 if (
	`LIST_NEXT
((
elm
), 
field
) != 
NULL
) \

161 
	`LIST_NEXT
((
elm
), 
field
)->field.
le_prev
 = \

162 (
elm
)->
field
.
le_prev
; \

163 *(
elm
)->
field
.
le_prev
 = 
	`LIST_NEXT
((elm), field); \

164 } while (0)

	)

170 #define 
	#PPPOE_ADD_16
(
PTR
, 
VAL
) \

171 *(
PTR
)++ = (
VAL
) / 256; \

172 *(
PTR
)++ = (
VAL
) % 256

	)

175 #define 
	#PPPOE_ADD_HEADER
(
PTR
, 
CODE
, 
SESS
, 
LEN
) \

176 *(
PTR
)++ = 
PPPOE_VERTYPE
; \

177 *(
PTR
)++ = (
CODE
); \

178 
	`PPPOE_ADD_16
(
PTR
, 
SESS
); \

179 
	`PPPOE_ADD_16
(
PTR
, 
LEN
)

	)

181 #define 
	#PPPOE_DISC_TIMEOUT
 (5*1000)

	)

182 #define 
	#PPPOE_SLOW_RETRY
 (60*1000)

	)

183 #define 
	#PPPOE_DISC_MAXPADI
 4

	)

184 #define 
	#PPPOE_DISC_MAXPADR
 2

	)

186 #ifdef 
PPPOE_SERVER


188 #define 
	#IFF_PASSIVE
 
IFF_LINK0


	)

191 struct 
	spppoe_softc
 {

192 
LIST_ENTRY
(
pppoe_softc
) 
	msc_list
;

193 struct 
netif
 *
	msc_ethif
;

194 int 
	msc_pd
;

195 void (*
	msc_linkStatusCB
)(int 
	mpd
, int 
	mup
);

197 int 
	msc_state
;

198 struct 
eth_addr
 
	msc_dest
;

199 
u16_t
 
	msc_session
;

201 char *
	msc_service_name
;

202 char *
	msc_concentrator_name
;

203 
u8_t
 *
	msc_ac_cookie
;

204 
size_t
 
	msc_ac_cookie_len
;

205 #ifdef 
PPPOE_SERVER


206 
u8_t
 *
	msc_hunique
;

207 
size_t
 
	msc_hunique_len
;

209 int 
	msc_padi_retried
;

210 int 
	msc_padr_retried
;

214 static void 
pppoe_dispatch_disc_pkt
(struct 
netif
 *, struct 
pbuf
 *);

217 static int 
pppoe_do_disconnect
(struct 
pppoe_softc
 *);

218 static void 
pppoe_abort_connect
(struct 
pppoe_softc
 *);

219 static void 
pppoe_clear_softc
(struct 
pppoe_softc
 *, const char *);

222 static void 
pppoe_timeout
(void *);

225 static 
err_t
 
pppoe_send_padi
(struct 
pppoe_softc
 *);

226 static 
err_t
 
pppoe_send_padr
(struct 
pppoe_softc
 *);

227 #ifdef 
PPPOE_SERVER


228 static 
err_t
 
pppoe_send_pado
(struct 
pppoe_softc
 *);

229 static 
err_t
 
pppoe_send_pads
(struct 
pppoe_softc
 *);

231 static 
err_t
 
pppoe_send_padt
(struct 
netif
 *, 
u_int
, const 
u8_t
 *);

234 static struct 
pppoe_softc
 * 
pppoe_find_softc_by_session
(
u_int
, struct 
netif
 *);

235 static struct 
pppoe_softc
 * 
pppoe_find_softc_by_hunique
(
u8_t
 *, 
size_t
, struct 
netif
 *);

237 static 
	$LIST_HEAD
(
pppoe_softc_head
, 
pppoe_softc
) 
pppoe_softc_list
;

239 int 
pppoe_hdrlen
;

242 
	$pppoe_init
(void)

244 
pppoe_hdrlen
 = sizeof(struct 
eth_hdr
) + 
PPPOE_HEADERLEN
;

245 
	`LIST_INIT
(&
pppoe_softc_list
);

246 
	}
}

248 
err_t


249 
pppoe_create
(struct 
netif
 *
ethif
, int 
pd
, void (*
linkStatusCB
)(int pd, int 
up
), struct 
pppoe_softc
 **
scptr
)

251 struct 
pppoe_softc
 *
sc
;

253 
sc
 = 
	`mem_malloc
(sizeof(struct 
pppoe_softc
));

254 if(!
sc
) {

255 *
scptr
 = 
NULL
;

256 return 
ERR_MEM
;

258 
	`memset
(
sc
, 0, sizeof(struct 
pppoe_softc
));

261 
	`MEMCPY
(&
sc
->
sc_dest
, 
ethbroadcast
.
addr
, sizeof(sc->sc_dest));

263 
sc
->
sc_pd
 = 
pd
;

264 
sc
->
sc_linkStatusCB
 = 
linkStatusCB
;

265 
sc
->
sc_ethif
 = 
ethif
;

267 
	`LIST_INSERT_HEAD
(&
pppoe_softc_list
, 
sc
, 
sc_list
);

269 *
scptr
 = 
sc
;

271 return 
ERR_OK
;

272 
	}
}

274 
err_t


275 
	$pppoe_destroy
(struct 
netif
 *
ifp
)

277 struct 
pppoe_softc
 * 
sc
;

279 
	`LIST_FOREACH
(
sc
, &
pppoe_softc_list
, 
sc_list
) {

280 if (
sc
->
sc_ethif
 == 
ifp
) {

285 if(!(
sc
 && (sc->
sc_ethif
 == 
ifp
))) {

286 return 
ERR_IF
;

289 
	`tcpip_untimeout
(
pppoe_timeout
, 
sc
);

290 
	`LIST_REMOVE
(
sc
, 
sc_list
);

292 if (
sc
->
sc_concentrator_name
) {

293 
	`mem_free
(
sc
->
sc_concentrator_name
);

295 if (
sc
->
sc_service_name
) {

296 
	`mem_free
(
sc
->
sc_service_name
);

298 if (
sc
->
sc_ac_cookie
) {

299 
	`mem_free
(
sc
->
sc_ac_cookie
);

301 
	`mem_free
(
sc
);

303 return 
ERR_OK
;

304 
	}
}

312 static struct 
pppoe_softc
 *

313 
	$pppoe_find_softc_by_session
(
u_int
 
session
, struct 
netif
 *
rcvif
)

315 struct 
pppoe_softc
 *
sc
;

317 if (
session
 == 0) {

318 return 
NULL
;

321 
	`LIST_FOREACH
(
sc
, &
pppoe_softc_list
, 
sc_list
) {

322 if (
sc
->
sc_state
 == 
PPPOE_STATE_SESSION


323 && 
sc
->
sc_session
 == 
session
) {

324 if (
sc
->
sc_ethif
 == 
rcvif
) {

325 return 
sc
;

327 return 
NULL
;

331 return 
NULL
;

332 
	}
}

336 static struct 
pppoe_softc
 *

337 
	$pppoe_find_softc_by_hunique
(
u8_t
 *
token
, 
size_t
 
len
, struct 
netif
 *
rcvif
)

339 struct 
pppoe_softc
 *
sc
, *
t
;

341 if (
	`LIST_EMPTY
(&
pppoe_softc_list
)) {

342 return 
NULL
;

345 if (
len
 != sizeof 
sc
) {

346 return 
NULL
;

348 
	`MEMCPY
(&
t
, 
token
, 
len
);

350 
	`LIST_FOREACH
(
sc
, &
pppoe_softc_list
, 
sc_list
) {

351 if (
sc
 == 
t
) {

356 if (
sc
 == 
NULL
) {

357 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: alien host unique tag, no session found\n"));

358 return 
NULL
;

362 if (
sc
->
sc_state
 < 
PPPOE_STATE_PADI_SENT
 || sc->sc_state >= 
PPPOE_STATE_SESSION
) {

363 
	`printf
("%c%c%"
U16_F
": host unique tag found, but it belongs to a connection in state %d\n",

364 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, sc->
sc_state
);

365 return 
NULL
;

367 if (
sc
->
sc_ethif
 != 
rcvif
) {

368 
	`printf
("%c%c%"
U16_F
": wrong interface, not accepting host unique\n",

369 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
);

370 return 
NULL
;

372 return 
sc
;

373 
	}
}

376 
	$pppoe_linkstatus_up
(void *
arg
)

378 struct 
pppoe_softc
 *
sc
 = (struct pppoe_softc*)
arg
;

380 
sc
->
	`sc_linkStatusCB
(sc->
sc_pd
, 1);

381 
	}
}

385 
	$pppoe_dispatch_disc_pkt
(struct 
netif
 *netif, struct 
pbuf
 *
pb
)

387 
u16_t
 
tag
, 
len
;

388 
u16_t
 
session
, 
plen
;

389 struct 
pppoe_softc
 *
sc
;

390 const char *
err_msg
;

391 char 
devname
[6];

392 char *
error
;

393 
u8_t
 *
ac_cookie
;

394 
size_t
 
ac_cookie_len
;

395 #ifdef 
PPPOE_SERVER


396 
u8_t
 *
hunique
;

397 
size_t
 
hunique_len
;

399 struct 
pppoehdr
 *
ph
;

400 struct 
pppoetag
 
pt
;

401 int 
off
 = 0, 
err
, 
errortag
;

402 struct 
eth_hdr
 *
ethhdr
;

404 
pb
 = 
	`pppSingleBuf
(pb);

406 
	`strcpy
(
devname
, "pppoe");

407 
err_msg
 = 
NULL
;

408 
errortag
 = 0;

409 if (
pb
->
len
 < sizeof(*
ethhdr
)) {

410 goto 
done
;

412 
ethhdr
 = (struct 
eth_hdr
 *)
pb
->
payload
;

413 
off
 += sizeof(*
ethhdr
);

415 
ac_cookie
 = 
NULL
;

416 
ac_cookie_len
 = 0;

417 #ifdef 
PPPOE_SERVER


418 
hunique
 = 
NULL
;

419 
hunique_len
 = 0;

421 
session
 = 0;

422 if (
pb
->
len
 - 
off
 <= 
PPPOE_HEADERLEN
) {

423 
	`printf
("pppoe: packet too short: %d\n", 
pb
->
len
);

424 goto 
done
;

427 
ph
 = (struct 
pppoehdr
 *) (
ethhdr
 + 1);

428 if (
ph
->
vertype
 != 
PPPOE_VERTYPE
) {

429 
	`printf
("pppoe: unknown version/type packet: 0x%x\n", 
ph
->
vertype
);

430 goto 
done
;

432 
session
 = 
	`ntohs
(
ph
->session);

433 
plen
 = 
	`ntohs
(
ph
->plen);

434 
off
 += sizeof(*
ph
);

436 if (
plen
 + 
off
 > 
pb
->
len
) {

437 
	`printf
("pppoe: packet content does not fit: data available = %d, packet size = %u\n",

438 
pb
->
len
 - 
off
, 
plen
);

439 goto 
done
;

441 if(
pb
->
tot_len
 == pb->
len
) {

442 
pb
->
tot_len
 = pb->
len
 = 
off
 + 
plen
;

444 
tag
 = 0;

445 
len
 = 0;

446 
sc
 = 
NULL
;

447 while (
off
 + sizeof(
pt
) <= 
pb
->
len
) {

448 
	`MEMCPY
(&
pt
, (
u8_t
*)
pb
->
payload
 + 
off
, sizeof(pt));

449 
tag
 = 
	`ntohs
(
pt
.tag);

450 
len
 = 
	`ntohs
(
pt
.len);

451 if (
off
 + sizeof(
pt
) + 
len
 > 
pb
->len) {

452 
	`printf
("pppoe: tag 0x%x len 0x%x is too long\n", 
tag
, 
len
);

453 goto 
done
;

455 switch (
tag
) {

456 case 
PPPOE_TAG_EOL
:

457 goto 
breakbreak
;

458 case 
PPPOE_TAG_SNAME
:

460 case 
PPPOE_TAG_ACNAME
:

462 case 
PPPOE_TAG_HUNIQUE
:

463 if (
sc
 != 
NULL
) {

466 #ifdef 
PPPOE_SERVER


467 
hunique
 = (
u8_t
*)
pb
->
payload
 + 
off
 + sizeof(
pt
);

468 
hunique_len
 = 
len
;

470 
sc
 = 
	`pppoe_find_softc_by_hunique
((
u8_t
*)
pb
->
payload
 + 
off
 + sizeof(
pt
), 
len
, 
netif
);

471 if (
sc
 != 
NULL
) {

472 
	`snprintf
(
devname
, sizeof(devname), "%c%c%"
U16_F
, 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
);

475 case 
PPPOE_TAG_ACCOOKIE
:

476 if (
ac_cookie
 == 
NULL
) {

477 
ac_cookie
 = (
u8_t
*)
pb
->
payload
 + 
off
 + sizeof(
pt
);

478 
ac_cookie_len
 = 
len
;

481 case 
PPPOE_TAG_SNAME_ERR
:

482 
err_msg
 = "SERVICE NAME ERROR";

483 
errortag
 = 1;

485 case 
PPPOE_TAG_ACSYS_ERR
:

486 
err_msg
 = "AC SYSTEM ERROR";

487 
errortag
 = 1;

489 case 
PPPOE_TAG_GENERIC_ERR
:

490 
err_msg
 = "GENERIC ERROR";

491 
errortag
 = 1;

494 if (
err_msg
) {

495 
error
 = 
NULL
;

496 if (
errortag
 && 
len
) {

497 
error
 = 
	`mem_malloc
(
len
+1);

498 if (
error
) {

499 
	`strncpy
(
error
, (char*)
pb
->
payload
 + 
off
 + sizeof(
pt
), 
len
);

500 
error
[
len
-1] = '\0';

503 if (
error
) {

504 
	`printf
("%s: %s: %s\n", 
devname
, 
err_msg
, 
error
);

505 
	`mem_free
(
error
);

507 
	`printf
("%s: %s\n", 
devname
, 
err_msg
);

509 if (
errortag
) {

510 goto 
done
;

513 
off
 += sizeof(
pt
) + 
len
;

516 
breakbreak
:;

517 switch (
ph
->
code
) {

518 case 
PPPOE_CODE_PADI
:

519 #ifdef 
PPPOE_SERVER


524 if (
	`LIST_EMPTY
(&
pppoe_softc_list
)) {

525 goto 
done
;

527 
	`LIST_FOREACH
(
sc
, &
pppoe_softc_list
, 
sc_list
) {

528 if (!(
sc
->
sc_sppp
.
pp_if
.
if_flags
 & 
IFF_UP
)) {

531 if (!(
sc
->
sc_sppp
.
pp_if
.
if_flags
 & 
IFF_PASSIVE
)) {

534 if (
sc
->
sc_state
 == 
PPPOE_STATE_INITIAL
) {

538 if (
sc
 == 
NULL
) {

540 goto 
done
;

542 if (
hunique
) {

543 if (
sc
->
sc_hunique
) {

544 
	`mem_free
(
sc
->
sc_hunique
);

546 
sc
->
sc_hunique
 = 
	`mem_malloc
(
hunique_len
);

547 if (
sc
->
sc_hunique
 == 
NULL
) {

548 goto 
done
;

550 
sc
->
sc_hunique_len
 = 
hunique_len
;

551 
	`MEMCPY
(
sc
->
sc_hunique
, 
hunique
, 
hunique_len
);

553 
	`MEMCPY
(&
sc
->
sc_dest
, 
eh
->
ether_shost
, sizeof sc->sc_dest);

554 
sc
->
sc_state
 = 
PPPOE_STATE_PADO_SENT
;

555 
	`pppoe_send_pado
(
sc
);

558 case 
PPPOE_CODE_PADR
:

559 #ifdef 
PPPOE_SERVER


563 if (
ac_cookie
 == 
NULL
) {

565 
	`printf
("pppoe: received PADR but not includes ac_cookie\n");

566 goto 
done
;

568 
sc
 = 
	`pppoe_find_softc_by_hunique
(
ac_cookie
, 
ac_cookie_len
, 
netif
);

569 if (
sc
 == 
NULL
) {

571 if (!
	`LIST_EMPTY
(&
pppoe_softc_list
)) {

572 
	`printf
("pppoe: received PADR but could not find request for it\n");

574 goto 
done
;

576 if (
sc
->
sc_state
 != 
PPPOE_STATE_PADO_SENT
) {

577 
	`printf
("%c%c%"
U16_F
": received unexpected PADR\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
);

578 goto 
done
;

580 if (
hunique
) {

581 if (
sc
->
sc_hunique
) {

582 
	`mem_free
(
sc
->
sc_hunique
);

584 
sc
->
sc_hunique
 = 
	`mem_malloc
(
hunique_len
);

585 if (
sc
->
sc_hunique
 == 
NULL
) {

586 goto 
done
;

588 
sc
->
sc_hunique_len
 = 
hunique_len
;

589 
	`MEMCPY
(
sc
->
sc_hunique
, 
hunique
, 
hunique_len
);

591 
	`pppoe_send_pads
(
sc
);

592 
sc
->
sc_state
 = 
PPPOE_STATE_SESSION
;

593 
	`tcpip_timeout
 (100, 
pppoe_linkstatus_up
, 
sc
);

597 goto 
done
;

599 case 
PPPOE_CODE_PADO
:

600 if (
sc
 == 
NULL
) {

602 if (!
	`LIST_EMPTY
(&
pppoe_softc_list
)) {

603 
	`printf
("pppoe: received PADO but could not find request for it\n");

605 goto 
done
;

607 if (
sc
->
sc_state
 != 
PPPOE_STATE_PADI_SENT
) {

608 
	`printf
("%c%c%"
U16_F
": received unexpected PADO\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
);

609 goto 
done
;

611 if (
ac_cookie
) {

612 if (
sc
->
sc_ac_cookie
) {

613 
	`mem_free
(
sc
->
sc_ac_cookie
);

615 
sc
->
sc_ac_cookie
 = 
	`mem_malloc
(
ac_cookie_len
);

616 if (
sc
->
sc_ac_cookie
 == 
NULL
) {

617 goto 
done
;

619 
sc
->
sc_ac_cookie_len
 = 
ac_cookie_len
;

620 
	`MEMCPY
(
sc
->
sc_ac_cookie
, 
ac_cookie
, 
ac_cookie_len
);

622 
	`MEMCPY
(&
sc
->
sc_dest
, 
ethhdr
->
src
.
addr
, sizeof(sc->sc_dest.addr));

623 
	`tcpip_untimeout
(
pppoe_timeout
, 
sc
);

624 
sc
->
sc_padr_retried
 = 0;

625 
sc
->
sc_state
 = 
PPPOE_STATE_PADR_SENT
;

626 if ((
err
 = 
	`pppoe_send_padr
(
sc
)) != 0) {

627 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": failed to send PADR, error=%d\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, 
err
));

629 
	`tcpip_timeout
(
PPPOE_DISC_TIMEOUT
 * (1 + 
sc
->
sc_padr_retried
), 
pppoe_timeout
, sc);

631 case 
PPPOE_CODE_PADS
:

632 if (
sc
 == 
NULL
) {

633 goto 
done
;

635 
sc
->
sc_session
 = 
session
;

636 
	`tcpip_untimeout
(
pppoe_timeout
, 
sc
);

637 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": session 0x%x connected\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, 
session
));

638 
sc
->
sc_state
 = 
PPPOE_STATE_SESSION
;

639 
	`tcpip_timeout
 (100, 
pppoe_linkstatus_up
, 
sc
);

641 case 
PPPOE_CODE_PADT
:

642 if (
sc
 == 
NULL
) {

643 goto 
done
;

645 
	`pppoe_clear_softc
(
sc
, "received PADT");

648 if(
sc
) {

649 
	`printf
("%c%c%"
U16_F
": unknown code (0x%04x) session = 0x%04x\n",

650 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
,

651 
ph
->
code
, 
session
);

653 
	`printf
("pppoe: unknown code (0x%04x) session = 0x%04x\n", 
ph
->
code
, 
session
);

658 
done
:

659 
	`pbuf_free
(
pb
);

661 
	}
}

664 
	$pppoe_disc_input
(struct 
netif
 *netif, struct 
pbuf
 *
p
)

667 if (!
	`LIST_EMPTY
(&
pppoe_softc_list
)) {

668 
	`pppoe_dispatch_disc_pkt
(
netif
, 
p
);

670 
	`pbuf_free
(
p
);

672 
	}
}

675 
	$pppoe_data_input
(struct 
netif
 *netif, struct 
pbuf
 *
pb
)

677 
u16_t
 
session
, 
plen
;

678 struct 
pppoe_softc
 *
sc
;

679 struct 
pppoehdr
 *
ph
;

680 #ifdef 
PPPOE_TERM_UNKNOWN_SESSIONS


681 
u8_t
 
shost
[
ETHER_ADDR_LEN
];

684 #ifdef 
PPPOE_TERM_UNKNOWN_SESSIONS


685 
	`MEMCPY
(
shost
, ((struct 
eth_hdr
 *)
pb
->
payload
)->
src
.
addr
, sizeof(shost));

687 if (
	`pbuf_header
(
pb
, -(int)sizeof(struct 
eth_hdr
)) != 0) {

689 
	`PPPDEBUG
((
LOG_ERR
, "pppoe_data_input: pbuf_header failed\n"));

690 
	`LINK_STATS_INC
(
link
.
lenerr
);

691 goto 
drop
;

694 
pb
 = 
	`pppSingleBuf
 (pb);

696 if (
pb
->
len
 <= 
PPPOE_HEADERLEN
) {

697 
	`printf
("pppoe (data): dropping too short packet: %d bytes\n", 
pb
->
len
);

698 goto 
drop
;

701 if (
pb
->
len
 < sizeof(*
ph
)) {

702 
	`printf
("pppoe_data_input: could not get PPPoE header\n");

703 goto 
drop
;

705 
ph
 = (struct 
pppoehdr
 *)
pb
->
payload
;

707 if (
ph
->
vertype
 != 
PPPOE_VERTYPE
) {

708 
	`printf
("pppoe (data): unknown version/type packet: 0x%x\n", 
ph
->
vertype
);

709 goto 
drop
;

711 if (
ph
->
code
 != 0) {

712 goto 
drop
;

715 
session
 = 
	`ntohs
(
ph
->session);

716 
sc
 = 
	`pppoe_find_softc_by_session
(
session
, 
netif
);

717 if (
sc
 == 
NULL
) {

718 #ifdef 
PPPOE_TERM_UNKNOWN_SESSIONS


719 
	`printf
("pppoe: input for unknown session 0x%x, sending PADT\n", 
session
);

720 
	`pppoe_send_padt
(
netif
, 
session
, 
shost
);

722 goto 
drop
;

725 
plen
 = 
	`ntohs
(
ph
->plen);

727 if (
	`pbuf_header
(
pb
, -(int)(
PPPOE_HEADERLEN
)) != 0) {

729 
	`PPPDEBUG
((
LOG_ERR
, "pppoe_data_input: pbuf_header PPPOE_HEADERLEN failed\n"));

730 
	`LINK_STATS_INC
(
link
.
lenerr
);

731 goto 
drop
;

734 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe_data_input: %c%c%"
U16_F
": pkthdr.len=%d, pppoe.len=%d\n",

735 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
,

736 
pb
->
len
, 
plen
));

738 if (
pb
->
len
 < 
plen
) {

739 goto 
drop
;

742 
	`pppInProcOverEthernet
(
sc
->
sc_pd
, 
pb
);

746 
drop
:

747 
	`pbuf_free
(
pb
);

748 
	}
}

750 static 
err_t


751 
	$pppoe_output
(struct 
pppoe_softc
 *
sc
, struct 
pbuf
 *
pb
)

753 struct 
eth_hdr
 *
ethhdr
;

754 
u16_t
 
etype
;

755 
err_t
 
res
;

757 if (!
sc
->
sc_ethif
) {

758 
	`pbuf_free
(
pb
);

759 return 
ERR_IF
;

762 
ethhdr
 = (struct 
eth_hdr
 *)
pb
->
payload
;

763 
etype
 = 
sc
->
sc_state
 == 
PPPOE_STATE_SESSION
 ? 
ETHTYPE_PPPOE
 : 
ETHTYPE_PPPOEDISC
;

764 
ethhdr
->
type
 = 
	`htons
(
etype
);

765 
	`MEMCPY
(
ethhdr
->
dest
.
addr
, 
sc
->
sc_dest
.addr, sizeof(ethhdr->dest.addr));

766 
	`MEMCPY
(
ethhdr
->
src
.
addr
, ((struct 
eth_addr
 *)
sc
->
sc_ethif
->
hwaddr
)->addr, sizeof(ethhdr->src.addr));

768 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
" (%x) state=%d, session=0x%x output -> %02"
X16_F
":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F", len=%d\n",

769 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, 
etype
,

770 
sc
->
sc_state
, sc->
sc_session
,

771 
sc
->
sc_dest
.
addr
[0], sc->sc_dest.addr[1], sc->sc_dest.addr[2], sc->sc_dest.addr[3], sc->sc_dest.addr[4], sc->sc_dest.addr[5],

772 
pb
->
tot_len
));

774 
res
 = 
sc
->
sc_ethif
->
	`linkoutput
(sc->sc_ethif, 
pb
);

776 
	`pbuf_free
(
pb
);

778 return 
res
;

779 
	}
}

781 static 
err_t


782 
	$pppoe_send_padi
(struct 
pppoe_softc
 *
sc
)

784 struct 
pbuf
 *
pb
;

785 
u8_t
 *
p
;

786 int 
len
, 
l1
 = 0, 
l2
 = 0;

788 if (
sc
->
sc_state
 >
PPPOE_STATE_PADI_SENT
) {

789 
	`PPPDEBUG
((
LOG_ERR
, "ERROR: pppoe_send_padi in state %d", 
sc
->
sc_state
));

793 
len
 = 2 + 2 + 2 + 2 + sizeof 
sc
;

794 if (
sc
->
sc_service_name
 != 
NULL
) {

795 
l1
 = 
	`strlen
(
sc
->
sc_service_name
);

796 
len
 += 
l1
;

798 if (
sc
->
sc_concentrator_name
 != 
NULL
) {

799 
l2
 = 
	`strlen
(
sc
->
sc_concentrator_name
);

800 
len
 += 2 + 2 + 
l2
;

804 
pb
 = 
	`pbuf_alloc
(
PBUF_LINK
, sizeof(struct 
eth_hdr
) + 
PPPOE_HEADERLEN
 + 
len
, 
PBUF_RAM
);

805 if (!
pb
) {

806 return 
ERR_MEM
;

809 
p
 = (
u8_t
*)
pb
->
payload
 + sizeof (struct 
eth_hdr
);

811 
	`PPPOE_ADD_HEADER
(
p
, 
PPPOE_CODE_PADI
, 0, 
len
);

812 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_SNAME
);

813 if (
sc
->
sc_service_name
 != 
NULL
) {

814 
	`PPPOE_ADD_16
(
p
, 
l1
);

815 
	`MEMCPY
(
p
, 
sc
->
sc_service_name
, 
l1
);

816 
p
 += 
l1
;

818 
	`PPPOE_ADD_16
(
p
, 0);

820 if (
sc
->
sc_concentrator_name
 != 
NULL
) {

821 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_ACNAME
);

822 
	`PPPOE_ADD_16
(
p
, 
l2
);

823 
	`MEMCPY
(
p
, 
sc
->
sc_concentrator_name
, 
l2
);

824 
p
 += 
l2
;

826 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_HUNIQUE
);

827 
	`PPPOE_ADD_16
(
p
, sizeof(
sc
));

828 
	`MEMCPY
(
p
, &
sc
, sizeof sc);

831 return 
	`pppoe_output
(
sc
, 
pb
);

832 
	}
}

835 
	$pppoe_timeout
(void *
arg
)

837 int 
retry_wait
, 
err
;

838 struct 
pppoe_softc
 *
sc
 = (struct pppoe_softc*)
arg
;

840 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": timeout\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
));

842 switch (
sc
->
sc_state
) {

843 case 
PPPOE_STATE_PADI_SENT
:

855 
retry_wait
 = 
PPPOE_DISC_TIMEOUT
 * (1 + 
sc
->
sc_padi_retried
);

857 
sc
->
sc_padi_retried
++;

858 if (
sc
->
sc_padi_retried
 >= 
PPPOE_DISC_MAXPADI
) {

860 if ((
sc
->
sc_sppp
.
pp_if
.
if_flags
 & 
IFF_LINK1
) == 0) {

862 
retry_wait
 = 
PPPOE_SLOW_RETRY
;

866 
	`pppoe_abort_connect
(
sc
);

870 if ((
err
 = 
	`pppoe_send_padi
(
sc
)) != 0) {

871 
sc
->
sc_padi_retried
--;

872 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": failed to transmit PADI, error=%d\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, 
err
));

874 
	`tcpip_timeout
(
retry_wait
, 
pppoe_timeout
, 
sc
);

877 case 
PPPOE_STATE_PADR_SENT
:

878 
sc
->
sc_padr_retried
++;

879 if (
sc
->
sc_padr_retried
 >= 
PPPOE_DISC_MAXPADR
) {

880 
	`MEMCPY
(&
sc
->
sc_dest
, 
ethbroadcast
.
addr
, sizeof(sc->sc_dest));

881 
sc
->
sc_state
 = 
PPPOE_STATE_PADI_SENT
;

882 
sc
->
sc_padr_retried
 = 0;

883 if ((
err
 = 
	`pppoe_send_padi
(
sc
)) != 0) {

884 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": failed to send PADI, error=%d\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, 
err
));

886 
	`tcpip_timeout
(
PPPOE_DISC_TIMEOUT
 * (1 + 
sc
->
sc_padi_retried
), 
pppoe_timeout
, sc);

889 if ((
err
 = 
	`pppoe_send_padr
(
sc
)) != 0) {

890 
sc
->
sc_padr_retried
--;

891 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": failed to send PADR, error=%d\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, 
err
));

893 
	`tcpip_timeout
(
PPPOE_DISC_TIMEOUT
 * (1 + 
sc
->
sc_padr_retried
), 
pppoe_timeout
, sc);

895 case 
PPPOE_STATE_CLOSING
:

896 
	`pppoe_do_disconnect
(
sc
);

901 
	}
}

905 
	$pppoe_connect
(struct 
pppoe_softc
 *
sc
)

907 int 
err
;

909 if (
sc
->
sc_state
 != 
PPPOE_STATE_INITIAL
) {

910 return 
EBUSY
;

913 #ifdef 
PPPOE_SERVER


915 if ((
sc
->
sc_sppp
.
pp_if
.
if_flags
 & 
IFF_PASSIVE
)) {

920 
sc
->
sc_state
 = 
PPPOE_STATE_PADI_SENT
;

921 
sc
->
sc_padr_retried
 = 0;

922 
err
 = 
	`pppoe_send_padi
(
sc
);

923 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": failed to send PADI, error=%d\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, 
err
));

924 
	`tcpip_timeout
(
PPPOE_DISC_TIMEOUT
, 
pppoe_timeout
, 
sc
);

925 return 
err
;

926 
	}
}

930 
	$pppoe_disconnect
(struct 
pppoe_softc
 *
sc
)

932 if (
sc
->
sc_state
 < 
PPPOE_STATE_SESSION
) {

940 
sc
->
sc_state
 = 
PPPOE_STATE_CLOSING
;

941 
	`tcpip_timeout
(20, 
pppoe_timeout
, 
sc
);

942 
	}
}

945 
	$pppoe_do_disconnect
(struct 
pppoe_softc
 *
sc
)

947 int 
err
;

949 if (
sc
->
sc_state
 < 
PPPOE_STATE_SESSION
) {

950 
err
 = 
EBUSY
;

952 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": disconnecting\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
));

953 
err
 = 
	`pppoe_send_padt
(
sc
->
sc_ethif
, sc->
sc_session
, (const 
u8_t
 *)&sc->
sc_dest
);

957 
sc
->
sc_state
 = 
PPPOE_STATE_INITIAL
;

958 
	`MEMCPY
(&
sc
->
sc_dest
, 
ethbroadcast
.
addr
, sizeof(sc->sc_dest));

959 if (
sc
->
sc_ac_cookie
) {

960 
	`mem_free
(
sc
->
sc_ac_cookie
);

961 
sc
->
sc_ac_cookie
 = 
NULL
;

963 
sc
->
sc_ac_cookie_len
 = 0;

964 #ifdef 
PPPOE_SERVER


965 if (
sc
->
sc_hunique
) {

966 
	`mem_free
(
sc
->
sc_hunique
);

967 
sc
->
sc_hunique
 = 
NULL
;

969 
sc
->
sc_hunique_len
 = 0;

971 
sc
->
sc_session
 = 0;

973 
sc
->
	`sc_linkStatusCB
(sc->
sc_pd
, 0);

975 return 
err
;

976 
	}
}

980 
	$pppoe_abort_connect
(struct 
pppoe_softc
 *
sc
)

982 
	`printf
("%c%c%"
U16_F
": could not establish connection\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
);

983 
sc
->
sc_state
 = 
PPPOE_STATE_CLOSING
;

985 
sc
->
	`sc_linkStatusCB
(sc->
sc_pd
, 0);

988 
	`MEMCPY
(&
sc
->
sc_dest
, 
ethbroadcast
.
addr
, sizeof(sc->sc_dest));

989 
sc
->
sc_state
 = 
PPPOE_STATE_INITIAL
;

990 
	}
}

993 static 
err_t


994 
	$pppoe_send_padr
(struct 
pppoe_softc
 *
sc
)

996 struct 
pbuf
 *
pb
;

997 
u8_t
 *
p
;

998 
size_t
 
len
, 
l1
 = 0;

1000 if (
sc
->
sc_state
 != 
PPPOE_STATE_PADR_SENT
) {

1001 return 
ERR_CONN
;

1004 
len
 = 2 + 2 + 2 + 2 + sizeof(
sc
);

1005 if (
sc
->
sc_service_name
 != 
NULL
) {

1006 
l1
 = 
	`strlen
(
sc
->
sc_service_name
);

1007 
len
 += 
l1
;

1009 if (
sc
->
sc_ac_cookie_len
 > 0) {

1010 
len
 += 2 + 2 + 
sc
->
sc_ac_cookie_len
;

1012 
pb
 = 
	`pbuf_alloc
(
PBUF_LINK
, sizeof(struct 
eth_hdr
) + 
PPPOE_HEADERLEN
 + 
len
, 
PBUF_RAM
);

1013 if (!
pb
) {

1014 return 
ERR_MEM
;

1016 
p
 = (
u8_t
*)
pb
->
payload
 + sizeof (struct 
eth_hdr
);

1017 
	`PPPOE_ADD_HEADER
(
p
, 
PPPOE_CODE_PADR
, 0, 
len
);

1018 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_SNAME
);

1019 if (
sc
->
sc_service_name
 != 
NULL
) {

1020 
	`PPPOE_ADD_16
(
p
, 
l1
);

1021 
	`MEMCPY
(
p
, 
sc
->
sc_service_name
, 
l1
);

1022 
p
 += 
l1
;

1024 
	`PPPOE_ADD_16
(
p
, 0);

1026 if (
sc
->
sc_ac_cookie_len
 > 0) {

1027 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_ACCOOKIE
);

1028 
	`PPPOE_ADD_16
(
p
, 
sc
->
sc_ac_cookie_len
);

1029 
	`MEMCPY
(
p
, 
sc
->
sc_ac_cookie
, sc->
sc_ac_cookie_len
);

1030 
p
 += 
sc
->
sc_ac_cookie_len
;

1032 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_HUNIQUE
);

1033 
	`PPPOE_ADD_16
(
p
, sizeof(
sc
));

1034 
	`MEMCPY
(
p
, &
sc
, sizeof sc);

1036 return 
	`pppoe_output
(
sc
, 
pb
);

1037 
	}
}

1040 static 
err_t


1041 
	$pppoe_send_padt
(struct 
netif
 *
outgoing_if
, 
u_int
 
session
, const 
u8_t
 *
dest
)

1043 struct 
pbuf
 *
pb
;

1044 struct 
eth_hdr
 *
ethhdr
;

1045 
err_t
 
res
;

1046 
u8_t
 *
p
;

1048 
pb
 = 
	`pbuf_alloc
(
PBUF_LINK
, sizeof(struct 
eth_hdr
) + 
PPPOE_HEADERLEN
, 
PBUF_RAM
);

1049 if (!
pb
) {

1050 return 
ERR_MEM
;

1053 
ethhdr
 = (struct 
eth_hdr
 *)
pb
->
payload
;

1054 
ethhdr
->
type
 = 
	`htons
(
ETHTYPE_PPPOEDISC
);

1055 
	`MEMCPY
(
ethhdr
->
dest
.
addr
, dest, sizeof(ethhdr->dest.addr));

1056 
	`MEMCPY
(
ethhdr
->
src
.
addr
, ((struct 
eth_addr
 *)
outgoing_if
->
hwaddr
)->addr, sizeof(ethhdr->src.addr));

1058 
p
 = (
u8_t
*)(
ethhdr
 + 1);

1059 
	`PPPOE_ADD_HEADER
(
p
, 
PPPOE_CODE_PADT
, 
session
, 0);

1061 
res
 = 
outgoing_if
->
	`linkoutput
(outgoing_if, 
pb
);

1063 
	`pbuf_free
(
pb
);

1065 return 
res
;

1066 
	}
}

1068 #ifdef 
PPPOE_SERVER


1069 static 
err_t


1070 
	$pppoe_send_pado
(struct 
pppoe_softc
 *
sc
)

1072 struct 
pbuf
 *
pb
;

1073 
u8_t
 *
p
;

1074 
size_t
 
len
;

1076 if (
sc
->
sc_state
 != 
PPPOE_STATE_PADO_SENT
) {

1077 return 
ERR_CONN
;

1081 
len
 = 0;

1083 
len
 += 2 + 2 + sizeof(
sc
);

1085 
len
 += 2 + 2 + 
sc
->
sc_hunique_len
;

1086 
pb
 = 
	`pbuf_alloc
(
PBUF_LINK
, sizeof(struct 
eth_hdr
) + 
PPPOE_HEADERLEN
 + 
len
, 
PBUF_RAM
);

1087 if (!
pb
) {

1088 return 
ERR_MEM
;

1090 
p
 = (
u8_t
*)
pb
->
payload
 + sizeof (struct 
eth_hdr
);

1091 
	`PPPOE_ADD_HEADER
(
p
, 
PPPOE_CODE_PADO
, 0, 
len
);

1092 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_ACCOOKIE
);

1093 
	`PPPOE_ADD_16
(
p
, sizeof(
sc
));

1094 
	`MEMCPY
(
p
, &
sc
, sizeof(sc));

1095 
p
 += sizeof(
sc
);

1096 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_HUNIQUE
);

1097 
	`PPPOE_ADD_16
(
p
, 
sc
->
sc_hunique_len
);

1098 
	`MEMCPY
(
p
, 
sc
->
sc_hunique
, sc->
sc_hunique_len
);

1099 return 
	`pppoe_output
(
sc
, 
pb
);

1100 
	}
}

1102 static 
err_t


1103 
	$pppoe_send_pads
(struct 
pppoe_softc
 *
sc
)

1105 struct 
pbuf
 *
pb
;

1106 
u8_t
 *
p
;

1107 
size_t
 
len
, 
l1
 = 0;

1109 if (
sc
->
sc_state
 != 
PPPOE_STATE_PADO_SENT
) {

1110 return 
ERR_CONN
;

1113 
sc
->
sc_session
 = 
mono_time
.
tv_sec
 % 0xff + 1;

1115 
len
 = 0;

1117 
len
 += 2 + 2 + 2 + 2 + 
sc
->
sc_hunique_len
;

1118 if (
sc
->
sc_service_name
 != 
NULL
) {

1119 
l1
 = 
	`strlen
(
sc
->
sc_service_name
);

1120 
len
 += 
l1
;

1122 
pb
 = 
	`pbuf_alloc
(
PBUF_LINK
, sizeof(struct 
eth_hdr
) + 
PPPOE_HEADERLEN
 + 
len
, 
PBUF_RAM
);

1123 if (!
pb
) {

1124 return 
ERR_MEM
;

1126 
p
 = (
u8_t
*)
pb
->
payload
 + sizeof (struct 
eth_hdr
);

1127 
	`PPPOE_ADD_HEADER
(
p
, 
PPPOE_CODE_PADS
, 
sc
->
sc_session
, 
len
);

1128 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_SNAME
);

1129 if (
sc
->
sc_service_name
 != 
NULL
) {

1130 
	`PPPOE_ADD_16
(
p
, 
l1
);

1131 
	`MEMCPY
(
p
, 
sc
->
sc_service_name
, 
l1
);

1132 
p
 += 
l1
;

1134 
	`PPPOE_ADD_16
(
p
, 0);

1136 
	`PPPOE_ADD_16
(
p
, 
PPPOE_TAG_HUNIQUE
);

1137 
	`PPPOE_ADD_16
(
p
, 
sc
->
sc_hunique_len
);

1138 
	`MEMCPY
(
p
, 
sc
->
sc_hunique
, sc->
sc_hunique_len
);

1139 return 
	`pppoe_output
(
sc
, 
pb
);

1140 
	}
}

1143 
err_t


1144 
	$pppoe_xmit
(struct 
pppoe_softc
 *
sc
, struct 
pbuf
 *
pb
)

1146 
u8_t
 *
p
;

1147 
size_t
 
len
;

1150 if (
sc
->
sc_state
 < 
PPPOE_STATE_SESSION
) {

1152 
	`pbuf_free
(
pb
);

1153 return 
ERR_CONN
;

1156 
len
 = 
pb
->
tot_len
;

1159 if (
	`pbuf_header
(
pb
, sizeof(struct 
eth_hdr
) + 
PPPOE_HEADERLEN
) != 0) {

1161 
	`PPPDEBUG
((
LOG_ERR
, "pppoe: %c%c%"
U16_F
": pppoe_xmit: could not allocate room for header\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
));

1162 
	`LINK_STATS_INC
(
link
.
lenerr
);

1163 
	`pbuf_free
(
pb
);

1164 return 
ERR_BUF
;

1167 
p
 = (
u8_t
*)
pb
->
payload
 + sizeof(struct 
eth_hdr
);

1168 
	`PPPOE_ADD_HEADER
(
p
, 0, 
sc
->
sc_session
, 
len
);

1170 return 
	`pppoe_output
(
sc
, 
pb
);

1171 
	}
}

1175 
	$pppoe_ifattach_hook
(void *
arg
, struct 
pbuf
 **
mp
, struct 
netif
 *
ifp
, int 
dir
)

1177 struct 
pppoe_softc
 *
sc
;

1178 int 
s
;

1180 if (
mp
 != (struct 
pbuf
 **)
PFIL_IFNET_DETACH
) {

1184 
	`LIST_FOREACH
(
sc
, &
pppoe_softc_list
, 
sc_list
) {

1185 if (
sc
->
sc_ethif
 != 
ifp
) {

1188 if (
sc
->
sc_sppp
.
pp_if
.
if_flags
 & 
IFF_UP
) {

1189 
sc
->
sc_sppp
.
pp_if
.
if_flags
 &= ~(
IFF_UP
|
IFF_RUNNING
);

1190 
	`printf
("%c%c%"
U16_F
": ethernet interface detached, going down\n",

1191 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
);

1193 
sc
->
sc_ethif
 = 
NULL
;

1194 
	`pppoe_clear_softc
(
sc
, "ethernet interface detached");

1198 
	}
}

1202 
	$pppoe_clear_softc
(struct 
pppoe_softc
 *
sc
, const char *
message
)

1204 
	`LWIP_UNUSED_ARG
(
message
);

1207 
	`tcpip_untimeout
(
pppoe_timeout
, 
sc
);

1208 
	`PPPDEBUG
((
LOG_DEBUG
, "pppoe: %c%c%"
U16_F
": session 0x%x terminated, %s\n", 
sc
->
sc_ethif
->
name
[0], sc->sc_ethif->name[1], sc->sc_ethif->
num
, sc->
sc_session
, 
message
));

1211 
sc
->
sc_state
 = 
PPPOE_STATE_INITIAL
;

1214 
sc
->
	`sc_linkStatusCB
(sc->
sc_pd
, 0);

1217 
	`MEMCPY
(&
sc
->
sc_dest
, 
ethbroadcast
.
addr
, sizeof(sc->sc_dest));

1218 if (
sc
->
sc_ac_cookie
) {

1219 
	`mem_free
(
sc
->
sc_ac_cookie
);

1220 
sc
->
sc_ac_cookie
 = 
NULL
;

1222 
sc
->
sc_ac_cookie_len
 = 0;

1223 
sc
->
sc_session
 = 0;

1224 
	}
}

	@/root/Robux/net/lwip/netif/ppp/pppdebug.h

36 #ifndef 
PPPDEBUG_H


37 #define 
	#PPPDEBUG_H


	)

44 
	mLOG_CRITICAL
 = 0,

45 
	mLOG_ERR
 = 1,

46 
	mLOG_NOTICE
 = 2,

47 
	mLOG_WARNING
 = 3,

48 
	mLOG_INFO
 = 5,

49 
	mLOG_DETAIL
 = 6,

50 
	mLOG_DEBUG
 = 7

51 } 
	tLogCodes
;

60 void 
ppp_trace
(int 
level
, const char *
format
,...);

62 #define 
	#TRACELCP
 
PPP_DEBUG


	)

64 #if 
PPP_DEBUG


66 #define 
	#AUTHDEBUG
(
a
) 
ppp_trace
 
	)
a

67 #define 
	#IPCPDEBUG
(
a
) 
ppp_trace
 
	)
a

68 #define 
	#UPAPDEBUG
(
a
) 
ppp_trace
 
	)
a

69 #define 
	#LCPDEBUG
(
a
) 
ppp_trace
 
	)
a

70 #define 
	#FSMDEBUG
(
a
) 
ppp_trace
 
	)
a

71 #define 
	#CHAPDEBUG
(
a
) 
ppp_trace
 
	)
a

72 #define 
	#PPPDEBUG
(
a
) 
ppp_trace
 
	)
a

76 #define 
	#AUTHDEBUG
(
a
)

	)

77 #define 
	#IPCPDEBUG
(
a
)

	)

78 #define 
	#UPAPDEBUG
(
a
)

	)

79 #define 
	#LCPDEBUG
(
a
)

	)

80 #define 
	#FSMDEBUG
(
a
)

	)

81 #define 
	#CHAPDEBUG
(
a
)

	)

82 #define 
	#PPPDEBUG
(
a
)

	)

	@/root/Robux/net/lwip/netif/ppp/randm.c

34 #include 
	~"lwip/opt.h
"

36 #if 
PPP_SUPPORT


38 #include 
	~"md5.h
"

39 #include 
	~"randm.h
"

41 #include 
	~"ppp.h
"

42 #include 
	~"pppdebug.h
"

45 #if 
MD5_SUPPORT


46 #define 
	#RANDPOOLSZ
 16

	)

51 static char 
	grandPool
[
RANDPOOLSZ
];

52 static long 
	grandCount
 = 0;

67 
	$avRandomInit
()

69 
	`avChurnRand
(
NULL
, 0);

70 
	}
}

83 
	$avChurnRand
(char *
randData
, 
u32_t
 
randLen
)

85 
MD5_CTX
 
md5
;

88 
	`MD5Init
(&
md5
);

89 
	`MD5Update
(&
md5
, (
u_char
 *)
randPool
, sizeof(randPool));

90 if (
randData
) {

91 
	`MD5Update
(&
md5
, (
u_char
 *)
randData
, 
randLen
);

95 char 
foobar
;

96 } 
sysData
;

99 
	`MD5Update
(&
md5
, (
u_char
 *)&
sysData
, sizeof(sysData));

101 
	`MD5Final
((
u_char
 *)
randPool
, &
md5
);

103 
	}
}

122 
	$avGenRand
(char *
buf
, 
u32_t
 
bufLen
)

124 
MD5_CTX
 
md5
;

125 
u_char
 
tmp
[16];

126 
u32_t
 
n
;

128 while (
bufLen
 > 0) {

129 
n
 = 
	`LWIP_MIN
(
bufLen
, 
RANDPOOLSZ
);

130 
	`MD5Init
(&
md5
);

131 
	`MD5Update
(&
md5
, (
u_char
 *)
randPool
, sizeof(randPool));

132 
	`MD5Update
(&
md5
, (
u_char
 *)&
randCount
, sizeof(randCount));

133 
	`MD5Final
(
tmp
, &
md5
);

134 
randCount
++;

135 
	`MEMCPY
(
buf
, 
tmp
, 
n
);

136 
buf
 += 
n
;

137 
bufLen
 -= 
n
;

139 
	}
}

144 
u32_t


145 
	$avRandom
()

147 
u32_t
 
newRand
;

149 
	`avGenRand
((char *)&
newRand
, sizeof(newRand));

151 return 
newRand
;

152 
	}
}

159 static int 
	gavRandomized
 = 0;

160 static 
u32_t
 
	gavRandomSeed
 = 0;

181 
	$avRandomInit
()

185 
u32_t
 *
lptr1
 = (u32_t *)((char *)&
clockBuf
[3]);

197 
	`readClk
();

198 
avRandomSeed
 += *(
u32_t
 *)
clockBuf
 + *
lptr1
 + 
OSIdleCtr


199 + 
	`ppp_mtime
() + ((
u32_t
)
TM1
 << 16) + TM1;

201 
avRandomSeed
 += 
	`sys_jiffies
();

205 
	`srand
((unsigned)
avRandomSeed
);

206 
	}
}

216 
	$avRandomize
(void)

218 static 
u32_t
 
last_jiffies
;

220 if (!
avRandomized
) {

221 
avRandomized
 = !0;

222 
	`avRandomInit
();

226 
avRandomSeed
 += (
	`sys_jiffies
() - 
last_jiffies
);

228 
last_jiffies
 = 
	`sys_jiffies
();

229 
	}
}

240 
u32_t


241 
	$avRandom
()

243 return ((((
u32_t
)
	`rand
() << 16) + rand()) + 
avRandomSeed
);

244 
	}
}

	@/root/Robux/net/lwip/netif/ppp/randm.h

34 #ifndef 
RANDM_H


35 #define 
	#RANDM_H


	)

43 void 
avRandomInit
(void);

53 void 
avChurnRand
(char *
randData
, 
u32_t
 
randLen
);

59 #if 
MD5_SUPPORT


60 #define 
	#avRandomize
() 
	`avChurnRand
(
NULL
, 0)

	)

62 void 
avRandomize
(void);

73 void 
avGenRand
(char *
buf
, 
u32_t
 
bufLen
);

78 
u32_t
 
avRandom
(void);

	@/root/Robux/net/lwip/netif/ppp/vj.c

31 #include 
	~"lwip/opt.h
"

33 #if 
PPP_SUPPORT


35 #include 
	~"ppp.h
"

36 #include 
	~"pppdebug.h
"

38 #include 
	~"vj.h
"

40 #include 
	~<string.h
>

42 #if 
VJ_SUPPORT


44 #if 
LINK_STATS


45 #define 
	#INCR
(
counter
) ++
comp
->
stats
.
	)
counter

47 #define 
	#INCR
(
counter
)

	)

50 #if 
defined
(
NO_CHAR_BITFIELDS
)

51 #define 
	#getip_hl
(
base
) ((base).
ip_hl_v
&0xf)

	)

52 #define 
	#getth_off
(
base
) (((base).
th_x2_off
&0xf0)>>4)

	)

54 #define 
	#getip_hl
(
base
) ((base).
ip_hl
)

	)

55 #define 
	#getth_off
(
base
) ((base).
th_off
)

	)

59 
	$vj_compress_init
(struct 
vjcompress
 *
comp
)

61 register 
u_int
 
i
;

62 register struct 
cstate
 *
tstate
 = 
comp
->tstate;

64 #if 
MAX_SLOTS
 == 0

65 
	`memset
((char *)
comp
, 0, sizeof(*comp));

67 
comp
->
maxSlotIndex
 = 
MAX_SLOTS
 - 1;

68 
comp
->
compressSlot
 = 0;

69 for (
i
 = 
MAX_SLOTS
 - 1; i > 0; --i) {

70 
tstate
[
i
].
cs_id
 = i;

71 
tstate
[
i
].
cs_next
 = &tstate[i - 1];

73 
tstate
[0].
cs_next
 = &tstate[
MAX_SLOTS
 - 1];

74 
tstate
[0].
cs_id
 = 0;

75 
comp
->
last_cs
 = &
tstate
[0];

76 
comp
->
last_recv
 = 255;

77 
comp
->
last_xmit
 = 255;

78 
comp
->
flags
 = 
VJF_TOSS
;

79 
	}
}

86 #define 
	#ENCODE
(
n
) { \

87 if ((
u_short
)(
n
) >= 256) { \

88 *
cp
++ = 0; \

89 
cp
[1] = (
n
); \

90 
cp
[0] = (
n
) >> 8; \

91 
cp
 += 2; \

93 *
cp
++ = (
n
); \

95 }

	)

96 #define 
	#ENCODEZ
(
n
) { \

97 if ((
u_short
)(
n
) >= 256 || (u_short)(n) == 0) { \

98 *
cp
++ = 0; \

99 
cp
[1] = (
n
); \

100 
cp
[0] = (
n
) >> 8; \

101 
cp
 += 2; \

103 *
cp
++ = (
n
); \

105 }

	)

107 #define 
	#DECODEL
(
f
) { \

108 if (*
cp
 == 0) {\

109 
u32_t
 
tmp
 = 
	`ntohl
(
f
) + ((
cp
[1] << 8) | cp[2]); \

110 (
f
) = 
	`htonl
(
tmp
); \

111 
cp
 += 3; \

113 
u32_t
 
tmp
 = 
	`ntohl
(
f
) + (u32_t)*
cp
++; \

114 (
f
) = 
	`htonl
(
tmp
); \

116 }

	)

118 #define 
	#DECODES
(
f
) { \

119 if (*
cp
 == 0) {\

120 
u_short
 
tmp
 = 
	`ntohs
(
f
) + (((u_short)
cp
[1] << 8) | cp[2]); \

121 (
f
) = 
	`htons
(
tmp
); \

122 
cp
 += 3; \

124 
u_short
 
tmp
 = 
	`ntohs
(
f
) + (u_short)*
cp
++; \

125 (
f
) = 
	`htons
(
tmp
); \

127 }

	)

129 #define 
	#DECODEU
(
f
) { \

130 if (*
cp
 == 0) {\

131 (
f
) = 
	`htons
(((
u_short
)
cp
[1] << 8) | cp[2]); \

132 
cp
 += 3; \

134 (
f
) = 
	`htons
((
u_short
)*
cp
++); \

136 }

	)

145 
u_int


146 
	$vj_compress_tcp
(struct 
vjcompress
 *
comp
, struct 
pbuf
 *
pb
)

148 register struct 
ip
 *ip = (struct ip *)
pb
->
payload
;

149 register struct 
cstate
 *
cs
 = 
comp
->
last_cs
->
cs_next
;

150 register 
u_short
 
hlen
 = 
	`getip_hl
(*
ip
);

151 register struct 
tcphdr
 *
oth
;

152 register struct 
tcphdr
 *
th
;

153 register 
u_short
 
deltaS
, 
deltaA
;

154 register 
u_long
 
deltaL
;

155 register 
u_int
 
changes
 = 0;

156 
u_char
 
new_seq
[16];

157 register 
u_char
 *
cp
 = 
new_seq
;

162 if (
ip
->
ip_p
 != 
IPPROTO_TCP
) {

163 return (
TYPE_IP
);

171 if ((
ip
->
ip_off
 & 
	`htons
(0x3fff)) || 
pb
->
tot_len
 < 40) {

172 return (
TYPE_IP
);

174 
th
 = (struct 
tcphdr
 *)&((long *)
ip
)[
hlen
];

175 if ((
th
->
th_flags
 & (
TCP_SYN
|
TCP_FIN
|
TCP_RST
|
TCP_ACK
)) != TCP_ACK) {

176 return (
TYPE_IP
);

185 
	`INCR
(
vjs_packets
);

186 if (
ip
->
ip_src
.
s_addr
 != 
cs
->
cs_ip
.ip_src.s_addr

187 || 
ip
->
ip_dst
.
s_addr
 != 
cs
->
cs_ip
.ip_dst.s_addr

188 || *(long *)
th
 != ((long *)&
cs
->
cs_ip
)[
	`getip_hl
(cs->cs_ip)]) {

201 register struct 
cstate
 *
lcs
;

202 register struct 
cstate
 *
lastcs
 = 
comp
->
last_cs
;

205 
lcs
 = 
cs
; cs = cs->
cs_next
;

206 
	`INCR
(
vjs_searches
);

207 if (
ip
->
ip_src
.
s_addr
 == 
cs
->
cs_ip
.ip_src.s_addr

208 && 
ip
->
ip_dst
.
s_addr
 == 
cs
->
cs_ip
.ip_dst.s_addr

209 && *(long *)
th
 == ((long *)&
cs
->
cs_ip
)[
	`getip_hl
(cs->cs_ip)]) {

210 goto 
found
;

212 } while (
cs
 != 
lastcs
);

222 
	`INCR
(
vjs_misses
);

223 
comp
->
last_cs
 = 
lcs
;

224 
hlen
 += 
	`getth_off
(*
th
);

225 
hlen
 <<= 2;

227 if (
hlen
 > 
pb
->
len
) {

228 return (
TYPE_IP
);

230 goto 
uncompressed
;

232 
found
:

236 if (
cs
 == 
lastcs
) {

237 
comp
->
last_cs
 = 
lcs
;

239 
lcs
->
cs_next
 = 
cs
->cs_next;

240 
cs
->
cs_next
 = 
lastcs
->cs_next;

241 
lastcs
->
cs_next
 = 
cs
;

245 
oth
 = (struct 
tcphdr
 *)&((long *)&
cs
->
cs_ip
)[
hlen
];

246 
deltaS
 = 
hlen
;

247 
hlen
 += 
	`getth_off
(*
th
);

248 
hlen
 <<= 2;

250 if (
hlen
 > 
pb
->
len
) {

251 
	`PPPDEBUG
((
LOG_INFO
, "vj_compress_tcp: header len %d spans buffers\n", 
hlen
));

252 return (
TYPE_IP
);

266 if (((
u_short
 *)
ip
)[0] != ((u_short *)&
cs
->
cs_ip
)[0]

267 || ((
u_short
 *)
ip
)[3] != ((u_short *)&
cs
->
cs_ip
)[3]

268 || ((
u_short
 *)
ip
)[4] != ((u_short *)&
cs
->
cs_ip
)[4]

269 || 
	`getth_off
(*
th
) != getth_off(*
oth
)

270 || (
deltaS
 > 5 && 
	`BCMP
(
ip
 + 1, &
cs
->
cs_ip
 + 1, (deltaS - 5) << 2))

271 || (
	`getth_off
(*
th
) > 5 && 
	`BCMP
(th + 1, 
oth
 + 1, (getth_off(*th) - 5) << 2))) {

272 goto 
uncompressed
;

281 if (
th
->
th_flags
 & 
TCP_URG
) {

282 
deltaS
 = 
	`ntohs
(
th
->
th_urp
);

283 
	`ENCODEZ
(
deltaS
);

284 
changes
 |= 
NEW_U
;

285 } else if (
th
->
th_urp
 != 
oth
->th_urp) {

290 goto 
uncompressed
;

293 if ((
deltaS
 = (
u_short
)(
	`ntohs
(
th
->
th_win
) - ntohs(
oth
->th_win))) != 0) {

294 
	`ENCODE
(
deltaS
);

295 
changes
 |= 
NEW_W
;

298 if ((
deltaL
 = 
	`ntohl
(
th
->
th_ack
) - ntohl(
oth
->th_ack)) != 0) {

299 if (
deltaL
 > 0xffff) {

300 goto 
uncompressed
;

302 
deltaA
 = (
u_short
)
deltaL
;

303 
	`ENCODE
(
deltaA
);

304 
changes
 |= 
NEW_A
;

307 if ((
deltaL
 = 
	`ntohl
(
th
->
th_seq
) - ntohl(
oth
->th_seq)) != 0) {

308 if (
deltaL
 > 0xffff) {

309 goto 
uncompressed
;

311 
deltaS
 = (
u_short
)
deltaL
;

312 
	`ENCODE
(
deltaS
);

313 
changes
 |= 
NEW_S
;

316 switch(
changes
) {

326 if (
ip
->
ip_len
 != 
cs
->
cs_ip
.ip_len &&

327 
	`ntohs
(
cs
->
cs_ip
.
ip_len
) == 
hlen
) {

333 case 
SPECIAL_I
:

334 case 
SPECIAL_D
:

339 goto 
uncompressed
;

341 case 
NEW_S
|
NEW_A
:

342 if (
deltaS
 == 
deltaA
 && deltaS == 
	`ntohs
(
cs
->
cs_ip
.
ip_len
) - 
hlen
) {

344 
changes
 = 
SPECIAL_I
;

345 
cp
 = 
new_seq
;

349 case 
NEW_S
:

350 if (
deltaS
 == 
	`ntohs
(
cs
->
cs_ip
.
ip_len
) - 
hlen
) {

352 
changes
 = 
SPECIAL_D
;

353 
cp
 = 
new_seq
;

358 
deltaS
 = (
u_short
)(
	`ntohs
(
ip
->
ip_id
) - ntohs(
cs
->
cs_ip
.ip_id));

359 if (
deltaS
 != 1) {

360 
	`ENCODEZ
(
deltaS
);

361 
changes
 |= 
NEW_I
;

363 if (
th
->
th_flags
 & 
TCP_PSH
) {

364 
changes
 |= 
TCP_PUSH_BIT
;

370 
deltaA
 = 
	`ntohs
(
th
->
th_sum
);

371 
	`BCOPY
(
ip
, &
cs
->
cs_ip
, 
hlen
);

382 
deltaS
 = (
u_short
)(
cp
 - 
new_seq
);

383 if (!
comp
->
compressSlot
 || comp->
last_xmit
 != 
cs
->
cs_id
) {

384 
comp
->
last_xmit
 = 
cs
->
cs_id
;

385 
hlen
 -= 
deltaS
 + 4;

386 if(
	`pbuf_header
(
pb
, -
hlen
)){

388 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

390 
cp
 = (
u_char
 *)
pb
->
payload
;

391 *
cp
++ = 
changes
 | 
NEW_C
;

392 *
cp
++ = 
cs
->
cs_id
;

394 
hlen
 -= 
deltaS
 + 3;

395 if(
	`pbuf_header
(
pb
, -
hlen
)) {

397 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

399 
cp
 = (
u_char
 *)
pb
->
payload
;

400 *
cp
++ = 
changes
;

402 *
cp
++ = 
deltaA
 >> 8;

403 *
cp
++ = 
deltaA
;

404 
	`BCOPY
(
new_seq
, 
cp
, 
deltaS
);

405 
	`INCR
(
vjs_compressed
);

406 return (
TYPE_COMPRESSED_TCP
);

413 
uncompressed
:

414 
	`BCOPY
(
ip
, &
cs
->
cs_ip
, 
hlen
);

415 
ip
->
ip_p
 = 
cs
->
cs_id
;

416 
comp
->
last_xmit
 = 
cs
->
cs_id
;

417 return (
TYPE_UNCOMPRESSED_TCP
);

418 
	}
}

424 
	$vj_uncompress_err
(struct 
vjcompress
 *
comp
)

426 
comp
->
flags
 |= 
VJF_TOSS
;

427 
	`INCR
(
vjs_errorin
);

428 
	}
}

435 
	$vj_uncompress_uncomp
(struct 
pbuf
 *
nb
, struct 
vjcompress
 *
comp
)

437 register 
u_int
 
hlen
;

438 register struct 
cstate
 *
cs
;

439 register struct 
ip
 *ip;

441 
ip
 = (struct ip *)
nb
->
payload
;

442 
hlen
 = 
	`getip_hl
(*
ip
) << 2;

443 if (
ip
->
ip_p
 >= 
MAX_SLOTS


444 || 
hlen
 + sizeof(struct 
tcphdr
) > 
nb
->
len


445 || (
hlen
 += 
	`getth_off
(*((struct 
tcphdr
 *)&((char *)
ip
)[hlen])) << 2)

446 > 
nb
->
len


447 || 
hlen
 > 
MAX_HDR
) {

448 
	`PPPDEBUG
((
LOG_INFO
, "vj_uncompress_uncomp: bad cid=%d, hlen=%d buflen=%d\n",

449 
ip
->
ip_p
, 
hlen
, 
nb
->
len
));

450 
comp
->
flags
 |= 
VJF_TOSS
;

451 
	`INCR
(
vjs_errorin
);

454 
cs
 = &
comp
->
rstate
[comp->
last_recv
 = 
ip
->
ip_p
];

455 
comp
->
flags
 &=~ 
VJF_TOSS
;

456 
ip
->
ip_p
 = 
IPPROTO_TCP
;

457 
	`BCOPY
(
ip
, &
cs
->
cs_ip
, 
hlen
);

458 
cs
->
cs_hlen
 = 
hlen
;

459 
	`INCR
(
vjs_uncompressedin
);

461 
	}
}

472 
	$vj_uncompress_tcp
(struct 
pbuf
 **
nb
, struct 
vjcompress
 *
comp
)

474 
u_char
 *
cp
;

475 struct 
tcphdr
 *
th
;

476 struct 
cstate
 *
cs
;

477 
u_short
 *
bp
;

478 struct 
pbuf
 *
n0
 = *
nb
;

479 
u32_t
 
tmp
;

480 
u_int
 
vjlen
, 
hlen
, 
changes
;

482 
	`INCR
(
vjs_compressedin
);

483 
cp
 = (
u_char
 *)
n0
->
payload
;

484 
changes
 = *
cp
++;

485 if (
changes
 & 
NEW_C
) {

490 if (*
cp
 >= 
MAX_SLOTS
) {

491 
	`PPPDEBUG
((
LOG_INFO
, "vj_uncompress_tcp: bad cid=%d\n", *
cp
));

492 goto 
bad
;

495 
comp
->
flags
 &=~ 
VJF_TOSS
;

496 
comp
->
last_recv
 = *
cp
++;

503 if (
comp
->
flags
 & 
VJF_TOSS
) {

504 
	`PPPDEBUG
((
LOG_INFO
, "vj_uncompress_tcp: tossing\n"));

505 
	`INCR
(
vjs_tossed
);

509 
cs
 = &
comp
->
rstate
[comp->
last_recv
];

510 
hlen
 = 
	`getip_hl
(
cs
->
cs_ip
) << 2;

511 
th
 = (struct 
tcphdr
 *)&((
u_char
 *)&
cs
->
cs_ip
)[
hlen
];

512 
th
->
th_sum
 = 
	`htons
((*
cp
 << 8) | cp[1]);

513 
cp
 += 2;

514 if (
changes
 & 
TCP_PUSH_BIT
) {

515 
th
->
th_flags
 |= 
TCP_PSH
;

517 
th
->
th_flags
 &=~ 
TCP_PSH
;

520 switch (
changes
 & 
SPECIALS_MASK
) {

521 case 
SPECIAL_I
:

523 register 
u32_t
 
i
 = 
	`ntohs
(
cs
->
cs_ip
.
ip_len
) - cs->
cs_hlen
;

525 
tmp
 = 
	`ntohl
(
th
->
th_ack
) + 
i
;

526 
th
->
th_ack
 = 
	`htonl
(
tmp
);

527 
tmp
 = 
	`ntohl
(
th
->
th_seq
) + 
i
;

528 
th
->
th_seq
 = 
	`htonl
(
tmp
);

532 case 
SPECIAL_D
:

534 
tmp
 = 
	`ntohl
(
th
->
th_seq
) + 
	`ntohs
(
cs
->
cs_ip
.
ip_len
) - cs->
cs_hlen
;

535 
th
->
th_seq
 = 
	`htonl
(
tmp
);

539 if (
changes
 & 
NEW_U
) {

540 
th
->
th_flags
 |= 
TCP_URG
;

541 
	`DECODEU
(
th
->
th_urp
);

543 
th
->
th_flags
 &=~ 
TCP_URG
;

545 if (
changes
 & 
NEW_W
) {

546 
	`DECODES
(
th
->
th_win
);

548 if (
changes
 & 
NEW_A
) {

549 
	`DECODEL
(
th
->
th_ack
);

551 if (
changes
 & 
NEW_S
) {

552 
	`DECODEL
(
th
->
th_seq
);

556 if (
changes
 & 
NEW_I
) {

557 
	`DECODES
(
cs
->
cs_ip
.
ip_id
);

559 
cs
->
cs_ip
.
ip_id
 = 
	`ntohs
(cs->cs_ip.ip_id) + 1;

560 
cs
->
cs_ip
.
ip_id
 = 
	`htons
(cs->cs_ip.ip_id);

568 
vjlen
 = (
u_short
)(
cp
 - (
u_char
*)
n0
->
payload
);

569 if (
n0
->
len
 < 
vjlen
) {

574 
	`PPPDEBUG
((
LOG_INFO
, "vj_uncompress_tcp: head buffer %d too short %d\n",

575 
n0
->
len
, 
vjlen
));

576 goto 
bad
;

579 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


580 
tmp
 = 
n0
->
tot_len
 - 
vjlen
 + 
cs
->
cs_hlen
;

581 
cs
->
cs_ip
.
ip_len
 = 
	`htons
(
tmp
);

583 
cs
->
cs_ip
.
ip_len
 = 
	`htons
(
n0
->
tot_len
 - 
vjlen
 + cs->
cs_hlen
);

587 
bp
 = (
u_short
 *) &
cs
->
cs_ip
;

588 
cs
->
cs_ip
.
ip_sum
 = 0;

589 for (
tmp
 = 0; 
hlen
 > 0; hlen -= 2) {

590 
tmp
 += *
bp
++;

592 
tmp
 = (tmp & 0xffff) + (tmp >> 16);

593 
tmp
 = (tmp & 0xffff) + (tmp >> 16);

594 
cs
->
cs_ip
.
ip_sum
 = (
u_short
)(~
tmp
);

597 if(
	`pbuf_header
(
n0
, -((
s16_t
)(
vjlen
)))) {

599 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

600 goto 
bad
;

603 if(
	`LWIP_MEM_ALIGN
(
n0
->
payload
) != n0->payload) {

604 struct 
pbuf
 *
np
, *
q
;

605 
u8_t
 *
bufptr
;

607 
np
 = 
	`pbuf_alloc
(
PBUF_RAW
, 
n0
->
len
 + 
cs
->
cs_hlen
, 
PBUF_POOL
);

608 if(!
np
) {

609 
	`PPPDEBUG
((
LOG_WARNING
, "vj_uncompress_tcp: realign failed\n"));

610 goto 
bad
;

613 if(
	`pbuf_header
(
np
, -
cs
->
cs_hlen
)) {

615 
	`LWIP_ASSERT
("pbuf_header failed\n", 0);

616 goto 
bad
;

619 
bufptr
 = 
n0
->
payload
;

620 for(
q
 = 
np
; q != 
NULL
; q = q->
next
) {

621 
	`MEMCPY
(
q
->
payload
, 
bufptr
, q->
len
);

622 
bufptr
 += 
q
->
len
;

625 if(
n0
->
next
) {

626 
	`pbuf_chain
(
np
, 
n0
->
next
);

627 
	`pbuf_dechain
(
n0
);

629 
	`pbuf_free
(
n0
);

630 
n0
 = 
np
;

633 if(
	`pbuf_header
(
n0
, 
cs
->
cs_hlen
)) {

634 struct 
pbuf
 *
np
;

636 
	`LWIP_ASSERT
("vj_uncompress_tcp: cs->cs_hlen <= PBUF_POOL_BUFSIZE", 
cs
->
cs_hlen
 <= 
PBUF_POOL_BUFSIZE
);

637 
np
 = 
	`pbuf_alloc
(
PBUF_RAW
, 
cs
->
cs_hlen
, 
PBUF_POOL
);

638 if(!
np
) {

639 
	`PPPDEBUG
((
LOG_WARNING
, "vj_uncompress_tcp: prepend failed\n"));

640 goto 
bad
;

642 
	`pbuf_cat
(
np
, 
n0
);

643 
n0
 = 
np
;

645 
	`LWIP_ASSERT
("n0->len >= cs->cs_hlen", 
n0
->
len
 >= 
cs
->
cs_hlen
);

646 
	`MEMCPY
(
n0
->
payload
, &
cs
->
cs_ip
, cs->
cs_hlen
);

648 *
nb
 = 
n0
;

650 return 
vjlen
;

652 
bad
:

653 
comp
->
flags
 |= 
VJF_TOSS
;

654 
	`INCR
(
vjs_errorin
);

656 
	}
}

	@/root/Robux/net/lwip/netif/ppp/vj.h

25 #ifndef 
VJ_H


26 #define 
	#VJ_H


	)

28 #include 
	~"vjbsdhdr.h
"

30 #define 
	#MAX_SLOTS
 16

	)

31 #define 
	#MAX_HDR
 128

	)

77 #define 
	#TYPE_IP
 0x40

	)

78 #define 
	#TYPE_UNCOMPRESSED_TCP
 0x70

	)

79 #define 
	#TYPE_COMPRESSED_TCP
 0x80

	)

80 #define 
	#TYPE_ERROR
 0x00

	)

83 #define 
	#NEW_C
 0x40

	)

84 #define 
	#NEW_I
 0x20

	)

85 #define 
	#NEW_S
 0x08

	)

86 #define 
	#NEW_A
 0x04

	)

87 #define 
	#NEW_W
 0x02

	)

88 #define 
	#NEW_U
 0x01

	)

91 #define 
	#SPECIAL_I
 (
NEW_S
|
NEW_W
|
NEW_U
)

	)

92 #define 
	#SPECIAL_D
 (
NEW_S
|
NEW_A
|
NEW_W
|
NEW_U
)

	)

93 #define 
	#SPECIALS_MASK
 (
NEW_S
|
NEW_A
|
NEW_W
|
NEW_U
)

	)

95 #define 
	#TCP_PUSH_BIT
 0x10

	)

104 struct 
	scstate
 {

105 struct 
cstate
 *
	mcs_next
;

106 
u_short
 
	mcs_hlen
;

107 
u_char
 
	mcs_id
;

108 
u_char
 
	mcs_filler
;

110 char 
	mcsu_hdr
[
MAX_HDR
];

111 struct 
ip
 
	mcsu_ip
;

112 } 
	mvjcs_u
;

114 #define 
	#cs_ip
 
vjcs_u
.
csu_ip


	)

115 #define 
	#cs_hdr
 
vjcs_u
.
csu_hdr


	)

118 struct 
	svjstat
 {

119 unsigned long 
	mvjs_packets
;

120 unsigned long 
	mvjs_compressed
;

121 unsigned long 
	mvjs_searches
;

122 unsigned long 
	mvjs_misses
;

123 unsigned long 
	mvjs_uncompressedin
;

124 unsigned long 
	mvjs_compressedin
;

125 unsigned long 
	mvjs_errorin
;

126 unsigned long 
	mvjs_tossed
;

132 struct 
	svjcompress
 {

133 struct 
cstate
 *
	mlast_cs
;

134 
u_char
 
	mlast_recv
;

135 
u_char
 
	mlast_xmit
;

136 
u_short
 
	mflags
;

137 
u_char
 
	mmaxSlotIndex
;

138 
u_char
 
	mcompressSlot
;

139 #if 
LINK_STATS


140 struct 
vjstat
 
	mstats
;

142 struct 
cstate
 
	mtstate
[
MAX_SLOTS
];

143 struct 
cstate
 
	mrstate
[
MAX_SLOTS
];

147 #define 
	#VJF_TOSS
 1U

	)

149 extern void 
vj_compress_init
 (struct 
vjcompress
 *
comp
);

150 extern 
u_int
 
vj_compress_tcp
 (struct 
vjcompress
 *
comp
, struct 
pbuf
 *
pb
);

151 extern void 
vj_uncompress_err
 (struct 
vjcompress
 *
comp
);

152 extern int 
vj_uncompress_uncomp
(struct 
pbuf
 *
nb
, struct 
vjcompress
 *
comp
);

153 extern int 
vj_uncompress_tcp
 (struct 
pbuf
 **
nb
, struct 
vjcompress
 *
comp
);

	@/root/Robux/net/lwip/netif/ppp/vjbsdhdr.h

1 #ifndef 
VJBSDHDR_H


2 #define 
	#VJBSDHDR_H


	)

4 #include 
	~"lwip/tcp.h
"

13 
PACK_STRUCT_BEGIN


14 struct 
	sip


16 #if 
defined
(
NO_CHAR_BITFIELDS
)

17 
u_char
 
	mip_hl_v
;

19 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


20 unsigned 
	mip_hl
:4,

21 
	mip_v
 :4;

22 #elif 
BYTE_ORDER
 == 
BIG_ENDIAN


23 unsigned 
	mip_v
 :4,

24 
	mip_hl
:4;

26 
	mCOMPLAIN
 - 
NO
 
BYTE
 
ORDER
 
	mSELECTED
!

29 
u_char
 
	mip_tos
;

30 
u_short
 
	mip_len
;

31 
u_short
 
	mip_id
;

32 
u_short
 
	mip_off
;

33 #define 
	#IP_DF
 0x4000

	)

34 #define 
	#IP_MF
 0x2000

	)

35 #define 
	#IP_OFFMASK
 0x1fff

	)

36 
u_char
 
	mip_ttl
;

37 
u_char
 
	mip_p
;

38 
u_short
 
	mip_sum
;

39 struct 
in_addr
 
	mip_src
,
	mip_dst
;

41 
PACK_STRUCT_END


43 typedef 
u32_t
 
	ttcp_seq
;

49 
PACK_STRUCT_BEGIN


50 struct 
	stcphdr


52 
u_short
 
	mth_sport
;

53 
u_short
 
	mth_dport
;

54 
tcp_seq
 
	mth_seq
;

55 
tcp_seq
 
	mth_ack
;

56 #if 
defined
(
NO_CHAR_BITFIELDS
)

57 
u_char
 
	mth_x2_off
;

59 #if 
BYTE_ORDER
 == 
LITTLE_ENDIAN


60 unsigned 
	mth_x2
 :4,

61 
	mth_off
:4;

63 #if 
BYTE_ORDER
 == 
BIG_ENDIAN


64 unsigned 
	mth_off
:4,

65 
	mth_x2
 :4;

68 
u_char
 
	mth_flags
;

69 
u_short
 
	mth_win
;

70 
u_short
 
	mth_sum
;

71 
u_short
 
	mth_urp
;

73 
	gPACK_STRUCT_END


	@/root/Robux/net/lwip/netif/slipif.c

45 #include 
	~"netif/slipif.h
"

46 #include 
	~"lwip/opt.h
"

48 #if 
LWIP_HAVE_SLIPIF


50 #include 
	~"lwip/def.h
"

51 #include 
	~"lwip/pbuf.h
"

52 #include 
	~"lwip/sys.h
"

53 #include 
	~"lwip/stats.h
"

54 #include 
	~"lwip/snmp.h
"

55 #include 
	~"lwip/sio.h
"

57 #define 
	#SLIP_END
 0300

	)

58 #define 
	#SLIP_ESC
 0333

	)

59 #define 
	#SLIP_ESC_END
 0334

	)

60 #define 
	#SLIP_ESC_ESC
 0335

	)

62 #define 
	#MAX_SIZE
 1500

	)

74 
err_t


75 
	$slipif_output
(struct 
netif
 *netif, struct 
pbuf
 *
p
, struct 
ip_addr
 *
ipaddr
)

77 struct 
pbuf
 *
q
;

78 
u16_t
 
i
;

79 
u8_t
 
c
;

81 
	`LWIP_ASSERT
("netif != NULL", (
netif
 != 
NULL
));

82 
	`LWIP_ASSERT
("netif->state != NULL", (
netif
->
state
 != 
NULL
));

83 
	`LWIP_ASSERT
("p != NULL", (
p
 != 
NULL
));

85 
	`LWIP_UNUSED_ARG
(
ipaddr
);

88 
	`sio_send
(
SLIP_END
, 
netif
->
state
);

90 for (
q
 = 
p
; q != 
NULL
; q = q->
next
) {

91 for (
i
 = 0; i < 
q
->
len
; i++) {

92 
c
 = ((
u8_t
 *)
q
->
payload
)[
i
];

93 switch (
c
) {

94 case 
SLIP_END
:

95 
	`sio_send
(
SLIP_ESC
, 
netif
->
state
);

96 
	`sio_send
(
SLIP_ESC_END
, 
netif
->
state
);

98 case 
SLIP_ESC
:

99 
	`sio_send
(
SLIP_ESC
, 
netif
->
state
);

100 
	`sio_send
(
SLIP_ESC_ESC
, 
netif
->
state
);

103 
	`sio_send
(
c
, 
netif
->
state
);

108 
	`sio_send
(
SLIP_END
, 
netif
->
state
);

109 return 
ERR_OK
;

110 
	}
}

120 static struct 
pbuf
 *

121 
	$slipif_input
(struct 
netif
 *netif)

123 
u8_t
 
c
;

125 struct 
pbuf
 *
p
, *
q
;

126 
u16_t
 
recved
;

127 
u16_t
 
i
;

129 
	`LWIP_ASSERT
("netif != NULL", (
netif
 != 
NULL
));

130 
	`LWIP_ASSERT
("netif->state != NULL", (
netif
->
state
 != 
NULL
));

132 
q
 = 
p
 = 
NULL
;

133 
recved
 = 
i
 = 0;

134 
c
 = 0;

137 
c
 = 
	`sio_recv
(
netif
->
state
);

138 switch (
c
) {

139 case 
SLIP_END
:

140 if (
recved
 > 0) {

143 
	`pbuf_realloc
(
q
, 
recved
);

145 
	`LINK_STATS_INC
(
link
.
recv
);

147 
	`LWIP_DEBUGF
(
SLIP_DEBUG
, ("slipif: Got packet\n"));

148 return 
q
;

152 case 
SLIP_ESC
:

153 
c
 = 
	`sio_recv
(
netif
->
state
);

154 switch (
c
) {

155 case 
SLIP_ESC_END
:

156 
c
 = 
SLIP_END
;

158 case 
SLIP_ESC_ESC
:

159 
c
 = 
SLIP_ESC
;

166 if (
p
 == 
NULL
) {

168 
	`LWIP_DEBUGF
(
SLIP_DEBUG
, ("slipif_input: alloc\n"));

169 
p
 = 
	`pbuf_alloc
(
PBUF_LINK
, 
PBUF_POOL_BUFSIZE
, 
PBUF_POOL
);

171 if (
p
 == 
NULL
) {

172 
	`LINK_STATS_INC
(
link
.
drop
);

173 
	`LWIP_DEBUGF
(
SLIP_DEBUG
, ("slipif_input: no new pbuf! (DROP)\n"));

178 if (
q
 != 
NULL
) {

180 
	`pbuf_cat
(
q
, 
p
);

183 
q
 = 
p
;

188 if ((
p
 != 
NULL
) && (
recved
 <= 
MAX_SIZE
)) {

189 ((
u8_t
 *)
p
->
payload
)[
i
] = 
c
;

190 
recved
++;

191 
i
++;

192 if (
i
 >= 
p
->
len
) {

194 
i
 = 0;

195 if (
p
->
next
 != 
NULL
 && p->next->
len
 > 0) {

197 
p
 = p->
next
;

201 
p
 = 
NULL
;

208 return 
NULL
;

209 
	}
}

211 #if !
NO_SYS


220 
	$slipif_loop
(void *
nf
)

222 struct 
pbuf
 *
p
;

223 struct 
netif
 *netif = (struct netif *)
nf
;

226 
p
 = 
	`slipif_input
(
netif
);

227 if (
p
 != 
NULL
) {

228 if (
netif
->
	`input
(
p
, netif) != 
ERR_OK
) {

229 
	`pbuf_free
(
p
);

230 
p
 = 
NULL
;

234 
	}
}

250 
err_t


251 
	$slipif_init
(struct 
netif
 *netif)

254 
	`LWIP_DEBUGF
(
SLIP_DEBUG
, ("slipif_init: netif->num=%"
U16_F
"\n", (
u16_t
)
netif
->
num
));

256 
netif
->
name
[0] = 's';

257 
netif
->
name
[1] = 'l';

258 
netif
->
output
 = 
slipif_output
;

259 
netif
->
mtu
 = 
MAX_SIZE
;

260 
netif
->
flags
 = 
NETIF_FLAG_POINTTOPOINT
;

263 
netif
->
state
 = 
	`sio_open
(netif->
num
);

264 if (!
netif
->
state
) {

266 return 
ERR_IF
;

273 
	`NETIF_INIT_SNMP
(
netif
, 
snmp_ifType_slip
, 0);

276 
	`sys_thread_new
(
SLIPIF_THREAD_NAME
, 
slipif_loop
, 
netif
, 
SLIPIF_THREAD_STACKSIZE
, 
SLIPIF_THREAD_PRIO
);

277 return 
ERR_OK
;

278 
	}
}

	@/root/Robux/net/ns.h

1 #include 
	~<inc/ns.h
>

2 #include 
	~<inc/lib.h
>

4 #define 
	#IP
 "10.0.2.15"

	)

5 #define 
	#MASK
 "255.255.255.0"

	)

6 #define 
	#DEFAULT
 "10.0.2.2"

	)

8 #define 
	#TIMER_INTERVAL
 250

	)

11 #define 
	#QUEUE_SIZE
 20

	)

12 #define 
	#REQVA
 (0x0ffff000 - 
QUEUE_SIZE
 * 
PGSIZE
)

	)

15 void 
timer
(
envid_t
 
ns_envid
, 
uint32_t
 
initial_to
);

18 void 
input
(
envid_t
 
ns_envid
);

21 void 
output
(
envid_t
 
ns_envid
);

	@/root/Robux/net/output.c

1 #include 
	~"ns.h
"

3 extern union 
Nsipc
 
nsipcbuf
;

5 char 
	gdata
[
PGSIZE
] 
__attribute__
 ((
aligned
(PGSIZE)));

8 
	$output
(
envid_t
 
ns_envid
)

10 
binaryname
 = "ns_output";

15 int 
r
;

16 
envid_t
 
from_id
;

17 while((
r
 = 
	`ipc_recv
(&
from_id
, 
data
, 
NULL
)) >= 0)

19 if(
r
 != 
NSREQ_OUTPUT
 || 
from_id
 != 
ns_envid
)

22 struct 
jif_pkt
 *
packet
 = (struct jif_pkt*) 
data
;

23 if((
r
 = 
	`sys_net_send_packet
(&
packet
->
jp_data
, packet->
jp_len
)) < 0)

24 
	`cprintf
("Error sending packet: %e\n", 
r
);

27 
	`cprintf
("net output: ipc_recv failed: %e\n", 
r
);

28 
	}
}

	@/root/Robux/net/serv.c

6 #include 
	~<inc/x86.h
>

7 #include 
	~<inc/string.h
>

8 #include 
	~<inc/env.h
>

9 #include 
	~<inc/ns.h
>

10 #include 
	~<inc/lib.h
>

12 #include 
	~<arch/perror.h
>

13 #include 
	~<arch/thread.h
>

14 #include 
	~<lwip/sockets.h
>

15 #include 
	~<lwip/netif.h
>

16 #include 
	~<lwip/stats.h
>

17 #include 
	~<lwip/sys.h
>

18 #include 
	~<lwip/tcp.h
>

19 #include 
	~<lwip/udp.h
>

20 #include 
	~<lwip/dhcp.h
>

21 #include 
	~<lwip/tcpip.h
>

22 #include 
	~<lwip/stats.h
>

23 #include 
	~<lwip/netbuf.h
>

24 #include 
	~<netif/etharp.h
>

25 #include 
	~<jif/jif.h
>

27 #include 
	~"ns.h
"

30 int 
	gerrno
;

32 struct 
netif
 
	gnif
;

34 #define 
	#debug
 0

	)

36 struct 
	stimer_thread
 {

37 
uint32_t
 
	mmsec
;

38 void (*
	mfunc
)(void);

39 const char *
	mname
;

42 static struct 
timer_thread
 
	gt_arp
;

43 static struct 
timer_thread
 
	gt_tcpf
;

44 static struct 
timer_thread
 
	gt_tcps
;

46 static 
envid_t
 
	gtimer_envid
;

47 static 
envid_t
 
	ginput_envid
;

48 static 
envid_t
 
	goutput_envid
;

50 static 
bool
 
	gbuse
[
QUEUE_SIZE
];

51 static int 
	$next_i
(int 
i
) { return (i+1) % 
QUEUE_SIZE
; 
	}
}

52 static int 
	$prev_i
(int 
i
) { return (i ? i-1 : 
QUEUE_SIZE
-1); 
	}
}

55 
	$get_buffer
(void) {

56 void *
va
;

58 int 
i
;

59 for (
i
 = 0; i < 
QUEUE_SIZE
; i++)

60 if (!
buse
[
i
]) break;

62 if (
i
 == 
QUEUE_SIZE
) {

63 
	`panic
("NS: buffer overflow");

67 
va
 = (void *)(
REQVA
 + 
i
 * 
PGSIZE
);

68 
buse
[
i
] = 1;

70 return 
va
;

71 
	}
}

74 
	$put_buffer
(void *
va
) {

75 int 
i
 = ((
uint32_t
)
va
 - 
REQVA
) / 
PGSIZE
;

76 
buse
[
i
] = 0;

77 
	}
}

80 
	$lwip_init
(struct 
netif
 *
nif
, void *
if_state
,

81 
uint32_t
 
init_addr
, uint32_t 
init_mask
, uint32_t 
init_gw
)

83 struct 
ip_addr
 
ipaddr
, 
netmask
, 
gateway
;

84 
ipaddr
.
addr
 = 
init_addr
;

85 
netmask
.
addr
 = 
init_mask
;

86 
gateway
.
addr
 = 
init_gw
;

88 if (0 == 
	`netif_add
(
nif
, &
ipaddr
, &
netmask
, &
gateway
,

89 
if_state
,

90 
jif_init
,

91 
ip_input
))

92 
	`panic
("lwip_init: error in netif_add\n");

94 
	`netif_set_default
(
nif
);

95 
	`netif_set_up
(
nif
);

96 
	}
}

98 static void 
__attribute__
((
noreturn
))

99 
	$net_timer
(
uint32_t
 
arg
)

101 struct 
timer_thread
 *
t
 = (struct timer_thread *) 
arg
;

104 
uint32_t
 
cur
 = 
	`sys_time_msec
();

106 
	`lwip_core_lock
();

107 
t
->
	`func
();

108 
	`lwip_core_unlock
();

110 
	`thread_wait
(0, 0, 
cur
 + 
t
->
msec
);

112 
	}
}

115 
start_timer
(struct 
timer_thread
 *
t
, void (*
func
)(void), const char *
name
, int 
msec
)

117 
t
->
msec
 = msec;

118 
t
->
func
 = func;

119 
t
->
name
 = name;

120 int 
r
 = 
	`thread_create
(0, 
name
, &
net_timer
, (
uint32_t
)
t
);

121 if (
r
 < 0)

122 
	`panic
("cannot create timer thread: %s", 
	`e2s
(
r
));

123 
	}
}

126 
	$tcpip_init_done
(void *
arg
)

128 
uint32_t
 *
done
 = 
arg
;

129 *
done
 = 1;

130 
	`thread_wakeup
(
done
);

131 
	}
}

134 
	$serve_init
(
uint32_t
 
ipaddr
, uint32_t 
netmask
, uint32_t 
gw
)

136 int 
r
;

137 
	`lwip_core_lock
();

139 
uint32_t
 
done
 = 0;

140 
	`tcpip_init
(&
tcpip_init_done
, &
done
);

141 
	`lwip_core_unlock
();

142 
	`thread_wait
(&
done
, 0, (
uint32_t
)~0);

143 
	`lwip_core_lock
();

145 
	`lwip_init
(&
nif
, &
output_envid
, 
ipaddr
, 
netmask
, 
gw
);

147 
	`start_timer
(&
t_arp
, &
etharp_tmr
, "arp timer", 
ARP_TMR_INTERVAL
);

148 
	`start_timer
(&
t_tcpf
, &
tcp_fasttmr
, "tcp f timer", 
TCP_FAST_INTERVAL
);

149 
	`start_timer
(&
t_tcps
, &
tcp_slowtmr
, "tcp s timer", 
TCP_SLOW_INTERVAL
);

151 struct 
in_addr
 
ia
 = {
ipaddr
};

152 
	`cprintf
("ns: %02x:%02x:%02x:%02x:%02x:%02x"

154 
nif
.
hwaddr
[0], nif.hwaddr[1], nif.hwaddr[2],

155 
nif
.
hwaddr
[3], nif.hwaddr[4], nif.hwaddr[5],

156 
	`inet_ntoa
(
ia
));

158 
	`lwip_core_unlock
();

160 
	`cprintf
("NS: TCP/IP initialized.\n");

161 
	}
}

164 
	$process_timer
(
envid_t
 
envid
) {

165 
uint32_t
 
start
, 
now
, 
to
;

167 if (
envid
 != 
timer_envid
) {

168 
	`cprintf
("NS: received timer interrupt from envid %x not timer env\n", 
envid
);

172 
start
 = 
	`sys_time_msec
();

173 
	`thread_yield
();

174 
now
 = 
	`sys_time_msec
();

176 
to
 = 
TIMER_INTERVAL
 - (
now
 - 
start
);

177 
	`ipc_send
(
envid
, 
to
, 0, 0);

178 
	}
}

180 struct 
	sst_args
 {

181 
int32_t
 
	mreqno
;

182 
uint32_t
 
	mwhom
;

183 union 
Nsipc
 *
	mreq
;

187 
	$serve_thread
(
uint32_t
 
a
) {

188 struct 
st_args
 *
args
 = (struct st_args *)
a
;

189 union 
Nsipc
 *
req
 = 
args
->req;

190 int 
r
;

192 switch (
args
->
reqno
) {

193 case 
NSREQ_ACCEPT
:

195 struct 
Nsret_accept
 
ret
;

196 
r
 = 
	`lwip_accept
(
req
->
accept
.
req_s
, &
ret
.
ret_addr
,

197 &
ret
.
ret_addrlen
);

198 
	`memmove
(
req
, &
ret
, sizeof ret);

201 case 
NSREQ_BIND
:

203 int 
uid
 = 
envs
[
	`ENVX
(
args
->
whom
)].
env_uid
;

204 struct 
sockaddr_in
 *
addr
 = (struct sockaddr_in*)&
req
->
bind
.
req_name
;

205 if(
uid
 != 0 && 
	`ntohs
(
addr
->
sin_port
) < 1024)

207 
r
 = -
E_BAD_PERM
;

211 
r
 = 
	`lwip_bind
(
req
->
bind
.
req_s
, &req->bind.
req_name
,

212 
req
->
bind
.
req_namelen
);

216 case 
NSREQ_SHUTDOWN
:

217 
r
 = 
	`lwip_shutdown
(
req
->
shutdown
.
req_s
, req->shutdown.
req_how
);

219 case 
NSREQ_CLOSE
:

220 
r
 = 
	`lwip_close
(
req
->
close
.
req_s
);

222 case 
NSREQ_CONNECT
:

223 
r
 = 
	`lwip_connect
(
req
->
connect
.
req_s
, &req->connect.
req_name
,

224 
req
->
connect
.
req_namelen
);

226 case 
NSREQ_LISTEN
:

227 
r
 = 
	`lwip_listen
(
req
->
listen
.
req_s
, req->listen.
req_backlog
);

229 case 
NSREQ_RECV
:

232 
r
 = 
	`lwip_recv
(
req
->
recv
.
req_s
, req->
recvRet
.
ret_buf
,

233 
req
->
recv
.
req_len
, req->recv.
req_flags
);

235 case 
NSREQ_SEND
:

236 
r
 = 
	`lwip_send
(
req
->
send
.
req_s
, &req->send.
req_buf
,

237 
req
->
send
.
req_size
, req->send.
req_flags
);

239 case 
NSREQ_SOCKET
:

240 
r
 = 
	`lwip_socket
(
req
->
socket
.
req_domain
, req->socket.
req_type
,

241 
req
->
socket
.
req_protocol
);

243 case 
NSREQ_INPUT
:

244 
	`jif_input
(&
nif
, (void *)&
req
->
pkt
);

245 
r
 = 0;

248 
	`cprintf
("Invalid request code %d from %08x\n", 
args
->
whom
, args->
req
);

249 
r
 = -
E_INVAL
;

253 if (
r
 == -1) {

254 char 
buf
[100];

255 
	`snprintf
(
buf
, sizeof buf, "ns req type %d", 
args
->
reqno
);

256 
	`perror
(
buf
);

259 if (
args
->
reqno
 != 
NSREQ_INPUT
)

260 
	`ipc_send
(
args
->
whom
, 
r
, 0, 0);

262 
	`put_buffer
(
args
->
req
);

263 
	`sys_page_unmap
(0, (void*) 
args
->
req
);

264 
	`free
(
args
);

265 
	}
}

268 
	$serve
(void) {

269 
int32_t
 
reqno
;

270 
uint32_t
 
whom
;

271 int 
i
, 
perm
;

272 void *
va
;

278 for (
i
 = 0; 
	`thread_wakeups_pending
() && i < 32; ++i)

279 
	`thread_yield
();

281 
perm
 = 0;

282 
va
 = 
	`get_buffer
();

283 
reqno
 = 
	`ipc_recv
((
int32_t
 *) &
whom
, (void *) 
va
, &
perm
);

284 if (
debug
) {

285 
	`cprintf
("ns req %d from %08x\n", 
reqno
, 
whom
);

289 if (
reqno
 == 
NSREQ_TIMER
) {

290 
	`process_timer
(
whom
);

291 
	`put_buffer
(
va
);

296 if (!(
perm
 & 
PTE_P
)) {

297 
	`cprintf
("Invalid request from %08x: no argument page\n", 
whom
);

303 struct 
st_args
 *
args
 = 
	`malloc
(sizeof(struct st_args));

304 if (!
args
)

305 
	`panic
("could not allocate thread args structure");

307 
args
->
reqno
 = reqno;

308 
args
->
whom
 = whom;

309 
args
->
req
 = 
va
;

311 
	`thread_create
(0, "serve_thread", 
serve_thread
, (
uint32_t
)
args
);

312 
	`thread_yield
();

314 
	}
}

317 
	$tmain
(
uint32_t
 
arg
) {

318 
	`serve_init
(
	`inet_addr
(
IP
),

319 
	`inet_addr
(
MASK
),

320 
	`inet_addr
(
DEFAULT
));

321 
	`serve
();

322 
	}
}

325 
	$umain
(int 
argc
, char **
argv
)

327 
envid_t
 
ns_envid
 = 
	`sys_getenvid
();

329 
binaryname
 = "ns";

332 
timer_envid
 = 
	`fork
();

333 if (
timer_envid
 < 0)

334 
	`panic
("error forking");

335 else if (
timer_envid
 == 0) {

336 
	`timer
(
ns_envid
, 
TIMER_INTERVAL
);

342 
input_envid
 = 
	`fork
();

343 if (
input_envid
 < 0)

344 
	`panic
("error forking");

345 else if (
input_envid
 == 0) {

346 
	`input
(
ns_envid
);

352 
output_envid
 = 
	`fork
();

353 if (
output_envid
 < 0)

354 
	`panic
("error forking");

355 else if (
output_envid
 == 0) {

356 
	`output
(
ns_envid
);

362 
	`thread_init
();

363 
	`thread_create
(0, "main", 
tmain
, 0);

364 
	`thread_yield
();

366 
	}
}

	@/root/Robux/net/testinput.c

1 #include 
	~"ns.h
"

2 #include 
	~<netif/etharp.h
>

4 static 
envid_t
 
	goutput_envid
;

5 static 
envid_t
 
	ginput_envid
;

7 static struct 
jif_pkt
 *
	gpkt
 = (struct jif_pkt*)
REQVA
;

11 
	$announce
(void)

19 
uint8_t
 
mac
[6];

20 
	`sys_get_mac_addr
(
mac
);

21 
uint32_t
 
myip
 = 
	`inet_addr
(
IP
);

22 
uint32_t
 
gwip
 = 
	`inet_addr
(
DEFAULT
);

23 int 
r
;

25 if ((
r
 = 
	`sys_page_alloc
(0, 
pkt
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

26 
	`panic
("sys_page_map: %e", 
r
);

28 struct 
etharp_hdr
 *
arp
 = (struct etharp_hdr*)
pkt
->
jp_data
;

29 
pkt
->
jp_len
 = sizeof(*
arp
);

31 
	`memset
(
arp
->
ethhdr
.
dest
.
addr
, 0xff, 
ETHARP_HWADDR_LEN
);

32 
	`memcpy
(
arp
->
ethhdr
.
src
.
addr
, 
mac
, 
ETHARP_HWADDR_LEN
);

33 
arp
->
ethhdr
.
type
 = 
	`htons
(
ETHTYPE_ARP
);

34 
arp
->
hwtype
 = 
	`htons
(1);

35 
arp
->
proto
 = 
	`htons
(
ETHTYPE_IP
);

36 
arp
->
_hwlen_protolen
 = 
	`htons
((
ETHARP_HWADDR_LEN
 << 8) | 4);

37 
arp
->
opcode
 = 
	`htons
(
ARP_REQUEST
);

38 
	`memcpy
(
arp
->
shwaddr
.
addr
, 
mac
, 
ETHARP_HWADDR_LEN
);

39 
	`memcpy
(
arp
->
sipaddr
.
addrw
, &
myip
, 4);

40 
	`memset
(
arp
->
dhwaddr
.
addr
, 0x00, 
ETHARP_HWADDR_LEN
);

41 
	`memcpy
(
arp
->
dipaddr
.
addrw
, &
gwip
, 4);

43 
	`ipc_send
(
output_envid
, 
NSREQ_OUTPUT
, 
pkt
, 
PTE_P
|
PTE_W
|
PTE_U
);

44 
	`sys_page_unmap
(0, 
pkt
);

45 
	}
}

48 
	$hexdump
(const char *
prefix
, const void *
data
, int 
len
)

50 int 
i
;

51 char 
buf
[80];

52 char *
end
 = 
buf
 + sizeof(buf);

53 char *
out
 = 
NULL
;

54 for (
i
 = 0; i < 
len
; i++) {

55 if (
i
 % 16 == 0)

56 
out
 = 
buf
 + 
	`snprintf
(buf, 
end
 - buf,

57 "%s%04x ", 
prefix
, 
i
);

58 
out
 += 
	`snprintf
(out, 
end
 - out, "%02x", ((
uint8_t
*)
data
)[
i
]);

59 if (
i
 % 16 == 15 || i == 
len
 - 1)

60 
	`cprintf
("%.*s\n", 
out
 - 
buf
, buf);

61 if (
i
 % 2 == 1)

62 *(
out
++) = ' ';

63 if (
i
 % 16 == 7)

64 *(
out
++) = ' ';

66 
	}
}

69 
	$umain
(int 
argc
, char **
argv
)

71 
envid_t
 
ns_envid
 = 
	`sys_getenvid
();

72 int 
i
, 
r
, 
first
 = 1;

74 
binaryname
 = "testinput";

76 
output_envid
 = 
	`fork
();

77 if (
output_envid
 < 0)

78 
	`panic
("error forking");

79 else if (
output_envid
 == 0) {

80 
	`output
(
ns_envid
);

84 
input_envid
 = 
	`fork
();

85 if (
input_envid
 < 0)

86 
	`panic
("error forking");

87 else if (
input_envid
 == 0) {

88 
	`input
(
ns_envid
);

92 
	`cprintf
("Sending ARP announcement...\n");

93 
	`announce
();

96 
envid_t
 
whom
;

97 int 
perm
;

99 
int32_t
 
req
 = 
	`ipc_recv
((int32_t *)&
whom
, 
pkt
, &
perm
);

100 if (
req
 < 0)

101 
	`panic
("ipc_recv: %e", 
req
);

102 if (
whom
 != 
input_envid
)

103 
	`panic
("IPC from unexpected environment %08x", 
whom
);

104 if (
req
 != 
NSREQ_INPUT
)

105 
	`panic
("Unexpected IPC %d", 
req
);

107 
	`hexdump
("input: ", 
pkt
->
jp_data
, pkt->
jp_len
);

108 
	`cprintf
("\n");

112 if (
first
)

113 
	`cprintf
("Waiting for packets...\n");

114 
first
 = 0;

116 
	}
}

	@/root/Robux/net/testoutput.c

1 #include 
	~"ns.h
"

3 #ifndef 
TESTOUTPUT_COUNT


4 #define 
	#TESTOUTPUT_COUNT
 10

	)

7 static 
envid_t
 
	goutput_envid
;

9 static struct 
jif_pkt
 *
	gpkt
 = (struct jif_pkt*)
REQVA
;

13 
	$umain
(int 
argc
, char **
argv
)

15 
envid_t
 
ns_envid
 = 
	`sys_getenvid
();

16 int 
i
, 
r
;

18 
binaryname
 = "testoutput";

20 
output_envid
 = 
	`fork
();

21 if (
output_envid
 < 0)

22 
	`panic
("error forking");

23 else if (
output_envid
 == 0) {

24 
	`output
(
ns_envid
);

28 for (
i
 = 0; i < 
TESTOUTPUT_COUNT
; i++) {

29 if ((
r
 = 
	`sys_page_alloc
(0, 
pkt
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

30 
	`panic
("sys_page_alloc: %e", 
r
);

31 
pkt
->
jp_len
 = 
	`snprintf
(pkt->
jp_data
,

32 
PGSIZE
 - sizeof(
pkt
->
jp_len
),

33 "Packet %02d", 
i
);

34 
	`cprintf
("Transmitting packet %d\n", 
i
);

35 
	`ipc_send
(
output_envid
, 
NSREQ_OUTPUT
, 
pkt
, 
PTE_P
|
PTE_W
|
PTE_U
);

36 
	`sys_page_unmap
(0, 
pkt
);

40 for (
i
 = 0; i < 
TESTOUTPUT_COUNT
*2; i++)

41 
	`sys_yield
();

42 
	}
}

	@/root/Robux/net/timer.c

1 #include 
	~"ns.h
"

4 
	$timer
(
envid_t
 
ns_envid
, 
uint32_t
 
initial_to
) {

5 int 
r
;

6 
uint32_t
 
stop
 = 
	`sys_time_msec
() + 
initial_to
;

8 
binaryname
 = "ns_timer";

11 while((
r
 = 
	`sys_time_msec
()) < 
stop
 && r >= 0) {

12 
	`sys_yield
();

14 if (
r
 < 0)

15 
	`panic
("sys_time_msec: %e", 
r
);

17 
	`ipc_send
(
ns_envid
, 
NSREQ_TIMER
, 0, 0);

20 
uint32_t
 
to
, 
whom
;

21 
to
 = 
	`ipc_recv
((
int32_t
 *) &
whom
, 0, 0);

23 if (
whom
 != 
ns_envid
) {

24 
	`cprintf
("NS TIMER: timer thread got IPC message from env %x not NS\n", 
whom
);

28 
stop
 = 
	`sys_time_msec
() + 
to
;

32 
	}
}

	@/root/Robux/security/secipc.h

10 #ifndef 
JOS_SECIPC_H


11 #define 
	#JOS_SECIPC_H


	)

13 #include 
	~<inc/security.h
>

16 enum 
	eSECIPC_TYPE


18 
	mNAME2INFO
 = 1,

19 
	mUID2INFO
,

20 
	mVERIFYPASS
,

24 union 
	usecipc_buffer


28 char 
	mname
[
NAME_LEN
];

29 } 
	mname_req
;

33 
uid_t
 
	muid
;

34 } 
	muid_req
;

38 
uid_t
 
	muid
;

39 char 
	mpass
[
PASS_LEN
];

40 } 
	mverify_req
;

	@/root/Robux/security/security.c

13 #include 
	~<inc/lib.h
>

14 #include 
	~<inc/security.h
>

15 #include 
	~<security/secipc.h
>

16 #include 
	~<inc/mmu.h
>

17 #include 
	~<contrib/sha2/sha2.h
>

21 struct 
user_info
 *
	greply_buf
 = (struct user_info *)0x10000000;

22 union 
secipc_buffer
 *
	grequest_buf
 = (union secipc_buffer *)0x10001000;

28 
	$read_passwd
(char **
ret
, 
uint32_t
 *
sizeret
)

30 int 
fd
 = 
	`open
("passwd", 
O_RDONLY
);

31 if(
fd
 < 0)

32 *
ret
 = 
NULL
;

36 struct 
Stat
 
stat
;

37 
	`fstat
(
fd
, &
stat
);

38 
uint32_t
 
size
 = 
stat
.
st_size
;

41 *
ret
 = 
	`malloc
(
size
+1);

44 int 
red
 = 0;

45 while(
red
 != 
size
)

47 
red
 += 
	`read
(
fd
, (*
ret
)+red, 
size
-red);

51 (*
ret
)[
size
] = '\0';

52 
	`close
(
fd
);

54 *
sizeret
 = 
size
;

56 
	}
}

61 
	$count_users
(char *
passwd
, 
uint32_t
 
size
)

63 int 
i
;

64 int 
ret
 = 0;

65 for(
i
 = 0; i < 
size
; i++)

67 if(
passwd
[
i
] == '\n')

68 
ret
 += 1;

71 return 
ret
;

72 
	}
}

78 
	$get_user_arr
(struct 
user_info
 **
arrptr
, 
uint32_t
 *
count_ret
)

80 char *
passwd
;

81 
uint32_t
 
size
;

82 
	`read_passwd
(&
passwd
, &
size
);

83 if(
passwd
 == 
NULL
)

84 
	`panic
("security: cannot read passwd\n");

87 int 
usernum
 = 
	`count_users
(
passwd
, 
size
);

89 *
arrptr
 = (struct 
user_info
 *) 
	`malloc
(sizeof(struct user_info) * 
usernum
);

92 char **
lines
 = (char**)
	`malloc
(
usernum
 * sizeof(char*));

93 const char *
cur
 = 
passwd
;

94 const char *
end
 = 
	`strchr
(
cur
, '\n');

95 int 
i
 = 0;

96 while(
end
 != 
NULL
)

98 
lines
[
i
] = (char*)
	`malloc
(
end
 - 
cur
 + 1);

99 
	`memmove
(
lines
[
i
], 
cur
, 
end
-cur);

100 
lines
[
i
][
end
-
cur
] = '\0';

102 
i
++;

103 
cur
 = 
end
+1;

104 
end
 = 
	`strchr
(
cur
, '\n');

109 struct 
user_info
 *
ret
 = *
arrptr
;

110 int 
retindex
 = 0;

111 for(
i
 = 0; i<
usernum
; i++)

113 
cur
 = 
lines
[
i
];

115 
end
 = 
	`strchr
(
cur
, ':');

117 if(
end
 == 
NULL
)

119 
	`cprintf
("passwd: no name\n");

122 
	`strncpy
(
ret
[
retindex
].
ui_name
, 
cur
, 
	`MIN
(
NAME_LEN
, 
end
-cur));

124 
cur
 = 
end
+1;

125 
end
 = 
	`strchr
(
cur
, ':');

126 if(
end
 == 
NULL
)

128 
	`cprintf
("passwd: no pass\n");

131 
	`strncpy
(
ret
[
retindex
].
ui_pass
, 
cur
, 
	`MIN
(
PASS_LEN
, 
end
-cur));

133 char 
tmp_buf
[20];

135 
cur
 = 
end
+1;

136 
end
 = 
	`strchr
(
cur
, ':');

137 if(
end
 == 
NULL
)

139 
	`cprintf
("passwd: no uid\n");

142 
	`memset
(
tmp_buf
, 0, 20);

143 
	`strncpy
(
tmp_buf
, 
cur
, 
	`MIN
(19, 
end
-cur));

144 
ret
[
retindex
].
ui_uid
 = 
	`atoi
(
tmp_buf
);

146 
cur
 = 
end
+1;

147 
end
 = 
	`strchr
(
cur
, ':');

148 if(
end
 == 
NULL
)

150 
	`cprintf
("passwd: no gid\n");

153 
	`memset
(
tmp_buf
, 0, 20);

154 
	`strncpy
(
tmp_buf
, 
cur
, 
	`MIN
(19, 
end
-cur));

155 
ret
[
retindex
].
ui_gid
 = 
	`atoi
(
tmp_buf
);

157 
cur
 = 
end
+1;

158 
end
 = 
	`strchr
(
cur
, ':');

159 if(
end
 == 
NULL
)

161 
	`cprintf
("passwd: no comment\n");

164 
	`strncpy
(
ret
[
retindex
].
ui_comment
, 
cur
, 
	`MIN
(
COMMENT_LEN
, 
end
-cur));

166 
cur
 = 
end
+1;

167 
end
 = 
	`strchr
(
cur
, ':');

168 if(
end
 == 
NULL
)

170 
	`cprintf
("passwd: no home\n");

173 
	`strncpy
(
ret
[
retindex
].
ui_home
, 
cur
, 
	`MIN
(
NAME_LEN
, 
end
-cur));

175 
cur
 = 
end
+1;

176 
	`strncpy
(
ret
[
retindex
].
ui_shell
, 
cur
, 
PATH_LEN
);

178 
retindex
++;

181 *
count_ret
 = 
retindex
;

183 for(
i
 = 0; i<
usernum
; i++)

185 
	`free
(
lines
[
i
]);

188 
	`free
(
lines
);

189 
	`free
(
passwd
);

190 
	}
}

194 
	$hash_pass
(char *
input
, char *
buf
)

196 
	`strncpy
(
buf
, "{JOS}", 
PASS_LEN
);

198 char 
output
[
SHA256_DIGEST_STRING_LENGTH
];

200 
	`SHA256_Data
((
uint8_t
*)
input
, 
	`strlen
(input), 
output
);

202 
	`strcat
(
buf
, 
output
);

203 
	}
}

208 
	$recv_loop
()

210 
envid_t
 
from
;

211 int 
req
;

214 
req
 = 
	`ipc_recv
(&
from
, 
request_buf
, 
NULL
);

216 struct 
user_info
 *
user_arr
;

217 struct 
user_info
 *
req_user
 = 
NULL
;

218 
uint32_t
 
user_count
;

219 
	`get_user_arr
(&
user_arr
, &
user_count
);

222 int 
i
;

223 switch(
req
)

227 case 
NAME2INFO
:

228 for(
i
 = 0; i < 
user_count
; i++)

230 if(
	`strncmp
(
user_arr
[
i
].
ui_name
,

231 
request_buf
->
name_req
.
name
,

232 
NAME_LEN
) == 0)

234 
req_user
 = &
user_arr
[
i
];

240 case 
UID2INFO
:

241 for(
i
 = 0; i < 
user_count
; i++)

243 if(
user_arr
[
i
].
ui_uid
 == 
request_buf
->
uid_req
.
uid
)

245 
req_user
 = &
user_arr
[
i
];

250 case 
VERIFYPASS
:

251 for(
i
 = 0; i < 
user_count
; i++)

253 if(
user_arr
[
i
].
ui_uid
 == 
request_buf
->
verify_req
.
uid
)

255 
req_user
 = &
user_arr
[
i
];

262 switch(
req
)

264 case 
NAME2INFO
:

267 if(
req_user
 == 
NULL
)

269 
	`ipc_send
(
from
, -
E_USER_NOT_FOUND
, 
NULL
, 0);

273 if(
	`sys_page_alloc
(0, 
reply_buf
, 
PTE_P
 | 
PTE_U
 | 
PTE_W
) < 0)

274 
	`panic
("security: failed to alloc reply page\n");

277 
	`memmove
(
reply_buf
, 
req_user
, sizeof(struct 
user_info
));

278 
	`memset
(
reply_buf
->
ui_pass
, 0, 
PASS_LEN
);

279 
	`ipc_send
(
from
, 0, 
reply_buf
, 
PTE_P
 | 
PTE_U
 | 
PTE_W
);

282 case 
UID2INFO
:

285 if(
req_user
 == 
NULL
)

287 
	`ipc_send
(
from
, -
E_USER_NOT_FOUND
, 
NULL
, 0);

291 if(
	`sys_page_alloc
(0, 
reply_buf
, 
PTE_P
 | 
PTE_U
 | 
PTE_W
) < 0)

292 
	`panic
("security: failed to alloc reply page\n");

295 
	`memmove
(
reply_buf
, 
req_user
, sizeof(struct 
user_info
));

296 
	`memset
(
reply_buf
->
ui_pass
, 0, 
PASS_LEN
);

297 
	`ipc_send
(
from
, 0, 
reply_buf
, 
PTE_P
 | 
PTE_U
 | 
PTE_W
);

300 case 
VERIFYPASS
:

302 if(
req_user
 == 
NULL
)

304 
	`ipc_send
(
from
, -
E_USER_NOT_FOUND
, 
NULL
, 0);

308 char 
temp
[
PASS_LEN
];

309 
	`memset
(
temp
, 0, 
PASS_LEN
);

310 
	`hash_pass
(
request_buf
->
verify_req
.
pass
, 
temp
);

311 int 
comp
 = 
	`strncmp
(
req_user
->
ui_pass
, 
temp
, 
PASS_LEN
);

314 
	`ipc_send
(
from
, (
comp
 == 0)?0:1, 
NULL
, 0);

318 
	`ipc_send
(
from
, -
E_INVAL
, 
NULL
, 0);

321 
	`free
(
user_arr
);

323 
	}
}

327 
	$umain
(int 
argc
, char *
argv
[])

329 
binaryname
="security";

331 
	`cprintf
("Security server running\n");

333 
	`recv_loop
();

335 
	`exit
();

336 
	}
}

	@/root/Robux/user/badsegment.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

9 
asm
 volatile("movw $0x28,%ax; movw %ax,%ds");

10 
	}
}

	@/root/Robux/user/breakpoint.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

8 
asm
 volatile("int $3");

9 
	}
}

	@/root/Robux/user/buggyhello.c

4 #include 
	~<inc/lib.h
>

7 
	$umain
(int 
argc
, char **
argv
)

9 
	`sys_cputs
((char*)1, 1);

10 
	}
}

	@/root/Robux/user/buggyhello2.c

4 #include 
	~<inc/lib.h
>

6 const char *
	ghello
 = "hello, world\n";

9 
	$umain
(int 
argc
, char **
argv
)

11 
	`sys_cputs
(
hello
, 1024*1024);

12 
	}
}

	@/root/Robux/user/cat.c

1 #include 
	~<inc/lib.h
>

3 char 
	gbuf
[8192];

6 
	$cat
(int 
f
, char *
s
)

8 long 
n
;

9 int 
r
;

11 while ((
n
 = 
	`read
(
f
, 
buf
, (long)sizeof(buf))) > 0)

12 if ((
r
 = 
	`write
(1, 
buf
, 
n
)) != n)

14 
	`printf
("write error copying %s: %e\n", 
s
, 
r
);

15 
	`exit
();

17 if (
n
 < 0)

19 
	`printf
("error reading %s: %e\n", 
s
, 
n
);

21 
	}
}

24 
	$umain
(int 
argc
, char **
argv
)

26 int 
f
, 
i
;

28 
binaryname
 = "cat";

29 if (
argc
 == 1)

30 
	`cat
(0, "<stdin>");

32 for (
i
 = 1; i < 
argc
; i++) {

33 
f
 = 
	`open
(
argv
[
i
], 
O_RDONLY
);

34 if (
f
 < 0)

35 
	`printf
("can't open %s: %e\n", 
argv
[
i
], 
f
);

37 
	`cat
(
f
, 
argv
[
i
]);

38 
	`close
(
f
);

41 
	}
}

	@/root/Robux/user/chgrp.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 
binaryname
 = "chgrp";

7 if (
argc
<3) {

8 
	`printf
("not enough arguments\n");

9 
	`exit
();

12 int 
fdnum
,
r
,
i
;

13 char *
gid_str
 = 
argv
[1];

14 
gid_t
 
gid
;

16 if (
	`strlen
(
gid_str
)>4)

17 
	`printf
("not a valid gid:%s. Please use at most 4 digits",
gid_str
);

18 
gid
 = (
gid_t
)
	`atoi
(
gid_str
);

20 for (
i
=2; i<
argc
; i++) {

21 
fdnum
 = 
	`open
(
argv
[
i
],
O_RDONLY
);

22 if (
fdnum
<0)

23 
	`printf
("can't open %s: %e\n",
argv
[
i
],
fdnum
);

25 if ((
r
=
	`fchgrp
(
fdnum
,
gid
))<0)

26 
	`printf
("chmod failed: %e\n", 
r
);

28 
	`close
(
fdnum
);

30 
	}
}

	@/root/Robux/user/chmod.c

1 #include 
	~<inc/lib.h
>

5 
	$atoi_octal
(char *
str
)

7 int 
end
,
i
;

8 int 
ret
=0;

9 int 
str_len
 = 
	`strlen
(
str
);

11 for (
end
=0;end<
str_len
;end++)

13 char 
c
 = 
str
[
end
];

14 switch(
c
)

26 
i
++;

30 for(
i
=1; i <= 
end
; i++)

32 int 
c
 = 
str
[
end
-
i
] - '0';

34 int 
mult
;

35 for(
mult
 = 0; mult < (
i
-1); mult++)

36 
c
 *= 8;

38 
ret
 += 
c
;

40 return 
ret
;

41 
	}
}

45 
	$umain
(int 
argc
, char **
argv
)

47 
binaryname
 = "chmod";

48 if (
argc
<3) {

49 
	`printf
("not enough arguments\n");

50 
	`exit
();

53 int 
fdnum
, 
r
,
i
,
perm_len
,
end
;

54 char *
perm_str
 = 
argv
[1];

55 
fsperm_t
 
perm
;

58 if (
	`strlen
(
perm_str
)>3)

60 
	`printf
("invalid permission argument: %s\n",
perm_str
);

64 
perm
 = (
fsperm_t
)
	`atoi_octal
(
perm_str
);

65 for (
i
=2; i<
argc
; i++) {

66 
fdnum
 = 
	`open
(
argv
[
i
],
O_RDONLY
);

67 if (
fdnum
<0)

68 
	`printf
("can't open %s: %e\n",
argv
[
i
],
fdnum
);

70 if ((
r
=
	`fchmod
(
fdnum
,
perm
))<0)

71 
	`printf
("chmod failed: %e\n", 
r
);

73 
	`close
(
fdnum
);

76 
	}
}

	@/root/Robux/user/chown.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 
binaryname
 = "chown";

7 if (
argc
<3) {

8 
	`printf
("not enough arguments\n");

9 
	`exit
();

12 int 
fdnum
,
r
,
i
;

13 char *
username
 = 
argv
[1];

14 struct 
user_info
 
u_info
;

15 
uid_t
 
uid
;

17 if ((
r
=
	`get_user_by_name
(
username
,&
u_info
))<0)

19 
	`printf
("could not find user %s",
username
);

20 
	`exit
();

23 
uid
 = 
u_info
.
ui_uid
;

24 for (
i
=2; i<
argc
; i++) {

25 
fdnum
 = 
	`open
(
argv
[
i
],
O_RDONLY
);

26 if (
fdnum
<0)

27 
	`printf
("can't open %s: %e\n",
argv
[
i
],
fdnum
);

29 if ((
r
=
	`fchown
(
fdnum
,
uid
))<0)

30 
	`printf
("chmod failed: %e\n", 
r
);

32 
	`close
(
fdnum
);

34 
	}
}

	@/root/Robux/user/divzero.c

3 #include 
	~<inc/lib.h
>

5 int 
	gzero
;

8 
	$umain
(int 
argc
, char **
argv
)

10 
zero
 = 0;

11 
	`printf
("1/0 is %08x!\n", 1/
zero
);

12 
	}
}

	@/root/Robux/user/dumbfork.c

4 #include 
	~<inc/string.h
>

5 #include 
	~<inc/lib.h
>

7 
envid_t
 
dumbfork
(void);

10 
	$umain
(int 
argc
, char **
argv
)

12 
envid_t
 
who
;

13 int 
i
;

16 
who
 = 
	`dumbfork
();

19 for (
i
 = 0; i < (
who
 ? 10 : 20); i++) {

20 
	`printf
("%d: I am the %s!\n", 
i
, 
who
 ? "parent" : "child");

21 
	`sys_yield
();

23 
	}
}

26 
	$duppage
(
envid_t
 
dstenv
, void *
addr
)

28 int 
r
;

31 if ((
r
 = 
	`sys_page_alloc
(
dstenv
, 
addr
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

32 
	`panic
("sys_page_alloc: %e", 
r
);

33 if ((
r
 = 
	`sys_page_map
(
dstenv
, 
addr
, 0, 
UTEMP
, 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

34 
	`panic
("sys_page_map: %e", 
r
);

35 
	`memmove
(
UTEMP
, 
addr
, 
PGSIZE
);

36 if ((
r
 = 
	`sys_page_unmap
(0, 
UTEMP
)) < 0)

37 
	`panic
("sys_page_unmap: %e", 
r
);

38 
	}
}

40 
envid_t


41 
	$dumbfork
(void)

43 
envid_t
 
envid
;

44 
uint8_t
 *
addr
;

45 int 
r
;

46 extern unsigned char 
end
[];

53 
envid
 = 
	`sys_exofork
();

54 if (
envid
 < 0)

55 
	`panic
("sys_exofork: %e", 
envid
);

56 if (
envid
 == 0) {

61 
thisenv
 = &
envs
[
	`ENVX
(
	`sys_getenvid
())];

68 for (
addr
 = (
uint8_t
*) 
UTEXT
; addr < 
end
; addr += 
PGSIZE
)

69 
	`duppage
(
envid
, 
addr
);

72 
	`duppage
(
envid
, 
	`ROUNDDOWN
(&
addr
, 
PGSIZE
));

75 if ((
r
 = 
	`sys_env_set_status
(
envid
, 
ENV_RUNNABLE
)) < 0)

76 
	`panic
("sys_env_set_status: %e", 
r
);

78 return 
envid
;

79 
	}
}

	@/root/Robux/user/echo.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
i
, 
nflag
;

8 
nflag
 = 0;

9 if (
argc
 > 1 && 
	`strcmp
(
argv
[1], "-n") == 0) {

10 
nflag
 = 1;

11 
argc
--;

12 
argv
++;

14 for (
i
 = 1; i < 
argc
; i++) {

15 if (
i
 > 1)

16 
	`write
(1, " ", 1);

17 
	`write
(1, 
argv
[
i
], 
	`strlen
(argv[i]));

19 if (!
nflag
)

20 
	`write
(1, "\n", 1);

21 
	}
}

	@/root/Robux/user/echosrv.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<lwip/sockets.h
>

3 #include 
	~<lwip/inet.h
>

5 #define 
	#PORT
 7

	)

7 #define 
	#BUFFSIZE
 32

	)

8 #define 
	#MAXPENDING
 5

9 

	)

11 
	$die
(char *
m
)

13 
	`printf
("%s\n", 
m
);

14 
	`exit
();

15 
	}
}

18 
	$handle_client
(int 
sock
)

20 char 
buffer
[
BUFFSIZE
];

21 int 
received
 = -1;

23 if ((
received
 = 
	`read
(
sock
, 
buffer
, 
BUFFSIZE
)) < 0)

24 
	`die
("Failed to receive initial bytes from client");

27 while (
received
 > 0) {

29 if (
	`write
(
sock
, 
buffer
, 
received
) != received)

30 
	`die
("Failed to send bytes to client");

33 if ((
received
 = 
	`read
(
sock
, 
buffer
, 
BUFFSIZE
)) < 0)

34 
	`die
("Failed to receive additional bytes from client");

36 
	`close
(
sock
);

37 
	}
}

40 
	$umain
(int 
argc
, char **
argv
)

42 int 
serversock
, 
clientsock
;

43 struct 
sockaddr_in
 
echoserver
, 
echoclient
;

44 char 
buffer
[
BUFFSIZE
];

45 unsigned int 
echolen
;

46 int 
received
 = 0;

49 if ((
serversock
 = 
	`socket
(
PF_INET
, 
SOCK_STREAM
, 
IPPROTO_TCP
)) < 0)

50 
	`die
("Failed to create socket");

52 
	`printf
("opened socket\n");

55 
	`memset
(&
echoserver
, 0, sizeof(echoserver));

56 
echoserver
.
sin_family
 = 
AF_INET
;

57 
echoserver
.
sin_addr
.
s_addr
 = 
	`htonl
(
INADDR_ANY
);

58 
echoserver
.
sin_port
 = 
	`htons
(
PORT
);

60 
	`printf
("trying to bind\n");

63 if (
	`bind
(
serversock
, (struct 
sockaddr
 *) &
echoserver
,

64 sizeof(
echoserver
)) < 0) {

65 
	`die
("Failed to bind the server socket");

69 if (
	`listen
(
serversock
, 
MAXPENDING
) < 0)

70 
	`die
("Failed to listen on server socket");

72 
	`printf
("bound\n");

76 unsigned int 
clientlen
 = sizeof(
echoclient
);

78 if ((
clientsock
 =

79 
	`accept
(
serversock
, (struct 
sockaddr
 *) &
echoclient
,

80 &
clientlen
)) < 0) {

81 
	`die
("Failed to accept client connection");

83 
	`printf
("Client connected: %s\n", 
	`inet_ntoa
(
echoclient
.
sin_addr
));

84 
	`handle_client
(
clientsock
);

87 
	`close
(
serversock
);

89 
	}
}

	@/root/Robux/user/echotest.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<lwip/sockets.h
>

3 #include 
	~<lwip/inet.h
>

5 #define 
	#BUFFSIZE
 32

	)

6 #define 
	#IPADDR
 "10.0.2.15"

	)

7 #define 
	#PORT
 10000

	)

9 const char *
	gmsg
 = "Hello world!\n";

12 
	$die
(char *
m
)

14 
	`printf
("%s\n", 
m
);

15 
	`exit
();

16 
	}
}

18 void 
	$umain
(int 
argc
, char **
argv
)

20 int 
sock
;

21 struct 
sockaddr_in
 
echoserver
;

22 char 
buffer
[
BUFFSIZE
];

23 unsigned int 
echolen
;

24 int 
received
 = 0;

26 
	`printf
("Connecting to:\n");

27 
	`printf
("\tip address %s = %x\n", 
IPADDR
, 
	`inet_addr
(IPADDR));

30 if ((
sock
 = 
	`socket
(
PF_INET
, 
SOCK_STREAM
, 
IPPROTO_TCP
)) < 0)

31 
	`die
("Failed to create socket");

33 
	`printf
("opened socket\n");

36 
	`memset
(&
echoserver
, 0, sizeof(echoserver));

37 
echoserver
.
sin_family
 = 
AF_INET
;

38 
echoserver
.
sin_addr
.
s_addr
 = 
	`inet_addr
(
IPADDR
);

39 
echoserver
.
sin_port
 = 
	`htons
(
PORT
);

41 
	`printf
("trying to connect to server\n");

44 if (
	`connect
(
sock
, (struct 
sockaddr
 *) &
echoserver
, sizeof(echoserver)) < 0)

45 
	`die
("Failed to connect with server");

47 
	`printf
("connected to server\n");

50 
echolen
 = 
	`strlen
(
msg
);

51 if (
	`write
(
sock
, 
msg
, 
echolen
) != echolen)

52 
	`die
("Mismatch in number of sent bytes");

55 
	`printf
("Received: \n");

56 while (
received
 < 
echolen
) {

57 int 
bytes
 = 0;

58 if ((
bytes
 = 
	`read
(
sock
, 
buffer
, 
BUFFSIZE
-1)) < 1) {

59 
	`die
("Failed to receive bytes from server");

61 
received
 += 
bytes
;

62 
buffer
[
bytes
] = '\0';

63 
	`printf
(
buffer
);

65 
	`printf
("\n");

67 
	`close
(
sock
);

68 
	}
}

	@/root/Robux/user/evilhello.c

4 #include 
	~<inc/lib.h
>

7 
	$umain
(int 
argc
, char **
argv
)

10 
	`sys_cputs
((char*)0xf010000c, 100);

11 
	}
}

	@/root/Robux/user/fairness.c

5 #include 
	~<inc/lib.h
>

8 
	$umain
(int 
argc
, char **
argv
)

10 
envid_t
 
who
, 
id
;

12 
id
 = 
	`sys_getenvid
();

14 if (
thisenv
 == &
envs
[1]) {

16 
	`ipc_recv
(&
who
, 0, 0);

17 
	`printf
("%x recv from %x\n", 
id
, 
who
);

20 
	`printf
("%x loop sending to %x\n", 
id
, 
envs
[1].
env_id
);

22 
	`ipc_send
(
envs
[1].
env_id
, 0, 0, 0);

24 
	}
}

	@/root/Robux/user/faultalloc.c

3 #include 
	~<inc/lib.h
>

6 
	$handler
(struct 
UTrapframe
 *
utf
)

8 int 
r
;

9 void *
addr
 = (void*)
utf
->
utf_fault_va
;

11 
	`printf
("fault %x\n", 
addr
);

12 if ((
r
 = 
	`sys_page_alloc
(0, 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

13 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

14 
	`panic
("allocating at %x in page fault handler: %e", 
addr
, 
r
);

15 
	`snprintf
((char*) 
addr
, 100, "this string was faulted in at %x", addr);

16 
	}
}

19 
	$umain
(int 
argc
, char **
argv
)

21 
	`set_pgfault_handler
(
handler
);

22 
	`printf
("%s\n", (char*)0xDeadBeef);

23 
	`printf
("%s\n", (char*)0xCafeBffe);

24 
	}
}

	@/root/Robux/user/faultallocbad.c

4 #include 
	~<inc/lib.h
>

7 
	$handler
(struct 
UTrapframe
 *
utf
)

9 int 
r
;

10 void *
addr
 = (void*)
utf
->
utf_fault_va
;

12 
	`printf
("fault %x\n", 
addr
);

13 if ((
r
 = 
	`sys_page_alloc
(0, 
	`ROUNDDOWN
(
addr
, 
PGSIZE
),

14 
PTE_P
|
PTE_U
|
PTE_W
)) < 0)

15 
	`panic
("allocating at %x in page fault handler: %e", 
addr
, 
r
);

16 
	`snprintf
((char*) 
addr
, 100, "this string was faulted in at %x", addr);

17 
	}
}

20 
	$umain
(int 
argc
, char **
argv
)

22 
	`set_pgfault_handler
(
handler
);

23 
	`sys_cputs
((char*)0xDEADBEEF, 4);

24 
	}
}

	@/root/Robux/user/faultbadhandler.c

6 #include 
	~<inc/lib.h
>

9 
	$umain
(int 
argc
, char **
argv
)

11 
	`sys_page_alloc
(0, (void*) (
UXSTACKTOP
 - 
PGSIZE
), 
PTE_P
|
PTE_U
|
PTE_W
);

12 
	`sys_env_set_pgfault_upcall
(0, (void*) 0xDeadBeef);

14 
	}
}

	@/root/Robux/user/faultdie.c

3 #include 
	~<inc/lib.h
>

6 
	$handler
(struct 
UTrapframe
 *
utf
)

8 void *
addr
 = (void*)
utf
->
utf_fault_va
;

9 
uint32_t
 
err
 = 
utf
->
utf_err
;

10 
	`printf
("i faulted at va %x, err %x\n", 
addr
, 
err
 & 7);

11 
	`sys_env_destroy
(
	`sys_getenvid
());

12 
	}
}

15 
	$umain
(int 
argc
, char **
argv
)

17 
	`set_pgfault_handler
(
handler
);

19 
	}
}

	@/root/Robux/user/faultevilhandler.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

8 
	`sys_page_alloc
(0, (void*) (
UXSTACKTOP
 - 
PGSIZE
), 
PTE_P
|
PTE_U
|
PTE_W
);

9 
	`sys_env_set_pgfault_upcall
(0, (void*) 0xF0100020);

11 
	}
}

	@/root/Robux/user/faultnostack.c

3 #include 
	~<inc/lib.h
>

5 void 
_pgfault_upcall
();

8 
	$umain
(int 
argc
, char **
argv
)

10 
	`sys_env_set_pgfault_upcall
(0, (void*) 
_pgfault_upcall
);

12 
	}
}

	@/root/Robux/user/faultread.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

8 
	`printf
("I read %08x from location 0!\n", *(unsigned*)0);

9 
	}
}

	@/root/Robux/user/faultreadkernel.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

8 
	`printf
("I read %08x from location 0xf0100000!\n", *(unsigned*)0xf0100000);

9 
	}
}

	@/root/Robux/user/faultregs.c

3 #include 
	~<inc/lib.h
>

5 struct 
	sregs


7 struct 
PushRegs
 
	mregs
;

8 
uintptr_t
 
	meip
;

9 
uint32_t
 
	meflags
;

10 
uintptr_t
 
	mesp
;

13 #define 
	#SAVE_REGS
(
base
) \

14 "\tmovl %%edi, "
base
"+0x00\n" \

15 "\tmovl %%esi, "
base
"+0x04\n" \

16 "\tmovl %%ebp, "
base
"+0x08\n" \

17 "\tmovl %%ebx, "
base
"+0x10\n" \

18 "\tmovl %%edx, "
base
"+0x14\n" \

19 "\tmovl %%ecx, "
base
"+0x18\n" \

20 "\tmovl %%eax, "
base
"+0x1c\n" \

21 "\tmovl %%esp, "
base
"+0x28\n"

	)

23 #define 
	#LOAD_REGS
(
base
) \

24 "\tmovl "
base
"+0x00, %%edi\n" \

25 "\tmovl "
base
"+0x04, %%esi\n" \

26 "\tmovl "
base
"+0x08, %%ebp\n" \

27 "\tmovl "
base
"+0x10, %%ebx\n" \

28 "\tmovl "
base
"+0x14, %%edx\n" \

29 "\tmovl "
base
"+0x18, %%ecx\n" \

30 "\tmovl "
base
"+0x1c, %%eax\n" \

31 "\tmovl "
base
"+0x28, %%esp\n"

	)

33 static struct 
regs
 
	gbefore
, 
	gduring
, 
	gafter
;

36 
	$check_regs
(struct 
regs
* 
a
, const char *
an
, struct regs* 
b
, const char *
bn
,

37 const char *
testname
)

39 int 
mismatch
 = 0;

41 
	`printf
("%-6s %-8s %-8s\n", "", 
an
, 
bn
);

43 #define 
	#CHECK
(
name
, 
field
) \

45 
	`printf
("%-6s %08x %08x ", #name, 
a
->
field
, 
b
->field); \

46 if (
a
->
field
 == 
b
->field) \

47 
	`printf
("OK\n"); \

49 
	`printf
("MISMATCH\n"); \

50 
mismatch
 = 1; \

52 } while (0)

	)

54 
	`CHECK
(
edi
, 
regs
.
reg_edi
);

55 
	`CHECK
(
esi
, 
regs
.
reg_esi
);

56 
	`CHECK
(
ebp
, 
regs
.
reg_ebp
);

57 
	`CHECK
(
ebx
, 
regs
.
reg_ebx
);

58 
	`CHECK
(
edx
, 
regs
.
reg_edx
);

59 
	`CHECK
(
ecx
, 
regs
.
reg_ecx
);

60 
	`CHECK
(
eax
, 
regs
.
reg_eax
);

61 
	`CHECK
(
eip
, eip);

62 
	`CHECK
(
eflags
, eflags);

63 
	`CHECK
(
esp
, esp);

65 #undef 
CHECK


67 
	`printf
("Registers %s ", 
testname
);

68 if (!
mismatch
)

69 
	`printf
("OK\n");

71 
	`printf
("MISMATCH\n");

72 
	}
}

75 
	$pgfault
(struct 
UTrapframe
 *
utf
)

77 int 
r
;

79 if (
utf
->
utf_fault_va
 != (
uint32_t
)
UTEMP
)

80 
	`panic
("pgfault expected at UTEMP, got 0x%08x (eip %08x)",

81 
utf
->
utf_fault_va
, utf->
utf_eip
);

84 
during
.
regs
 = 
utf
->
utf_regs
;

85 
during
.
eip
 = 
utf
->
utf_eip
;

86 
during
.
eflags
 = 
utf
->
utf_eflags
;

87 
during
.
esp
 = 
utf
->
utf_esp
;

88 
	`check_regs
(&
before
, "before", &
during
, "during", "in UTrapframe");

91 if ((
r
 = 
	`sys_page_alloc
(0, 
UTEMP
, 
PTE_U
|
PTE_P
|
PTE_W
)) < 0)

92 
	`panic
("sys_page_alloc: %e", 
r
);

93 
	}
}

96 
	$umain
(int 
argc
, char **
argv
)

98 
	`set_pgfault_handler
(
pgfault
);

100 
__asm
 
	`__volatile
(

117 
	`SAVE_REGS
("%0")

123 
	`SAVE_REGS
("%1")

127 
	`LOAD_REGS
("%0")

136 : : "m" (
before
), "m" (
after
) : "memory", "cc");

141 if (*(int*)
UTEMP
 != 42)

142 
	`printf
("EIP after page-fault MISMATCH\n");

143 
after
.
eip
 = 
before
.eip;

145 
	`check_regs
(&
before
, "before", &
after
, "after", "after page-fault");

146 
	}
}

	@/root/Robux/user/faultwrite.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

9 
	}
}

	@/root/Robux/user/faultwritekernel.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

9 
	}
}

	@/root/Robux/user/forktree.c

3 #include 
	~<inc/lib.h
>

5 #define 
	#DEPTH
 3

	)

7 void 
forktree
(const char *
cur
);

10 
	$forkchild
(const char *
cur
, char 
branch
)

12 char 
nxt
[
DEPTH
+1];

14 if (
	`strlen
(
cur
) >= 
DEPTH
)

17 
	`snprintf
(
nxt
, 
DEPTH
+1, "%s%c", 
cur
, 
branch
);

18 int 
r
;

19 if ((
r
 = 
	`fork
()) == 0) {

20 
	`forktree
(
nxt
);

21 
	`exit
();

23 
	`wait
(
r
);

24 
	}
}

27 
	$forktree
(const char *
cur
)

29 
	`printf
("%04x: I am '%s'\n", 
	`sys_getenvid
(), 
cur
);

31 
	`forkchild
(
cur
, '0');

32 
	`forkchild
(
cur
, '1');

33 
	}
}

36 
	$umain
(int 
argc
, char **
argv
)

38 
	`forktree
("");

39 
	}
}

	@/root/Robux/user/freq.c

1 #include 
	~<inc/lib.h
>

5 
	$umain
(int 
argc
, char **
argv
)

8 
uint32_t
 
data
[256];

9 
	`memset
(
data
, 0, sizeof(
uint32_t
)*256);

11 int 
r
;

12 char 
buf
[1];

13 while((
r
 = 
	`read
(0, &
buf
, 1)) == 1)

15 
data
[(
uint32_t
)
buf
[0]] += 1;

19 int 
i
;

21 int 
max
 = 0;

22 for(
i
 = 0; i < 256; i++)

24 
max
 = 
	`MAX
(max, 
data
[
i
]);

27 const int 
max_width
 = 50;

28 int 
perblock
 = 1;

29 if(
max
 / 
perblock
 > 
max_width
)

31 
perblock
 = 5;

32 while(
max
 / 
perblock
 > 
max_width
)

33 
perblock
 += 5;

36 
	`printf
("Frequence diagram (# = %d):\n", 
perblock
);

38 for(
i
 = 0; i < 256; i++)

40 if(
data
[
i
] == 0)

43 if(
i
 >= ' ' && i <= '~')

44 
	`printf
(" '%c' = %8d : ", (char) 
i
, 
data
[i]);

46 
	`printf
("0x%02x = %8d : ", (char) 
i
, 
data
[i]);

48 int 
j
;

49 for(
j
 = 0; j * 
perblock
 < 
data
[
i
]; j++)

50 
	`printf
("#");

52 
	`printf
("\n");

55 
	`exit
();

57 
	}
}

	@/root/Robux/user/hello.c

2 #include 
	~<inc/lib.h
>

5 
	$umain
(int 
argc
, char **
argv
)

7 
	`printf
("hello, world\n");

8 
	`printf
("i am environment %08x\n", 
thisenv
->
env_id
);

9 
	}
}

	@/root/Robux/user/httpd.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<lwip/sockets.h
>

3 #include 
	~<lwip/inet.h
>

5 #define 
	#PORT
 80

	)

6 #define 
	#VERSION
 "0.1"

	)

7 #define 
	#HTTP_VERSION
 "1.0"

	)

9 #define 
	#E_BAD_REQ
 1000

	)

11 #define 
	#BUFFSIZE
 512

	)

12 #define 
	#MAXPENDING
 5

13 

	)

14 struct 
	shttp_request
 {

15 int 
	msock
;

16 char *
	murl
;

17 char *
	mversion
;

20 struct 
	sresponce_header
 {

21 int 
	mcode
;

22 char *
	mheader
;

25 struct 
responce_header
 
	gheaders
[] = {

26 { 200, "HTTP/" 
HTTP_VERSION
 " 200 OK\r\n"

27 "Server: jhttpd/" 
VERSION
 "\r\n"},

31 struct 
	serror_messages
 {

32 int 
	mcode
;

33 char *
	mmsg
;

36 struct 
error_messages
 
	gerrors
[] = {

42 
	$die
(char *
m
)

44 
	`printf
("%s\n", 
m
);

45 
	`exit
();

46 
	}
}

49 
	$req_free
(struct 
http_request
 *
req
)

51 
	`free
(
req
->
url
);

52 
	`free
(
req
->
version
);

53 
	}
}

56 
	$send_header
(struct 
http_request
 *
req
, int 
code
)

58 struct 
responce_header
 *
h
 = 
headers
;

59 while (
h
->
code
 != 0 && h->
header
!= 0) {

60 if (
h
->
code
 == code)

62 
h
++;

65 if (
h
->
code
 == 0)

68 int 
len
 = 
	`strlen
(
h
->
header
);

69 if (
	`write
(
req
->
sock
, 
h
->
header
, 
len
) != len) {

70 
	`die
("Failed to send bytes to client");

74 
	}
}

77 
	$send_data
(struct 
http_request
 *
req
, int 
fd
, 
off_t
 
file_size
)

80 char *
buf
 = (char*)
	`malloc
(
file_size
);

81 int 
rd
 = 0;

82 while(
rd
 != 
file_size
)

84 
rd
 += 
	`read
(
fd
, 
buf
+rd, 
file_size
 - rd);

87 
	`write
(
req
->
sock
, 
buf
, 
file_size
);

90 
	}
}

93 
	$send_size
(struct 
http_request
 *
req
, 
off_t
 
size
)

95 char 
buf
[64];

96 int 
r
;

98 
r
 = 
	`snprintf
(
buf
, 64, "Content-Length: %ld\r\n", (long)
size
);

99 if (
r
 > 63)

100 
	`panic
("buffer too small!");

102 if (
	`write
(
req
->
sock
, 
buf
, 
r
) != r)

106 
	}
}

109 
	$mime_type
(const char *
file
)

113 
	}
}

116 
	$send_content_type
(struct 
http_request
 *
req
)

118 char 
buf
[128];

119 int 
r
;

120 const char *
type
;

122 
type
 = 
	`mime_type
(
req
->
url
);

123 if (!
type
)

126 
r
 = 
	`snprintf
(
buf
, 128, "Content-Type: %s\r\n", 
type
);

127 if (
r
 > 127)

128 
	`panic
("buffer too small!");

130 if (
	`write
(
req
->
sock
, 
buf
, 
r
) != r)

134 
	}
}

137 
	$send_header_fin
(struct 
http_request
 *
req
)

139 const char *
fin
 = "\r\n";

140 int 
fin_len
 = 
	`strlen
(
fin
);

142 if (
	`write
(
req
->
sock
, 
fin
, 
fin_len
) != fin_len)

146 
	}
}

150 
	$http_request_parse
(struct 
http_request
 *
req
, char *
request
)

152 const char *
url
;

153 const char *
version
;

154 int 
url_len
, 
version_len
;

156 if (!
req
)

159 if (
	`strncmp
(
request
, "GET ", 4) != 0)

160 return -
E_BAD_REQ
;

163 
request
 += 4;

166 
url
 = 
request
;

167 while (*
request
 && *request != ' ')

168 
request
++;

169 
url_len
 = 
request
 - 
url
;

171 
req
->
url
 = 
	`malloc
(
url_len
 + 1);

172 
	`memmove
(
req
->
url
, url, 
url_len
);

173 
req
->
url
[
url_len
] = '\0';

176 
request
++;

178 
version
 = 
request
;

179 while (*
request
 && *request != '\n')

180 
request
++;

181 
version_len
 = 
request
 - 
version
;

183 
req
->
version
 = 
	`malloc
(
version_len
 + 1);

184 
	`memmove
(
req
->
version
, version, 
version_len
);

185 
req
->
version
[
version_len
] = '\0';

190 
	}
}

193 
	$send_error
(struct 
http_request
 *
req
, int 
code
)

195 char 
buf
[512];

196 int 
r
;

198 struct 
error_messages
 *
e
 = 
errors
;

199 while (
e
->
code
 != 0 && e->
msg
 != 0) {

200 if (
e
->
code
 == code)

202 
e
++;

205 if (
e
->
code
 == 0)

208 
r
 = 
	`snprintf
(
buf
, 512, "HTTP/" 
HTTP_VERSION
" %d %s\r\n"

209 "Server: jhttpd/" 
VERSION
 "\r\n"

214 
e
->
code
, e->
msg
, e->code, e->msg);

216 if (
	`write
(
req
->
sock
, 
buf
, 
r
) != r)

220 
	}
}

223 
	$send_file
(struct 
http_request
 *
req
)

225 int 
r
;

226 
off_t
 
file_size
 = -1;

227 int 
fd
;

235 
fd
 = 
	`open
(
req
->
url
, 
O_RDONLY
);

236 if(
fd
 < 0)

238 
	`send_error
(
req
, 404);

242 struct 
Stat
 
stat
;

243 if(
	`fstat
(
fd
, &
stat
) < 0)

245 
	`send_error
(
req
, 500);

249 if(
stat
.
st_isdir
)

251 
	`send_error
(
req
, 404);

255 
file_size
 = 
stat
.
st_size
;

260 if ((
r
 = 
	`send_header
(
req
, 200)) < 0)

261 goto 
end
;

263 if ((
r
 = 
	`send_size
(
req
, 
file_size
)) < 0)

264 goto 
end
;

266 if ((
r
 = 
	`send_content_type
(
req
)) < 0)

267 goto 
end
;

269 if ((
r
 = 
	`send_header_fin
(
req
)) < 0)

270 goto 
end
;

272 
r
 = 
	`send_data
(
req
, 
fd
, 
file_size
);

274 
end
:

275 
	`close
(
fd
);

276 return 
r
;

277 
	}
}

280 
	$handle_client
(int 
sock
)

282 struct 
http_request
 
con_d
;

283 int 
r
;

284 char 
buffer
[
BUFFSIZE
];

285 int 
received
 = -1;

286 struct 
http_request
 *
req
 = &
con_d
;

291 if ((
received
 = 
	`read
(
sock
, 
buffer
, 
BUFFSIZE
)) < 0)

292 
	`panic
("failed to read");

294 
	`memset
(
req
, 0, sizeof(req));

296 
req
->
sock
 = sock;

298 
r
 = 
	`http_request_parse
(
req
, 
buffer
);

299 if (
r
 == -
E_BAD_REQ
)

300 
	`send_error
(
req
, 400);

301 else if (
r
 < 0)

302 
	`panic
("parse failed");

304 
	`send_file
(
req
);

306 
	`req_free
(
req
);

312 
	`close
(
sock
);

313 
	}
}

316 
	$umain
(int 
argc
, char **
argv
)

318 int 
serversock
, 
clientsock
;

319 struct 
sockaddr_in
 
server
, 
client
;

321 
binaryname
 = "jhttpd";

324 if ((
serversock
 = 
	`socket
(
PF_INET
, 
SOCK_STREAM
, 
IPPROTO_TCP
)) < 0)

325 
	`die
("Failed to create socket");

328 
	`memset
(&
server
, 0, sizeof(server));

329 
server
.
sin_family
 = 
AF_INET
;

330 
server
.
sin_addr
.
s_addr
 = 
	`htonl
(
INADDR_ANY
);

331 
server
.
sin_port
 = 
	`htons
(
PORT
);

334 if (
	`bind
(
serversock
, (struct 
sockaddr
 *) &
server
,

335 sizeof(
server
)) < 0)

337 
	`die
("Failed to bind the server socket");

341 if (
	`listen
(
serversock
, 
MAXPENDING
) < 0)

342 
	`die
("Failed to listen on server socket");

344 
	`printf
("Waiting for http connections...\n");

347 unsigned int 
clientlen
 = sizeof(
client
);

349 if ((
clientsock
 = 
	`accept
(
serversock
,

350 (struct 
sockaddr
 *) &
client
,

351 &
clientlen
)) < 0)

353 
	`die
("Failed to accept client connection");

355 
	`handle_client
(
clientsock
);

358 
	`close
(
serversock
);

359 
	}
}

	@/root/Robux/user/icode.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
fd
, 
n
, 
r
;

7 char 
buf
[512+1];

9 
binaryname
 = "icode";

11 
	`printf
("icode startup\n");

13 
	`printf
("icode: open /motd\n");

14 if ((
fd
 = 
	`open
("/motd", 
O_RDONLY
)) < 0)

15 
	`panic
("icode: open /motd: %e", 
fd
);

17 
	`printf
("icode: read /motd\n");

18 while ((
n
 = 
	`read
(
fd
, 
buf
, sizeof buf-1)) > 0)

19 
	`sys_cputs
(
buf
, 
n
);

21 
	`printf
("icode: close /motd\n");

22 
	`close
(
fd
);

24 
	`printf
("icode: spawn /init\n");

25 if ((
r
 = 
	`spawnl
("/oldinit", "init", "initarg1", "initarg2", (char*)0)) < 0)

26 
	`panic
("icode: spawn /init: %e", 
r
);

28 
	`printf
("icode: exiting\n");

29 
	}
}

	@/root/Robux/user/idle.c

3 #include 
	~<inc/x86.h
>

4 #include 
	~<inc/lib.h
>

7 
	$umain
(int 
argc
, char **
argv
)

9 
binaryname
 = "idle";

17 
	`sys_yield
();

19 
	}
}

	@/root/Robux/user/init.c

1 #include 
	~<inc/lib.h
>

4 char 
	mmsg1
[5000];

5 char 
	mmsg2
[1000];

6 } 
	gdata
 = {

11 char 
	gbss
[6000];

14 
	$sum
(const char *
s
, int 
n
)

16 int 
i
, 
tot
 = 0;

17 for (
i
 = 0; i < 
n
; i++)

18 
tot
 ^= 
i
 * 
s
[i];

19 return 
tot
;

20 
	}
}

23 
	$umain
(int 
argc
, char **
argv
)

25 int 
i
, 
r
, 
x
, 
want
;

26 char 
args
[256];

28 if(
	`getuid
() != 0)

30 
	`printf
("Only root may run init\n");

31 
	`exit
();

34 
	`printf
("init: running\n");

36 
want
 = 0xf989e;

37 if ((
x
 = 
	`sum
((char*)&
data
, sizeof data)) != 
want
)

38 
	`printf
("init: data is not initialized: got sum %08x wanted %08x\n",

39 
x
, 
want
);

41 
	`printf
("init: data seems okay\n");

42 if ((
x
 = 
	`sum
(
bss
, sizeof bss)) != 0)

43 
	`printf
("bss is not initialized: wanted sum 0 got %08x\n", 
x
);

45 
	`printf
("init: bss seems okay\n");

48 
	`strcat
(
args
, "init: args:");

49 for (
i
 = 0; i < 
argc
; i++) {

50 
	`strcat
(
args
, " '");

51 
	`strcat
(
args
, 
argv
[
i
]);

52 
	`strcat
(
args
, "'");

54 
	`printf
("%s\n", 
args
);

56 
	`printf
("init: running sh\n");

59 
	`close
(0);

60 if ((
r
 = 
	`opencons
()) < 0)

61 
	`panic
("opencons: %e", 
r
);

62 if (
r
 != 0)

63 
	`panic
("first opencons used fd %d", 
r
);

64 if ((
r
 = 
	`dup
(0, 1)) < 0)

65 
	`panic
("dup: %e", 
r
);

67 
	`printf
("init: starting login\n");

68 
r
 = 
	`spawnl
("/login", "login", "-t", (char*)0);

69 if (
r
 < 0) {

70 
	`printf
("init: spawn sh: %e\n", 
r
);

73 
	`wait
(
r
);

75 
	}
}

	@/root/Robux/user/initsh.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
i
, 
r
, 
x
, 
want
;

8 
	`printf
("initsh: running sh\n");

11 
	`close
(0);

12 if ((
r
 = 
	`opencons
()) < 0)

13 
	`panic
("opencons: %e", 
r
);

14 if (
r
 != 0)

15 
	`panic
("first opencons used fd %d", 
r
);

16 if ((
r
 = 
	`dup
(0, 1)) < 0)

17 
	`panic
("dup: %e", 
r
);

19 
	`printf
("init: starting sh\n");

20 
r
 = 
	`spawnl
("/sh", "sh", (char*)0);

21 if (
r
 < 0) {

22 
	`printf
("init: spawn sh: %e\n", 
r
);

25 
	`wait
(
r
);

27 
	}
}

	@/root/Robux/user/josinit.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
fd
, 
n
, 
r
;

7 char 
buf
[512+1];

9 
binaryname
 = "icode";

11 
	`printf
("icode startup\n");

13 
	`printf
("icode: open /motd\n");

14 if ((
fd
 = 
	`open
("/motd", 
O_RDONLY
)) < 0)

15 
	`panic
("icode: open /motd: %e", 
fd
);

17 
	`printf
("icode: read /motd\n");

18 while ((
n
 = 
	`read
(
fd
, 
buf
, sizeof buf-1)) > 0)

19 
	`sys_cputs
(
buf
, 
n
);

21 
	`printf
("icode: close /motd\n");

22 
	`close
(
fd
);

24 
	`printf
("icode: spawn /init\n");

25 if ((
r
 = 
	`spawnl
("/init", "init", "initarg1", "initarg2", (char*)0)) < 0)

26 
	`panic
("icode: spawn /init: %e", 
r
);

28 
	`printf
("icode: exiting\n");

29 
	}
}

	@/root/Robux/user/login.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<inc/stdio.h
>

3 #include 
	~<inc/string.h
>

4 #include 
	~<inc/error.h
>

5 #include 
	~<inc/env.h
>

6 #include 
	~<inc/security.h
>

8 void 
login
(int);

9 void 
login_init
(void);

11 char *
	gusername
;

12 char *
	gpassword
;

16 
	$login_init
(void)

18 
username
 = (char*)
	`malloc
(
NAME_LEN
);

19 
password
 = (char*)
	`malloc
(
PASS_LEN
);

20 if ((!
username
) || (!
password
))

21 
	`panic
("login initialization failed");

22 
	}
}

25 
	$login
(int 
forever
)

27 int 
r
,
uid
;

28 struct 
user_info
 
info
;

29 char * 
buf
;

31 
	`printf
("initializing login environment\n");

32 
	`login_init
();

34 if(
	`getuid
() != 0)

36 
	`printf
("Error: You must run login as root\n");

37 
	`exit
();

41 int 
i
;

42 for (
i
 = 0; i < 100; i++)

43 
	`sys_yield
();

48 
buf
 = 
	`readline
("\nusername: ");

49 if(
buf
 == 
NULL
)

51 
	`printf
("Terminating login\n");

52 
	`exit
();

54 
	`strncpy
(
username
,
buf
,
NAME_LEN
);

55 
username
[
NAME_LEN
-1] = '\0';

58 if(!
	`iscons
(1) && 0)

60 char 
d1
 = 0xFF;

61 char 
d2
 = 0xFD;

62 char 
d3
 = 0x2D;

63 
	`write
(1, &
d1
, 1);

64 
	`write
(1, &
d2
, 1);

65 
	`write
(1, &
d3
, 1);

68 
buf
 = 
	`readline_full
("password: ", 1);

69 if(
buf
 == 
NULL
)

71 
	`printf
("Terminating login\n");

72 
	`exit
();

76 if(!
	`iscons
(1) && 0)

78 char 
d1
 = 0xFF;

79 char 
d2
 = 0xFE;

80 char 
d3
 = 0x2D;

81 
	`write
(1, &
d1
, 1);

82 
	`write
(1, &
d2
, 1);

83 
	`write
(1, &
d3
, 1);

86 
	`strncpy
(
password
,
buf
,
PASS_LEN
);

87 
password
[
PASS_LEN
-1] = '\0';

88 
	`printf
("\n");

90 
r
 = 
	`get_user_by_name
(
username
, &
info
);

92 if(
r
 != 0) {

93 
	`printf
("No user exists: %s\n", 
username
);

97 
r
 = 
	`verify_password
(
info
.
ui_uid
, 
password
);

99 if(
r
 == 0)

101 const char *
newarg
[3];

102 
newarg
[0] = 
info
.
ui_shell
;

103 
newarg
[1] = "-i";

104 
newarg
[2] = 
NULL
;

105 int 
pid
 = 
	`spawn_full
(
info
.
ui_shell
, 
newarg
, info.
ui_uid
, info.
ui_gid
);

106 if(
pid
 != 0)

108 
	`wait
(
pid
);

109 if(!
forever
)

110 
	`exit
();

115 
	`printf
("Bad password\n");

119 
	}
}

122 
	$umain
(int 
argc
, char *
argv
[])

125 
binaryname
="login";

128 if(!
	`isopen
(0) && !isopen(1))

130 
	`close
(0);

131 
	`close
(1);

132 
	`opencons
();

133 
	`opencons
();

136 if(
argc
 == 2 && 
	`strcmp
(
argv
[1], "-t") == 0)

137 
	`login
(0);

139 
	`login
(1);

140 
	`exit
();

141 
	}
}

	@/root/Robux/user/logname.c

1 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char *
argv
[])

8 
binaryname
 = "logname";

10 
uid_t
 
uid
 = 
	`getuid
();

11 struct 
user_info
 
info
;

13 int 
r
 = 
	`get_user_by_id
(
uid
, &
info
);

14 if(
r
 < 0)

15 
	`printf
("Failed to get user for id %d: %e\n", 
uid
, 
r
);

18 
	`printf
("%s\n", 
info
.
ui_name
);

21 
	`exit
();

22 
	}
}

	@/root/Robux/user/ls.c

1 #include 
	~<inc/lib.h
>

3 int 
	gflag
[256];

5 void 
lsdir
(const char*, const char*);

6 void 
ls1
(const char*, 
bool
, 
off_t
, const char*);

7 void 
ls2
(const char *
prefix
, struct 
Stat
 *
f
);

10 
	$ls
(const char *
path
, const char *
prefix
)

12 int 
r
;

13 struct 
Stat
 
st
;

15 if ((
r
 = 
	`stat
(
path
, &
st
)) < 0)

17 
	`printf
("stat %s: %e\n", 
path
, 
r
);

20 if (
st
.
st_isdir
 && !
flag
['d'])

21 
	`lsdir
(
path
, 
prefix
);

23 
	`ls2
(0, &
st
);

24 
	}
}

27 
	$lsdir
(const char *
path
, const char *
prefix
)

29 int 
fd
, 
n
;

30 struct 
File
 
f
;

32 if ((
fd
 = 
	`open
(
path
, 
O_RDONLY
)) < 0)

33 
	`panic
("open %s: %e", 
path
, 
fd
);

34 while ((
n
 = 
	`readn
(
fd
, &
f
, sizeof f)) == sizeof f)

35 if (
f
.
f_name
[0])

37 struct 
Stat
 
st
;

38 int 
r
;

39 if((
r
 = 
	`stat
(
f
.
f_name
, &
st
)) < 0)

41 
	`memset
(&
st
, 0, sizeof(st));

42 
	`strncpy
(
st
.
st_name
, 
f
.
f_name
, 
MAXNAMELEN
);

43 
st
.
st_uid
 = 0xFFFF;

44 
st
.
st_gid
 = 
r
;

45 
st
.
st_size
 = 
r
;

47 
	`ls2
(
prefix
, &
st
);

49 if (
n
 > 0)

50 
	`panic
("short read in directory %s", 
path
);

51 if (
n
 < 0)

52 
	`panic
("error reading directory %s: %e", 
path
, 
n
);

53 
	}
}

57 
	$ls2
(const char *
prefix
, struct 
Stat
 *
f
)

59 if(
flag
['l'])

61 
	`printf
("-%c%c%c%c%c%c%c%c%c ",

62 (
f
->
st_perm
 & 
FSP_O_R
) ? 'r':'-',

63 (
f
->
st_perm
 & 
FSP_O_W
) ? 'w':'-',

64 (
f
->
st_perm
 & 
FSP_O_X
) ? 'x':'-',

65 (
f
->
st_perm
 & 
FSP_G_R
) ? 'r':'-',

66 (
f
->
st_perm
 & 
FSP_G_W
) ? 'w':'-',

67 (
f
->
st_perm
 & 
FSP_G_X
) ? 'x':'-',

68 (
f
->
st_perm
 & 
FSP_A_R
) ? 'r':'-',

69 (
f
->
st_perm
 & 
FSP_A_W
) ? 'w':'-',

70 (
f
->
st_perm
 & 
FSP_A_X
) ? 'x':'-');

72 struct 
user_info
 
info
;

73 int 
r
;

74 if(
f
->
st_uid
 != 0xFFFF)

75 
r
 = 
	`get_user_by_id
(
f
->
st_uid
, &
info
);

78 
r
 = 0;

79 
	`strcpy
(
info
.
ui_name
, "?unknown?");

81 if(
r
 < 0)

82 
	`printf
("%15d ", 
f
->
st_uid
);

84 
	`printf
("%15s ", 
info
.
ui_name
);

86 
	`printf
("%5d %11d %s\n", 
f
->
st_gid
, f->
st_size
, f->
st_name
);

90 char *
sep
;

91 if(
prefix
[0] && prefix[
	`strlen
(prefix)-1] != '/')

92 
sep
 = "/";

94 
sep
 = "";

96 
	`printf
("%s%s%s\n", 
prefix
, 
sep
, 
f
->
st_name
);

98 
	}
}

101 
	$ls1
(const char *
prefix
, 
bool
 
isdir
, 
off_t
 
size
, const char *
name
)

103 const char *
sep
;

105 if(
flag
['l'])

106 
	`printf
("%11d %c ", 
size
, 
isdir
 ? 'd' : '-');

107 if(
prefix
) {

108 if (
prefix
[0] && prefix[
	`strlen
(prefix)-1] != '/')

109 
sep
 = "/";

111 
sep
 = "";

112 
	`printf
("%s%s", 
prefix
, 
sep
);

114 
	`printf
("%s", 
name
);

115 if(
flag
['F'] && 
isdir
)

116 
	`printf
("/");

117 
	`printf
("\n");

118 
	}
}

121 
	$usage
(void)

123 
	`printf
("usage: ls [-dFl] [file...]\n");

124 
	`exit
();

125 
	}
}

128 
	$umain
(int 
argc
, char **
argv
)

130 int 
i
;

131 struct 
Argstate
 
args
;

133 
	`argstart
(&
argc
, 
argv
, &
args
);

134 while ((
i
 = 
	`argnext
(&
args
)) >= 0)

135 switch (
i
) {

139 
flag
[
i
]++;

142 
	`usage
();

145 if (
argc
 == 1)

146 
	`ls
("/", "");

148 for (
i
 = 1; i < 
argc
; i++)

149 
	`ls
(
argv
[
i
], argv[i]);

151 
	}
}

	@/root/Robux/user/lsfd.c

1 #include 
	~<inc/lib.h
>

4 
	$usage
(void)

6 
	`printf
("usage: lsfd [-1]\n");

7 
	`exit
();

8 
	}
}

11 
	$umain
(int 
argc
, char **
argv
)

13 int 
i
, 
usefprint
 = 0;

14 struct 
Stat
 
st
;

15 struct 
Argstate
 
args
;

17 
	`argstart
(&
argc
, 
argv
, &
args
);

18 while ((
i
 = 
	`argnext
(&
args
)) >= 0)

19 if (
i
 == '1')

20 
usefprint
 = 1;

22 
	`usage
();

24 for (
i
 = 0; i < 32; i++)

25 if (
	`fstat
(
i
, &
st
) >= 0) {

26 if (
usefprint
)

27 
	`fprintf
(1, "fd %d: name %s isdir %d size %d dev %s\n",

28 
i
, 
st
.
st_name
, st.
st_isdir
,

29 
st
.
st_size
, st.
st_dev
->
dev_name
);

31 
	`printf
("fd %d: name %s isdir %d size %d dev %s\n",

32 
i
, 
st
.
st_name
, st.
st_isdir
,

33 
st
.
st_size
, st.
st_dev
->
dev_name
);

35 
	}
}

	@/root/Robux/user/num.c

1 #include 
	~<inc/lib.h
>

3 #define 
	#BUF_SIZE
 2048

	)

5 int 
	gbol
 = 1;

6 int 
	gline
 = 0;

8 int 
	gbuf_index
 = 0;

9 char 
	gbuffer
[
BUF_SIZE
];

11 void 
	$my_flush
()

13 int 
r
 = 0;

14 while(
r
 != 
buf_index
)

15 
r
 += 
	`write
(1, 
buffer
 + r, 
buf_index
 - r);

16 
buf_index
 = 0;

17 
	}
}

20 
	$my_putch
(int 
c
, void *
empty
)

22 
buffer
[
buf_index
++] = 
c
;

24 if(
buf_index
 == 
BUF_SIZE
)

25 
	`my_flush
();

27 
	}
}

30 
	$num
(int 
f
, const char *
s
)

32 long 
n
;

33 int 
r
;

34 char 
c
;

36 while ((
n
 = 
	`read
(
f
, &
c
, 1)) > 0) {

37 if (
bol
) {

38 
	`printfmt
(
my_putch
, 
NULL
, "%5d ", ++
line
);

40 
bol
 = 0;

44 
	`my_putch
(
c
, 
NULL
);

45 if (
c
 == '\n')

46 
bol
 = 1;

48 if (
n
 < 0)

49 
	`panic
("error reading %s: %e", 
s
, 
n
);

51 
	`my_flush
();

52 
	}
}

55 
	$umain
(int 
argc
, char **
argv
)

57 int 
f
, 
i
;

59 
binaryname
 = "num";

60 if (
argc
 == 1)

61 
	`num
(0, "<stdin>");

63 for (
i
 = 1; i < 
argc
; i++) {

64 
f
 = 
	`open
(
argv
[
i
], 
O_RDONLY
);

65 if (
f
 < 0)

66 
	`panic
("can't open %s: %e", 
argv
[
i
], 
f
);

68 
	`num
(
f
, 
argv
[
i
]);

69 
	`close
(
f
);

72 
	`exit
();

73 
	}
}

	@/root/Robux/user/oldinit.c

1 #include 
	~<inc/lib.h
>

4 char 
	mmsg1
[5000];

5 char 
	mmsg2
[1000];

6 } 
	gdata
 = {

11 char 
	gbss
[6000];

14 
	$sum
(const char *
s
, int 
n
)

16 int 
i
, 
tot
 = 0;

17 for (
i
 = 0; i < 
n
; i++)

18 
tot
 ^= 
i
 * 
s
[i];

19 return 
tot
;

20 
	}
}

23 
	$umain
(int 
argc
, char **
argv
)

25 int 
i
, 
r
, 
x
, 
want
;

26 char 
args
[256];

28 if(
	`getuid
() != 0)

30 
	`printf
("Only root may run init\n");

31 
	`exit
();

34 
	`printf
("init: running\n");

36 
want
 = 0xf989e;

37 if ((
x
 = 
	`sum
((char*)&
data
, sizeof data)) != 
want
)

38 
	`printf
("init: data is not initialized: got sum %08x wanted %08x\n",

39 
x
, 
want
);

41 
	`printf
("init: data seems okay\n");

42 if ((
x
 = 
	`sum
(
bss
, sizeof bss)) != 0)

43 
	`printf
("bss is not initialized: wanted sum 0 got %08x\n", 
x
);

45 
	`printf
("init: bss seems okay\n");

48 
	`strcat
(
args
, "init: args:");

49 for (
i
 = 0; i < 
argc
; i++) {

50 
	`strcat
(
args
, " '");

51 
	`strcat
(
args
, 
argv
[
i
]);

52 
	`strcat
(
args
, "'");

54 
	`printf
("%s\n", 
args
);

56 
	`printf
("init: running sh\n");

59 
	`close
(0);

60 if ((
r
 = 
	`opencons
()) < 0)

61 
	`panic
("opencons: %e", 
r
);

62 if (
r
 != 0)

63 
	`panic
("first opencons used fd %d", 
r
);

64 if ((
r
 = 
	`dup
(0, 1)) < 0)

65 
	`panic
("dup: %e", 
r
);

67 
	`printf
("init: starting sh\n");

68 
r
 = 
	`spawnl
("/oldsh", "sh", "-i", (char*)0);

69 if (
r
 < 0) {

70 
	`printf
("init: spawn sh: %e\n", 
r
);

73 
	`wait
(
r
);

75 
	}
}

	@/root/Robux/user/oldsh.c

1 #include 
	~<inc/lib.h
>

3 #define 
	#BUFSIZ
 1024

	)

4 int 
	gdebug
 = 0;

13 int 
gettoken
(char *
s
, char **
token
);

16 #define 
	#printf
 
printf


	)

23 #define 
	#MAXARGS
 16

	)

25 
	$runcmd
(char* 
s
)

27 char *
argv
[
MAXARGS
], *
t
, 
argv0buf
[
BUFSIZ
];

28 int 
argc
, 
c
, 
i
, 
r
, 
p
[2], 
fd
, 
pipe_child
;

30 
pipe_child
 = 0;

31 
	`gettoken
(
s
, 0);

33 
again
:

34 
argc
 = 0;

36 switch ((
c
 = 
	`gettoken
(0, &
t
))) {

39 if (
argc
 == 
MAXARGS
) {

40 
	`printf
("too many arguments\n");

41 
	`exit
();

43 
argv
[
argc
++] = 
t
;

48 if (
	`gettoken
(0, &
t
) != 'w') {

49 
	`printf
("syntax error: < not followed by word\n");

50 
	`exit
();

52 if ((
fd
 = 
	`open
(
t
, 
O_RDONLY
)) < 0) {

53 
	`printf
("open %s for read: %e\n", 
t
, 
fd
);

54 
	`exit
();

56 if (
fd
 != 0) {

57 
	`dup
(
fd
, 0);

58 
	`close
(
fd
);

64 if (
	`gettoken
(0, &
t
) != 'w') {

65 
	`printf
("syntax error: > not followed by word\n");

66 
	`exit
();

68 if ((
fd
 = 
	`open
(
t
, 
O_WRONLY
|
O_CREAT
|
O_TRUNC
)) < 0) {

69 
	`printf
("open %s for write: %e\n", 
t
, 
fd
);

70 
	`exit
();

72 if (
fd
 != 1) {

73 
	`dup
(
fd
, 1);

74 
	`close
(
fd
);

79 if ((
r
 = 
	`pipe
(
p
)) < 0) {

80 
	`printf
("pipe: %e\n", 
r
);

81 
	`exit
();

83 if (
debug
)

84 
	`printf
("PIPE: %d %d\n", 
p
[0], p[1]);

85 if ((
r
 = 
	`fork
()) < 0) {

86 
	`printf
("fork: %e\n", 
r
);

87 
	`exit
();

89 if (
r
 == 0) {

90 if (
p
[0] != 0) {

91 
	`dup
(
p
[0], 0);

92 
	`close
(
p
[0]);

94 
	`close
(
p
[1]);

95 goto 
again
;

97 
pipe_child
 = 
r
;

98 if (
p
[1] != 1) {

99 
	`dup
(
p
[1], 1);

100 
	`close
(
p
[1]);

102 
	`close
(
p
[0]);

103 goto 
runit
;

105 
	`panic
("| not implemented");

110 goto 
runit
;

113 
	`panic
("bad return %d from gettoken", 
c
);

119 
runit
:

121 if(
argc
 == 0) {

122 if (
debug
)

123 
	`printf
("EMPTY COMMAND\n");

131 if (
argv
[0][0] != '/') {

132 
argv0buf
[0] = '/';

133 
	`strcpy
(
argv0buf
 + 1, 
argv
[0]);

134 
argv
[0] = 
argv0buf
;

136 
argv
[
argc
] = 0;

139 if (
debug
) {

140 
	`printf
("[%08x] SPAWN:", 
thisenv
->
env_id
);

141 for (
i
 = 0; 
argv
[i]; i++)

142 
	`printf
(" %s", 
argv
[
i
]);

143 
	`printf
("\n");

147 if ((
r
 = 
	`spawn
(
argv
[0], (const char**) argv)) < 0)

148 
	`printf
("spawn %s: %e\n", 
argv
[0], 
r
);

152 
	`close_all
();

153 if (
r
 >= 0) {

154 if (
debug
)

155 
	`printf
("[%08x] WAIT %s %08x\n", 
thisenv
->
env_id
, 
argv
[0], 
r
);

156 
	`wait
(
r
);

157 if (
debug
)

158 
	`printf
("[%08x] wait finished\n", 
thisenv
->
env_id
);

163 if (
pipe_child
) {

164 if (
debug
)

165 
	`printf
("[%08x] WAIT pipe_child %08x\n", 
thisenv
->
env_id
, 
pipe_child
);

166 
	`wait
(
pipe_child
);

167 if (
debug
)

168 
	`printf
("[%08x] wait finished\n", 
thisenv
->
env_id
);

172 
	`exit
();

173 
	}
}

187 #define 
	#WHITESPACE
 " \t\r\n"

	)

188 #define 
	#SYMBOLS
 "<|>&;()"

	)

191 
	$_gettoken
(char *
s
, char **
p1
, char **
p2
)

193 int 
t
;

195 if (
s
 == 0) {

196 if (
debug
 > 1)

197 
	`printf
("GETTOKEN NULL\n");

201 if (
debug
 > 1)

202 
	`printf
("GETTOKEN: %s\n", 
s
);

204 *
p1
 = 0;

205 *
p2
 = 0;

207 while (
	`strchr
(
WHITESPACE
, *
s
))

208 *
s
++ = 0;

209 if (*
s
 == 0) {

210 if (
debug
 > 1)

211 
	`printf
("EOL\n");

214 if (
	`strchr
(
SYMBOLS
, *
s
)) {

215 
t
 = *
s
;

216 *
p1
 = 
s
;

217 *
s
++ = 0;

218 *
p2
 = 
s
;

219 if (
debug
 > 1)

220 
	`printf
("TOK %c\n", 
t
);

221 return 
t
;

223 *
p1
 = 
s
;

224 while (*
s
 && !
	`strchr
(
WHITESPACE
 
SYMBOLS
, *s))

225 
s
++;

226 *
p2
 = 
s
;

227 if (
debug
 > 1) {

228 
t
 = **
p2
;

229 **
p2
 = 0;

230 
	`printf
("WORD: %s\n", *
p1
);

231 **
p2
 = 
t
;

234 
	}
}

237 
	$gettoken
(char *
s
, char **
p1
)

239 static int 
c
, 
nc
;

240 static char* 
np1
, *
np2
;

242 if (
s
) {

243 
nc
 = 
	`_gettoken
(
s
, &
np1
, &
np2
);

246 
c
 = 
nc
;

247 *
p1
 = 
np1
;

248 
nc
 = 
	`_gettoken
(
np2
, &
np1
, &np2);

249 return 
c
;

250 
	}
}

254 
	$usage
(void)

256 
	`printf
("usage: sh [-dix] [command-file]\n");

257 
	`exit
();

258 
	}
}

261 
	$umain
(int 
argc
, char **
argv
)

263 int 
r
, 
interactive
, 
echocmds
;

264 struct 
Argstate
 
args
;

266 
interactive
 = '?';

267 
echocmds
 = 0;

268 
	`argstart
(&
argc
, 
argv
, &
args
);

269 while ((
r
 = 
	`argnext
(&
args
)) >= 0)

270 switch (
r
) {

272 
debug
++;

275 
interactive
 = 1;

278 
echocmds
 = 1;

281 
	`usage
();

284 if (
argc
 > 2)

285 
	`usage
();

286 if (
argc
 == 2) {

287 
	`close
(0);

288 if ((
r
 = 
	`open
(
argv
[1], 
O_RDONLY
)) < 0)

289 
	`panic
("open %s: %e", 
argv
[1], 
r
);

290 
	`assert
(
r
 == 0);

292 if (
interactive
 == '?')

293 
interactive
 = 
	`iscons
(0);

295 char *
prompt
 = "$ ";

298 char *
buf
;

300 
buf
 = 
	`readline
(
interactive
 ? 
prompt
 : 
NULL
);

301 if (
buf
 == 
NULL
) {

302 if (
debug
)

303 
	`printf
("EXITING\n");

304 
	`exit
();

306 if (
debug
)

307 
	`printf
("LINE: %s\n", 
buf
);

308 if (
buf
[0] == '#')

310 if (
echocmds
)

311 
	`printf
("# %s\n", 
buf
);

312 if (
debug
)

313 
	`printf
("BEFORE FORK\n");

315 if(
	`strncmp
(
buf
, "exit", 4) == 0)

316 
	`exit
();

318 if ((
r
 = 
	`fork
()) < 0)

319 
	`panic
("fork: %e", 
r
);

320 if (
debug
)

321 
	`printf
("FORK: %d\n", 
r
);

322 if (
r
 == 0) {

323 
	`runcmd
(
buf
);

324 
	`exit
();

326 
	`wait
(
r
);

328 
	}
}

	@/root/Robux/user/pingpong.c

4 #include 
	~<inc/lib.h
>

7 
	$umain
(int 
argc
, char **
argv
)

9 
envid_t
 
who
;

11 if ((
who
 = 
	`fork
()) != 0) {

13 
	`printf
("send 0 from %x to %x\n", 
	`sys_getenvid
(), 
who
);

14 
	`ipc_send
(
who
, 0, 0, 0);

18 
uint32_t
 
i
 = 
	`ipc_recv
(&
who
, 0, 0);

19 
	`printf
("%x got %d from %x\n", 
	`sys_getenvid
(), 
i
, 
who
);

20 if (
i
 == 10)

22 
i
++;

23 
	`ipc_send
(
who
, 
i
, 0, 0);

24 if (
i
 == 10)

28 
	}
}

	@/root/Robux/user/pingpongs.c

4 #include 
	~<inc/lib.h
>

6 
uint32_t
 
	gval
;

9 
	$umain
(int 
argc
, char **
argv
)

11 
envid_t
 
who
;

12 
uint32_t
 
i
;

14 
i
 = 0;

15 if ((
who
 = 
	`sfork
()) != 0) {

16 
	`printf
("i am %08x; thisenv is %p\n", 
	`sys_getenvid
(), 
thisenv
);

18 
	`printf
("send 0 from %x to %x\n", 
	`sys_getenvid
(), 
who
);

19 
	`ipc_send
(
who
, 0, 0, 0);

23 
	`ipc_recv
(&
who
, 0, 0);

24 
	`printf
("%x got %d from %x (thisenv is %p %x)\n", 
	`sys_getenvid
(), 
val
, 
who
, 
thisenv
, thisenv->
env_id
);

25 if (
val
 == 10)

27 ++
val
;

28 
	`ipc_send
(
who
, 0, 0, 0);

29 if (
val
 == 10)

33 
	}
}

	@/root/Robux/user/primes.c

11 #include 
	~<inc/lib.h
>

14 
	$primeproc
(void)

16 int 
i
, 
id
, 
p
;

17 
envid_t
 
envid
;

20 
top
:

21 
p
 = 
	`ipc_recv
(&
envid
, 0, 0);

22 
	`printf
("CPU %d: %d\n", 
thisenv
->
env_cpunum
, 
p
);

25 if ((
id
 = 
	`fork
()) < 0)

26 
	`panic
("fork: %e", 
id
);

27 if (
id
 == 0)

28 goto 
top
;

32 
i
 = 
	`ipc_recv
(&
envid
, 0, 0);

33 if (
i
 % 
p
)

34 
	`ipc_send
(
id
, 
i
, 0, 0);

36 
	}
}

39 
	$umain
(int 
argc
, char **
argv
)

41 int 
i
, 
id
;

44 if ((
id
 = 
	`fork
()) < 0)

45 
	`panic
("fork: %e", 
id
);

46 if (
id
 == 0)

47 
	`primeproc
();

50 for (
i
 = 2; ; i++)

51 
	`ipc_send
(
id
, 
i
, 0, 0);

52 
	}
}

	@/root/Robux/user/primespipe.c

11 #include 
	~<inc/lib.h
>

14 
	$primeproc
(int 
fd
)

16 int 
i
, 
id
, 
p
, 
pfd
[2], 
wfd
, 
r
;

19 
top
:

20 if ((
r
 = 
	`readn
(
fd
, &
p
, 4)) != 4)

21 
	`panic
("primeproc could not read initial prime: %d, %e", 
r
, r >= 0 ? 0 : r);

23 
	`printf
("%d\n", 
p
);

26 if ((
i
=
	`pipe
(
pfd
)) < 0)

27 
	`panic
("pipe: %e", 
i
);

28 if ((
id
 = 
	`fork
()) < 0)

29 
	`panic
("fork: %e", 
id
);

30 if (
id
 == 0) {

31 
	`close
(
fd
);

32 
	`close
(
pfd
[1]);

33 
fd
 = 
pfd
[0];

34 goto 
top
;

37 
	`close
(
pfd
[0]);

38 
wfd
 = 
pfd
[1];

42 if ((
r
=
	`readn
(
fd
, &
i
, 4)) != 4)

43 
	`panic
("primeproc %d readn %d %d %e", 
p
, 
fd
, 
r
, r >= 0 ? 0 : r);

44 if (
i
%
p
)

45 if ((
r
=
	`write
(
wfd
, &
i
, 4)) != 4)

46 
	`panic
("primeproc %d write: %d %e", 
p
, 
r
, r >= 0 ? 0 : r);

48 
	}
}

51 
	$umain
(int 
argc
, char **
argv
)

53 int 
i
, 
id
, 
p
[2], 
r
;

55 
binaryname
 = "primespipe";

57 if ((
i
=
	`pipe
(
p
)) < 0)

58 
	`panic
("pipe: %e", 
i
);

61 if ((
id
=
	`fork
()) < 0)

62 
	`panic
("fork: %e", 
id
);

64 if (
id
 == 0) {

65 
	`close
(
p
[1]);

66 
	`primeproc
(
p
[0]);

69 
	`close
(
p
[0]);

72 for (
i
=2;; i++)

73 if ((
r
=
	`write
(
p
[1], &
i
, 4)) != 4)

74 
	`panic
("generator write: %d, %e", 
r
, r >= 0 ? 0 : r);

75 
	}
}

	@/root/Robux/user/sh.c

1 #include 
	~<inc/lib.h
>

3 #define 
	#BUFSIZ
 1024

	)

4 int 
	gdebug
 = 0;

13 int 
gettoken
(char *
s
, char **
token
);

16 #define 
	#printf
 
printf


	)

23 #define 
	#MAXARGS
 16

	)

25 
	$runcmd
(char* 
s
)

27 char *
argv
[
MAXARGS
], *
t
, 
argv0buf
[
BUFSIZ
];

28 int 
argc
, 
c
, 
i
, 
r
, 
p
[2], 
fd
, 
pipe_child
;

30 
pipe_child
 = 0;

31 
	`gettoken
(
s
, 0);

33 
again
:

34 
argc
 = 0;

36 switch ((
c
 = 
	`gettoken
(0, &
t
))) {

39 if (
argc
 == 
MAXARGS
) {

40 
	`printf
("too many arguments\n");

41 
	`exit
();

43 
argv
[
argc
++] = 
t
;

48 if (
	`gettoken
(0, &
t
) != 'w') {

49 
	`printf
("syntax error: < not followed by word\n");

50 
	`exit
();

52 if ((
fd
 = 
	`open
(
t
, 
O_RDONLY
)) < 0) {

53 
	`printf
("open %s for read: %e\n", 
t
, 
fd
);

54 
	`exit
();

56 if (
fd
 != 0) {

57 
	`dup
(
fd
, 0);

58 
	`close
(
fd
);

64 if (
	`gettoken
(0, &
t
) != 'w') {

65 
	`printf
("syntax error: > not followed by word\n");

66 
	`exit
();

68 if ((
fd
 = 
	`open
(
t
, 
O_WRONLY
|
O_CREAT
|
O_TRUNC
)) < 0) {

69 
	`printf
("open %s for write: %e\n", 
t
, 
fd
);

70 
	`exit
();

72 if (
fd
 != 1) {

73 
	`dup
(
fd
, 1);

74 
	`close
(
fd
);

79 if ((
r
 = 
	`pipe
(
p
)) < 0) {

80 
	`printf
("pipe: %e\n", 
r
);

81 
	`exit
();

83 if (
debug
)

84 
	`printf
("PIPE: %d %d\n", 
p
[0], p[1]);

85 if ((
r
 = 
	`fork
()) < 0) {

86 
	`printf
("fork: %e\n", 
r
);

87 
	`exit
();

89 if (
r
 == 0) {

90 if (
p
[0] != 0) {

91 
	`dup
(
p
[0], 0);

92 
	`close
(
p
[0]);

94 
	`close
(
p
[1]);

95 goto 
again
;

97 
pipe_child
 = 
r
;

98 if (
p
[1] != 1) {

99 
	`dup
(
p
[1], 1);

100 
	`close
(
p
[1]);

102 
	`close
(
p
[0]);

103 goto 
runit
;

105 
	`panic
("| not implemented");

110 goto 
runit
;

113 
	`panic
("bad return %d from gettoken", 
c
);

119 
runit
:

121 if(
argc
 == 0) {

122 if (
debug
)

123 
	`printf
("EMPTY COMMAND\n");

131 if (
argv
[0][0] != '/') {

132 
argv0buf
[0] = '/';

133 
	`strcpy
(
argv0buf
 + 1, 
argv
[0]);

134 
argv
[0] = 
argv0buf
;

136 
argv
[
argc
] = 0;

139 if (
debug
) {

140 
	`printf
("[%08x] SPAWN:", 
thisenv
->
env_id
);

141 for (
i
 = 0; 
argv
[i]; i++)

142 
	`printf
(" %s", 
argv
[
i
]);

143 
	`printf
("\n");

147 if ((
r
 = 
	`spawn
(
argv
[0], (const char**) argv)) < 0)

148 
	`printf
("spawn %s: %e\n", 
argv
[0], 
r
);

152 
	`close_all
();

153 if (
r
 >= 0) {

154 if (
debug
)

155 
	`printf
("[%08x] WAIT %s %08x\n", 
thisenv
->
env_id
, 
argv
[0], 
r
);

156 
	`wait
(
r
);

157 if (
debug
)

158 
	`printf
("[%08x] wait finished\n", 
thisenv
->
env_id
);

163 if (
pipe_child
) {

164 if (
debug
)

165 
	`printf
("[%08x] WAIT pipe_child %08x\n", 
thisenv
->
env_id
, 
pipe_child
);

166 
	`wait
(
pipe_child
);

167 if (
debug
)

168 
	`printf
("[%08x] wait finished\n", 
thisenv
->
env_id
);

172 
	`exit
();

173 
	}
}

187 #define 
	#WHITESPACE
 " \t\r\n"

	)

188 #define 
	#SYMBOLS
 "<|>&;()"

	)

191 
	$_gettoken
(char *
s
, char **
p1
, char **
p2
)

193 int 
t
;

195 if (
s
 == 0) {

196 if (
debug
 > 1)

197 
	`printf
("GETTOKEN NULL\n");

201 if (
debug
 > 1)

202 
	`printf
("GETTOKEN: %s\n", 
s
);

204 *
p1
 = 0;

205 *
p2
 = 0;

207 while (
	`strchr
(
WHITESPACE
, *
s
))

208 *
s
++ = 0;

209 if (*
s
 == 0) {

210 if (
debug
 > 1)

211 
	`printf
("EOL\n");

214 if (
	`strchr
(
SYMBOLS
, *
s
)) {

215 
t
 = *
s
;

216 *
p1
 = 
s
;

217 *
s
++ = 0;

218 *
p2
 = 
s
;

219 if (
debug
 > 1)

220 
	`printf
("TOK %c\n", 
t
);

221 return 
t
;

223 *
p1
 = 
s
;

224 while (*
s
 && !
	`strchr
(
WHITESPACE
 
SYMBOLS
, *s))

225 
s
++;

226 *
p2
 = 
s
;

227 if (
debug
 > 1) {

228 
t
 = **
p2
;

229 **
p2
 = 0;

230 
	`printf
("WORD: %s\n", *
p1
);

231 **
p2
 = 
t
;

234 
	}
}

237 
	$gettoken
(char *
s
, char **
p1
)

239 static int 
c
, 
nc
;

240 static char* 
np1
, *
np2
;

242 if (
s
) {

243 
nc
 = 
	`_gettoken
(
s
, &
np1
, &
np2
);

246 
c
 = 
nc
;

247 *
p1
 = 
np1
;

248 
nc
 = 
	`_gettoken
(
np2
, &
np1
, &np2);

249 return 
c
;

250 
	}
}

254 
	$usage
(void)

256 
	`printf
("usage: sh [-dix] [command-file]\n");

257 
	`exit
();

258 
	}
}

261 
	$umain
(int 
argc
, char **
argv
)

263 int 
r
, 
interactive
, 
echocmds
;

264 struct 
Argstate
 
args
;

266 
interactive
 = '?';

267 
echocmds
 = 0;

268 
	`argstart
(&
argc
, 
argv
, &
args
);

269 while ((
r
 = 
	`argnext
(&
args
)) >= 0)

270 switch (
r
) {

272 
debug
++;

275 
interactive
 = 1;

278 
echocmds
 = 1;

281 
	`usage
();

284 if (
argc
 > 2)

285 
	`usage
();

286 if (
argc
 == 2) {

287 
	`close
(0);

288 if ((
r
 = 
	`open
(
argv
[1], 
O_RDONLY
)) < 0)

289 
	`panic
("open %s: %e", 
argv
[1], 
r
);

290 
	`assert
(
r
 == 0);

292 if (
interactive
 == '?')

293 
interactive
 = 
	`iscons
(0);

295 char 
prompt
[100];

297 struct 
user_info
 
info
;

298 
r
 = 
	`get_user_by_id
(
	`getuid
(), &
info
);

299 if(
r
 < 0)

300 
	`strncpy
(
prompt
, "unknown", 90);

302 
	`strncpy
(
prompt
, 
info
.
ui_name
, 90);

304 
	`strcat
(
prompt
, "@jos");

306 if(
	`getuid
() == 0)

307 
	`strcat
(
prompt
, "# ");

309 
	`strcat
(
prompt
, "$ ");

312 char *
buf
;

314 
buf
 = 
	`readline
(
interactive
 ? 
prompt
 : 
NULL
);

315 if (
buf
 == 
NULL
) {

316 if (
debug
)

317 
	`printf
("EXITING\n");

318 
	`exit
();

320 if (
debug
)

321 
	`printf
("LINE: %s\n", 
buf
);

322 if (
buf
[0] == '#')

324 if (
echocmds
)

325 
	`printf
("# %s\n", 
buf
);

326 if (
debug
)

327 
	`printf
("BEFORE FORK\n");

329 if(
	`strncmp
(
buf
, "exit", 4) == 0)

330 
	`exit
();

332 if ((
r
 = 
	`fork
()) < 0)

333 
	`panic
("fork: %e", 
r
);

334 if (
debug
)

335 
	`printf
("FORK: %d\n", 
r
);

336 if (
r
 == 0) {

337 
	`runcmd
(
buf
);

338 
	`exit
();

340 
	`wait
(
r
);

342 
	}
}

	@/root/Robux/user/sha2speed.c

35 #include 
	~<inc/lib.h
>

36 #include 
	~<inc/string.h
>

38 #include 
	~<contrib/sha2/sha2.h
>

40 #define 
	#stdin
 0

	)

41 #define 
	#stdout
 1

	)

42 #define 
	#stderr
 1

	)

44 #define 
	#BUFSIZE
 1024

	)

46 void 
	$usage
(char *
prog
) {

47 
	`fprintf
(
stderr
, "Usage:\t%s [<num-of-bytes>] [<num-of-loops>] [<fill-byte>]\n", 
prog
);

48 
	`exit
();

49 
	}
}

51 void 
	$printspeed
(char *
caption
, unsigned long 
bytes
, unsigned int 
time
) {

52 if (
bytes
 / 1073741824UL > 0) {

53 
	`printf
("%s %d sec \n", 
caption
, 
time
);

55 else if (
bytes
 / 1024 > 0) {

56 
	`printf
("%s %d \n", 
caption
, 
time
);

58 
	`printf
("%s %d \n", 
caption
, 
time
);

60 
	}
}

64 
	$umain
(int 
argc
, char **
argv
) {

65 
SHA256_CTX
 
c256
;

66 
SHA384_CTX
 
c384
;

67 
SHA512_CTX
 
c512
;

68 char *
buf
 = (char*)
	`malloc
(
BUFSIZE
);

69 char 
md
[
SHA512_DIGEST_STRING_LENGTH
];

70 int 
bytes
, 
blocks
, 
rep
, 
i
, 
j
;

71 unsigned int 
start
, 
end
;

72 unsigned int 
t
, 
ave256
, 
ave384
, 
ave512
;

73 unsigned int 
best256
, 
best384
, 
best512
;

75 if (
argc
 > 4) {

76 
	`usage
(
argv
[0]);

80 
bytes
 = 1024 * 1024 * 4;

81 if (
argc
 > 1) {

82 
blocks
 = 
	`atoi
(
argv
[1]);

84 
blocks
 = 
bytes
 / 
BUFSIZE
;

87 
rep
 = 2;

88 if (
argc
 > 2) {

89 
rep
 = 
	`atoi
(
argv
[2]);

93 if (
argc
 > 3) {

94 
	`memset
(
buf
, 
	`atoi
(
argv
[2]), 
BUFSIZE
);

96 
	`memset
(
buf
, 0xb7, 
BUFSIZE
);

99 
ave256
 = 
ave384
 = 
ave512
 = 0;

100 
best256
 = 
best384
 = 
best512
 = 100000;

101 for (
i
 = 0; i < 
rep
; i++) {

102 
	`SHA256_Init
(&
c256
);

103 
	`SHA384_Init
(&
c384
);

104 
	`SHA512_Init
(&
c512
);

106 
start
 = 
	`sys_time_msec
();

107 for (
j
 = 0; j < 
blocks
; j++) {

108 
	`SHA256_Update
(&
c256
, (unsigned char*)
buf
, 
BUFSIZE
);

110 if (
bytes
 % 
BUFSIZE
) {

111 
	`SHA256_Update
(&
c256
, (unsigned char*)
buf
, 
bytes
 % 
BUFSIZE
);

113 
	`SHA256_End
(&
c256
, 
md
);

114 
end
 = 
	`sys_time_msec
();

115 
t
 = ((
end
 - 
start
));

116 
ave256
 += 
t
;

117 if (
t
 < 
best256
) {

118 
best256
 = 
t
;

120 
	`printf
("SHA-256[%d] (%d/%d/%d ms) = 0x%s\n", 
i
+1, 
t
, 
ave256
/(i+1), 
best256
, 
md
);

122 
start
 = 
	`sys_time_msec
();

123 for (
j
 = 0; j < 
blocks
; j++) {

124 
	`SHA384_Update
(&
c384
, (unsigned char*)
buf
, 
BUFSIZE
);

126 if (
bytes
 % 
BUFSIZE
) {

127 
	`SHA384_Update
(&
c384
, (unsigned char*)
buf
, 
bytes
 % 
BUFSIZE
);

129 
	`SHA384_End
(&
c384
, 
md
);

130 
end
 = 
	`sys_time_msec
();

131 
t
 = 
end
 - 
start
;

132 
ave384
 += 
t
;

133 if (
t
 < 
best384
) {

134 
best384
 = 
t
;

136 
	`printf
("SHA-384[%d] (%d/%d/%d ms) = 0x%s\n", 
i
+1, 
t
, 
ave384
/(i+1), 
best384
, 
md
);

138 
start
 = 
	`sys_time_msec
();

139 for (
j
 = 0; j < 
blocks
; j++) {

140 
	`SHA512_Update
(&
c512
, (unsigned char*)
buf
, 
BUFSIZE
);

142 if (
bytes
 % 
BUFSIZE
) {

143 
	`SHA512_Update
(&
c512
, (unsigned char*)
buf
, 
bytes
 % 
BUFSIZE
);

145 
	`SHA512_End
(&
c512
, 
md
);

146 
end
 = 
	`sys_time_msec
();

147 
t
 = 
end
-
start
;

148 
ave512
 += 
t
;

149 if (
t
 < 
best512
) {

150 
best512
 = 
t
;

152 
	`printf
("SHA-512[%d] (%d/%d/%d ms) = 0x%s\n", 
i
+1, 
t
, 
ave512
/(i+1), 
best512
, 
md
);

154 
ave256
 /= 
rep
;

155 
ave384
 /= 
rep
;

156 
ave512
 /= 
rep
;

157 
	`printf
("\nTEST RESULTS SUMMARY:\nTEST REPETITIONS: %d\n", 
rep
);

158 if (
bytes
 / 1073741824UL > 0) {

159 
	`printf
("TEST SET SIZE: %d GB\n", 
bytes
/1073741824UL);

160 } else if (
bytes
 / 1048576 > 0) {

161 
	`printf
("TEST SET SIZE: %d MB\n", 
bytes
/1048576);

162 } else if (
bytes
 /1024 > 0) {

163 
	`printf
("TEST SET SIZE: %d KB\n", 
bytes
/1024);

165 
	`printf
("TEST SET SIZE: %d B\n", 
bytes
);

167 
	`printspeed
("SHA-256 average:", 
bytes
, 
ave256
);

168 
	`printspeed
("SHA-256 best: ", 
bytes
, 
best256
);

169 
	`printspeed
("SHA-384 average:", 
bytes
, 
ave384
);

170 
	`printspeed
("SHA-384 best: ", 
bytes
, 
best384
);

171 
	`printspeed
("SHA-512 average:", 
bytes
, 
ave512
);

172 
	`printspeed
("SHA-512 best: ", 
bytes
, 
best512
);

174 
	}
}

	@/root/Robux/user/softint.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

8 
asm
 volatile("int $14");

9 
	}
}

	@/root/Robux/user/spawnhello.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
r
;

7 
	`printf
("i am parent environment %08x\n", 
thisenv
->
env_id
);

8 if ((
r
 = 
	`spawnl
("hello", "hello", 0)) < 0)

9 
	`panic
("spawn(hello) failed: %e", 
r
);

10 
	}
}

	@/root/Robux/user/spawninit.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
r
;

7 
	`printf
("i am parent environment %08x\n", 
thisenv
->
env_id
);

8 if ((
r
 = 
	`spawnl
("init", "init", "one", "two", 0)) < 0)

9 
	`panic
("spawnl(init) failed: %e", 
r
);

10 
	}
}

	@/root/Robux/user/spin.c

4 #include 
	~<inc/lib.h
>

7 
	$umain
(int 
argc
, char **
argv
)

9 
envid_t
 
env
;

11 
	`printf
("I am the parent. Forking the child...\n");

12 if ((
env
 = 
	`fork
()) == 0) {

13 
	`printf
("I am the child. Spinning...\n");

18 
	`printf
("I am the parent. Running the child...\n");

19 
	`sys_yield
();

20 
	`sys_yield
();

21 
	`sys_yield
();

22 
	`sys_yield
();

23 
	`sys_yield
();

24 
	`sys_yield
();

25 
	`sys_yield
();

26 
	`sys_yield
();

28 
	`printf
("I am the parent. Killing the child...\n");

29 
	`sys_env_destroy
(
env
);

30 
	}
}

	@/root/Robux/user/stresssched.c

1 #include 
	~<inc/lib.h
>

3 volatile int 
	gcounter
;

6 
	$umain
(int 
argc
, char **
argv
)

8 int 
i
, 
j
;

9 int 
seen
;

10 
envid_t
 
parent
 = 
	`sys_getenvid
();

13 for (
i
 = 0; i < 20; i++)

14 if (
	`fork
() == 0)

16 if (
i
 == 20) {

17 
	`sys_yield
();

22 while (
envs
[
	`ENVX
(
parent
)].
env_status
 != 
ENV_FREE
)

23 
asm
 volatile("pause");

26 for (
i
 = 0; i < 10; i++) {

27 
	`sys_yield
();

28 for (
j
 = 0; j < 10000; j++)

29 
counter
++;

32 if (
counter
 != 10*10000)

33 
	`panic
("ran on two CPUs at once (counter is %d)", 
counter
);

36 
	`printf
("[%08x] stresssched on CPU %d\n", 
thisenv
->
env_id
, thisenv->
env_cpunum
);

38 
	}
}

	@/root/Robux/user/telnetd.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<lwip/sockets.h
>

3 #include 
	~<lwip/inet.h
>

6 #define 
	#MAXPENDING
 10

	)

8 void 
	$die
(const char *
msg
, int 
error_code
)

10 
	`printf
(
msg
, 
error_code
);

11 
	`exit
();

12 
	}
}

16 
	$handle_client
(int 
clientsock
)

21 int 
r
 = 
	`fork
();

22 if(
r
 == 0)

24 
	`dup
(
clientsock
, 0);

25 
	`dup
(
clientsock
, 1);

26 
r
 = 
	`spawnl
("login", "login", "-t", 
NULL
);

27 
	`wait
(
r
);

28 
	`close
(0);

29 
	`close
(1);

30 
	`exit
();

33 
	`close
(
clientsock
);

34 
	}
}

37 
	$do_listen
(short 
port
)

39 int 
serversock
, 
clientsock
;

40 struct 
sockaddr_in
 
serveraddr
, 
clientaddr
;

41 unsigned int 
clientlen
;

43 
serversock
 = 
	`socket
(
PF_INET
, 
SOCK_STREAM
, 
IPPROTO_TCP
);

44 if(
serversock
 < 0)

45 
	`die
("Failed to create socket: %e\n", 
serversock
);

47 
	`memset
(&
serveraddr
, 0, sizeof(serveraddr));

48 
serveraddr
.
sin_family
 = 
AF_INET
;

49 
serveraddr
.
sin_addr
.
s_addr
 = 
	`htonl
(
INADDR_ANY
);

50 
serveraddr
.
sin_port
 = 
	`htons
(
port
);

52 int 
r
 = 
	`bind
(
serversock
, (struct 
sockaddr
*) &
serveraddr
, sizeof(serveraddr));

53 if(
r
 < 0)

54 
	`die
("Failed to bind: %e\n", 
r
);

56 
r
 = 
	`listen
(
serversock
, 
MAXPENDING
);

57 if(
r
 < 0)

58 
	`die
("Failed to listen: %e\n", 
r
);

60 
	`printf
("Telnet server running on port %d\n", 
port
);

63 
clientsock
 = 
	`accept
(
serversock
, (struct 
sockaddr
 *) &
clientaddr
, &
clientlen
);

64 if(
clientsock
 < 0)

65 
	`die
("Failed to accept client connection: %e\n", 
clientsock
);

67 
	`printf
("Telnet: Client connected from %s\n", 
	`inet_ntoa
(
clientaddr
.
sin_addr
));

68 
	`handle_client
(
clientsock
);

72 
	`close
(
serversock
);

74 
	}
}

78 
	$umain
(int 
argc
, char *
argv
[])

80 short 
port
 = 23;

81 if(
argc
 == 2)

82 
port
 = 
	`atoi
(
argv
[1]);

83 else if(
argc
 > 2)

85 
	`printf
("Usage: telnet [port]\n");

93 
	`do_listen
(
port
);

95 
	}
}

	@/root/Robux/user/testbss.c

3 #include 
	~<inc/lib.h
>

5 #define 
	#ARRAYSIZE
 (1024*1024)

	)

7 
uint32_t
 
	gbigarray
[
ARRAYSIZE
];

10 
	$umain
(int 
argc
, char **
argv
)

12 int 
i
;

14 
	`printf
("Making sure bss works right...\n");

15 for (
i
 = 0; i < 
ARRAYSIZE
; i++)

16 if (
bigarray
[
i
] != 0)

17 
	`panic
("bigarray[%d] isn't cleared!\n", 
i
);

18 for (
i
 = 0; i < 
ARRAYSIZE
; i++)

19 
bigarray
[
i
] = i;

20 for (
i
 = 0; i < 
ARRAYSIZE
; i++)

21 if (
bigarray
[
i
] != i)

22 
	`panic
("bigarray[%d] didn't hold its value!\n", 
i
);

24 
	`printf
("Yes, good. Now doing a wild write off the end...\n");

25 
bigarray
[
ARRAYSIZE
+1024] = 0;

26 
	`panic
("SHOULD HAVE TRAPPED!!!");

27 
	}
}

	@/root/Robux/user/testfdsharing.c

1 #include 
	~<inc/x86.h
>

2 #include 
	~<inc/lib.h
>

4 char 
	gbuf
[512], 
	gbuf2
[512];

7 
	$umain
(int 
argc
, char **
argv
)

9 int 
fd
, 
r
, 
n
, 
n2
;

11 if ((
fd
 = 
	`open
("motd", 
O_RDONLY
)) < 0)

12 
	`panic
("open motd: %e", 
fd
);

13 
	`seek
(
fd
, 0);

14 if ((
n
 = 
	`readn
(
fd
, 
buf
, sizeof buf)) <= 0)

15 
	`panic
("readn: %e", 
n
);

17 if ((
r
 = 
	`fork
()) < 0)

18 
	`panic
("fork: %e", 
r
);

19 if (
r
 == 0) {

20 
	`seek
(
fd
, 0);

21 
	`printf
("going to read in child (might page fault if your sharing is buggy)\n");

22 if ((
n2
 = 
	`readn
(
fd
, 
buf2
, sizeof buf2)) != 
n
)

23 
	`panic
("read in parent got %d, read in child got %d", 
n
, 
n2
);

24 if (
	`memcmp
(
buf
, 
buf2
, 
n
) != 0)

25 
	`panic
("read in parent got different bytes from read in child");

26 
	`printf
("read in child succeeded\n");

27 
	`seek
(
fd
, 0);

28 
	`close
(
fd
);

29 
	`exit
();

31 
	`wait
(
r
);

32 if ((
n2
 = 
	`readn
(
fd
, 
buf2
, sizeof buf2)) != 
n
)

33 
	`panic
("read in parent got %d, then got %d", 
n
, 
n2
);

34 
	`printf
("read in parent succeeded\n");

35 
	`close
(
fd
);

37 if ((
fd
 = 
	`open
("newmotd", 
O_RDWR
)) < 0)

38 
	`panic
("open newmotd: %e", 
fd
);

39 
	`seek
(
fd
, 0);

40 if ((
n
 = 
	`write
(
fd
, "hello", 5)) != 5)

41 
	`panic
("write: %e", 
n
);

43 if ((
r
 = 
	`fork
()) < 0)

44 
	`panic
("fork: %e", 
r
);

45 if (
r
 == 0) {

46 
	`seek
(
fd
, 0);

47 
	`printf
("going to write in child\n");

48 if ((
n
 = 
	`write
(
fd
, "world", 5)) != 5)

49 
	`panic
("write in child: %e", 
n
);

50 
	`printf
("write in child finished\n");

51 
	`close
(
fd
);

52 
	`exit
();

54 
	`wait
(
r
);

55 
	`seek
(
fd
, 0);

56 if ((
n
 = 
	`readn
(
fd
, 
buf
, 5)) != 5)

57 
	`panic
("readn: %e", 
n
);

58 
buf
[5] = 0;

59 if (
	`strcmp
(
buf
, "hello") == 0)

60 
	`printf
("write to file failed; got old data\n");

61 else if (
	`strcmp
(
buf
, "world") == 0)

62 
	`printf
("write to file succeeded\n");

64 
	`printf
("write to file failed; got %s\n", 
buf
);

66 
	`breakpoint
();

67 
	}
}

	@/root/Robux/user/testfile.c

1 #include 
	~<inc/lib.h
>

3 const char *
	gmsg
 = "This is the NEW message of the day!\n\n";

5 #define 
	#FVA
 ((struct 
Fd
*)0xCCCCC000)

	)

8 
	$xopen
(const char *
path
, int 
mode
)

10 extern union 
Fsipc
 
fsipcbuf
;

11 
envid_t
 
fsenv
;

13 
	`strcpy
(
fsipcbuf
.
open
.
req_path
, 
path
);

14 
fsipcbuf
.
open
.
req_omode
 = 
mode
;

16 
fsenv
 = 
	`ipc_find_env
(
ENV_TYPE_FS
);

17 
	`ipc_send
(
fsenv
, 
FSREQ_OPEN
, &
fsipcbuf
, 
PTE_P
 | 
PTE_W
 | 
PTE_U
);

18 return 
	`ipc_recv
(
NULL
, 
FVA
, NULL);

19 
	}
}

22 
	$umain
(int 
argc
, char **
argv
)

24 int 
r
, 
f
, 
i
;

25 struct 
Fd
 *
fd
;

26 struct 
Fd
 
fdcopy
;

27 struct 
Stat
 
st
;

28 char 
buf
[512];

31 if ((
r
 = 
	`xopen
("/not-found", 
O_RDONLY
)) < 0 && r != -
E_NOT_FOUND
)

32 
	`panic
("serve_open /not-found: %e", 
r
);

33 else if (
r
 >= 0)

34 
	`panic
("serve_open /not-found succeeded!");

36 if ((
r
 = 
	`xopen
("/newmotd", 
O_RDONLY
)) < 0)

37 
	`panic
("serve_open /newmotd: %e", 
r
);

38 if (
FVA
->
fd_dev_id
 != 'f' || FVA->
fd_offset
 != 0 || FVA->
fd_omode
 != 
O_RDONLY
)

39 
	`panic
("serve_open did not fill struct Fd correctly\n");

40 
	`printf
("serve_open is good\n");

42 if ((
r
 = 
devfile
.
	`dev_stat
(
FVA
, &
st
)) < 0)

43 
	`panic
("file_stat: %e", 
r
);

44 if (
	`strlen
(
msg
) != 
st
.
st_size
)

45 
	`panic
("file_stat returned size %d wanted %d\n", 
st
.
st_size
, 
	`strlen
(
msg
));

46 
	`printf
("file_stat is good\n");

48 
	`memset
(
buf
, 0, sizeof buf);

49 if ((
r
 = 
devfile
.
	`dev_read
(
FVA
, 
buf
, sizeof buf)) < 0)

50 
	`panic
("file_read: %e", 
r
);

51 if (
	`strcmp
(
buf
, 
msg
) != 0)

52 
	`panic
("file_read returned wrong data");

53 
	`printf
("file_read is good\n");

55 if ((
r
 = 
devfile
.
	`dev_close
(
FVA
)) < 0)

56 
	`panic
("file_close: %e", 
r
);

57 
	`printf
("file_close is good\n");

63 
fdcopy
 = *
FVA
;

64 
	`sys_page_unmap
(0, 
FVA
);

66 if ((
r
 = 
devfile
.
	`dev_read
(&
fdcopy
, 
buf
, sizeof buf)) != -
E_INVAL
)

67 
	`panic
("serve_read does not handle stale fileids correctly: %e", 
r
);

68 
	`printf
("stale fileid is good\n");

71 if ((
r
 = 
	`xopen
("/new-file", 
O_RDWR
|
O_CREAT
)) < 0)

72 
	`panic
("serve_open /new-file: %e", 
r
);

74 if ((
r
 = 
devfile
.
	`dev_write
(
FVA
, 
msg
, 
	`strlen
(msg))) != strlen(msg))

75 
	`panic
("file_write: %e", 
r
);

76 
	`printf
("file_write is good\n");

78 
FVA
->
fd_offset
 = 0;

79 
	`memset
(
buf
, 0, sizeof buf);

80 if ((
r
 = 
devfile
.
	`dev_read
(
FVA
, 
buf
, sizeof buf)) < 0)

81 
	`panic
("file_read after file_write: %e", 
r
);

82 if (
r
 != 
	`strlen
(
msg
))

83 
	`panic
("file_read after file_write returned wrong length: %d", 
r
);

84 if (
	`strcmp
(
buf
, 
msg
) != 0)

85 
	`panic
("file_read after file_write returned wrong data");

86 
	`printf
("file_read after file_write is good\n");

89 if ((
r
 = 
	`open
("/not-found", 
O_RDONLY
)) < 0 && r != -
E_NOT_FOUND
)

90 
	`panic
("open /not-found: %e", 
r
);

91 else if (
r
 >= 0)

92 
	`panic
("open /not-found succeeded!");

94 if ((
r
 = 
	`open
("/newmotd", 
O_RDONLY
)) < 0)

95 
	`panic
("open /newmotd: %e", 
r
);

96 
fd
 = (struct 
Fd
*) (0xD0000000 + 
r
*
PGSIZE
);

97 if (
fd
->
fd_dev_id
 != 'f' || fd->
fd_offset
 != 0 || fd->
fd_omode
 != 
O_RDONLY
)

98 
	`panic
("open did not fill struct Fd correctly\n");

99 
	`printf
("open is good\n");

102 if ((
f
 = 
	`open
("/big", 
O_WRONLY
|
O_CREAT
)) < 0)

103 
	`panic
("creat /big: %e", 
f
);

104 
	`memset
(
buf
, 0, sizeof(buf));

105 for (
i
 = 0; i < (
NDIRECT
*3)*
BLKSIZE
; i += sizeof(
buf
)) {

106 *(int*)
buf
 = 
i
;

107 
	`printf
("Writing %d\n", 
i
);

108 if ((
r
 = 
	`write
(
f
, 
buf
, sizeof(buf))) < 0)

109 
	`panic
("write /big@%d: %e", 
i
, 
r
);

111 
	`close
(
f
);

113 if ((
f
 = 
	`open
("/big", 
O_RDONLY
)) < 0)

114 
	`panic
("open /big: %e", 
f
);

115 for (
i
 = 0; i < (
NDIRECT
*3)*
BLKSIZE
; i += sizeof(
buf
)) {

116 *(int*)
buf
 = 
i
;

117 if ((
r
 = 
	`readn
(
f
, 
buf
, sizeof(buf))) < 0)

118 
	`panic
("read /big@%d: %e", 
i
, 
r
);

119 if (
r
 != sizeof(
buf
))

120 
	`panic
("read /big from %d returned %d < %d bytes",

121 
i
, 
r
, sizeof(
buf
));

122 if (*(int*)
buf
 != 
i
)

123 
	`panic
("read /big from %d returned bad data %d",

124 
i
, *(int*)
buf
);

126 
	`close
(
f
);

127 
	`printf
("large file is good\n");

128 
	}
}

	@/root/Robux/user/testkbd.c

2 #include 
	~<inc/lib.h
>

5 
	$umain
(int 
argc
, char **
argv
)

7 int 
i
, 
r
;

10 for (
i
 = 0; i < 10; ++i)

11 
	`sys_yield
();

13 
	`close
(0);

14 if ((
r
 = 
	`opencons
()) < 0)

15 
	`panic
("opencons: %e", 
r
);

16 if (
r
 != 0)

17 
	`panic
("first opencons used fd %d", 
r
);

18 if ((
r
 = 
	`dup
(0, 1)) < 0)

19 
	`panic
("dup: %e", 
r
);

22 char *
buf
;

24 
buf
 = 
	`readline
("Type a line: ");

25 if (
buf
 != 
NULL
)

26 
	`fprintf
(1, "%s\n", 
buf
);

28 
	`fprintf
(1, "(end of file received)\n");

30 
	}
}

	@/root/Robux/user/testmalloc.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 char *
buf
;

7 int 
n
;

8 void *
v
;

11 
buf
 = 
	`readline
("> ");

12 if (
buf
 == 0)

13 
	`exit
();

14 if (
	`memcmp
(
buf
, "free ", 5) == 0) {

15 
v
 = (void*) 
	`strtol
(
buf
 + 5, 0, 0);

16 
	`free
(
v
);

17 } else if (
	`memcmp
(
buf
, "malloc ", 7) == 0) {

18 
n
 = 
	`strtol
(
buf
 + 7, 0, 0);

19 
v
 = 
	`malloc
(
n
);

20 
	`printf
("\t0x%x\n", (
uintptr_t
) 
v
);

22 
	`printf
("?unknown command\n");

24 
	}
}

	@/root/Robux/user/testpipe.c

1 #include 
	~<inc/lib.h
>

3 char *
	gmsg
 = "Now is the time for all good men to come to the aid of their party.";

6 
	$umain
(int 
argc
, char **
argv
)

8 char 
buf
[100];

9 int 
i
, 
pid
, 
p
[2];

11 
binaryname
 = "pipereadeof";

13 if ((
i
 = 
	`pipe
(
p
)) < 0)

14 
	`panic
("pipe: %e", 
i
);

16 if ((
pid
 = 
	`fork
()) < 0)

17 
	`panic
("fork: %e", 
i
);

19 if (
pid
 == 0) {

20 
	`printf
("[%08x] pipereadeof close %d\n", 
thisenv
->
env_id
, 
p
[1]);

21 
	`close
(
p
[1]);

22 
	`printf
("[%08x] pipereadeof readn %d\n", 
thisenv
->
env_id
, 
p
[0]);

23 
i
 = 
	`readn
(
p
[0], 
buf
, sizeof buf-1);

24 if (
i
 < 0)

25 
	`panic
("read: %e", 
i
);

26 
buf
[
i
] = 0;

27 if (
	`strcmp
(
buf
, 
msg
) == 0)

28 
	`printf
("\npipe read closed properly\n");

30 
	`printf
("\ngot %d bytes: %s\n", 
i
, 
buf
);

31 
	`exit
();

33 
	`printf
("[%08x] pipereadeof close %d\n", 
thisenv
->
env_id
, 
p
[0]);

34 
	`close
(
p
[0]);

35 
	`printf
("[%08x] pipereadeof write %d\n", 
thisenv
->
env_id
, 
p
[1]);

36 if ((
i
 = 
	`write
(
p
[1], 
msg
, 
	`strlen
(msg))) != strlen(msg))

37 
	`panic
("write: %e", 
i
);

38 
	`close
(
p
[1]);

40 
	`wait
(
pid
);

42 
binaryname
 = "pipewriteeof";

43 if ((
i
 = 
	`pipe
(
p
)) < 0)

44 
	`panic
("pipe: %e", 
i
);

46 if ((
pid
 = 
	`fork
()) < 0)

47 
	`panic
("fork: %e", 
i
);

49 if (
pid
 == 0) {

50 
	`close
(
p
[0]);

52 
	`printf
(".");

53 if (
	`write
(
p
[1], "x", 1) != 1)

56 
	`printf
("\npipe write closed properly\n");

57 
	`exit
();

59 
	`close
(
p
[0]);

60 
	`close
(
p
[1]);

61 
	`wait
(
pid
);

63 
	`printf
("pipe tests passed\n");

64 
	}
}

	@/root/Robux/user/testpiperace.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
p
[2], 
r
, 
pid
, 
i
, 
max
;

7 void *
va
;

8 struct 
Fd
 *
fd
;

9 const volatile struct 
Env
 *
kid
;

11 
	`printf
("testing for dup race...\n");

12 if ((
r
 = 
	`pipe
(
p
)) < 0)

13 
	`panic
("pipe: %e", 
r
);

14 
max
 = 200;

15 if ((
r
 = 
	`fork
()) < 0)

16 
	`panic
("fork: %e", 
r
);

17 if (
r
 == 0) {

18 
	`close
(
p
[1]);

37 for (
i
=0; i<
max
; i++) {

38 if(
	`pipeisclosed
(
p
[0])){

39 
	`printf
("RACE: pipe appears closed\n");

40 
	`exit
();

42 
	`sys_yield
();

45 
	`ipc_recv
(0,0,0);

47 
pid
 = 
r
;

48 
	`printf
("pid is %d\n", 
pid
);

49 
va
 = 0;

50 
kid
 = &
envs
[
	`ENVX
(
pid
)];

51 
	`printf
("kid is %d\n", 
kid
-
envs
);

52 
	`dup
(
p
[0], 10);

53 while (
kid
->
env_status
 == 
ENV_RUNNABLE
)

54 
	`dup
(
p
[0], 10);

56 
	`printf
("child done with loop\n");

57 if (
	`pipeisclosed
(
p
[0]))

58 
	`panic
("somehow the other end of p[0] got closed!");

59 if ((
r
 = 
	`fd_lookup
(
p
[0], &
fd
)) < 0)

60 
	`panic
("cannot look up p[0]: %e", 
r
);

61 
va
 = 
	`fd2data
(
fd
);

62 if (
	`pageref
(
va
) != 3+1)

63 
	`printf
("\nchild detected race\n");

65 
	`printf
("\nrace didn't happen\n", 
max
);

66 
	}
}

	@/root/Robux/user/testpiperace2.c

2 #include 
	~<inc/lib.h
>

5 
	$umain
(int 
argc
, char **
argv
)

7 int 
p
[2], 
r
, 
i
;

8 struct 
Fd
 *
fd
;

9 const volatile struct 
Env
 *
kid
;

11 
	`printf
("testing for pipeisclosed race...\n");

12 if ((
r
 = 
	`pipe
(
p
)) < 0)

13 
	`panic
("pipe: %e", 
r
);

14 if ((
r
 = 
	`fork
()) < 0)

15 
	`panic
("fork: %e", 
r
);

16 if (
r
 == 0) {

20 
	`close
(
p
[1]);

21 for (
i
 = 0; i < 200; i++) {

22 if (
i
 % 10 == 0)

23 
	`printf
("%d.", 
i
);

26 
	`dup
(
p
[0], 10);

27 
	`sys_yield
();

28 
	`close
(10);

29 
	`sys_yield
();

31 
	`exit
();

55 
kid
 = &
envs
[
	`ENVX
(
r
)];

56 while (
kid
->
env_status
 == 
ENV_RUNNABLE
)

57 if (
	`pipeisclosed
(
p
[0]) != 0) {

58 
	`printf
("\nRACE: pipe appears closed\n");

59 
	`sys_env_destroy
(
r
);

60 
	`exit
();

62 
	`printf
("child done with loop\n");

63 if (
	`pipeisclosed
(
p
[0]))

64 
	`panic
("somehow the other end of p[0] got closed!");

65 if ((
r
 = 
	`fd_lookup
(
p
[0], &
fd
)) < 0)

66 
	`panic
("cannot look up p[0]: %e", 
r
);

67 (void) 
	`fd2data
(
fd
);

68 
	`printf
("race didn't happen\n");

69 
	}
}

	@/root/Robux/user/testptelibrary.c

1 #include 
	~<inc/lib.h
>

3 #define 
	#VA
 ((char *) 0xA0000000)

	)

4 const char *
	gmsg
 = "hello, world\n";

5 const char *
	gmsg2
 = "goodbye, world\n";

7 void 
childofspawn
(void);

10 
	$umain
(int 
argc
, char **
argv
)

12 int 
r
;

14 if (
argc
 != 0)

15 
	`childofspawn
();

17 if ((
r
 = 
	`sys_page_alloc
(0, 
VA
, 
PTE_P
|
PTE_W
|
PTE_U
|
PTE_SHARE
)) < 0)

18 
	`panic
("sys_page_alloc: %e", 
r
);

21 if ((
r
 = 
	`fork
()) < 0)

22 
	`panic
("fork: %e", 
r
);

23 if (
r
 == 0) {

24 
	`strcpy
(
VA
, 
msg
);

25 
	`exit
();

27 
	`wait
(
r
);

28 
	`printf
("fork handles PTE_SHARE %s\n", 
	`strcmp
(
VA
, 
msg
) == 0 ? "right" : "wrong");

31 if ((
r
 = 
	`spawnl
("/testptelibrary", "testptelibrary", "arg", 0)) < 0)

32 
	`panic
("spawn: %e", 
r
);

33 
	`wait
(
r
);

34 
	`printf
("spawn handles PTE_SHARE %s\n", 
	`strcmp
(
VA
, 
msg2
) == 0 ? "right" : "wrong");

35 
	}
}

38 
	$childofspawn
(void)

40 
	`strcpy
(
VA
, 
msg2
);

41 
	`exit
();

42 
	}
}

	@/root/Robux/user/testpteshare.c

1 #include 
	~<inc/x86.h
>

2 #include 
	~<inc/lib.h
>

4 #define 
	#VA
 ((char *) 0xA0000000)

	)

5 const char *
	gmsg
 = "hello, world\n";

6 const char *
	gmsg2
 = "goodbye, world\n";

8 void 
childofspawn
(void);

11 
	$umain
(int 
argc
, char **
argv
)

13 int 
r
;

15 if (
argc
 != 0)

16 
	`childofspawn
();

18 if ((
r
 = 
	`sys_page_alloc
(0, 
VA
, 
PTE_P
|
PTE_W
|
PTE_U
|
PTE_SHARE
)) < 0)

19 
	`panic
("sys_page_alloc: %e", 
r
);

22 if ((
r
 = 
	`fork
()) < 0)

23 
	`panic
("fork: %e", 
r
);

24 if (
r
 == 0) {

25 
	`strcpy
(
VA
, 
msg
);

26 
	`exit
();

28 
	`wait
(
r
);

29 
	`printf
("fork handles PTE_SHARE %s\n", 
	`strcmp
(
VA
, 
msg
) == 0 ? "right" : "wrong");

32 if ((
r
 = 
	`spawnl
("/testpteshare", "testpteshare", "arg", 0)) < 0)

33 
	`panic
("spawn: %e", 
r
);

34 
	`wait
(
r
);

35 
	`printf
("spawn handles PTE_SHARE %s\n", 
	`strcmp
(
VA
, 
msg2
) == 0 ? "right" : "wrong");

37 
	`breakpoint
();

38 
	}
}

41 
	$childofspawn
(void)

43 
	`strcpy
(
VA
, 
msg2
);

44 
	`exit
();

45 
	}
}

	@/root/Robux/user/testsec.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 struct 
user_info
 
info
;

8 int 
r
 = 
	`get_user_by_id
(1000, &
info
);

10 if(
r
 != 0)

11 
	`panic
("Failed to get user info\n");

14 
	`printf
("Test: %s (%d) info: %s, shell: %s, home: %s\n", 
info
.
ui_name
, info.
ui_uid
, info.
ui_comment
, info.
ui_shell
, info.
ui_home
);

16 
r
 = 
	`get_user_by_name
("rmcqueen", &
info
);

17 if(
r
 != 0)

18 
	`panic
("Failed to get 2\n");

19 
	`printf
("Test2: %d\n", 
info
.
ui_uid
);

21 
r
 = 
	`verify_password
(1000, "hello");

22 
	`printf
("Pass: %d\n", 
r
);

23 
	}
}

	@/root/Robux/user/testshell.c

1 #include 
	~<inc/x86.h
>

2 #include 
	~<inc/lib.h
>

4 void 
wrong
(int, int, int);

7 
	$umain
(int 
argc
, char **
argv
)

9 char 
c1
, 
c2
;

10 int 
r
, 
rfd
, 
wfd
, 
kfd
, 
n1
, 
n2
, 
off
, 
nloff
;

12 
	`close
(0);

13 
	`close
(1);

14 
	`opencons
();

15 
	`opencons
();

17 if ((
rfd
 = 
	`open
("testshell.sh", 
O_RDONLY
)) < 0)

18 
	`panic
("open testshell.sh: %e", 
rfd
);

19 if ((
wfd
 = 
	`open
("testshell.out", 
O_WRONLY
|
O_CREAT
|
O_TRUNC
)) < 0)

20 
	`panic
("open testshell.out: %e", 
wfd
);

22 
	`printf
("running sh -x < testshell.sh > testshell.out\n");

23 if ((
r
 = 
	`fork
()) < 0)

24 
	`panic
("fork: %e", 
r
);

25 if (
r
 == 0) {

26 
	`dup
(
rfd
, 0);

27 
	`dup
(
wfd
, 1);

28 
	`close
(
rfd
);

29 
	`close
(
wfd
);

30 if ((
r
 = 
	`spawnl
("/sh", "sh", "-x", 0)) < 0)

31 
	`panic
("spawn: %e", 
r
);

32 
	`close
(0);

33 
	`close
(1);

34 
	`wait
(
r
);

35 
	`exit
();

37 
	`close
(
rfd
);

38 
	`close
(
wfd
);

39 
	`wait
(
r
);

41 if ((
rfd
 = 
	`open
("testshell.out", 
O_RDONLY
)) < 0)

42 
	`panic
("open testshell.out for reading: %e", 
rfd
);

43 if ((
kfd
 = 
	`open
("testshell.key", 
O_RDONLY
)) < 0)

44 
	`panic
("open testshell.key for reading: %e", 
kfd
);

46 
nloff
 = 0;

47 for (
off
=0;; off++) {

48 
n1
 = 
	`read
(
rfd
, &
c1
, 1);

49 
n2
 = 
	`read
(
kfd
, &
c2
, 1);

50 if (
n1
 < 0)

51 
	`panic
("reading testshell.out: %e", 
n1
);

52 if (
n2
 < 0)

53 
	`panic
("reading testshell.key: %e", 
n2
);

54 if (
n1
 == 0 && 
n2
 == 0)

56 if (
n1
 != 1 || 
n2
 != 1 || 
c1
 != 
c2
)

57 
	`wrong
(
rfd
, 
kfd
, 
nloff
);

58 if (
c1
 == '\n')

59 
nloff
 = 
off
+1;

61 
	`printf
("shell ran correctly\n");

63 
	`breakpoint
();

64 
	}
}

67 
	$wrong
(int 
rfd
, int 
kfd
, int 
off
)

69 char 
buf
[100];

70 int 
n
;

72 
	`seek
(
rfd
, 
off
);

73 
	`seek
(
kfd
, 
off
);

75 
	`printf
("shell produced incorrect output.\n");

76 
	`printf
("expected:\n===\n");

77 while ((
n
 = 
	`read
(
kfd
, 
buf
, sizeof buf-1)) > 0)

78 
	`sys_cputs
(
buf
, 
n
);

79 
	`printf
("===\ngot:\n===\n");

80 while ((
n
 = 
	`read
(
rfd
, 
buf
, sizeof buf-1)) > 0)

81 
	`sys_cputs
(
buf
, 
n
);

82 
	`printf
("===\n");

83 
	`exit
();

84 
	}
}

	@/root/Robux/user/testtime.c

1 #include 
	~<inc/lib.h
>

2 #include 
	~<inc/x86.h
>

5 
	$sleep
(int 
sec
)

7 unsigned 
now
 = 
	`sys_time_msec
();

8 unsigned 
end
 = 
now
 + 
sec
 * 1000;

10 if ((int)
now
 < 0 && (int)now > -
MAXERROR
)

11 
	`panic
("sys_time_msec: %e", (int)
now
);

12 if (
end
 < 
now
)

13 
	`panic
("sleep: wrap");

15 while (
	`sys_time_msec
() < 
end
)

16 
	`sys_yield
();

17 
	}
}

20 
	$umain
(int 
argc
, char **
argv
)

22 int 
i
;

25 for (
i
 = 0; i < 50; i++)

26 
	`sys_yield
();

28 
	`printf
("starting count down: ");

29 for (
i
 = 5; i >= 0; i--) {

30 
	`printf
("%d ", 
i
);

31 
	`sleep
(1);

33 
	`printf
("\n");

34 
	`breakpoint
();

35 
	}
}

	@/root/Robux/user/writemotd.c

1 #include 
	~<inc/lib.h
>

4 
	$umain
(int 
argc
, char **
argv
)

6 int 
rfd
, 
wfd
;

7 char 
buf
[512];

8 int 
n
, 
r
;

10 if ((
rfd
 = 
	`open
("/newmotd", 
O_RDONLY
)) < 0)

11 
	`panic
("open /newmotd: %e", 
rfd
);

12 if ((
wfd
 = 
	`open
("/motd", 
O_RDWR
)) < 0)

13 
	`panic
("open /motd: %e", 
wfd
);

14 
	`printf
("file descriptors %d %d\n", 
rfd
, 
wfd
);

15 if (
rfd
 == 
wfd
)

16 
	`panic
("open /newmotd and /motd give same file descriptor");

18 
	`printf
("OLD MOTD\n===\n");

19 while ((
n
 = 
	`read
(
wfd
, 
buf
, sizeof buf-1)) > 0)

20 
	`sys_cputs
(
buf
, 
n
);

21 
	`printf
("===\n");

22 
	`seek
(
wfd
, 0);

24 if ((
r
 = 
	`ftruncate
(
wfd
, 0)) < 0)

25 
	`panic
("truncate /motd: %e", 
r
);

27 
	`printf
("NEW MOTD\n===\n");

28 while ((
n
 = 
	`read
(
rfd
, 
buf
, sizeof buf-1)) > 0) {

29 
	`sys_cputs
(
buf
, 
n
);

30 if ((
r
 = 
	`write
(
wfd
, 
buf
, 
n
)) != n)

31 
	`panic
("write /motd: %e", 
r
);

33 
	`printf
("===\n");

35 if (
n
 < 0)

36 
	`panic
("read /newmotd: %e", 
n
);

38 
	`close
(
rfd
);

39 
	`close
(
wfd
);

40 
	}
}

	@/root/Robux/user/yield.c

3 #include 
	~<inc/lib.h
>

6 
	$umain
(int 
argc
, char **
argv
)

8 int 
i
;

10 
	`printf
("Hello, I am environment %08x.\n", 
thisenv
->
env_id
);

11 for (
i
 = 0; i < 5; i++) {

12 
	`sys_yield
();

13 
	`printf
("Back in environment %08x, iteration %d.\n",

14 
thisenv
->
env_id
, 
i
);

16 
	`printf
("All done in environment %08x.\n", 
thisenv
->
env_id
);

17 
	}
}

	@
1
.
0
306
9753
/root/Robux/boot/main.c
/root/Robux/contrib/sha2/sha2.c
/root/Robux/contrib/sha2/sha2.h
/root/Robux/contrib/sha2/sha2prog.c
/root/Robux/contrib/sha2/sha2speed.c
/root/Robux/fs/bc.c
/root/Robux/fs/fs.c
/root/Robux/fs/fs.h
/root/Robux/fs/fsformat.c
/root/Robux/fs/ide.c
/root/Robux/fs/serv.c
/root/Robux/fs/test.c
/root/Robux/inc/args.h
/root/Robux/inc/assert.h
/root/Robux/inc/elf.h
/root/Robux/inc/env.h
/root/Robux/inc/error.h
/root/Robux/inc/fd.h
/root/Robux/inc/fs.h
/root/Robux/inc/kbdreg.h
/root/Robux/inc/lib.h
/root/Robux/inc/malloc.h
/root/Robux/inc/memlayout.h
/root/Robux/inc/mmu.h
/root/Robux/inc/ns.h
/root/Robux/inc/queue.h
/root/Robux/inc/security.h
/root/Robux/inc/stab.h
/root/Robux/inc/stdarg.h
/root/Robux/inc/stdio.h
/root/Robux/inc/string.h
/root/Robux/inc/syscall.h
/root/Robux/inc/trap.h
/root/Robux/inc/types.h
/root/Robux/inc/x86.h
/root/Robux/kern/console.c
/root/Robux/kern/console.h
/root/Robux/kern/cpu.h
/root/Robux/kern/e1000.c
/root/Robux/kern/e1000.h
/root/Robux/kern/entrypgdir.c
/root/Robux/kern/env.c
/root/Robux/kern/env.h
/root/Robux/kern/init.c
/root/Robux/kern/kclock.c
/root/Robux/kern/kclock.h
/root/Robux/kern/kdebug.c
/root/Robux/kern/kdebug.h
/root/Robux/kern/lapic.c
/root/Robux/kern/monitor.c
/root/Robux/kern/monitor.h
/root/Robux/kern/mpconfig.c
/root/Robux/kern/pci.c
/root/Robux/kern/pci.h
/root/Robux/kern/pcireg.h
/root/Robux/kern/picirq.c
/root/Robux/kern/picirq.h
/root/Robux/kern/pmap.c
/root/Robux/kern/pmap.h
/root/Robux/kern/printf.c
/root/Robux/kern/sched.c
/root/Robux/kern/sched.h
/root/Robux/kern/spinlock.c
/root/Robux/kern/spinlock.h
/root/Robux/kern/syscall.c
/root/Robux/kern/syscall.h
/root/Robux/kern/time.c
/root/Robux/kern/time.h
/root/Robux/kern/trap.c
/root/Robux/kern/trap.h
/root/Robux/lib/args.c
/root/Robux/lib/b64.c
/root/Robux/lib/console.c
/root/Robux/lib/exit.c
/root/Robux/lib/fd.c
/root/Robux/lib/file.c
/root/Robux/lib/fork.c
/root/Robux/lib/fprintf.c
/root/Robux/lib/getid.c
/root/Robux/lib/ipc.c
/root/Robux/lib/libmain.c
/root/Robux/lib/malloc.c
/root/Robux/lib/nsipc.c
/root/Robux/lib/pageref.c
/root/Robux/lib/panic.c
/root/Robux/lib/pgfault.c
/root/Robux/lib/pipe.c
/root/Robux/lib/printf.c
/root/Robux/lib/printfmt.c
/root/Robux/lib/readline.c
/root/Robux/lib/security.c
/root/Robux/lib/sha2.c
/root/Robux/lib/sockets.c
/root/Robux/lib/spawn.c
/root/Robux/lib/string.c
/root/Robux/lib/syscall.c
/root/Robux/lib/wait.c
/root/Robux/net/input.c
/root/Robux/net/lwip/api/api_lib.c
/root/Robux/net/lwip/api/api_msg.c
/root/Robux/net/lwip/api/err.c
/root/Robux/net/lwip/api/netbuf.c
/root/Robux/net/lwip/api/netdb.c
/root/Robux/net/lwip/api/netifapi.c
/root/Robux/net/lwip/api/sockets.c
/root/Robux/net/lwip/api/tcpip.c
/root/Robux/net/lwip/core/dhcp.c
/root/Robux/net/lwip/core/dns.c
/root/Robux/net/lwip/core/init.c
/root/Robux/net/lwip/core/ipv4/autoip.c
/root/Robux/net/lwip/core/ipv4/icmp.c
/root/Robux/net/lwip/core/ipv4/igmp.c
/root/Robux/net/lwip/core/ipv4/inet.c
/root/Robux/net/lwip/core/ipv4/inet_chksum.c
/root/Robux/net/lwip/core/ipv4/ip.c
/root/Robux/net/lwip/core/ipv4/ip_addr.c
/root/Robux/net/lwip/core/ipv4/ip_frag.c
/root/Robux/net/lwip/core/ipv6/icmp6.c
/root/Robux/net/lwip/core/ipv6/inet6.c
/root/Robux/net/lwip/core/ipv6/ip6.c
/root/Robux/net/lwip/core/ipv6/ip6_addr.c
/root/Robux/net/lwip/core/mem.c
/root/Robux/net/lwip/core/memp.c
/root/Robux/net/lwip/core/netif.c
/root/Robux/net/lwip/core/pbuf.c
/root/Robux/net/lwip/core/raw.c
/root/Robux/net/lwip/core/snmp/asn1_dec.c
/root/Robux/net/lwip/core/snmp/asn1_enc.c
/root/Robux/net/lwip/core/snmp/mib2.c
/root/Robux/net/lwip/core/snmp/mib_structs.c
/root/Robux/net/lwip/core/snmp/msg_in.c
/root/Robux/net/lwip/core/snmp/msg_out.c
/root/Robux/net/lwip/core/stats.c
/root/Robux/net/lwip/core/sys.c
/root/Robux/net/lwip/core/tcp.c
/root/Robux/net/lwip/core/tcp_in.c
/root/Robux/net/lwip/core/tcp_out.c
/root/Robux/net/lwip/core/udp.c
/root/Robux/net/lwip/include/ipv4/lwip/autoip.h
/root/Robux/net/lwip/include/ipv4/lwip/icmp.h
/root/Robux/net/lwip/include/ipv4/lwip/igmp.h
/root/Robux/net/lwip/include/ipv4/lwip/inet.h
/root/Robux/net/lwip/include/ipv4/lwip/inet_chksum.h
/root/Robux/net/lwip/include/ipv4/lwip/ip.h
/root/Robux/net/lwip/include/ipv4/lwip/ip_addr.h
/root/Robux/net/lwip/include/ipv4/lwip/ip_frag.h
/root/Robux/net/lwip/include/ipv6/lwip/icmp.h
/root/Robux/net/lwip/include/ipv6/lwip/inet.h
/root/Robux/net/lwip/include/ipv6/lwip/ip.h
/root/Robux/net/lwip/include/ipv6/lwip/ip_addr.h
/root/Robux/net/lwip/include/lwip/api.h
/root/Robux/net/lwip/include/lwip/api_msg.h
/root/Robux/net/lwip/include/lwip/arch.h
/root/Robux/net/lwip/include/lwip/debug.h
/root/Robux/net/lwip/include/lwip/def.h
/root/Robux/net/lwip/include/lwip/dhcp.h
/root/Robux/net/lwip/include/lwip/dns.h
/root/Robux/net/lwip/include/lwip/err.h
/root/Robux/net/lwip/include/lwip/init.h
/root/Robux/net/lwip/include/lwip/mem.h
/root/Robux/net/lwip/include/lwip/memp.h
/root/Robux/net/lwip/include/lwip/memp_std.h
/root/Robux/net/lwip/include/lwip/netbuf.h
/root/Robux/net/lwip/include/lwip/netdb.h
/root/Robux/net/lwip/include/lwip/netif.h
/root/Robux/net/lwip/include/lwip/netifapi.h
/root/Robux/net/lwip/include/lwip/opt.h
/root/Robux/net/lwip/include/lwip/pbuf.h
/root/Robux/net/lwip/include/lwip/raw.h
/root/Robux/net/lwip/include/lwip/sio.h
/root/Robux/net/lwip/include/lwip/snmp.h
/root/Robux/net/lwip/include/lwip/snmp_asn1.h
/root/Robux/net/lwip/include/lwip/snmp_msg.h
/root/Robux/net/lwip/include/lwip/snmp_structs.h
/root/Robux/net/lwip/include/lwip/sockets.h
/root/Robux/net/lwip/include/lwip/stats.h
/root/Robux/net/lwip/include/lwip/sys.h
/root/Robux/net/lwip/include/lwip/tcp.h
/root/Robux/net/lwip/include/lwip/tcpip.h
/root/Robux/net/lwip/include/lwip/udp.h
/root/Robux/net/lwip/include/netif/etharp.h
/root/Robux/net/lwip/include/netif/loopif.h
/root/Robux/net/lwip/include/netif/ppp_oe.h
/root/Robux/net/lwip/include/netif/slipif.h
/root/Robux/net/lwip/jos/arch/cc.h
/root/Robux/net/lwip/jos/arch/i386/setjmp.h
/root/Robux/net/lwip/jos/arch/perf.h
/root/Robux/net/lwip/jos/arch/perror.c
/root/Robux/net/lwip/jos/arch/perror.h
/root/Robux/net/lwip/jos/arch/setjmp.h
/root/Robux/net/lwip/jos/arch/sys_arch.c
/root/Robux/net/lwip/jos/arch/sys_arch.h
/root/Robux/net/lwip/jos/arch/thread.c
/root/Robux/net/lwip/jos/arch/thread.h
/root/Robux/net/lwip/jos/arch/threadq.h
/root/Robux/net/lwip/jos/jif/jif.c
/root/Robux/net/lwip/jos/jif/jif.h
/root/Robux/net/lwip/jos/lwipopts.h
/root/Robux/net/lwip/netif/etharp.c
/root/Robux/net/lwip/netif/ethernetif.c
/root/Robux/net/lwip/netif/loopif.c
/root/Robux/net/lwip/netif/ppp/auth.c
/root/Robux/net/lwip/netif/ppp/auth.h
/root/Robux/net/lwip/netif/ppp/chap.c
/root/Robux/net/lwip/netif/ppp/chap.h
/root/Robux/net/lwip/netif/ppp/chpms.c
/root/Robux/net/lwip/netif/ppp/chpms.h
/root/Robux/net/lwip/netif/ppp/fsm.c
/root/Robux/net/lwip/netif/ppp/fsm.h
/root/Robux/net/lwip/netif/ppp/ipcp.c
/root/Robux/net/lwip/netif/ppp/ipcp.h
/root/Robux/net/lwip/netif/ppp/lcp.c
/root/Robux/net/lwip/netif/ppp/lcp.h
/root/Robux/net/lwip/netif/ppp/magic.c
/root/Robux/net/lwip/netif/ppp/magic.h
/root/Robux/net/lwip/netif/ppp/md5.c
/root/Robux/net/lwip/netif/ppp/md5.h
/root/Robux/net/lwip/netif/ppp/pap.c
/root/Robux/net/lwip/netif/ppp/pap.h
/root/Robux/net/lwip/netif/ppp/ppp.c
/root/Robux/net/lwip/netif/ppp/ppp.h
/root/Robux/net/lwip/netif/ppp/ppp_oe.c
/root/Robux/net/lwip/netif/ppp/pppdebug.h
/root/Robux/net/lwip/netif/ppp/randm.c
/root/Robux/net/lwip/netif/ppp/randm.h
/root/Robux/net/lwip/netif/ppp/vj.c
/root/Robux/net/lwip/netif/ppp/vj.h
/root/Robux/net/lwip/netif/ppp/vjbsdhdr.h
/root/Robux/net/lwip/netif/slipif.c
/root/Robux/net/ns.h
/root/Robux/net/output.c
/root/Robux/net/serv.c
/root/Robux/net/testinput.c
/root/Robux/net/testoutput.c
/root/Robux/net/timer.c
/root/Robux/security/secipc.h
/root/Robux/security/security.c
/root/Robux/user/badsegment.c
/root/Robux/user/breakpoint.c
/root/Robux/user/buggyhello.c
/root/Robux/user/buggyhello2.c
/root/Robux/user/cat.c
/root/Robux/user/chgrp.c
/root/Robux/user/chmod.c
/root/Robux/user/chown.c
/root/Robux/user/divzero.c
/root/Robux/user/dumbfork.c
/root/Robux/user/echo.c
/root/Robux/user/echosrv.c
/root/Robux/user/echotest.c
/root/Robux/user/evilhello.c
/root/Robux/user/fairness.c
/root/Robux/user/faultalloc.c
/root/Robux/user/faultallocbad.c
/root/Robux/user/faultbadhandler.c
/root/Robux/user/faultdie.c
/root/Robux/user/faultevilhandler.c
/root/Robux/user/faultnostack.c
/root/Robux/user/faultread.c
/root/Robux/user/faultreadkernel.c
/root/Robux/user/faultregs.c
/root/Robux/user/faultwrite.c
/root/Robux/user/faultwritekernel.c
/root/Robux/user/forktree.c
/root/Robux/user/freq.c
/root/Robux/user/hello.c
/root/Robux/user/httpd.c
/root/Robux/user/icode.c
/root/Robux/user/idle.c
/root/Robux/user/init.c
/root/Robux/user/initsh.c
/root/Robux/user/josinit.c
/root/Robux/user/login.c
/root/Robux/user/logname.c
/root/Robux/user/ls.c
/root/Robux/user/lsfd.c
/root/Robux/user/num.c
/root/Robux/user/oldinit.c
/root/Robux/user/oldsh.c
/root/Robux/user/pingpong.c
/root/Robux/user/pingpongs.c
/root/Robux/user/primes.c
/root/Robux/user/primespipe.c
/root/Robux/user/sh.c
/root/Robux/user/sha2speed.c
/root/Robux/user/softint.c
/root/Robux/user/spawnhello.c
/root/Robux/user/spawninit.c
/root/Robux/user/spin.c
/root/Robux/user/stresssched.c
/root/Robux/user/telnetd.c
/root/Robux/user/testbss.c
/root/Robux/user/testfdsharing.c
/root/Robux/user/testfile.c
/root/Robux/user/testkbd.c
/root/Robux/user/testmalloc.c
/root/Robux/user/testpipe.c
/root/Robux/user/testpiperace.c
/root/Robux/user/testpiperace2.c
/root/Robux/user/testptelibrary.c
/root/Robux/user/testpteshare.c
/root/Robux/user/testsec.c
/root/Robux/user/testshell.c
/root/Robux/user/testtime.c
/root/Robux/user/writemotd.c
/root/Robux/user/yield.c
